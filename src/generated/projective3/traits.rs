#![doc = " Trait implementations for projective3."]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
use super::products::*;
use super::types::{Bivector, Flector, Motor, Quadvector, Scalar, Trivector, Vector};
use crate::scalar::Float;
use approx::{AbsDiffEq, RelativeEq, UlpsEq};
use std::ops::{Add, BitXor, Mul, Neg, Sub};
impl<T: Float> Add for Bivector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new(
            self.e12() + rhs.e12(),
            self.e13() + rhs.e13(),
            self.e23() + rhs.e23(),
            self.e01() + rhs.e01(),
            self.e02() + rhs.e02(),
            self.e03() + rhs.e03(),
        )
    }
}
impl<T: Float> Sub for Bivector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new(
            self.e12() - rhs.e12(),
            self.e13() - rhs.e13(),
            self.e23() - rhs.e23(),
            self.e01() - rhs.e01(),
            self.e02() - rhs.e02(),
            self.e03() - rhs.e03(),
        )
    }
}
impl<T: Float> Neg for Bivector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new(
            -self.e12(),
            -self.e13(),
            -self.e23(),
            -self.e01(),
            -self.e02(),
            -self.e03(),
        )
    }
}
impl<T: Float> Mul<T> for Bivector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Bivector<f32>> for f32 {
    type Output = Bivector<f32>;
    #[inline]
    fn mul(self, v: Bivector<f32>) -> Bivector<f32> {
        v.scale(self)
    }
}
impl Mul<Bivector<f64>> for f64 {
    type Output = Bivector<f64>;
    #[inline]
    fn mul(self, v: Bivector<f64>) -> Bivector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Bivector<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Motor<T> {
        geometric_bivector_bivector(&self, &rhs)
    }
}
impl<T: Float> Mul<Flector<T>> for Bivector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Flector<T> {
        geometric_bivector_flector(&self, &rhs)
    }
}
impl<T: Float> Mul<Motor<T>> for Bivector<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Motor<T>) -> Motor<T> {
        geometric_bivector_motor(&self, &rhs)
    }
}
impl<T: Float> Mul<Quadvector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn mul(self, rhs: Quadvector<T>) -> Bivector<T> {
        geometric_bivector_quadvector(&self, &rhs)
    }
}
impl<T: Float> Mul<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Bivector<T> {
        geometric_bivector_scalar(&self, &rhs)
    }
}
impl<T: Float> Mul<Trivector<T>> for Bivector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Trivector<T>) -> Flector<T> {
        geometric_bivector_trivector(&self, &rhs)
    }
}
impl<T: Float> Mul<Vector<T>> for Bivector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Vector<T>) -> Flector<T> {
        geometric_bivector_vector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Bivector<T>> for Bivector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn bitxor(self, rhs: Bivector<T>) -> Quadvector<T> {
        outer_bivector_bivector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Flector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Flector<T>) -> Trivector<T> {
        outer_bivector_flector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bitxor(self, rhs: Scalar<T>) -> Bivector<T> {
        outer_bivector_scalar(&self, &rhs)
    }
}
impl<T: Float> BitXor<Vector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Vector<T>) -> Trivector<T> {
        outer_bivector_vector(&self, &rhs)
    }
}
impl<T: Float> Add for Flector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new(
            self.e1() + rhs.e1(),
            self.e2() + rhs.e2(),
            self.e3() + rhs.e3(),
            self.e0() + rhs.e0(),
            self.e123() + rhs.e123(),
            self.e012() + rhs.e012(),
            self.e013() + rhs.e013(),
            self.e023() + rhs.e023(),
        )
    }
}
impl<T: Float> Sub for Flector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new(
            self.e1() - rhs.e1(),
            self.e2() - rhs.e2(),
            self.e3() - rhs.e3(),
            self.e0() - rhs.e0(),
            self.e123() - rhs.e123(),
            self.e012() - rhs.e012(),
            self.e013() - rhs.e013(),
            self.e023() - rhs.e023(),
        )
    }
}
impl<T: Float> Neg for Flector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new(
            -self.e1(),
            -self.e2(),
            -self.e3(),
            -self.e0(),
            -self.e123(),
            -self.e012(),
            -self.e013(),
            -self.e023(),
        )
    }
}
impl<T: Float> Mul<T> for Flector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Flector<f32>> for f32 {
    type Output = Flector<f32>;
    #[inline]
    fn mul(self, v: Flector<f32>) -> Flector<f32> {
        v.scale(self)
    }
}
impl Mul<Flector<f64>> for f64 {
    type Output = Flector<f64>;
    #[inline]
    fn mul(self, v: Flector<f64>) -> Flector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Flector<T> {
        geometric_flector_bivector(&self, &rhs)
    }
}
impl<T: Float> Mul<Flector<T>> for Flector<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Motor<T> {
        geometric_flector_flector(&self, &rhs)
    }
}
impl<T: Float> Mul<Motor<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Motor<T>) -> Flector<T> {
        geometric_flector_motor(&self, &rhs)
    }
}
impl<T: Float> Mul<Quadvector<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Quadvector<T>) -> Flector<T> {
        geometric_flector_quadvector(&self, &rhs)
    }
}
impl<T: Float> Mul<Scalar<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Flector<T> {
        geometric_flector_scalar(&self, &rhs)
    }
}
impl<T: Float> Mul<Trivector<T>> for Flector<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Trivector<T>) -> Motor<T> {
        geometric_flector_trivector(&self, &rhs)
    }
}
impl<T: Float> Mul<Vector<T>> for Flector<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Vector<T>) -> Motor<T> {
        geometric_flector_vector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Bivector<T>> for Flector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Bivector<T>) -> Trivector<T> {
        outer_flector_bivector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Motor<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn bitxor(self, rhs: Motor<T>) -> Flector<T> {
        outer_flector_motor(&self, &rhs)
    }
}
impl<T: Float> BitXor<Scalar<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn bitxor(self, rhs: Scalar<T>) -> Flector<T> {
        outer_flector_scalar(&self, &rhs)
    }
}
impl<T: Float> BitXor<Trivector<T>> for Flector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn bitxor(self, rhs: Trivector<T>) -> Quadvector<T> {
        outer_flector_trivector(&self, &rhs)
    }
}
impl<T: Float> Add for Motor<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new(
            self.s() + rhs.s(),
            self.e12() + rhs.e12(),
            self.e13() + rhs.e13(),
            self.e23() + rhs.e23(),
            self.e01() + rhs.e01(),
            self.e02() + rhs.e02(),
            self.e03() + rhs.e03(),
            self.e0123() + rhs.e0123(),
        )
    }
}
impl<T: Float> Sub for Motor<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new(
            self.s() - rhs.s(),
            self.e12() - rhs.e12(),
            self.e13() - rhs.e13(),
            self.e23() - rhs.e23(),
            self.e01() - rhs.e01(),
            self.e02() - rhs.e02(),
            self.e03() - rhs.e03(),
            self.e0123() - rhs.e0123(),
        )
    }
}
impl<T: Float> Neg for Motor<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new(
            -self.s(),
            -self.e12(),
            -self.e13(),
            -self.e23(),
            -self.e01(),
            -self.e02(),
            -self.e03(),
            -self.e0123(),
        )
    }
}
impl<T: Float> Mul<T> for Motor<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Motor<f32>> for f32 {
    type Output = Motor<f32>;
    #[inline]
    fn mul(self, v: Motor<f32>) -> Motor<f32> {
        v.scale(self)
    }
}
impl Mul<Motor<f64>> for f64 {
    type Output = Motor<f64>;
    #[inline]
    fn mul(self, v: Motor<f64>) -> Motor<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Motor<T> {
        geometric_motor_bivector(&self, &rhs)
    }
}
impl<T: Float> Mul<Flector<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Flector<T> {
        geometric_motor_flector(&self, &rhs)
    }
}
impl<T: Float> Mul<Motor<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Motor<T>) -> Motor<T> {
        geometric_motor_motor(&self, &rhs)
    }
}
impl<T: Float> Mul<Scalar<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Motor<T> {
        geometric_motor_scalar(&self, &rhs)
    }
}
impl<T: Float> Mul<Trivector<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Trivector<T>) -> Flector<T> {
        geometric_motor_trivector(&self, &rhs)
    }
}
impl<T: Float> Mul<Vector<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Vector<T>) -> Flector<T> {
        geometric_motor_vector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Flector<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn bitxor(self, rhs: Flector<T>) -> Flector<T> {
        outer_motor_flector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Motor<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn bitxor(self, rhs: Motor<T>) -> Motor<T> {
        outer_motor_motor(&self, &rhs)
    }
}
impl<T: Float> BitXor<Quadvector<T>> for Motor<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn bitxor(self, rhs: Quadvector<T>) -> Quadvector<T> {
        outer_motor_quadvector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Scalar<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn bitxor(self, rhs: Scalar<T>) -> Motor<T> {
        outer_motor_scalar(&self, &rhs)
    }
}
impl<T: Float> BitXor<Trivector<T>> for Motor<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Trivector<T>) -> Trivector<T> {
        outer_motor_trivector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Vector<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn bitxor(self, rhs: Vector<T>) -> Flector<T> {
        outer_motor_vector(&self, &rhs)
    }
}
impl<T: Float> Add for Quadvector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new(self.e0123() + rhs.e0123())
    }
}
impl<T: Float> Sub for Quadvector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new(self.e0123() - rhs.e0123())
    }
}
impl<T: Float> Neg for Quadvector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new(-self.e0123())
    }
}
impl<T: Float> Mul<T> for Quadvector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Quadvector<f32>> for f32 {
    type Output = Quadvector<f32>;
    #[inline]
    fn mul(self, v: Quadvector<f32>) -> Quadvector<f32> {
        v.scale(self)
    }
}
impl Mul<Quadvector<f64>> for f64 {
    type Output = Quadvector<f64>;
    #[inline]
    fn mul(self, v: Quadvector<f64>) -> Quadvector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Quadvector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Bivector<T> {
        geometric_quadvector_bivector(&self, &rhs)
    }
}
impl<T: Float> Mul<Flector<T>> for Quadvector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Flector<T> {
        geometric_quadvector_flector(&self, &rhs)
    }
}
impl<T: Float> Mul<Scalar<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Quadvector<T> {
        geometric_quadvector_scalar(&self, &rhs)
    }
}
impl<T: Float> Mul<Trivector<T>> for Quadvector<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Trivector<T>) -> Vector<T> {
        geometric_quadvector_trivector(&self, &rhs)
    }
}
impl<T: Float> Mul<Vector<T>> for Quadvector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn mul(self, rhs: Vector<T>) -> Trivector<T> {
        geometric_quadvector_vector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Motor<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn bitxor(self, rhs: Motor<T>) -> Quadvector<T> {
        outer_quadvector_motor(&self, &rhs)
    }
}
impl<T: Float> BitXor<Scalar<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn bitxor(self, rhs: Scalar<T>) -> Quadvector<T> {
        outer_quadvector_scalar(&self, &rhs)
    }
}
impl<T: Float> Add for Scalar<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new(self.s() + rhs.s())
    }
}
impl<T: Float> Sub for Scalar<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new(self.s() - rhs.s())
    }
}
impl<T: Float> Neg for Scalar<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new(-self.s())
    }
}
impl<T: Float> Mul<T> for Scalar<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Scalar<f32>> for f32 {
    type Output = Scalar<f32>;
    #[inline]
    fn mul(self, v: Scalar<f32>) -> Scalar<f32> {
        v.scale(self)
    }
}
impl Mul<Scalar<f64>> for f64 {
    type Output = Scalar<f64>;
    #[inline]
    fn mul(self, v: Scalar<f64>) -> Scalar<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Bivector<T> {
        geometric_scalar_bivector(&self, &rhs)
    }
}
impl<T: Float> Mul<Flector<T>> for Scalar<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Flector<T> {
        geometric_scalar_flector(&self, &rhs)
    }
}
impl<T: Float> Mul<Motor<T>> for Scalar<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Motor<T>) -> Motor<T> {
        geometric_scalar_motor(&self, &rhs)
    }
}
impl<T: Float> Mul<Quadvector<T>> for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn mul(self, rhs: Quadvector<T>) -> Quadvector<T> {
        geometric_scalar_quadvector(&self, &rhs)
    }
}
impl<T: Float> Mul<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Scalar<T> {
        geometric_scalar_scalar(&self, &rhs)
    }
}
impl<T: Float> Mul<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn mul(self, rhs: Trivector<T>) -> Trivector<T> {
        geometric_scalar_trivector(&self, &rhs)
    }
}
impl<T: Float> Mul<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Vector<T>) -> Vector<T> {
        geometric_scalar_vector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bitxor(self, rhs: Bivector<T>) -> Bivector<T> {
        outer_scalar_bivector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Flector<T>> for Scalar<T> {
    type Output = Flector<T>;
    #[inline]
    fn bitxor(self, rhs: Flector<T>) -> Flector<T> {
        outer_scalar_flector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Motor<T>> for Scalar<T> {
    type Output = Motor<T>;
    #[inline]
    fn bitxor(self, rhs: Motor<T>) -> Motor<T> {
        outer_scalar_motor(&self, &rhs)
    }
}
impl<T: Float> BitXor<Quadvector<T>> for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn bitxor(self, rhs: Quadvector<T>) -> Quadvector<T> {
        outer_scalar_quadvector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bitxor(self, rhs: Scalar<T>) -> Scalar<T> {
        outer_scalar_scalar(&self, &rhs)
    }
}
impl<T: Float> BitXor<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Trivector<T>) -> Trivector<T> {
        outer_scalar_trivector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn bitxor(self, rhs: Vector<T>) -> Vector<T> {
        outer_scalar_vector(&self, &rhs)
    }
}
impl<T: Float> Add for Trivector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new(
            self.e123() + rhs.e123(),
            self.e012() + rhs.e012(),
            self.e013() + rhs.e013(),
            self.e023() + rhs.e023(),
        )
    }
}
impl<T: Float> Sub for Trivector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new(
            self.e123() - rhs.e123(),
            self.e012() - rhs.e012(),
            self.e013() - rhs.e013(),
            self.e023() - rhs.e023(),
        )
    }
}
impl<T: Float> Neg for Trivector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new(-self.e123(), -self.e012(), -self.e013(), -self.e023())
    }
}
impl<T: Float> Mul<T> for Trivector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Trivector<f32>> for f32 {
    type Output = Trivector<f32>;
    #[inline]
    fn mul(self, v: Trivector<f32>) -> Trivector<f32> {
        v.scale(self)
    }
}
impl Mul<Trivector<f64>> for f64 {
    type Output = Trivector<f64>;
    #[inline]
    fn mul(self, v: Trivector<f64>) -> Trivector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Trivector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Flector<T> {
        geometric_trivector_bivector(&self, &rhs)
    }
}
impl<T: Float> Mul<Flector<T>> for Trivector<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Motor<T> {
        geometric_trivector_flector(&self, &rhs)
    }
}
impl<T: Float> Mul<Motor<T>> for Trivector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Motor<T>) -> Flector<T> {
        geometric_trivector_motor(&self, &rhs)
    }
}
impl<T: Float> Mul<Quadvector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Quadvector<T>) -> Vector<T> {
        geometric_trivector_quadvector(&self, &rhs)
    }
}
impl<T: Float> Mul<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Trivector<T> {
        geometric_trivector_scalar(&self, &rhs)
    }
}
impl<T: Float> BitXor<Flector<T>> for Trivector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn bitxor(self, rhs: Flector<T>) -> Quadvector<T> {
        outer_trivector_flector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Motor<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Motor<T>) -> Trivector<T> {
        outer_trivector_motor(&self, &rhs)
    }
}
impl<T: Float> BitXor<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Scalar<T>) -> Trivector<T> {
        outer_trivector_scalar(&self, &rhs)
    }
}
impl<T: Float> BitXor<Vector<T>> for Trivector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn bitxor(self, rhs: Vector<T>) -> Quadvector<T> {
        outer_trivector_vector(&self, &rhs)
    }
}
impl<T: Float> Add for Vector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new(
            self.e1() + rhs.e1(),
            self.e2() + rhs.e2(),
            self.e3() + rhs.e3(),
            self.e0() + rhs.e0(),
        )
    }
}
impl<T: Float> Sub for Vector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new(
            self.e1() - rhs.e1(),
            self.e2() - rhs.e2(),
            self.e3() - rhs.e3(),
            self.e0() - rhs.e0(),
        )
    }
}
impl<T: Float> Neg for Vector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new(-self.e1(), -self.e2(), -self.e3(), -self.e0())
    }
}
impl<T: Float> Mul<T> for Vector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Vector<f32>> for f32 {
    type Output = Vector<f32>;
    #[inline]
    fn mul(self, v: Vector<f32>) -> Vector<f32> {
        v.scale(self)
    }
}
impl Mul<Vector<f64>> for f64 {
    type Output = Vector<f64>;
    #[inline]
    fn mul(self, v: Vector<f64>) -> Vector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Vector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Flector<T> {
        geometric_vector_bivector(&self, &rhs)
    }
}
impl<T: Float> Mul<Flector<T>> for Vector<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Motor<T> {
        geometric_vector_flector(&self, &rhs)
    }
}
impl<T: Float> Mul<Motor<T>> for Vector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Motor<T>) -> Flector<T> {
        geometric_vector_motor(&self, &rhs)
    }
}
impl<T: Float> Mul<Quadvector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn mul(self, rhs: Quadvector<T>) -> Trivector<T> {
        geometric_vector_quadvector(&self, &rhs)
    }
}
impl<T: Float> Mul<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Vector<T> {
        geometric_vector_scalar(&self, &rhs)
    }
}
impl<T: Float> BitXor<Bivector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Bivector<T>) -> Trivector<T> {
        outer_vector_bivector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Motor<T>> for Vector<T> {
    type Output = Flector<T>;
    #[inline]
    fn bitxor(self, rhs: Motor<T>) -> Flector<T> {
        outer_vector_motor(&self, &rhs)
    }
}
impl<T: Float> BitXor<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bitxor(self, rhs: Scalar<T>) -> Vector<T> {
        outer_vector_scalar(&self, &rhs)
    }
}
impl<T: Float> BitXor<Trivector<T>> for Vector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn bitxor(self, rhs: Trivector<T>) -> Quadvector<T> {
        outer_vector_trivector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Vector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bitxor(self, rhs: Vector<T>) -> Bivector<T> {
        outer_vector_vector(&self, &rhs)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Bivector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.e12().abs_diff_eq(&other.e12(), epsilon)
            && self.e13().abs_diff_eq(&other.e13(), epsilon)
            && self.e23().abs_diff_eq(&other.e23(), epsilon)
            && self.e01().abs_diff_eq(&other.e01(), epsilon)
            && self.e02().abs_diff_eq(&other.e02(), epsilon)
            && self.e03().abs_diff_eq(&other.e03(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Bivector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.e12().relative_eq(&other.e12(), epsilon, max_relative)
            && self.e13().relative_eq(&other.e13(), epsilon, max_relative)
            && self.e23().relative_eq(&other.e23(), epsilon, max_relative)
            && self.e01().relative_eq(&other.e01(), epsilon, max_relative)
            && self.e02().relative_eq(&other.e02(), epsilon, max_relative)
            && self.e03().relative_eq(&other.e03(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Bivector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.e12().ulps_eq(&other.e12(), epsilon, max_ulps)
            && self.e13().ulps_eq(&other.e13(), epsilon, max_ulps)
            && self.e23().ulps_eq(&other.e23(), epsilon, max_ulps)
            && self.e01().ulps_eq(&other.e01(), epsilon, max_ulps)
            && self.e02().ulps_eq(&other.e02(), epsilon, max_ulps)
            && self.e03().ulps_eq(&other.e03(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Flector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.e1().abs_diff_eq(&other.e1(), epsilon)
            && self.e2().abs_diff_eq(&other.e2(), epsilon)
            && self.e3().abs_diff_eq(&other.e3(), epsilon)
            && self.e0().abs_diff_eq(&other.e0(), epsilon)
            && self.e123().abs_diff_eq(&other.e123(), epsilon)
            && self.e012().abs_diff_eq(&other.e012(), epsilon)
            && self.e013().abs_diff_eq(&other.e013(), epsilon)
            && self.e023().abs_diff_eq(&other.e023(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Flector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.e1().relative_eq(&other.e1(), epsilon, max_relative)
            && self.e2().relative_eq(&other.e2(), epsilon, max_relative)
            && self.e3().relative_eq(&other.e3(), epsilon, max_relative)
            && self.e0().relative_eq(&other.e0(), epsilon, max_relative)
            && self
                .e123()
                .relative_eq(&other.e123(), epsilon, max_relative)
            && self
                .e012()
                .relative_eq(&other.e012(), epsilon, max_relative)
            && self
                .e013()
                .relative_eq(&other.e013(), epsilon, max_relative)
            && self
                .e023()
                .relative_eq(&other.e023(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Flector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.e1().ulps_eq(&other.e1(), epsilon, max_ulps)
            && self.e2().ulps_eq(&other.e2(), epsilon, max_ulps)
            && self.e3().ulps_eq(&other.e3(), epsilon, max_ulps)
            && self.e0().ulps_eq(&other.e0(), epsilon, max_ulps)
            && self.e123().ulps_eq(&other.e123(), epsilon, max_ulps)
            && self.e012().ulps_eq(&other.e012(), epsilon, max_ulps)
            && self.e013().ulps_eq(&other.e013(), epsilon, max_ulps)
            && self.e023().ulps_eq(&other.e023(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Motor<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon)
            && self.e12().abs_diff_eq(&other.e12(), epsilon)
            && self.e13().abs_diff_eq(&other.e13(), epsilon)
            && self.e23().abs_diff_eq(&other.e23(), epsilon)
            && self.e01().abs_diff_eq(&other.e01(), epsilon)
            && self.e02().abs_diff_eq(&other.e02(), epsilon)
            && self.e03().abs_diff_eq(&other.e03(), epsilon)
            && self.e0123().abs_diff_eq(&other.e0123(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Motor<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
            && self.e12().relative_eq(&other.e12(), epsilon, max_relative)
            && self.e13().relative_eq(&other.e13(), epsilon, max_relative)
            && self.e23().relative_eq(&other.e23(), epsilon, max_relative)
            && self.e01().relative_eq(&other.e01(), epsilon, max_relative)
            && self.e02().relative_eq(&other.e02(), epsilon, max_relative)
            && self.e03().relative_eq(&other.e03(), epsilon, max_relative)
            && self
                .e0123()
                .relative_eq(&other.e0123(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Motor<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
            && self.e12().ulps_eq(&other.e12(), epsilon, max_ulps)
            && self.e13().ulps_eq(&other.e13(), epsilon, max_ulps)
            && self.e23().ulps_eq(&other.e23(), epsilon, max_ulps)
            && self.e01().ulps_eq(&other.e01(), epsilon, max_ulps)
            && self.e02().ulps_eq(&other.e02(), epsilon, max_ulps)
            && self.e03().ulps_eq(&other.e03(), epsilon, max_ulps)
            && self.e0123().ulps_eq(&other.e0123(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Quadvector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.e0123().abs_diff_eq(&other.e0123(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Quadvector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.e0123()
            .relative_eq(&other.e0123(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Quadvector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.e0123().ulps_eq(&other.e0123(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Scalar<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Scalar<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Scalar<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Trivector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.e123().abs_diff_eq(&other.e123(), epsilon)
            && self.e012().abs_diff_eq(&other.e012(), epsilon)
            && self.e013().abs_diff_eq(&other.e013(), epsilon)
            && self.e023().abs_diff_eq(&other.e023(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Trivector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.e123()
            .relative_eq(&other.e123(), epsilon, max_relative)
            && self
                .e012()
                .relative_eq(&other.e012(), epsilon, max_relative)
            && self
                .e013()
                .relative_eq(&other.e013(), epsilon, max_relative)
            && self
                .e023()
                .relative_eq(&other.e023(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Trivector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.e123().ulps_eq(&other.e123(), epsilon, max_ulps)
            && self.e012().ulps_eq(&other.e012(), epsilon, max_ulps)
            && self.e013().ulps_eq(&other.e013(), epsilon, max_ulps)
            && self.e023().ulps_eq(&other.e023(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Vector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.e1().abs_diff_eq(&other.e1(), epsilon)
            && self.e2().abs_diff_eq(&other.e2(), epsilon)
            && self.e3().abs_diff_eq(&other.e3(), epsilon)
            && self.e0().abs_diff_eq(&other.e0(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Vector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.e1().relative_eq(&other.e1(), epsilon, max_relative)
            && self.e2().relative_eq(&other.e2(), epsilon, max_relative)
            && self.e3().relative_eq(&other.e3(), epsilon, max_relative)
            && self.e0().relative_eq(&other.e0(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Vector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.e1().ulps_eq(&other.e1(), epsilon, max_ulps)
            && self.e2().ulps_eq(&other.e2(), epsilon, max_ulps)
            && self.e3().ulps_eq(&other.e3(), epsilon, max_ulps)
            && self.e0().ulps_eq(&other.e0(), epsilon, max_ulps)
    }
}
#[cfg(any(test, feature = "proptest-support"))]
mod arbitrary_impls {
    use super::*;
    use proptest::prelude::*;
    use proptest::strategy::BoxedStrategy;
    use std::fmt::Debug;
    impl<T: Float + Debug + 'static> Arbitrary for Bivector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
            )
                .prop_map(|(x0, x1, x2, x3, x4, x5)| {
                    Bivector::new(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64(x3),
                        T::from_f64(x4),
                        T::from_f64(x5),
                    )
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Flector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
            )
                .prop_map(|(x0, x1, x2, x3, x4, x5, x6, x7)| {
                    Flector::new(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64(x3),
                        T::from_f64(x4),
                        T::from_f64(x5),
                        T::from_f64(x6),
                        T::from_f64(x7),
                    )
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Motor<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
            )
                .prop_map(|(x0, x1, x2, x3, x4, x5, x6, x7)| {
                    Motor::new(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64(x3),
                        T::from_f64(x4),
                        T::from_f64(x5),
                        T::from_f64(x6),
                        T::from_f64(x7),
                    )
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Quadvector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| Quadvector::new(T::from_f64(x0)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Scalar<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| Scalar::new(T::from_f64(x0)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Trivector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
            )
                .prop_map(|(x0, x1, x2, x3)| {
                    Trivector::new(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64(x3),
                    )
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Vector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
            )
                .prop_map(|(x0, x1, x2, x3)| {
                    Vector::new(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64(x3),
                    )
                })
                .boxed()
        }
    }
}
#[cfg(test)]
mod verification_tests {
    use super::*;
    use crate::algebra::Multivector;
    use crate::signature::Projective3;
    use approx::abs_diff_eq;
    use proptest::prelude::*;
    #[doc = r" Epsilon for floating-point comparisons in verification tests."]
    const EPSILON: f64 = 1e-10;
    proptest! { # [test] fn bivector_add_matches_multivector (a in any :: < Bivector < f64 >> () , b in any :: < Bivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result = a + b ; let generic_result = mv_a + mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Add mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } # [test] fn bivector_sub_matches_multivector (a in any :: < Bivector < f64 >> () , b in any :: < Bivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result = a - b ; let generic_result = mv_a - mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Sub mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } # [test] fn bivector_neg_matches_multivector (a in any :: < Bivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let specialized_result = - a ; let generic_result = - mv_a ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Neg mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn flector_add_matches_multivector (a in any :: < Flector < f64 >> () , b in any :: < Flector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result = a + b ; let generic_result = mv_a + mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Add mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } # [test] fn flector_sub_matches_multivector (a in any :: < Flector < f64 >> () , b in any :: < Flector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result = a - b ; let generic_result = mv_a - mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Sub mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } # [test] fn flector_neg_matches_multivector (a in any :: < Flector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let specialized_result = - a ; let generic_result = - mv_a ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Neg mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn motor_add_matches_multivector (a in any :: < Motor < f64 >> () , b in any :: < Motor < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result = a + b ; let generic_result = mv_a + mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Add mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } # [test] fn motor_sub_matches_multivector (a in any :: < Motor < f64 >> () , b in any :: < Motor < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result = a - b ; let generic_result = mv_a - mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Sub mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } # [test] fn motor_neg_matches_multivector (a in any :: < Motor < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let specialized_result = - a ; let generic_result = - mv_a ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Neg mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn quadvector_add_matches_multivector (a in any :: < Quadvector < f64 >> () , b in any :: < Quadvector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result = a + b ; let generic_result = mv_a + mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Add mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } # [test] fn quadvector_sub_matches_multivector (a in any :: < Quadvector < f64 >> () , b in any :: < Quadvector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result = a - b ; let generic_result = mv_a - mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Sub mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } # [test] fn quadvector_neg_matches_multivector (a in any :: < Quadvector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let specialized_result = - a ; let generic_result = - mv_a ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Neg mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn scalar_add_matches_multivector (a in any :: < Scalar < f64 >> () , b in any :: < Scalar < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result = a + b ; let generic_result = mv_a + mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Add mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } # [test] fn scalar_sub_matches_multivector (a in any :: < Scalar < f64 >> () , b in any :: < Scalar < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result = a - b ; let generic_result = mv_a - mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Sub mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } # [test] fn scalar_neg_matches_multivector (a in any :: < Scalar < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let specialized_result = - a ; let generic_result = - mv_a ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Neg mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn trivector_add_matches_multivector (a in any :: < Trivector < f64 >> () , b in any :: < Trivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result = a + b ; let generic_result = mv_a + mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Add mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } # [test] fn trivector_sub_matches_multivector (a in any :: < Trivector < f64 >> () , b in any :: < Trivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result = a - b ; let generic_result = mv_a - mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Sub mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } # [test] fn trivector_neg_matches_multivector (a in any :: < Trivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let specialized_result = - a ; let generic_result = - mv_a ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Neg mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn vector_add_matches_multivector (a in any :: < Vector < f64 >> () , b in any :: < Vector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result = a + b ; let generic_result = mv_a + mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Add mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } # [test] fn vector_sub_matches_multivector (a in any :: < Vector < f64 >> () , b in any :: < Vector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result = a - b ; let generic_result = mv_a - mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Sub mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } # [test] fn vector_neg_matches_multivector (a in any :: < Vector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let specialized_result = - a ; let generic_result = - mv_a ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Neg mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_bivector_bivector_motor_matches_multivector (a in any :: < Bivector < f64 >> () , b in any :: < Bivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Motor < f64 > = geometric_bivector_bivector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_bivector_flector_flector_matches_multivector (a in any :: < Bivector < f64 >> () , b in any :: < Flector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = geometric_bivector_flector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_bivector_motor_motor_matches_multivector (a in any :: < Bivector < f64 >> () , b in any :: < Motor < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Motor < f64 > = geometric_bivector_motor (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_bivector_quadvector_bivector_matches_multivector (a in any :: < Bivector < f64 >> () , b in any :: < Quadvector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Bivector < f64 > = geometric_bivector_quadvector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_bivector_scalar_bivector_matches_multivector (a in any :: < Bivector < f64 >> () , b in any :: < Scalar < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Bivector < f64 > = geometric_bivector_scalar (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_bivector_trivector_flector_matches_multivector (a in any :: < Bivector < f64 >> () , b in any :: < Trivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = geometric_bivector_trivector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_bivector_vector_flector_matches_multivector (a in any :: < Bivector < f64 >> () , b in any :: < Vector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = geometric_bivector_vector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_flector_bivector_flector_matches_multivector (a in any :: < Flector < f64 >> () , b in any :: < Bivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = geometric_flector_bivector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_flector_flector_motor_matches_multivector (a in any :: < Flector < f64 >> () , b in any :: < Flector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Motor < f64 > = geometric_flector_flector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_flector_motor_flector_matches_multivector (a in any :: < Flector < f64 >> () , b in any :: < Motor < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = geometric_flector_motor (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_flector_quadvector_flector_matches_multivector (a in any :: < Flector < f64 >> () , b in any :: < Quadvector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = geometric_flector_quadvector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_flector_scalar_flector_matches_multivector (a in any :: < Flector < f64 >> () , b in any :: < Scalar < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = geometric_flector_scalar (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_flector_trivector_motor_matches_multivector (a in any :: < Flector < f64 >> () , b in any :: < Trivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Motor < f64 > = geometric_flector_trivector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_flector_vector_motor_matches_multivector (a in any :: < Flector < f64 >> () , b in any :: < Vector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Motor < f64 > = geometric_flector_vector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_motor_bivector_motor_matches_multivector (a in any :: < Motor < f64 >> () , b in any :: < Bivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Motor < f64 > = geometric_motor_bivector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_motor_flector_flector_matches_multivector (a in any :: < Motor < f64 >> () , b in any :: < Flector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = geometric_motor_flector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_motor_motor_motor_matches_multivector (a in any :: < Motor < f64 >> () , b in any :: < Motor < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Motor < f64 > = geometric_motor_motor (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_motor_scalar_motor_matches_multivector (a in any :: < Motor < f64 >> () , b in any :: < Scalar < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Motor < f64 > = geometric_motor_scalar (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_motor_trivector_flector_matches_multivector (a in any :: < Motor < f64 >> () , b in any :: < Trivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = geometric_motor_trivector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_motor_vector_flector_matches_multivector (a in any :: < Motor < f64 >> () , b in any :: < Vector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = geometric_motor_vector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_quadvector_bivector_bivector_matches_multivector (a in any :: < Quadvector < f64 >> () , b in any :: < Bivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Bivector < f64 > = geometric_quadvector_bivector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_quadvector_flector_flector_matches_multivector (a in any :: < Quadvector < f64 >> () , b in any :: < Flector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = geometric_quadvector_flector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_quadvector_scalar_quadvector_matches_multivector (a in any :: < Quadvector < f64 >> () , b in any :: < Scalar < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Quadvector < f64 > = geometric_quadvector_scalar (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_quadvector_trivector_vector_matches_multivector (a in any :: < Quadvector < f64 >> () , b in any :: < Trivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Vector < f64 > = geometric_quadvector_trivector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_quadvector_vector_trivector_matches_multivector (a in any :: < Quadvector < f64 >> () , b in any :: < Vector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Trivector < f64 > = geometric_quadvector_vector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_scalar_bivector_bivector_matches_multivector (a in any :: < Scalar < f64 >> () , b in any :: < Bivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Bivector < f64 > = geometric_scalar_bivector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_scalar_flector_flector_matches_multivector (a in any :: < Scalar < f64 >> () , b in any :: < Flector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = geometric_scalar_flector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_scalar_motor_motor_matches_multivector (a in any :: < Scalar < f64 >> () , b in any :: < Motor < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Motor < f64 > = geometric_scalar_motor (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_scalar_quadvector_quadvector_matches_multivector (a in any :: < Scalar < f64 >> () , b in any :: < Quadvector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Quadvector < f64 > = geometric_scalar_quadvector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_scalar_scalar_scalar_matches_multivector (a in any :: < Scalar < f64 >> () , b in any :: < Scalar < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Scalar < f64 > = geometric_scalar_scalar (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_scalar_trivector_trivector_matches_multivector (a in any :: < Scalar < f64 >> () , b in any :: < Trivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Trivector < f64 > = geometric_scalar_trivector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_scalar_vector_vector_matches_multivector (a in any :: < Scalar < f64 >> () , b in any :: < Vector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Vector < f64 > = geometric_scalar_vector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_trivector_bivector_flector_matches_multivector (a in any :: < Trivector < f64 >> () , b in any :: < Bivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = geometric_trivector_bivector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_trivector_flector_motor_matches_multivector (a in any :: < Trivector < f64 >> () , b in any :: < Flector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Motor < f64 > = geometric_trivector_flector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_trivector_motor_flector_matches_multivector (a in any :: < Trivector < f64 >> () , b in any :: < Motor < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = geometric_trivector_motor (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_trivector_quadvector_vector_matches_multivector (a in any :: < Trivector < f64 >> () , b in any :: < Quadvector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Vector < f64 > = geometric_trivector_quadvector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_trivector_scalar_trivector_matches_multivector (a in any :: < Trivector < f64 >> () , b in any :: < Scalar < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Trivector < f64 > = geometric_trivector_scalar (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_vector_bivector_flector_matches_multivector (a in any :: < Vector < f64 >> () , b in any :: < Bivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = geometric_vector_bivector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_vector_flector_motor_matches_multivector (a in any :: < Vector < f64 >> () , b in any :: < Flector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Motor < f64 > = geometric_vector_flector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_vector_motor_flector_matches_multivector (a in any :: < Vector < f64 >> () , b in any :: < Motor < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = geometric_vector_motor (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_vector_quadvector_trivector_matches_multivector (a in any :: < Vector < f64 >> () , b in any :: < Quadvector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Trivector < f64 > = geometric_vector_quadvector (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn geometric_vector_scalar_vector_matches_multivector (a in any :: < Vector < f64 >> () , b in any :: < Scalar < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Vector < f64 > = geometric_vector_scalar (& a , & b) ; let generic_result = mv_a * mv_b ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Geometric product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_bivector_bivector_quadvector_matches_multivector (a in any :: < Bivector < f64 >> () , b in any :: < Bivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Quadvector < f64 > = outer_bivector_bivector (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_bivector_flector_trivector_matches_multivector (a in any :: < Bivector < f64 >> () , b in any :: < Flector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Trivector < f64 > = outer_bivector_flector (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_bivector_scalar_bivector_matches_multivector (a in any :: < Bivector < f64 >> () , b in any :: < Scalar < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Bivector < f64 > = outer_bivector_scalar (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_bivector_vector_trivector_matches_multivector (a in any :: < Bivector < f64 >> () , b in any :: < Vector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Trivector < f64 > = outer_bivector_vector (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_flector_bivector_trivector_matches_multivector (a in any :: < Flector < f64 >> () , b in any :: < Bivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Trivector < f64 > = outer_flector_bivector (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_flector_motor_flector_matches_multivector (a in any :: < Flector < f64 >> () , b in any :: < Motor < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = outer_flector_motor (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_flector_scalar_flector_matches_multivector (a in any :: < Flector < f64 >> () , b in any :: < Scalar < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = outer_flector_scalar (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_flector_trivector_quadvector_matches_multivector (a in any :: < Flector < f64 >> () , b in any :: < Trivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Quadvector < f64 > = outer_flector_trivector (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_motor_flector_flector_matches_multivector (a in any :: < Motor < f64 >> () , b in any :: < Flector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = outer_motor_flector (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_motor_motor_motor_matches_multivector (a in any :: < Motor < f64 >> () , b in any :: < Motor < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Motor < f64 > = outer_motor_motor (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_motor_quadvector_quadvector_matches_multivector (a in any :: < Motor < f64 >> () , b in any :: < Quadvector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Quadvector < f64 > = outer_motor_quadvector (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_motor_scalar_motor_matches_multivector (a in any :: < Motor < f64 >> () , b in any :: < Scalar < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Motor < f64 > = outer_motor_scalar (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_motor_trivector_trivector_matches_multivector (a in any :: < Motor < f64 >> () , b in any :: < Trivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Trivector < f64 > = outer_motor_trivector (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_motor_vector_flector_matches_multivector (a in any :: < Motor < f64 >> () , b in any :: < Vector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = outer_motor_vector (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_quadvector_motor_quadvector_matches_multivector (a in any :: < Quadvector < f64 >> () , b in any :: < Motor < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Quadvector < f64 > = outer_quadvector_motor (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_quadvector_scalar_quadvector_matches_multivector (a in any :: < Quadvector < f64 >> () , b in any :: < Scalar < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Quadvector < f64 > = outer_quadvector_scalar (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_scalar_bivector_bivector_matches_multivector (a in any :: < Scalar < f64 >> () , b in any :: < Bivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Bivector < f64 > = outer_scalar_bivector (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_scalar_flector_flector_matches_multivector (a in any :: < Scalar < f64 >> () , b in any :: < Flector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = outer_scalar_flector (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_scalar_motor_motor_matches_multivector (a in any :: < Scalar < f64 >> () , b in any :: < Motor < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Motor < f64 > = outer_scalar_motor (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_scalar_quadvector_quadvector_matches_multivector (a in any :: < Scalar < f64 >> () , b in any :: < Quadvector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Quadvector < f64 > = outer_scalar_quadvector (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_scalar_scalar_scalar_matches_multivector (a in any :: < Scalar < f64 >> () , b in any :: < Scalar < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Scalar < f64 > = outer_scalar_scalar (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_scalar_trivector_trivector_matches_multivector (a in any :: < Scalar < f64 >> () , b in any :: < Trivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Trivector < f64 > = outer_scalar_trivector (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_scalar_vector_vector_matches_multivector (a in any :: < Scalar < f64 >> () , b in any :: < Vector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Vector < f64 > = outer_scalar_vector (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_trivector_flector_quadvector_matches_multivector (a in any :: < Trivector < f64 >> () , b in any :: < Flector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Quadvector < f64 > = outer_trivector_flector (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_trivector_motor_trivector_matches_multivector (a in any :: < Trivector < f64 >> () , b in any :: < Motor < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Trivector < f64 > = outer_trivector_motor (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_trivector_scalar_trivector_matches_multivector (a in any :: < Trivector < f64 >> () , b in any :: < Scalar < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Trivector < f64 > = outer_trivector_scalar (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_trivector_vector_quadvector_matches_multivector (a in any :: < Trivector < f64 >> () , b in any :: < Vector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Quadvector < f64 > = outer_trivector_vector (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_vector_bivector_trivector_matches_multivector (a in any :: < Vector < f64 >> () , b in any :: < Bivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Trivector < f64 > = outer_vector_bivector (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_vector_motor_flector_matches_multivector (a in any :: < Vector < f64 >> () , b in any :: < Motor < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Flector < f64 > = outer_vector_motor (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_vector_scalar_vector_matches_multivector (a in any :: < Vector < f64 >> () , b in any :: < Scalar < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Vector < f64 > = outer_vector_scalar (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_vector_trivector_quadvector_matches_multivector (a in any :: < Vector < f64 >> () , b in any :: < Trivector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Quadvector < f64 > = outer_vector_trivector (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
    proptest! { # [test] fn outer_vector_vector_bivector_matches_multivector (a in any :: < Vector < f64 >> () , b in any :: < Vector < f64 >> ()) { let mv_a : Multivector < f64 , Projective3 > = a . into () ; let mv_b : Multivector < f64 , Projective3 > = b . into () ; let specialized_result : Bivector < f64 > = outer_vector_vector (& a , & b) ; let generic_result = mv_a . outer (& mv_b) ; let specialized_mv : Multivector < f64 , Projective3 > = specialized_result . into () ; prop_assert ! (abs_diff_eq ! (specialized_mv , generic_result , epsilon = EPSILON) , "Outer product mismatch: specialized={:?}, generic={:?}" , specialized_mv , generic_result) ; } }
}
