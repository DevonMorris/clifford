#![doc = " Type definitions for projective3."]
#![doc = ""]
#![doc = " 3D Projective Geometric Algebra"]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
#![allow(clippy::too_many_arguments)]
use crate::scalar::Float;
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
#[doc = "Bivector\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 3 | e1e2 | `e12` |\n| 5 | e1e3 | `e13` |\n| 6 | e2e3 | `e23` |\n| 9 | e1e4 | `e01` |\n| 10 | e2e4 | `e02` |\n| 12 | e3e4 | `e03` |\n\n\n# Example\n\n```ignore\nuse clifford::generated/projective3::Bivector;\n\nlet v = Bivector::new(1.0, 2.0, 3.0, 4.0, 5.0, 6.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Bivector<T: Float> {
    #[doc = "Coefficient of `e1e2`."]
    e12: T,
    #[doc = "Coefficient of `e1e3`."]
    e13: T,
    #[doc = "Coefficient of `e2e3`."]
    e23: T,
    #[doc = "Coefficient of `e1e4`."]
    e01: T,
    #[doc = "Coefficient of `e2e4`."]
    e02: T,
    #[doc = "Coefficient of `e3e4`."]
    e03: T,
}
impl<T: Float> Bivector<T> {
    #[doc = "Creates a new element from 5 independent coefficients.\n\nThe `e03` coefficient(s) are computed from geometric constraints.\nWhen divisors are zero (degenerate case), computed values default to zero."]
    #[inline]
    pub fn new(e12: T, e13: T, e23: T, e01: T, e02: T) -> Self {
        let e03 = if (e12).abs() > T::epsilon() {
            (e13 * e02 - e23 * e01) / (e12)
        } else {
            T::zero()
        };
        Self {
            e12,
            e13,
            e23,
            e01,
            e02,
            e03,
        }
    }
    #[doc = "Creates a new element from all coefficients with constraint validation.\n\nReturns an error if the geometric constraint is not satisfied within\nthe given tolerance.\n\n# Errors\n\nReturns `ConstraintError` if `|-2*e12*e03 + 2*e13*e02 - 2*e23*e01| > tolerance`."]
    #[inline]
    pub fn new_checked(
        e12: T,
        e13: T,
        e23: T,
        e01: T,
        e02: T,
        e03: T,
        tolerance: T,
    ) -> Result<Self, crate::ConstraintError> {
        let residual = -T::TWO * e12 * e03 + T::TWO * e13 * e02 - T::TWO * e23 * e01;
        if residual.abs() > tolerance {
            return Err(crate::ConstraintError::new(
                "Bivector",
                "-2*e12*e03 + 2*e13*e02 - 2*e23*e01 = 0",
                residual.to_f64().unwrap_or(0.0),
            ));
        }
        Ok(Self {
            e12,
            e13,
            e23,
            e01,
            e02,
            e03,
        })
    }
    #[doc = r" Creates a new element from all coefficients without validation."]
    #[doc = r""]
    #[doc = r" # Safety (Logical)"]
    #[doc = r""]
    #[doc = r" Caller must ensure the geometric constraint is satisfied."]
    #[doc = r" Use this for performance-critical code, automatic differentiation,"]
    #[doc = r" or when coefficients come from trusted sources (e.g., product operations)."]
    #[inline]
    pub fn new_unchecked(e12: T, e13: T, e23: T, e01: T, e02: T, e03: T) -> Self {
        Self {
            e12,
            e13,
            e23,
            e01,
            e02,
            e03,
        }
    }
    #[doc = "Returns the e12 component (coefficient of `e1e2`)."]
    #[inline]
    pub fn e12(&self) -> T {
        self.e12
    }
    #[doc = "Returns the e13 component (coefficient of `e1e3`)."]
    #[inline]
    pub fn e13(&self) -> T {
        self.e13
    }
    #[doc = "Returns the e23 component (coefficient of `e2e3`)."]
    #[inline]
    pub fn e23(&self) -> T {
        self.e23
    }
    #[doc = "Returns the e01 component (coefficient of `e1e4`)."]
    #[inline]
    pub fn e01(&self) -> T {
        self.e01
    }
    #[doc = "Returns the e02 component (coefficient of `e2e4`)."]
    #[inline]
    pub fn e02(&self) -> T {
        self.e02
    }
    #[doc = "Returns the e03 component (coefficient of `e3e4`)."]
    #[inline]
    pub fn e03(&self) -> T {
        self.e03
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e2 element."]
    #[inline]
    pub fn unit_e12() -> Self {
        Self::new_unchecked(
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e3 element."]
    #[inline]
    pub fn unit_e13() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e2e3 element."]
    #[inline]
    pub fn unit_e23() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e4 element."]
    #[inline]
    pub fn unit_e01() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e2e4 element."]
    #[inline]
    pub fn unit_e02() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e3e4 element."]
    #[inline]
    pub fn unit_e03() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
        )
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.e12 * self.e12
            + self.e13 * self.e13
            + self.e23 * self.e23
            + self.e01 * self.e01
            + self.e02 * self.e02
            + self.e03 * self.e03
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(
            self.e12 * s,
            self.e13 * s,
            self.e23 * s,
            self.e01 * s,
            self.e02 * s,
            self.e03 * s,
        )
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(
            -self.e12, -self.e13, -self.e23, -self.e01, -self.e02, -self.e03,
        )
    }
}
impl<T: Float> Default for Bivector<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Flector\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 1 | e1 | `e1` |\n| 2 | e2 | `e2` |\n| 4 | e3 | `e3` |\n| 8 | e4 | `e0` |\n| 7 | e1e2e3 | `e123` |\n| 11 | e1e2e4 | `e012` |\n| 13 | e1e3e4 | `e013` |\n| 14 | e2e3e4 | `e023` |\n\n\n# Example\n\n```ignore\nuse clifford::generated/projective3::Flector;\n\nlet v = Flector::new(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Flector<T: Float> {
    #[doc = "Coefficient of `e1`."]
    e1: T,
    #[doc = "Coefficient of `e2`."]
    e2: T,
    #[doc = "Coefficient of `e3`."]
    e3: T,
    #[doc = "Coefficient of `e4`."]
    e0: T,
    #[doc = "Coefficient of `e1e2e3`."]
    e123: T,
    #[doc = "Coefficient of `e1e2e4`."]
    e012: T,
    #[doc = "Coefficient of `e1e3e4`."]
    e013: T,
    #[doc = "Coefficient of `e2e3e4`."]
    e023: T,
}
impl<T: Float> Flector<T> {
    #[doc = "Creates a new element from 7 independent coefficients.\n\nThe `e023` coefficient(s) are computed from geometric constraints.\nWhen divisors are zero (degenerate case), computed values default to zero."]
    #[inline]
    pub fn new(e1: T, e2: T, e3: T, e0: T, e123: T, e012: T, e013: T) -> Self {
        let e023 = if (e1).abs() > T::epsilon() {
            (e2 * e013 - e3 * e012 + e0 * e123) / (e1)
        } else {
            T::zero()
        };
        Self {
            e1,
            e2,
            e3,
            e0,
            e123,
            e012,
            e013,
            e023,
        }
    }
    #[doc = "Creates a new element from all coefficients with constraint validation.\n\nReturns an error if the geometric constraint is not satisfied within\nthe given tolerance.\n\n# Errors\n\nReturns `ConstraintError` if `|-2*e1*e023 + 2*e2*e013 - 2*e3*e012 + 2*e0*e123| > tolerance`."]
    #[inline]
    pub fn new_checked(
        e1: T,
        e2: T,
        e3: T,
        e0: T,
        e123: T,
        e012: T,
        e013: T,
        e023: T,
        tolerance: T,
    ) -> Result<Self, crate::ConstraintError> {
        let residual =
            -T::TWO * e1 * e023 + T::TWO * e2 * e013 - T::TWO * e3 * e012 + T::TWO * e0 * e123;
        if residual.abs() > tolerance {
            return Err(crate::ConstraintError::new(
                "Flector",
                "-2*e1*e023 + 2*e2*e013 - 2*e3*e012 + 2*e0*e123 = 0",
                residual.to_f64().unwrap_or(0.0),
            ));
        }
        Ok(Self {
            e1,
            e2,
            e3,
            e0,
            e123,
            e012,
            e013,
            e023,
        })
    }
    #[doc = r" Creates a new element from all coefficients without validation."]
    #[doc = r""]
    #[doc = r" # Safety (Logical)"]
    #[doc = r""]
    #[doc = r" Caller must ensure the geometric constraint is satisfied."]
    #[doc = r" Use this for performance-critical code, automatic differentiation,"]
    #[doc = r" or when coefficients come from trusted sources (e.g., product operations)."]
    #[inline]
    pub fn new_unchecked(e1: T, e2: T, e3: T, e0: T, e123: T, e012: T, e013: T, e023: T) -> Self {
        Self {
            e1,
            e2,
            e3,
            e0,
            e123,
            e012,
            e013,
            e023,
        }
    }
    #[doc = "Returns the e1 component (coefficient of `e1`)."]
    #[inline]
    pub fn e1(&self) -> T {
        self.e1
    }
    #[doc = "Returns the e2 component (coefficient of `e2`)."]
    #[inline]
    pub fn e2(&self) -> T {
        self.e2
    }
    #[doc = "Returns the e3 component (coefficient of `e3`)."]
    #[inline]
    pub fn e3(&self) -> T {
        self.e3
    }
    #[doc = "Returns the e0 component (coefficient of `e4`)."]
    #[inline]
    pub fn e0(&self) -> T {
        self.e0
    }
    #[doc = "Returns the e123 component (coefficient of `e1e2e3`)."]
    #[inline]
    pub fn e123(&self) -> T {
        self.e123
    }
    #[doc = "Returns the e012 component (coefficient of `e1e2e4`)."]
    #[inline]
    pub fn e012(&self) -> T {
        self.e012
    }
    #[doc = "Returns the e013 component (coefficient of `e1e3e4`)."]
    #[inline]
    pub fn e013(&self) -> T {
        self.e013
    }
    #[doc = "Returns the e023 component (coefficient of `e2e3e4`)."]
    #[inline]
    pub fn e023(&self) -> T {
        self.e023
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.e1 * self.e1
            + self.e2 * self.e2
            + self.e3 * self.e3
            + self.e0 * self.e0
            + self.e123 * self.e123
            + self.e012 * self.e012
            + self.e013 * self.e013
            + self.e023 * self.e023
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(
            self.e1 * s,
            self.e2 * s,
            self.e3 * s,
            self.e0 * s,
            self.e123 * s,
            self.e012 * s,
            self.e013 * s,
            self.e023 * s,
        )
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(
            self.e1, self.e2, self.e3, self.e0, -self.e123, -self.e012, -self.e013, -self.e023,
        )
    }
}
impl<T: Float> Default for Flector<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Motor\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 0 | s | `s` |\n| 3 | e1e2 | `e12` |\n| 5 | e1e3 | `e13` |\n| 6 | e2e3 | `e23` |\n| 9 | e1e4 | `e01` |\n| 10 | e2e4 | `e02` |\n| 12 | e3e4 | `e03` |\n| 15 | e1e2e3e4 | `e0123` |\n\n\n# Example\n\n```ignore\nuse clifford::generated/projective3::Motor;\n\nlet v = Motor::new(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Motor<T: Float> {
    #[doc = "Coefficient of `s`."]
    s: T,
    #[doc = "Coefficient of `e1e2`."]
    e12: T,
    #[doc = "Coefficient of `e1e3`."]
    e13: T,
    #[doc = "Coefficient of `e2e3`."]
    e23: T,
    #[doc = "Coefficient of `e1e4`."]
    e01: T,
    #[doc = "Coefficient of `e2e4`."]
    e02: T,
    #[doc = "Coefficient of `e3e4`."]
    e03: T,
    #[doc = "Coefficient of `e1e2e3e4`."]
    e0123: T,
}
impl<T: Float> Motor<T> {
    #[doc = "Creates a new element from 6 independent coefficients.\n\nThe `s`, `e0123` coefficient(s) are computed from geometric constraints.\n\nReturns `None` if the constraint cannot be satisfied (e.g., when the\nsqrt argument would be negative)."]
    #[inline]
    pub fn new(e12: T, e13: T, e23: T, e01: T, e02: T, e03: T) -> Option<Self> {
        let sqrt_arg = T::from_i8(1) - e12 * e12 - e13 * e13 - e23 * e23;
        if sqrt_arg < T::zero() {
            return None;
        }
        let s = sqrt_arg.sqrt();
        let e0123 = if (s).abs() > T::epsilon() {
            (e12 * e03 - e13 * e02 + e23 * e01) / (s)
        } else {
            T::zero()
        };
        Some(Self {
            s,
            e12,
            e13,
            e23,
            e01,
            e02,
            e03,
            e0123,
        })
    }
    #[doc = "Creates a new element from all coefficients with constraint validation.\n\nReturns an error if the geometric constraint is not satisfied within\nthe given tolerance.\n\n# Errors\n\nReturns `ConstraintError` if `|s*s + e12*e12 + e13*e13 + e23*e23 = 1| > tolerance`."]
    #[inline]
    pub fn new_checked(
        s: T,
        e12: T,
        e13: T,
        e23: T,
        e01: T,
        e02: T,
        e03: T,
        e0123: T,
        tolerance: T,
    ) -> Result<Self, crate::ConstraintError> {
        let residual = s * s + e12 * e12 + e13 * e13 + e23 * e23;
        if residual.abs() > tolerance {
            return Err(crate::ConstraintError::new(
                "Motor",
                "s*s + e12*e12 + e13*e13 + e23*e23 = 1",
                residual.to_f64().unwrap_or(0.0),
            ));
        }
        Ok(Self {
            s,
            e12,
            e13,
            e23,
            e01,
            e02,
            e03,
            e0123,
        })
    }
    #[doc = r" Creates a new element from all coefficients without validation."]
    #[doc = r""]
    #[doc = r" # Safety (Logical)"]
    #[doc = r""]
    #[doc = r" Caller must ensure the geometric constraint is satisfied."]
    #[doc = r" Use this for performance-critical code, automatic differentiation,"]
    #[doc = r" or when coefficients come from trusted sources (e.g., product operations)."]
    #[inline]
    pub fn new_unchecked(s: T, e12: T, e13: T, e23: T, e01: T, e02: T, e03: T, e0123: T) -> Self {
        Self {
            s,
            e12,
            e13,
            e23,
            e01,
            e02,
            e03,
            e0123,
        }
    }
    #[doc = "Returns the s component (coefficient of `s`)."]
    #[inline]
    pub fn s(&self) -> T {
        self.s
    }
    #[doc = "Returns the e12 component (coefficient of `e1e2`)."]
    #[inline]
    pub fn e12(&self) -> T {
        self.e12
    }
    #[doc = "Returns the e13 component (coefficient of `e1e3`)."]
    #[inline]
    pub fn e13(&self) -> T {
        self.e13
    }
    #[doc = "Returns the e23 component (coefficient of `e2e3`)."]
    #[inline]
    pub fn e23(&self) -> T {
        self.e23
    }
    #[doc = "Returns the e01 component (coefficient of `e1e4`)."]
    #[inline]
    pub fn e01(&self) -> T {
        self.e01
    }
    #[doc = "Returns the e02 component (coefficient of `e2e4`)."]
    #[inline]
    pub fn e02(&self) -> T {
        self.e02
    }
    #[doc = "Returns the e03 component (coefficient of `e3e4`)."]
    #[inline]
    pub fn e03(&self) -> T {
        self.e03
    }
    #[doc = "Returns the e0123 component (coefficient of `e1e2e3e4`)."]
    #[inline]
    pub fn e0123(&self) -> T {
        self.e0123
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = r" Creates the identity element (scalar = 1, rest = 0)."]
    #[inline]
    pub fn identity() -> Self {
        Self::new_unchecked(
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.s * self.s
            + self.e12 * self.e12
            + self.e13 * self.e13
            + self.e23 * self.e23
            + self.e01 * self.e01
            + self.e02 * self.e02
            + self.e03 * self.e03
            + self.e0123 * self.e0123
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(
            self.s * s,
            self.e12 * s,
            self.e13 * s,
            self.e23 * s,
            self.e01 * s,
            self.e02 * s,
            self.e03 * s,
            self.e0123 * s,
        )
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(
            self.s, -self.e12, -self.e13, -self.e23, -self.e01, -self.e02, -self.e03, self.e0123,
        )
    }
}
impl<T: Float> Default for Motor<T> {
    fn default() -> Self {
        Self::identity()
    }
}
#[doc = "Quadvector\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 15 | e1e2e3e4 | `e0123` |\n\n\n# Example\n\n```ignore\nuse clifford::generated/projective3::Quadvector;\n\nlet v = Quadvector::new(1.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Quadvector<T: Float> {
    #[doc = "Coefficient of `e1e2e3e4`."]
    e0123: T,
}
impl<T: Float> Quadvector<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(e0123: T) -> Self {
        Self { e0123 }
    }
    #[doc = "Returns the e0123 component (coefficient of `e1e2e3e4`)."]
    #[inline]
    pub fn e0123(&self) -> T {
        self.e0123
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new(T::zero())
    }
    #[doc = "Creates the unit e1e2e3e4 element."]
    #[inline]
    pub fn unit_e0123() -> Self {
        Self::new(T::one())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.e0123 * self.e0123
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new(self.e0123 * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new(self.e0123)
    }
}
impl<T: Float> Default for Quadvector<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Scalar\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 0 | s | `s` |\n\n\n# Example\n\n```ignore\nuse clifford::generated/projective3::Scalar;\n\nlet v = Scalar::new(1.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Scalar<T: Float> {
    #[doc = "Coefficient of `s`."]
    s: T,
}
impl<T: Float> Scalar<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(s: T) -> Self {
        Self { s }
    }
    #[doc = "Returns the s component (coefficient of `s`)."]
    #[inline]
    pub fn s(&self) -> T {
        self.s
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new(T::zero())
    }
    #[doc = r" Creates the identity element (scalar = 1, rest = 0)."]
    #[inline]
    pub fn identity() -> Self {
        Self::new(T::one())
    }
    #[doc = "Creates the unit s element."]
    #[inline]
    pub fn unit_s() -> Self {
        Self::new(T::one())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.s * self.s
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new(self.s * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new(self.s)
    }
}
impl<T: Float> Default for Scalar<T> {
    fn default() -> Self {
        Self::identity()
    }
}
#[doc = "Trivector\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 7 | e1e2e3 | `e123` |\n| 11 | e1e2e4 | `e012` |\n| 13 | e1e3e4 | `e013` |\n| 14 | e2e3e4 | `e023` |\n\n\n# Example\n\n```ignore\nuse clifford::generated/projective3::Trivector;\n\nlet v = Trivector::new(1.0, 2.0, 3.0, 4.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Trivector<T: Float> {
    #[doc = "Coefficient of `e1e2e3`."]
    e123: T,
    #[doc = "Coefficient of `e1e2e4`."]
    e012: T,
    #[doc = "Coefficient of `e1e3e4`."]
    e013: T,
    #[doc = "Coefficient of `e2e3e4`."]
    e023: T,
}
impl<T: Float> Trivector<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(e123: T, e012: T, e013: T, e023: T) -> Self {
        Self {
            e123,
            e012,
            e013,
            e023,
        }
    }
    #[doc = "Returns the e123 component (coefficient of `e1e2e3`)."]
    #[inline]
    pub fn e123(&self) -> T {
        self.e123
    }
    #[doc = "Returns the e012 component (coefficient of `e1e2e4`)."]
    #[inline]
    pub fn e012(&self) -> T {
        self.e012
    }
    #[doc = "Returns the e013 component (coefficient of `e1e3e4`)."]
    #[inline]
    pub fn e013(&self) -> T {
        self.e013
    }
    #[doc = "Returns the e023 component (coefficient of `e2e3e4`)."]
    #[inline]
    pub fn e023(&self) -> T {
        self.e023
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new(T::zero(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e2e3 element."]
    #[inline]
    pub fn unit_e123() -> Self {
        Self::new(T::one(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e2e4 element."]
    #[inline]
    pub fn unit_e012() -> Self {
        Self::new(T::zero(), T::one(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e3e4 element."]
    #[inline]
    pub fn unit_e013() -> Self {
        Self::new(T::zero(), T::zero(), T::one(), T::zero())
    }
    #[doc = "Creates the unit e2e3e4 element."]
    #[inline]
    pub fn unit_e023() -> Self {
        Self::new(T::zero(), T::zero(), T::zero(), T::one())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.e123 * self.e123
            + self.e012 * self.e012
            + self.e013 * self.e013
            + self.e023 * self.e023
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new(self.e123 * s, self.e012 * s, self.e013 * s, self.e023 * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new(-self.e123, -self.e012, -self.e013, -self.e023)
    }
}
impl<T: Float> Default for Trivector<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Vector\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 1 | e1 | `e1` |\n| 2 | e2 | `e2` |\n| 4 | e3 | `e3` |\n| 8 | e4 | `e0` |\n\n\n# Example\n\n```ignore\nuse clifford::generated/projective3::Vector;\n\nlet v = Vector::new(1.0, 2.0, 3.0, 4.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Vector<T: Float> {
    #[doc = "Coefficient of `e1`."]
    e1: T,
    #[doc = "Coefficient of `e2`."]
    e2: T,
    #[doc = "Coefficient of `e3`."]
    e3: T,
    #[doc = "Coefficient of `e4`."]
    e0: T,
}
impl<T: Float> Vector<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(e1: T, e2: T, e3: T, e0: T) -> Self {
        Self { e1, e2, e3, e0 }
    }
    #[doc = "Returns the e1 component (coefficient of `e1`)."]
    #[inline]
    pub fn e1(&self) -> T {
        self.e1
    }
    #[doc = "Returns the e2 component (coefficient of `e2`)."]
    #[inline]
    pub fn e2(&self) -> T {
        self.e2
    }
    #[doc = "Returns the e3 component (coefficient of `e3`)."]
    #[inline]
    pub fn e3(&self) -> T {
        self.e3
    }
    #[doc = "Returns the e0 component (coefficient of `e4`)."]
    #[inline]
    pub fn e0(&self) -> T {
        self.e0
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new(T::zero(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1 element."]
    #[inline]
    pub fn unit_e1() -> Self {
        Self::new(T::one(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e2 element."]
    #[inline]
    pub fn unit_e2() -> Self {
        Self::new(T::zero(), T::one(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e3 element."]
    #[inline]
    pub fn unit_e3() -> Self {
        Self::new(T::zero(), T::zero(), T::one(), T::zero())
    }
    #[doc = "Creates the unit e4 element."]
    #[inline]
    pub fn unit_e0() -> Self {
        Self::new(T::zero(), T::zero(), T::zero(), T::one())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.e1 * self.e1 + self.e2 * self.e2 + self.e3 * self.e3 + self.e0 * self.e0
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new(self.e1 * s, self.e2 * s, self.e3 * s, self.e0 * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new(self.e1, self.e2, self.e3, self.e0)
    }
}
impl<T: Float> Default for Vector<T> {
    fn default() -> Self {
        Self::zero()
    }
}
