#![doc = " Product functions for the projective2 algebra."]
#![doc = ""]
#![doc = " This module provides all algebraic products between types in the algebra."]
#![doc = " Each function is named `{product}_{lhs}_{rhs}` where:"]
#![doc = " - `product` is one of: `geometric`, `exterior`, `left_contract`, `inner`, `scalar`"]
#![doc = " - `lhs` and `rhs` are the input type names in lowercase"]
#![doc = ""]
#![doc = " # Available Products"]
#![doc = ""]
#![doc = " | Product | Symbol | Description |"]
#![doc = " |---------|--------|-------------|"]
#![doc = " | `geometric_*` | `×` | Full geometric product |"]
#![doc = " | `exterior_*` | `∧` | Wedge/exterior product (grade sum) |"]
#![doc = " | `left_contract_*` | `⌋` | Left contraction |"]
#![doc = " | `inner_*` | `·` | Symmetric inner product (grade diff) |"]
#![doc = " | `scalar_*` | `⟨⟩₀` | Scalar (grade-0) product |"]
#![doc = ""]
#![doc = " # Sandwich Products"]
#![doc = ""]
#![doc = " For versor types (rotors, motors), sandwich products are provided:"]
#![doc = " - `sandwich_{versor}_{operand}(v, x)` computes `v × x × rev(v)`"]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen. Do not edit manually."]
use super::types::{Flector, Line, Motor, Point, Scalar, Trivector};
use crate::scalar::Float;
#[doc = "Exterior product: Flector ^ Flector -> Flector"]
#[inline]
pub fn exterior_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s(),
        a.s() * b.e12() + a.e12() * b.s(),
        a.s() * b.e01() + a.e01() * b.s(),
        a.s() * b.e02() + a.e02() * b.s(),
    )
}
#[doc = "Exterior product: Flector ^ Line -> Line"]
#[inline]
pub fn exterior_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> Line<T> {
    Line::new(a.s() * b.e12(), a.s() * b.e01(), a.s() * b.e02())
}
#[doc = "Exterior product: Flector ^ Motor -> Motor"]
#[inline]
pub fn exterior_flector_motor<T: Float>(a: &Flector<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e1(),
        a.s() * b.e2(),
        a.s() * b.e0(),
        a.s() * b.e012() + a.e12() * b.e0() + -(a.e01() * b.e2()) + a.e02() * b.e1(),
    )
}
#[doc = "Exterior product: Flector ^ Point -> Motor"]
#[inline]
pub fn exterior_flector_point<T: Float>(a: &Flector<T>, b: &Point<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e1(),
        a.s() * b.e2(),
        a.s() * b.e0(),
        a.e12() * b.e0() + -(a.e01() * b.e2()) + a.e02() * b.e1(),
    )
}
#[doc = "Exterior product: Flector ^ Scalar -> Flector"]
#[inline]
pub fn exterior_flector_scalar<T: Float>(a: &Flector<T>, b: &Scalar<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s(),
        a.e12() * b.s(),
        a.e01() * b.s(),
        a.e02() * b.s(),
    )
}
#[doc = "Exterior product: Flector ^ Trivector -> Trivector"]
#[inline]
pub fn exterior_flector_trivector<T: Float>(a: &Flector<T>, b: &Trivector<T>) -> Trivector<T> {
    Trivector::new(a.s() * b.e012())
}
#[doc = "Exterior product: Line ^ Flector -> Line"]
#[inline]
pub fn exterior_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> Line<T> {
    Line::new(a.e12() * b.s(), a.e01() * b.s(), a.e02() * b.s())
}
#[doc = "Exterior product: Line ^ Motor -> Trivector"]
#[inline]
pub fn exterior_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Trivector<T> {
    Trivector::new(a.e12() * b.e0() + -(a.e01() * b.e2()) + a.e02() * b.e1())
}
#[doc = "Exterior product: Line ^ Point -> Trivector"]
#[inline]
pub fn exterior_line_point<T: Float>(a: &Line<T>, b: &Point<T>) -> Trivector<T> {
    Trivector::new(a.e12() * b.e0() + -(a.e01() * b.e2()) + a.e02() * b.e1())
}
#[doc = "Exterior product: Line ^ Scalar -> Line"]
#[inline]
pub fn exterior_line_scalar<T: Float>(a: &Line<T>, b: &Scalar<T>) -> Line<T> {
    Line::new(a.e12() * b.s(), a.e01() * b.s(), a.e02() * b.s())
}
#[doc = "Exterior product: Motor ^ Flector -> Motor"]
#[inline]
pub fn exterior_motor_flector<T: Float>(a: &Motor<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.e1(),
        b.s() * a.e2(),
        b.s() * a.e0(),
        b.s() * a.e012() + b.e12() * a.e0() + -(b.e01() * a.e2()) + b.e02() * a.e1(),
    )
}
#[doc = "Exterior product: Motor ^ Line -> Trivector"]
#[inline]
pub fn exterior_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Trivector<T> {
    Trivector::new(b.e12() * a.e0() + -(b.e01() * a.e2()) + b.e02() * a.e1())
}
#[doc = "Exterior product: Motor ^ Motor -> Line"]
#[inline]
pub fn exterior_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Line<T> {
    Line::new(
        -(b.e1() * a.e2()) + b.e2() * a.e1(),
        -(b.e1() * a.e0()) + b.e0() * a.e1(),
        -(b.e2() * a.e0()) + b.e0() * a.e2(),
    )
}
#[doc = "Exterior product: Motor ^ Point -> Line"]
#[inline]
pub fn exterior_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Line<T> {
    Line::new(
        -(b.e1() * a.e2()) + b.e2() * a.e1(),
        -(b.e1() * a.e0()) + b.e0() * a.e1(),
        -(b.e2() * a.e0()) + b.e0() * a.e2(),
    )
}
#[doc = "Exterior product: Motor ^ Scalar -> Motor"]
#[inline]
pub fn exterior_motor_scalar<T: Float>(a: &Motor<T>, b: &Scalar<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.e1(),
        b.s() * a.e2(),
        b.s() * a.e0(),
        b.s() * a.e012(),
    )
}
#[doc = "Exterior product: Point ^ Flector -> Motor"]
#[inline]
pub fn exterior_point_flector<T: Float>(a: &Point<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.e1(),
        b.s() * a.e2(),
        b.s() * a.e0(),
        b.e12() * a.e0() + -(b.e01() * a.e2()) + b.e02() * a.e1(),
    )
}
#[doc = "Exterior product: Point ^ Line -> Trivector"]
#[inline]
pub fn exterior_point_line<T: Float>(a: &Point<T>, b: &Line<T>) -> Trivector<T> {
    Trivector::new(b.e12() * a.e0() + -(b.e01() * a.e2()) + b.e02() * a.e1())
}
#[doc = "Exterior product: Point ^ Motor -> Line"]
#[inline]
pub fn exterior_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Line<T> {
    Line::new(
        -(b.e1() * a.e2()) + b.e2() * a.e1(),
        -(b.e1() * a.e0()) + b.e0() * a.e1(),
        -(b.e2() * a.e0()) + b.e0() * a.e2(),
    )
}
#[doc = "Exterior product: Point ^ Point -> Line"]
#[inline]
pub fn exterior_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> Line<T> {
    Line::new(
        -(b.e1() * a.e2()) + b.e2() * a.e1(),
        -(b.e1() * a.e0()) + b.e0() * a.e1(),
        -(b.e2() * a.e0()) + b.e0() * a.e2(),
    )
}
#[doc = "Exterior product: Point ^ Scalar -> Point"]
#[inline]
pub fn exterior_point_scalar<T: Float>(a: &Point<T>, b: &Scalar<T>) -> Point<T> {
    Point::new(b.s() * a.e1(), b.s() * a.e2(), b.s() * a.e0())
}
#[doc = "Exterior product: Scalar ^ Flector -> Flector"]
#[inline]
pub fn exterior_scalar_flector<T: Float>(a: &Scalar<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s(),
        a.s() * b.e12(),
        a.s() * b.e01(),
        a.s() * b.e02(),
    )
}
#[doc = "Exterior product: Scalar ^ Line -> Line"]
#[inline]
pub fn exterior_scalar_line<T: Float>(a: &Scalar<T>, b: &Line<T>) -> Line<T> {
    Line::new(a.s() * b.e12(), a.s() * b.e01(), a.s() * b.e02())
}
#[doc = "Exterior product: Scalar ^ Motor -> Motor"]
#[inline]
pub fn exterior_scalar_motor<T: Float>(a: &Scalar<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e1(),
        a.s() * b.e2(),
        a.s() * b.e0(),
        a.s() * b.e012(),
    )
}
#[doc = "Exterior product: Scalar ^ Point -> Point"]
#[inline]
pub fn exterior_scalar_point<T: Float>(a: &Scalar<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.s() * b.e1(), a.s() * b.e2(), a.s() * b.e0())
}
#[doc = "Exterior product: Scalar ^ Scalar -> Scalar"]
#[inline]
pub fn exterior_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.s())
}
#[doc = "Exterior product: Scalar ^ Trivector -> Trivector"]
#[inline]
pub fn exterior_scalar_trivector<T: Float>(a: &Scalar<T>, b: &Trivector<T>) -> Trivector<T> {
    Trivector::new(a.s() * b.e012())
}
#[doc = "Exterior product: Trivector ^ Flector -> Trivector"]
#[inline]
pub fn exterior_trivector_flector<T: Float>(a: &Trivector<T>, b: &Flector<T>) -> Trivector<T> {
    Trivector::new(b.s() * a.e012())
}
#[doc = "Exterior product: Trivector ^ Scalar -> Trivector"]
#[inline]
pub fn exterior_trivector_scalar<T: Float>(a: &Trivector<T>, b: &Scalar<T>) -> Trivector<T> {
    Trivector::new(b.s() * a.e012())
}
#[doc = "Interior product (symmetric inner): Flector · Flector -> Flector"]
#[inline]
pub fn interior_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s() + -(a.e12() * b.e12()),
        a.s() * b.e12() + a.e12() * b.s(),
        a.s() * b.e01() + a.e01() * b.s(),
        a.s() * b.e02() + a.e02() * b.s(),
    )
}
#[doc = "Interior product (symmetric inner): Flector · Line -> Flector"]
#[inline]
pub fn interior_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> Flector<T> {
    Flector::new(
        -(a.e12() * b.e12()),
        a.s() * b.e12(),
        a.s() * b.e01(),
        a.s() * b.e02(),
    )
}
#[doc = "Interior product (symmetric inner): Flector · Motor -> Motor"]
#[inline]
pub fn interior_flector_motor<T: Float>(a: &Flector<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e1() + a.e12() * b.e2(),
        a.s() * b.e2() + -(a.e12() * b.e1()),
        a.s() * b.e0() + -(a.e12() * b.e012()) + -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
        a.s() * b.e012(),
    )
}
#[doc = "Interior product (symmetric inner): Flector · Point -> Point"]
#[inline]
pub fn interior_flector_point<T: Float>(a: &Flector<T>, b: &Point<T>) -> Point<T> {
    Point::new(
        a.s() * b.e1() + a.e12() * b.e2(),
        a.s() * b.e2() + -(a.e12() * b.e1()),
        a.s() * b.e0() + -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
    )
}
#[doc = "Interior product (symmetric inner): Flector · Scalar -> Flector"]
#[inline]
pub fn interior_flector_scalar<T: Float>(a: &Flector<T>, b: &Scalar<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s(),
        a.e12() * b.s(),
        a.e01() * b.s(),
        a.e02() * b.s(),
    )
}
#[doc = "Interior product (symmetric inner): Flector · Trivector -> Motor"]
#[inline]
pub fn interior_flector_trivector<T: Float>(a: &Flector<T>, b: &Trivector<T>) -> Motor<T> {
    Motor::new(
        T::zero(),
        T::zero(),
        -(a.e12() * b.e012()),
        a.s() * b.e012(),
    )
}
#[doc = "Interior product (symmetric inner): Line · Flector -> Flector"]
#[inline]
pub fn interior_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        -(a.e12() * b.e12()),
        a.e12() * b.s(),
        a.e01() * b.s(),
        a.e02() * b.s(),
    )
}
#[doc = "Interior product (symmetric inner): Line · Line -> Scalar"]
#[inline]
pub fn interior_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(-(a.e12() * b.e12()))
}
#[doc = "Interior product (symmetric inner): Line · Motor -> Point"]
#[inline]
pub fn interior_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e2(),
        -(a.e12() * b.e1()),
        -(a.e12() * b.e012()) + -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
    )
}
#[doc = "Interior product (symmetric inner): Line · Point -> Point"]
#[inline]
pub fn interior_line_point<T: Float>(a: &Line<T>, b: &Point<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e2(),
        -(a.e12() * b.e1()),
        -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
    )
}
#[doc = "Interior product (symmetric inner): Line · Scalar -> Line"]
#[inline]
pub fn interior_line_scalar<T: Float>(a: &Line<T>, b: &Scalar<T>) -> Line<T> {
    Line::new(a.e12() * b.s(), a.e01() * b.s(), a.e02() * b.s())
}
#[doc = "Interior product (symmetric inner): Line · Trivector -> Point"]
#[inline]
pub fn interior_line_trivector<T: Float>(a: &Line<T>, b: &Trivector<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), -(a.e12() * b.e012()))
}
#[doc = "Interior product (symmetric inner): Motor · Flector -> Motor"]
#[inline]
pub fn interior_motor_flector<T: Float>(a: &Motor<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.e1() + -(b.e12() * a.e2()),
        b.s() * a.e2() + b.e12() * a.e1(),
        b.s() * a.e0() + -(b.e12() * a.e012()) + b.e01() * a.e1() + b.e02() * a.e2(),
        b.s() * a.e012(),
    )
}
#[doc = "Interior product (symmetric inner): Motor · Line -> Point"]
#[inline]
pub fn interior_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Point<T> {
    Point::new(
        -(b.e12() * a.e2()),
        b.e12() * a.e1(),
        -(b.e12() * a.e012()) + b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Interior product (symmetric inner): Motor · Motor -> Flector"]
#[inline]
pub fn interior_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        b.e1() * a.e1() + b.e2() * a.e2(),
        T::zero(),
        -(b.e2() * a.e012()) + -(b.e012() * a.e2()),
        b.e1() * a.e012() + b.e012() * a.e1(),
    )
}
#[doc = "Interior product (symmetric inner): Motor · Point -> Flector"]
#[inline]
pub fn interior_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Flector<T> {
    Flector::new(
        b.e1() * a.e1() + b.e2() * a.e2(),
        T::zero(),
        -(b.e2() * a.e012()),
        b.e1() * a.e012(),
    )
}
#[doc = "Interior product (symmetric inner): Motor · Scalar -> Motor"]
#[inline]
pub fn interior_motor_scalar<T: Float>(a: &Motor<T>, b: &Scalar<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.e1(),
        b.s() * a.e2(),
        b.s() * a.e0(),
        b.s() * a.e012(),
    )
}
#[doc = "Interior product (symmetric inner): Motor · Trivector -> Line"]
#[inline]
pub fn interior_motor_trivector<T: Float>(a: &Motor<T>, b: &Trivector<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e012() * a.e2()), b.e012() * a.e1())
}
#[doc = "Interior product (symmetric inner): Point · Flector -> Point"]
#[inline]
pub fn interior_point_flector<T: Float>(a: &Point<T>, b: &Flector<T>) -> Point<T> {
    Point::new(
        b.s() * a.e1() + -(b.e12() * a.e2()),
        b.s() * a.e2() + b.e12() * a.e1(),
        b.s() * a.e0() + b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Interior product (symmetric inner): Point · Line -> Point"]
#[inline]
pub fn interior_point_line<T: Float>(a: &Point<T>, b: &Line<T>) -> Point<T> {
    Point::new(
        -(b.e12() * a.e2()),
        b.e12() * a.e1(),
        b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Interior product (symmetric inner): Point · Motor -> Flector"]
#[inline]
pub fn interior_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        b.e1() * a.e1() + b.e2() * a.e2(),
        T::zero(),
        -(b.e012() * a.e2()),
        b.e012() * a.e1(),
    )
}
#[doc = "Interior product (symmetric inner): Point · Point -> Scalar"]
#[inline]
pub fn interior_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> Scalar<T> {
    Scalar::new(b.e1() * a.e1() + b.e2() * a.e2())
}
#[doc = "Interior product (symmetric inner): Point · Scalar -> Point"]
#[inline]
pub fn interior_point_scalar<T: Float>(a: &Point<T>, b: &Scalar<T>) -> Point<T> {
    Point::new(b.s() * a.e1(), b.s() * a.e2(), b.s() * a.e0())
}
#[doc = "Interior product (symmetric inner): Point · Trivector -> Line"]
#[inline]
pub fn interior_point_trivector<T: Float>(a: &Point<T>, b: &Trivector<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e012() * a.e2()), b.e012() * a.e1())
}
#[doc = "Interior product (symmetric inner): Scalar · Flector -> Flector"]
#[inline]
pub fn interior_scalar_flector<T: Float>(a: &Scalar<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s(),
        a.s() * b.e12(),
        a.s() * b.e01(),
        a.s() * b.e02(),
    )
}
#[doc = "Interior product (symmetric inner): Scalar · Line -> Line"]
#[inline]
pub fn interior_scalar_line<T: Float>(a: &Scalar<T>, b: &Line<T>) -> Line<T> {
    Line::new(a.s() * b.e12(), a.s() * b.e01(), a.s() * b.e02())
}
#[doc = "Interior product (symmetric inner): Scalar · Motor -> Motor"]
#[inline]
pub fn interior_scalar_motor<T: Float>(a: &Scalar<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e1(),
        a.s() * b.e2(),
        a.s() * b.e0(),
        a.s() * b.e012(),
    )
}
#[doc = "Interior product (symmetric inner): Scalar · Point -> Point"]
#[inline]
pub fn interior_scalar_point<T: Float>(a: &Scalar<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.s() * b.e1(), a.s() * b.e2(), a.s() * b.e0())
}
#[doc = "Interior product (symmetric inner): Scalar · Scalar -> Scalar"]
#[inline]
pub fn interior_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.s())
}
#[doc = "Interior product (symmetric inner): Scalar · Trivector -> Trivector"]
#[inline]
pub fn interior_scalar_trivector<T: Float>(a: &Scalar<T>, b: &Trivector<T>) -> Trivector<T> {
    Trivector::new(a.s() * b.e012())
}
#[doc = "Interior product (symmetric inner): Trivector · Flector -> Motor"]
#[inline]
pub fn interior_trivector_flector<T: Float>(a: &Trivector<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        T::zero(),
        T::zero(),
        -(b.e12() * a.e012()),
        b.s() * a.e012(),
    )
}
#[doc = "Interior product (symmetric inner): Trivector · Line -> Point"]
#[inline]
pub fn interior_trivector_line<T: Float>(a: &Trivector<T>, b: &Line<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), -(b.e12() * a.e012()))
}
#[doc = "Interior product (symmetric inner): Trivector · Motor -> Line"]
#[inline]
pub fn interior_trivector_motor<T: Float>(a: &Trivector<T>, b: &Motor<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e2() * a.e012()), b.e1() * a.e012())
}
#[doc = "Interior product (symmetric inner): Trivector · Point -> Line"]
#[inline]
pub fn interior_trivector_point<T: Float>(a: &Trivector<T>, b: &Point<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e2() * a.e012()), b.e1() * a.e012())
}
#[doc = "Interior product (symmetric inner): Trivector · Scalar -> Trivector"]
#[inline]
pub fn interior_trivector_scalar<T: Float>(a: &Trivector<T>, b: &Scalar<T>) -> Trivector<T> {
    Trivector::new(b.s() * a.e012())
}
#[doc = "Left contraction: Flector | Flector -> Flector"]
#[inline]
pub fn left_contract_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s() + -(a.e12() * b.e12()),
        a.s() * b.e12(),
        a.s() * b.e01(),
        a.s() * b.e02(),
    )
}
#[doc = "Left contraction: Flector | Line -> Flector"]
#[inline]
pub fn left_contract_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> Flector<T> {
    Flector::new(
        -(a.e12() * b.e12()),
        a.s() * b.e12(),
        a.s() * b.e01(),
        a.s() * b.e02(),
    )
}
#[doc = "Left contraction: Flector | Motor -> Motor"]
#[inline]
pub fn left_contract_flector_motor<T: Float>(a: &Flector<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e1(),
        a.s() * b.e2(),
        a.s() * b.e0() + -(a.e12() * b.e012()),
        a.s() * b.e012(),
    )
}
#[doc = "Left contraction: Flector | Point -> Point"]
#[inline]
pub fn left_contract_flector_point<T: Float>(a: &Flector<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.s() * b.e1(), a.s() * b.e2(), a.s() * b.e0())
}
#[doc = "Left contraction: Flector | Scalar -> Scalar"]
#[inline]
pub fn left_contract_flector_scalar<T: Float>(a: &Flector<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.s())
}
#[doc = "Left contraction: Flector | Trivector -> Motor"]
#[inline]
pub fn left_contract_flector_trivector<T: Float>(a: &Flector<T>, b: &Trivector<T>) -> Motor<T> {
    Motor::new(
        T::zero(),
        T::zero(),
        -(a.e12() * b.e012()),
        a.s() * b.e012(),
    )
}
#[doc = "Left contraction: Line | Flector -> Scalar"]
#[inline]
pub fn left_contract_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> Scalar<T> {
    Scalar::new(-(a.e12() * b.e12()))
}
#[doc = "Left contraction: Line | Line -> Scalar"]
#[inline]
pub fn left_contract_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(-(a.e12() * b.e12()))
}
#[doc = "Left contraction: Line | Motor -> Point"]
#[inline]
pub fn left_contract_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), -(a.e12() * b.e012()))
}
#[doc = "Left contraction: Line | Trivector -> Point"]
#[inline]
pub fn left_contract_line_trivector<T: Float>(a: &Line<T>, b: &Trivector<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), -(a.e12() * b.e012()))
}
#[doc = "Left contraction: Motor | Flector -> Point"]
#[inline]
pub fn left_contract_motor_flector<T: Float>(a: &Motor<T>, b: &Flector<T>) -> Point<T> {
    Point::new(
        -(b.e12() * a.e2()),
        b.e12() * a.e1(),
        b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Left contraction: Motor | Line -> Point"]
#[inline]
pub fn left_contract_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Point<T> {
    Point::new(
        -(b.e12() * a.e2()),
        b.e12() * a.e1(),
        b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Left contraction: Motor | Motor -> Flector"]
#[inline]
pub fn left_contract_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        b.e1() * a.e1() + b.e2() * a.e2(),
        T::zero(),
        -(b.e012() * a.e2()),
        b.e012() * a.e1(),
    )
}
#[doc = "Left contraction: Motor | Point -> Scalar"]
#[inline]
pub fn left_contract_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Scalar<T> {
    Scalar::new(b.e1() * a.e1() + b.e2() * a.e2())
}
#[doc = "Left contraction: Motor | Trivector -> Line"]
#[inline]
pub fn left_contract_motor_trivector<T: Float>(a: &Motor<T>, b: &Trivector<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e012() * a.e2()), b.e012() * a.e1())
}
#[doc = "Left contraction: Point | Flector -> Point"]
#[inline]
pub fn left_contract_point_flector<T: Float>(a: &Point<T>, b: &Flector<T>) -> Point<T> {
    Point::new(
        -(b.e12() * a.e2()),
        b.e12() * a.e1(),
        b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Left contraction: Point | Line -> Point"]
#[inline]
pub fn left_contract_point_line<T: Float>(a: &Point<T>, b: &Line<T>) -> Point<T> {
    Point::new(
        -(b.e12() * a.e2()),
        b.e12() * a.e1(),
        b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Left contraction: Point | Motor -> Flector"]
#[inline]
pub fn left_contract_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        b.e1() * a.e1() + b.e2() * a.e2(),
        T::zero(),
        -(b.e012() * a.e2()),
        b.e012() * a.e1(),
    )
}
#[doc = "Left contraction: Point | Point -> Scalar"]
#[inline]
pub fn left_contract_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> Scalar<T> {
    Scalar::new(b.e1() * a.e1() + b.e2() * a.e2())
}
#[doc = "Left contraction: Point | Trivector -> Line"]
#[inline]
pub fn left_contract_point_trivector<T: Float>(a: &Point<T>, b: &Trivector<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e012() * a.e2()), b.e012() * a.e1())
}
#[doc = "Left contraction: Scalar | Flector -> Flector"]
#[inline]
pub fn left_contract_scalar_flector<T: Float>(a: &Scalar<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s(),
        a.s() * b.e12(),
        a.s() * b.e01(),
        a.s() * b.e02(),
    )
}
#[doc = "Left contraction: Scalar | Line -> Line"]
#[inline]
pub fn left_contract_scalar_line<T: Float>(a: &Scalar<T>, b: &Line<T>) -> Line<T> {
    Line::new(a.s() * b.e12(), a.s() * b.e01(), a.s() * b.e02())
}
#[doc = "Left contraction: Scalar | Motor -> Motor"]
#[inline]
pub fn left_contract_scalar_motor<T: Float>(a: &Scalar<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e1(),
        a.s() * b.e2(),
        a.s() * b.e0(),
        a.s() * b.e012(),
    )
}
#[doc = "Left contraction: Scalar | Point -> Point"]
#[inline]
pub fn left_contract_scalar_point<T: Float>(a: &Scalar<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.s() * b.e1(), a.s() * b.e2(), a.s() * b.e0())
}
#[doc = "Left contraction: Scalar | Scalar -> Scalar"]
#[inline]
pub fn left_contract_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.s())
}
#[doc = "Left contraction: Scalar | Trivector -> Trivector"]
#[inline]
pub fn left_contract_scalar_trivector<T: Float>(a: &Scalar<T>, b: &Trivector<T>) -> Trivector<T> {
    Trivector::new(a.s() * b.e012())
}
#[doc = "Right contraction: Flector ⌊ Flector -> Flector"]
#[inline]
pub fn right_contract_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s() + -(a.e12() * b.e12()),
        a.s() * b.e12() + a.e12() * b.s(),
        a.s() * b.e01() + a.e12() * b.e02() + a.e01() * b.s() + -(a.e02() * b.e12()),
        a.s() * b.e02() + -(a.e12() * b.e01()) + a.e01() * b.e12() + a.e02() * b.s(),
    )
}
#[doc = "Right contraction: Flector ⌊ Line -> Scalar"]
#[inline]
pub fn right_contract_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(-(a.e12() * b.e12()))
}
#[doc = "Right contraction: Flector ⌊ Motor -> Point"]
#[inline]
pub fn right_contract_flector_motor<T: Float>(a: &Flector<T>, b: &Motor<T>) -> Point<T> {
    Point::new(
        a.s() * b.e1() + a.e12() * b.e2(),
        a.s() * b.e2() + -(a.e12() * b.e1()),
        a.s() * b.e0() + -(a.e12() * b.e012()) + -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
    )
}
#[doc = "Right contraction: Flector ⌊ Point -> Point"]
#[inline]
pub fn right_contract_flector_point<T: Float>(a: &Flector<T>, b: &Point<T>) -> Point<T> {
    Point::new(
        a.s() * b.e1() + a.e12() * b.e2(),
        a.s() * b.e2() + -(a.e12() * b.e1()),
        a.s() * b.e0() + -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
    )
}
#[doc = "Right contraction: Flector ⌊ Scalar -> Flector"]
#[inline]
pub fn right_contract_flector_scalar<T: Float>(a: &Flector<T>, b: &Scalar<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s(),
        a.e12() * b.s(),
        a.e01() * b.s(),
        a.e02() * b.s(),
    )
}
#[doc = "Right contraction: Line ⌊ Flector -> Flector"]
#[inline]
pub fn right_contract_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        -(a.e12() * b.e12()),
        a.e12() * b.s(),
        a.e12() * b.e02() + a.e01() * b.s() + -(a.e02() * b.e12()),
        -(a.e12() * b.e01()) + a.e01() * b.e12() + a.e02() * b.s(),
    )
}
#[doc = "Right contraction: Line ⌊ Line -> Scalar"]
#[inline]
pub fn right_contract_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(-(a.e12() * b.e12()))
}
#[doc = "Right contraction: Line ⌊ Motor -> Point"]
#[inline]
pub fn right_contract_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e2(),
        -(a.e12() * b.e1()),
        -(a.e12() * b.e012()) + -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
    )
}
#[doc = "Right contraction: Line ⌊ Point -> Point"]
#[inline]
pub fn right_contract_line_point<T: Float>(a: &Line<T>, b: &Point<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e2(),
        -(a.e12() * b.e1()),
        -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
    )
}
#[doc = "Right contraction: Line ⌊ Scalar -> Line"]
#[inline]
pub fn right_contract_line_scalar<T: Float>(a: &Line<T>, b: &Scalar<T>) -> Line<T> {
    Line::new(a.e12() * b.s(), a.e01() * b.s(), a.e02() * b.s())
}
#[doc = "Right contraction: Motor ⌊ Flector -> Motor"]
#[inline]
pub fn right_contract_motor_flector<T: Float>(a: &Motor<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.e1() + -(b.e12() * a.e2()),
        b.s() * a.e2() + b.e12() * a.e1(),
        b.s() * a.e0() + -(b.e12() * a.e012()) + b.e01() * a.e1() + b.e02() * a.e2(),
        b.s() * a.e012() + b.e12() * a.e0() + -(b.e01() * a.e2()) + b.e02() * a.e1(),
    )
}
#[doc = "Right contraction: Motor ⌊ Line -> Point"]
#[inline]
pub fn right_contract_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Point<T> {
    Point::new(
        -(b.e12() * a.e2()),
        b.e12() * a.e1(),
        -(b.e12() * a.e012()) + b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Right contraction: Motor ⌊ Motor -> Flector"]
#[inline]
pub fn right_contract_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        b.e1() * a.e1() + b.e2() * a.e2(),
        -(b.e1() * a.e2()) + b.e2() * a.e1(),
        -(b.e1() * a.e0()) + -(b.e2() * a.e012()) + b.e0() * a.e1() + -(b.e012() * a.e2()),
        b.e1() * a.e012() + -(b.e2() * a.e0()) + b.e0() * a.e2() + b.e012() * a.e1(),
    )
}
#[doc = "Right contraction: Motor ⌊ Point -> Flector"]
#[inline]
pub fn right_contract_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Flector<T> {
    Flector::new(
        b.e1() * a.e1() + b.e2() * a.e2(),
        -(b.e1() * a.e2()) + b.e2() * a.e1(),
        -(b.e1() * a.e0()) + -(b.e2() * a.e012()) + b.e0() * a.e1(),
        b.e1() * a.e012() + -(b.e2() * a.e0()) + b.e0() * a.e2(),
    )
}
#[doc = "Right contraction: Motor ⌊ Scalar -> Motor"]
#[inline]
pub fn right_contract_motor_scalar<T: Float>(a: &Motor<T>, b: &Scalar<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.e1(),
        b.s() * a.e2(),
        b.s() * a.e0(),
        b.s() * a.e012(),
    )
}
#[doc = "Right contraction: Point ⌊ Flector -> Point"]
#[inline]
pub fn right_contract_point_flector<T: Float>(a: &Point<T>, b: &Flector<T>) -> Point<T> {
    Point::new(
        b.s() * a.e1() + -(b.e12() * a.e2()),
        b.s() * a.e2() + b.e12() * a.e1(),
        b.s() * a.e0() + b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Right contraction: Point ⌊ Motor -> Scalar"]
#[inline]
pub fn right_contract_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Scalar<T> {
    Scalar::new(b.e1() * a.e1() + b.e2() * a.e2())
}
#[doc = "Right contraction: Point ⌊ Point -> Scalar"]
#[inline]
pub fn right_contract_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> Scalar<T> {
    Scalar::new(b.e1() * a.e1() + b.e2() * a.e2())
}
#[doc = "Right contraction: Point ⌊ Scalar -> Point"]
#[inline]
pub fn right_contract_point_scalar<T: Float>(a: &Point<T>, b: &Scalar<T>) -> Point<T> {
    Point::new(b.s() * a.e1(), b.s() * a.e2(), b.s() * a.e0())
}
#[doc = "Right contraction: Scalar ⌊ Flector -> Scalar"]
#[inline]
pub fn right_contract_scalar_flector<T: Float>(a: &Scalar<T>, b: &Flector<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.s())
}
#[doc = "Right contraction: Scalar ⌊ Scalar -> Scalar"]
#[inline]
pub fn right_contract_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.s())
}
#[doc = "Right contraction: Trivector ⌊ Flector -> Motor"]
#[inline]
pub fn right_contract_trivector_flector<T: Float>(a: &Trivector<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        T::zero(),
        T::zero(),
        -(b.e12() * a.e012()),
        b.s() * a.e012(),
    )
}
#[doc = "Right contraction: Trivector ⌊ Line -> Point"]
#[inline]
pub fn right_contract_trivector_line<T: Float>(a: &Trivector<T>, b: &Line<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), -(b.e12() * a.e012()))
}
#[doc = "Right contraction: Trivector ⌊ Motor -> Line"]
#[inline]
pub fn right_contract_trivector_motor<T: Float>(a: &Trivector<T>, b: &Motor<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e2() * a.e012()), b.e1() * a.e012())
}
#[doc = "Right contraction: Trivector ⌊ Point -> Line"]
#[inline]
pub fn right_contract_trivector_point<T: Float>(a: &Trivector<T>, b: &Point<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e2() * a.e012()), b.e1() * a.e012())
}
#[doc = "Right contraction: Trivector ⌊ Scalar -> Trivector"]
#[inline]
pub fn right_contract_trivector_scalar<T: Float>(a: &Trivector<T>, b: &Scalar<T>) -> Trivector<T> {
    Trivector::new(b.s() * a.e012())
}
#[doc = "Regressive product (meet): Flector ∨ Flector -> Point"]
#[inline]
pub fn regressive_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e01() - a.e01() * b.e12(),
        a.e12() * b.e02() - a.e02() * b.e12(),
        a.e01() * b.e02() - a.e02() * b.e01(),
    )
}
#[doc = "Regressive product (meet): Flector ∨ Line -> Point"]
#[inline]
pub fn regressive_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e01() - a.e01() * b.e12(),
        a.e12() * b.e02() - a.e02() * b.e12(),
        a.e01() * b.e02() - a.e02() * b.e01(),
    )
}
#[doc = "Regressive product (meet): Flector ∨ Motor -> Flector"]
#[inline]
pub fn regressive_flector_motor<T: Float>(a: &Flector<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.e012() + a.e12() * b.e0() - a.e01() * b.e2() + a.e02() * b.e1(),
        a.e12() * b.e012(),
        a.e01() * b.e012(),
        a.e02() * b.e012(),
    )
}
#[doc = "Regressive product (meet): Flector ∨ Point -> Scalar"]
#[inline]
pub fn regressive_flector_point<T: Float>(a: &Flector<T>, b: &Point<T>) -> Scalar<T> {
    Scalar::new(a.e12() * b.e0() - a.e01() * b.e2() + a.e02() * b.e1())
}
#[doc = "Regressive product (meet): Flector ∨ Trivector -> Flector"]
#[inline]
pub fn regressive_flector_trivector<T: Float>(a: &Flector<T>, b: &Trivector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.e012(),
        a.e12() * b.e012(),
        a.e01() * b.e012(),
        a.e02() * b.e012(),
    )
}
#[doc = "Regressive product (meet): Line ∨ Flector -> Point"]
#[inline]
pub fn regressive_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e01() - a.e01() * b.e12(),
        a.e12() * b.e02() - a.e02() * b.e12(),
        a.e01() * b.e02() - a.e02() * b.e01(),
    )
}
#[doc = "Regressive product (meet): Line ∨ Line -> Point"]
#[inline]
pub fn regressive_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e01() - a.e01() * b.e12(),
        a.e12() * b.e02() - a.e02() * b.e12(),
        a.e01() * b.e02() - a.e02() * b.e01(),
    )
}
#[doc = "Regressive product (meet): Line ∨ Motor -> Flector"]
#[inline]
pub fn regressive_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        a.e12() * b.e0() - a.e01() * b.e2() + a.e02() * b.e1(),
        a.e12() * b.e012(),
        a.e01() * b.e012(),
        a.e02() * b.e012(),
    )
}
#[doc = "Regressive product (meet): Line ∨ Point -> Scalar"]
#[inline]
pub fn regressive_line_point<T: Float>(a: &Line<T>, b: &Point<T>) -> Scalar<T> {
    Scalar::new(a.e12() * b.e0() - a.e01() * b.e2() + a.e02() * b.e1())
}
#[doc = "Regressive product (meet): Line ∨ Trivector -> Line"]
#[inline]
pub fn regressive_line_trivector<T: Float>(a: &Line<T>, b: &Trivector<T>) -> Line<T> {
    Line::new(a.e12() * b.e012(), a.e01() * b.e012(), a.e02() * b.e012())
}
#[doc = "Regressive product (meet): Motor ∨ Flector -> Flector"]
#[inline]
pub fn regressive_motor_flector<T: Float>(a: &Motor<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.e1() * b.e02() - a.e2() * b.e01() + a.e0() * b.e12() + a.e012() * b.s(),
        a.e012() * b.e12(),
        a.e012() * b.e01(),
        a.e012() * b.e02(),
    )
}
#[doc = "Regressive product (meet): Motor ∨ Line -> Flector"]
#[inline]
pub fn regressive_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Flector<T> {
    Flector::new(
        a.e1() * b.e02() - a.e2() * b.e01() + a.e0() * b.e12(),
        a.e012() * b.e12(),
        a.e012() * b.e01(),
        a.e012() * b.e02(),
    )
}
#[doc = "Regressive product (meet): Motor ∨ Motor -> Motor"]
#[inline]
pub fn regressive_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.e1() * b.e012() + a.e012() * b.e1(),
        a.e2() * b.e012() + a.e012() * b.e2(),
        a.e0() * b.e012() + a.e012() * b.e0(),
        a.e012() * b.e012(),
    )
}
#[doc = "Regressive product (meet): Motor ∨ Point -> Point"]
#[inline]
pub fn regressive_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.e012() * b.e1(), a.e012() * b.e2(), a.e012() * b.e0())
}
#[doc = "Regressive product (meet): Motor ∨ Scalar -> Scalar"]
#[inline]
pub fn regressive_motor_scalar<T: Float>(a: &Motor<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.e012() * b.s())
}
#[doc = "Regressive product (meet): Motor ∨ Trivector -> Motor"]
#[inline]
pub fn regressive_motor_trivector<T: Float>(a: &Motor<T>, b: &Trivector<T>) -> Motor<T> {
    Motor::new(
        a.e1() * b.e012(),
        a.e2() * b.e012(),
        a.e0() * b.e012(),
        a.e012() * b.e012(),
    )
}
#[doc = "Regressive product (meet): Point ∨ Flector -> Scalar"]
#[inline]
pub fn regressive_point_flector<T: Float>(a: &Point<T>, b: &Flector<T>) -> Scalar<T> {
    Scalar::new(a.e1() * b.e02() - a.e2() * b.e01() + a.e0() * b.e12())
}
#[doc = "Regressive product (meet): Point ∨ Line -> Scalar"]
#[inline]
pub fn regressive_point_line<T: Float>(a: &Point<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(a.e1() * b.e02() - a.e2() * b.e01() + a.e0() * b.e12())
}
#[doc = "Regressive product (meet): Point ∨ Motor -> Point"]
#[inline]
pub fn regressive_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Point<T> {
    Point::new(a.e1() * b.e012(), a.e2() * b.e012(), a.e0() * b.e012())
}
#[doc = "Regressive product (meet): Point ∨ Trivector -> Point"]
#[inline]
pub fn regressive_point_trivector<T: Float>(a: &Point<T>, b: &Trivector<T>) -> Point<T> {
    Point::new(a.e1() * b.e012(), a.e2() * b.e012(), a.e0() * b.e012())
}
#[doc = "Regressive product (meet): Scalar ∨ Motor -> Scalar"]
#[inline]
pub fn regressive_scalar_motor<T: Float>(a: &Scalar<T>, b: &Motor<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.e012())
}
#[doc = "Regressive product (meet): Scalar ∨ Trivector -> Scalar"]
#[inline]
pub fn regressive_scalar_trivector<T: Float>(a: &Scalar<T>, b: &Trivector<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.e012())
}
#[doc = "Regressive product (meet): Trivector ∨ Flector -> Flector"]
#[inline]
pub fn regressive_trivector_flector<T: Float>(a: &Trivector<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.e012() * b.s(),
        a.e012() * b.e12(),
        a.e012() * b.e01(),
        a.e012() * b.e02(),
    )
}
#[doc = "Regressive product (meet): Trivector ∨ Line -> Line"]
#[inline]
pub fn regressive_trivector_line<T: Float>(a: &Trivector<T>, b: &Line<T>) -> Line<T> {
    Line::new(a.e012() * b.e12(), a.e012() * b.e01(), a.e012() * b.e02())
}
#[doc = "Regressive product (meet): Trivector ∨ Motor -> Motor"]
#[inline]
pub fn regressive_trivector_motor<T: Float>(a: &Trivector<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.e012() * b.e1(),
        a.e012() * b.e2(),
        a.e012() * b.e0(),
        a.e012() * b.e012(),
    )
}
#[doc = "Regressive product (meet): Trivector ∨ Point -> Point"]
#[inline]
pub fn regressive_trivector_point<T: Float>(a: &Trivector<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.e012() * b.e1(), a.e012() * b.e2(), a.e012() * b.e0())
}
#[doc = "Regressive product (meet): Trivector ∨ Scalar -> Scalar"]
#[inline]
pub fn regressive_trivector_scalar<T: Float>(a: &Trivector<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.e012() * b.s())
}
#[doc = "Regressive product (meet): Trivector ∨ Trivector -> Trivector"]
#[inline]
pub fn regressive_trivector_trivector<T: Float>(
    a: &Trivector<T>,
    b: &Trivector<T>,
) -> Trivector<T> {
    Trivector::new(a.e012() * b.e012())
}
#[doc = "Scalar product: Flector * Flector -> T (grade-0 part)"]
#[inline]
pub fn scalar_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> T {
    a.s() * b.s() - a.e12() * b.e12()
}
#[doc = "Scalar product: Flector * Line -> T (grade-0 part)"]
#[inline]
pub fn scalar_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> T {
    -(a.e12() * b.e12())
}
#[doc = "Scalar product: Flector * Scalar -> T (grade-0 part)"]
#[inline]
pub fn scalar_flector_scalar<T: Float>(a: &Flector<T>, b: &Scalar<T>) -> T {
    a.s() * b.s()
}
#[doc = "Scalar product: Line * Flector -> T (grade-0 part)"]
#[inline]
pub fn scalar_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> T {
    -(a.e12() * b.e12())
}
#[doc = "Scalar product: Line * Line -> T (grade-0 part)"]
#[inline]
pub fn scalar_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> T {
    -(a.e12() * b.e12())
}
#[doc = "Scalar product: Motor * Motor -> T (grade-0 part)"]
#[inline]
pub fn scalar_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> T {
    a.e1() * b.e1() + a.e2() * b.e2()
}
#[doc = "Scalar product: Motor * Point -> T (grade-0 part)"]
#[inline]
pub fn scalar_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> T {
    a.e1() * b.e1() + a.e2() * b.e2()
}
#[doc = "Scalar product: Point * Motor -> T (grade-0 part)"]
#[inline]
pub fn scalar_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> T {
    a.e1() * b.e1() + a.e2() * b.e2()
}
#[doc = "Scalar product: Point * Point -> T (grade-0 part)"]
#[inline]
pub fn scalar_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> T {
    a.e1() * b.e1() + a.e2() * b.e2()
}
#[doc = "Scalar product: Scalar * Flector -> T (grade-0 part)"]
#[inline]
pub fn scalar_scalar_flector<T: Float>(a: &Scalar<T>, b: &Flector<T>) -> T {
    a.s() * b.s()
}
#[doc = "Scalar product: Scalar * Scalar -> T (grade-0 part)"]
#[inline]
pub fn scalar_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> T {
    a.s() * b.s()
}
#[doc = "Dot product: Flector • Flector -> T (same-grade metric inner)"]
#[inline]
pub fn dot_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> T {
    a.s() * b.s() - a.e12() * b.e12()
}
#[doc = "Dot product: Flector • Line -> T (same-grade metric inner)"]
#[inline]
pub fn dot_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> T {
    -(a.e12() * b.e12())
}
#[doc = "Dot product: Flector • Scalar -> T (same-grade metric inner)"]
#[inline]
pub fn dot_flector_scalar<T: Float>(a: &Flector<T>, b: &Scalar<T>) -> T {
    a.s() * b.s()
}
#[doc = "Dot product: Line • Flector -> T (same-grade metric inner)"]
#[inline]
pub fn dot_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> T {
    -(a.e12() * b.e12())
}
#[doc = "Dot product: Line • Line -> T (same-grade metric inner)"]
#[inline]
pub fn dot_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> T {
    -(a.e12() * b.e12())
}
#[doc = "Dot product: Motor • Motor -> T (same-grade metric inner)"]
#[inline]
pub fn dot_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> T {
    a.e1() * b.e1() + a.e2() * b.e2()
}
#[doc = "Dot product: Motor • Point -> T (same-grade metric inner)"]
#[inline]
pub fn dot_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> T {
    a.e1() * b.e1() + a.e2() * b.e2()
}
#[doc = "Dot product: Point • Motor -> T (same-grade metric inner)"]
#[inline]
pub fn dot_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> T {
    a.e1() * b.e1() + a.e2() * b.e2()
}
#[doc = "Dot product: Point • Point -> T (same-grade metric inner)"]
#[inline]
pub fn dot_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> T {
    a.e1() * b.e1() + a.e2() * b.e2()
}
#[doc = "Dot product: Scalar • Flector -> T (same-grade metric inner)"]
#[inline]
pub fn dot_scalar_flector<T: Float>(a: &Scalar<T>, b: &Flector<T>) -> T {
    a.s() * b.s()
}
#[doc = "Dot product: Scalar • Scalar -> T (same-grade metric inner)"]
#[inline]
pub fn dot_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> T {
    a.s() * b.s()
}
#[doc = "Antidot product: Flector ⊚ Flector -> T (same-antigrade metric anti-inner)"]
#[inline]
pub fn antidot_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> T {
    a.e01() * b.e01() + a.e02() * b.e02()
}
#[doc = "Antidot product: Flector ⊚ Line -> T (same-antigrade metric anti-inner)"]
#[inline]
pub fn antidot_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> T {
    a.e01() * b.e01() + a.e02() * b.e02()
}
#[doc = "Antidot product: Line ⊚ Flector -> T (same-antigrade metric anti-inner)"]
#[inline]
pub fn antidot_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> T {
    a.e01() * b.e01() + a.e02() * b.e02()
}
#[doc = "Antidot product: Line ⊚ Line -> T (same-antigrade metric anti-inner)"]
#[inline]
pub fn antidot_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> T {
    a.e01() * b.e01() + a.e02() * b.e02()
}
#[doc = "Antidot product: Motor ⊚ Motor -> T (same-antigrade metric anti-inner)"]
#[inline]
pub fn antidot_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> T {
    -(a.e0() * b.e0()) + a.e012() * b.e012()
}
#[doc = "Antidot product: Motor ⊚ Point -> T (same-antigrade metric anti-inner)"]
#[inline]
pub fn antidot_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> T {
    -(a.e0() * b.e0())
}
#[doc = "Antidot product: Motor ⊚ Trivector -> T (same-antigrade metric anti-inner)"]
#[inline]
pub fn antidot_motor_trivector<T: Float>(a: &Motor<T>, b: &Trivector<T>) -> T {
    a.e012() * b.e012()
}
#[doc = "Antidot product: Point ⊚ Motor -> T (same-antigrade metric anti-inner)"]
#[inline]
pub fn antidot_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> T {
    -(a.e0() * b.e0())
}
#[doc = "Antidot product: Point ⊚ Point -> T (same-antigrade metric anti-inner)"]
#[inline]
pub fn antidot_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> T {
    -(a.e0() * b.e0())
}
#[doc = "Antidot product: Trivector ⊚ Motor -> T (same-antigrade metric anti-inner)"]
#[inline]
pub fn antidot_trivector_motor<T: Float>(a: &Trivector<T>, b: &Motor<T>) -> T {
    a.e012() * b.e012()
}
#[doc = "Antidot product: Trivector ⊚ Trivector -> T (same-antigrade metric anti-inner)"]
#[inline]
pub fn antidot_trivector_trivector<T: Float>(a: &Trivector<T>, b: &Trivector<T>) -> T {
    a.e012() * b.e012()
}
#[doc = "bulk contraction: Flector ∨ b★ Flector -> Flector"]
#[inline]
pub fn bulk_contraction_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s() + a.e12() * b.e12(),
        a.e12() * b.s(),
        a.e01() * b.s(),
        a.e02() * b.s(),
    )
}
#[doc = "bulk contraction: Flector ∨ b★ Line -> Scalar"]
#[inline]
pub fn bulk_contraction_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(a.e12() * b.e12())
}
#[doc = "bulk contraction: Flector ∨ b★ Motor -> Point"]
#[inline]
pub fn bulk_contraction_flector_motor<T: Float>(a: &Flector<T>, b: &Motor<T>) -> Point<T> {
    Point::new(
        -(a.e12() * b.e2()),
        a.e12() * b.e1(),
        a.e01() * b.e1() + a.e02() * b.e2(),
    )
}
#[doc = "bulk contraction: Flector ∨ b★ Point -> Point"]
#[inline]
pub fn bulk_contraction_flector_point<T: Float>(a: &Flector<T>, b: &Point<T>) -> Point<T> {
    Point::new(
        -(a.e12() * b.e2()),
        a.e12() * b.e1(),
        a.e01() * b.e1() + a.e02() * b.e2(),
    )
}
#[doc = "bulk contraction: Flector ∨ b★ Scalar -> Flector"]
#[inline]
pub fn bulk_contraction_flector_scalar<T: Float>(a: &Flector<T>, b: &Scalar<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s(),
        a.e12() * b.s(),
        a.e01() * b.s(),
        a.e02() * b.s(),
    )
}
#[doc = "bulk contraction: Line ∨ b★ Flector -> Flector"]
#[inline]
pub fn bulk_contraction_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.e12() * b.e12(),
        a.e12() * b.s(),
        a.e01() * b.s(),
        a.e02() * b.s(),
    )
}
#[doc = "bulk contraction: Line ∨ b★ Line -> Scalar"]
#[inline]
pub fn bulk_contraction_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(a.e12() * b.e12())
}
#[doc = "bulk contraction: Line ∨ b★ Motor -> Point"]
#[inline]
pub fn bulk_contraction_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Point<T> {
    Point::new(
        -(a.e12() * b.e2()),
        a.e12() * b.e1(),
        a.e01() * b.e1() + a.e02() * b.e2(),
    )
}
#[doc = "bulk contraction: Line ∨ b★ Point -> Point"]
#[inline]
pub fn bulk_contraction_line_point<T: Float>(a: &Line<T>, b: &Point<T>) -> Point<T> {
    Point::new(
        -(a.e12() * b.e2()),
        a.e12() * b.e1(),
        a.e01() * b.e1() + a.e02() * b.e2(),
    )
}
#[doc = "bulk contraction: Line ∨ b★ Scalar -> Line"]
#[inline]
pub fn bulk_contraction_line_scalar<T: Float>(a: &Line<T>, b: &Scalar<T>) -> Line<T> {
    Line::new(a.e12() * b.s(), a.e01() * b.s(), a.e02() * b.s())
}
#[doc = "bulk contraction: Motor ∨ b★ Flector -> Motor"]
#[inline]
pub fn bulk_contraction_motor_flector<T: Float>(a: &Motor<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        a.e1() * b.s(),
        a.e2() * b.s(),
        a.e0() * b.s() + a.e012() * b.e12(),
        a.e012() * b.s(),
    )
}
#[doc = "bulk contraction: Motor ∨ b★ Line -> Point"]
#[inline]
pub fn bulk_contraction_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), a.e012() * b.e12())
}
#[doc = "bulk contraction: Motor ∨ b★ Motor -> Flector"]
#[inline]
pub fn bulk_contraction_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        a.e1() * b.e1() + a.e2() * b.e2(),
        T::zero(),
        -(a.e012() * b.e2()),
        a.e012() * b.e1(),
    )
}
#[doc = "bulk contraction: Motor ∨ b★ Point -> Flector"]
#[inline]
pub fn bulk_contraction_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Flector<T> {
    Flector::new(
        a.e1() * b.e1() + a.e2() * b.e2(),
        T::zero(),
        -(a.e012() * b.e2()),
        a.e012() * b.e1(),
    )
}
#[doc = "bulk contraction: Motor ∨ b★ Scalar -> Motor"]
#[inline]
pub fn bulk_contraction_motor_scalar<T: Float>(a: &Motor<T>, b: &Scalar<T>) -> Motor<T> {
    Motor::new(
        a.e1() * b.s(),
        a.e2() * b.s(),
        a.e0() * b.s(),
        a.e012() * b.s(),
    )
}
#[doc = "bulk contraction: Point ∨ b★ Flector -> Point"]
#[inline]
pub fn bulk_contraction_point_flector<T: Float>(a: &Point<T>, b: &Flector<T>) -> Point<T> {
    Point::new(a.e1() * b.s(), a.e2() * b.s(), a.e0() * b.s())
}
#[doc = "bulk contraction: Point ∨ b★ Motor -> Scalar"]
#[inline]
pub fn bulk_contraction_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Scalar<T> {
    Scalar::new(a.e1() * b.e1() + a.e2() * b.e2())
}
#[doc = "bulk contraction: Point ∨ b★ Point -> Scalar"]
#[inline]
pub fn bulk_contraction_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> Scalar<T> {
    Scalar::new(a.e1() * b.e1() + a.e2() * b.e2())
}
#[doc = "bulk contraction: Point ∨ b★ Scalar -> Point"]
#[inline]
pub fn bulk_contraction_point_scalar<T: Float>(a: &Point<T>, b: &Scalar<T>) -> Point<T> {
    Point::new(a.e1() * b.s(), a.e2() * b.s(), a.e0() * b.s())
}
#[doc = "bulk contraction: Scalar ∨ b★ Flector -> Scalar"]
#[inline]
pub fn bulk_contraction_scalar_flector<T: Float>(a: &Scalar<T>, b: &Flector<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.s())
}
#[doc = "bulk contraction: Scalar ∨ b★ Scalar -> Scalar"]
#[inline]
pub fn bulk_contraction_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.s())
}
#[doc = "bulk contraction: Trivector ∨ b★ Flector -> Motor"]
#[inline]
pub fn bulk_contraction_trivector_flector<T: Float>(a: &Trivector<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(T::zero(), T::zero(), a.e012() * b.e12(), a.e012() * b.s())
}
#[doc = "bulk contraction: Trivector ∨ b★ Line -> Point"]
#[inline]
pub fn bulk_contraction_trivector_line<T: Float>(a: &Trivector<T>, b: &Line<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), a.e012() * b.e12())
}
#[doc = "bulk contraction: Trivector ∨ b★ Motor -> Line"]
#[inline]
pub fn bulk_contraction_trivector_motor<T: Float>(a: &Trivector<T>, b: &Motor<T>) -> Line<T> {
    Line::new(T::zero(), -(a.e012() * b.e2()), a.e012() * b.e1())
}
#[doc = "bulk contraction: Trivector ∨ b★ Point -> Line"]
#[inline]
pub fn bulk_contraction_trivector_point<T: Float>(a: &Trivector<T>, b: &Point<T>) -> Line<T> {
    Line::new(T::zero(), -(a.e012() * b.e2()), a.e012() * b.e1())
}
#[doc = "bulk contraction: Trivector ∨ b★ Scalar -> Trivector"]
#[inline]
pub fn bulk_contraction_trivector_scalar<T: Float>(
    a: &Trivector<T>,
    b: &Scalar<T>,
) -> Trivector<T> {
    Trivector::new(a.e012() * b.s())
}
#[doc = "weight contraction: Flector ∨ b☆ Flector -> Scalar"]
#[inline]
pub fn weight_contraction_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> Scalar<T> {
    Scalar::new(-(a.e01() * b.e01()) - a.e02() * b.e02())
}
#[doc = "weight contraction: Flector ∨ b☆ Line -> Scalar"]
#[inline]
pub fn weight_contraction_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(-(a.e01() * b.e01()) - a.e02() * b.e02())
}
#[doc = "weight contraction: Flector ∨ b☆ Motor -> Point"]
#[inline]
pub fn weight_contraction_flector_motor<T: Float>(a: &Flector<T>, b: &Motor<T>) -> Point<T> {
    Point::new(a.e01() * b.e0(), a.e02() * b.e0(), T::zero())
}
#[doc = "weight contraction: Flector ∨ b☆ Point -> Point"]
#[inline]
pub fn weight_contraction_flector_point<T: Float>(a: &Flector<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.e01() * b.e0(), a.e02() * b.e0(), T::zero())
}
#[doc = "weight contraction: Line ∨ b☆ Flector -> Scalar"]
#[inline]
pub fn weight_contraction_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> Scalar<T> {
    Scalar::new(-(a.e01() * b.e01()) - a.e02() * b.e02())
}
#[doc = "weight contraction: Line ∨ b☆ Line -> Scalar"]
#[inline]
pub fn weight_contraction_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(-(a.e01() * b.e01()) - a.e02() * b.e02())
}
#[doc = "weight contraction: Line ∨ b☆ Motor -> Point"]
#[inline]
pub fn weight_contraction_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Point<T> {
    Point::new(a.e01() * b.e0(), a.e02() * b.e0(), T::zero())
}
#[doc = "weight contraction: Line ∨ b☆ Point -> Point"]
#[inline]
pub fn weight_contraction_line_point<T: Float>(a: &Line<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.e01() * b.e0(), a.e02() * b.e0(), T::zero())
}
#[doc = "weight contraction: Motor ∨ b☆ Flector -> Point"]
#[inline]
pub fn weight_contraction_motor_flector<T: Float>(a: &Motor<T>, b: &Flector<T>) -> Point<T> {
    Point::new(-(a.e012() * b.e02()), a.e012() * b.e01(), T::zero())
}
#[doc = "weight contraction: Motor ∨ b☆ Line -> Point"]
#[inline]
pub fn weight_contraction_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Point<T> {
    Point::new(-(a.e012() * b.e02()), a.e012() * b.e01(), T::zero())
}
#[doc = "weight contraction: Motor ∨ b☆ Motor -> Flector"]
#[inline]
pub fn weight_contraction_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        -(a.e0() * b.e0()) - a.e012() * b.e012(),
        -(a.e012() * b.e0()),
        T::zero(),
        T::zero(),
    )
}
#[doc = "weight contraction: Motor ∨ b☆ Point -> Flector"]
#[inline]
pub fn weight_contraction_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Flector<T> {
    Flector::new(
        -(a.e0() * b.e0()),
        -(a.e012() * b.e0()),
        T::zero(),
        T::zero(),
    )
}
#[doc = "weight contraction: Motor ∨ b☆ Trivector -> Scalar"]
#[inline]
pub fn weight_contraction_motor_trivector<T: Float>(a: &Motor<T>, b: &Trivector<T>) -> Scalar<T> {
    Scalar::new(-(a.e012() * b.e012()))
}
#[doc = "weight contraction: Point ∨ b☆ Motor -> Scalar"]
#[inline]
pub fn weight_contraction_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Scalar<T> {
    Scalar::new(-(a.e0() * b.e0()))
}
#[doc = "weight contraction: Point ∨ b☆ Point -> Scalar"]
#[inline]
pub fn weight_contraction_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> Scalar<T> {
    Scalar::new(-(a.e0() * b.e0()))
}
#[doc = "weight contraction: Trivector ∨ b☆ Flector -> Point"]
#[inline]
pub fn weight_contraction_trivector_flector<T: Float>(
    a: &Trivector<T>,
    b: &Flector<T>,
) -> Point<T> {
    Point::new(-(a.e012() * b.e02()), a.e012() * b.e01(), T::zero())
}
#[doc = "weight contraction: Trivector ∨ b☆ Line -> Point"]
#[inline]
pub fn weight_contraction_trivector_line<T: Float>(a: &Trivector<T>, b: &Line<T>) -> Point<T> {
    Point::new(-(a.e012() * b.e02()), a.e012() * b.e01(), T::zero())
}
#[doc = "weight contraction: Trivector ∨ b☆ Motor -> Flector"]
#[inline]
pub fn weight_contraction_trivector_motor<T: Float>(a: &Trivector<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        -(a.e012() * b.e012()),
        -(a.e012() * b.e0()),
        T::zero(),
        T::zero(),
    )
}
#[doc = "weight contraction: Trivector ∨ b☆ Point -> Line"]
#[inline]
pub fn weight_contraction_trivector_point<T: Float>(a: &Trivector<T>, b: &Point<T>) -> Line<T> {
    Line::new(-(a.e012() * b.e0()), T::zero(), T::zero())
}
#[doc = "weight contraction: Trivector ∨ b☆ Trivector -> Scalar"]
#[inline]
pub fn weight_contraction_trivector_trivector<T: Float>(
    a: &Trivector<T>,
    b: &Trivector<T>,
) -> Scalar<T> {
    Scalar::new(-(a.e012() * b.e012()))
}
#[doc = "bulk expansion: Flector ∧ b★ Flector -> Motor"]
#[inline]
pub fn bulk_expansion_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        T::zero(),
        T::zero(),
        a.s() * b.e12(),
        a.s() * b.s() + a.e12() * b.e12(),
    )
}
#[doc = "bulk expansion: Flector ∧ b★ Line -> Motor"]
#[inline]
pub fn bulk_expansion_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> Motor<T> {
    Motor::new(T::zero(), T::zero(), a.s() * b.e12(), a.e12() * b.e12())
}
#[doc = "bulk expansion: Flector ∧ b★ Motor -> Line"]
#[inline]
pub fn bulk_expansion_flector_motor<T: Float>(a: &Flector<T>, b: &Motor<T>) -> Line<T> {
    Line::new(T::zero(), -(a.s() * b.e2()), a.s() * b.e1())
}
#[doc = "bulk expansion: Flector ∧ b★ Point -> Line"]
#[inline]
pub fn bulk_expansion_flector_point<T: Float>(a: &Flector<T>, b: &Point<T>) -> Line<T> {
    Line::new(T::zero(), -(a.s() * b.e2()), a.s() * b.e1())
}
#[doc = "bulk expansion: Flector ∧ b★ Scalar -> Trivector"]
#[inline]
pub fn bulk_expansion_flector_scalar<T: Float>(a: &Flector<T>, b: &Scalar<T>) -> Trivector<T> {
    Trivector::new(a.s() * b.s())
}
#[doc = "bulk expansion: Line ∧ b★ Flector -> Trivector"]
#[inline]
pub fn bulk_expansion_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> Trivector<T> {
    Trivector::new(a.e12() * b.e12())
}
#[doc = "bulk expansion: Line ∧ b★ Line -> Trivector"]
#[inline]
pub fn bulk_expansion_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Trivector<T> {
    Trivector::new(a.e12() * b.e12())
}
#[doc = "bulk expansion: Motor ∧ b★ Flector -> Line"]
#[inline]
pub fn bulk_expansion_motor_flector<T: Float>(a: &Motor<T>, b: &Flector<T>) -> Line<T> {
    Line::new(T::zero(), a.e1() * b.e12(), a.e2() * b.e12())
}
#[doc = "bulk expansion: Motor ∧ b★ Line -> Line"]
#[inline]
pub fn bulk_expansion_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Line<T> {
    Line::new(T::zero(), a.e1() * b.e12(), a.e2() * b.e12())
}
#[doc = "bulk expansion: Motor ∧ b★ Motor -> Trivector"]
#[inline]
pub fn bulk_expansion_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Trivector<T> {
    Trivector::new(a.e1() * b.e1() + a.e2() * b.e2())
}
#[doc = "bulk expansion: Motor ∧ b★ Point -> Trivector"]
#[inline]
pub fn bulk_expansion_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Trivector<T> {
    Trivector::new(a.e1() * b.e1() + a.e2() * b.e2())
}
#[doc = "bulk expansion: Point ∧ b★ Flector -> Line"]
#[inline]
pub fn bulk_expansion_point_flector<T: Float>(a: &Point<T>, b: &Flector<T>) -> Line<T> {
    Line::new(T::zero(), a.e1() * b.e12(), a.e2() * b.e12())
}
#[doc = "bulk expansion: Point ∧ b★ Line -> Line"]
#[inline]
pub fn bulk_expansion_point_line<T: Float>(a: &Point<T>, b: &Line<T>) -> Line<T> {
    Line::new(T::zero(), a.e1() * b.e12(), a.e2() * b.e12())
}
#[doc = "bulk expansion: Point ∧ b★ Motor -> Trivector"]
#[inline]
pub fn bulk_expansion_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Trivector<T> {
    Trivector::new(a.e1() * b.e1() + a.e2() * b.e2())
}
#[doc = "bulk expansion: Point ∧ b★ Point -> Trivector"]
#[inline]
pub fn bulk_expansion_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> Trivector<T> {
    Trivector::new(a.e1() * b.e1() + a.e2() * b.e2())
}
#[doc = "bulk expansion: Scalar ∧ b★ Flector -> Motor"]
#[inline]
pub fn bulk_expansion_scalar_flector<T: Float>(a: &Scalar<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(T::zero(), T::zero(), a.s() * b.e12(), a.s() * b.s())
}
#[doc = "bulk expansion: Scalar ∧ b★ Line -> Point"]
#[inline]
pub fn bulk_expansion_scalar_line<T: Float>(a: &Scalar<T>, b: &Line<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), a.s() * b.e12())
}
#[doc = "bulk expansion: Scalar ∧ b★ Motor -> Line"]
#[inline]
pub fn bulk_expansion_scalar_motor<T: Float>(a: &Scalar<T>, b: &Motor<T>) -> Line<T> {
    Line::new(T::zero(), -(a.s() * b.e2()), a.s() * b.e1())
}
#[doc = "bulk expansion: Scalar ∧ b★ Point -> Line"]
#[inline]
pub fn bulk_expansion_scalar_point<T: Float>(a: &Scalar<T>, b: &Point<T>) -> Line<T> {
    Line::new(T::zero(), -(a.s() * b.e2()), a.s() * b.e1())
}
#[doc = "bulk expansion: Scalar ∧ b★ Scalar -> Trivector"]
#[inline]
pub fn bulk_expansion_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Trivector<T> {
    Trivector::new(a.s() * b.s())
}
#[doc = "weight expansion: Flector ∧ b☆ Flector -> Motor"]
#[inline]
pub fn weight_expansion_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        -(a.s() * b.e02()),
        a.s() * b.e01(),
        T::zero(),
        -(a.e01() * b.e01()) - a.e02() * b.e02(),
    )
}
#[doc = "weight expansion: Flector ∧ b☆ Line -> Motor"]
#[inline]
pub fn weight_expansion_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> Motor<T> {
    Motor::new(
        -(a.s() * b.e02()),
        a.s() * b.e01(),
        T::zero(),
        -(a.e01() * b.e01()) - a.e02() * b.e02(),
    )
}
#[doc = "weight expansion: Flector ∧ b☆ Motor -> Flector"]
#[inline]
pub fn weight_expansion_flector_motor<T: Float>(a: &Flector<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        -(a.s() * b.e012()),
        -(a.s() * b.e0()) - a.e12() * b.e012(),
        -(a.e01() * b.e012()),
        -(a.e02() * b.e012()),
    )
}
#[doc = "weight expansion: Flector ∧ b☆ Point -> Line"]
#[inline]
pub fn weight_expansion_flector_point<T: Float>(a: &Flector<T>, b: &Point<T>) -> Line<T> {
    Line::new(-(a.s() * b.e0()), T::zero(), T::zero())
}
#[doc = "weight expansion: Flector ∧ b☆ Trivector -> Flector"]
#[inline]
pub fn weight_expansion_flector_trivector<T: Float>(
    a: &Flector<T>,
    b: &Trivector<T>,
) -> Flector<T> {
    Flector::new(
        -(a.s() * b.e012()),
        -(a.e12() * b.e012()),
        -(a.e01() * b.e012()),
        -(a.e02() * b.e012()),
    )
}
#[doc = "weight expansion: Line ∧ b☆ Flector -> Trivector"]
#[inline]
pub fn weight_expansion_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> Trivector<T> {
    Trivector::new(-(a.e01() * b.e01()) - a.e02() * b.e02())
}
#[doc = "weight expansion: Line ∧ b☆ Line -> Trivector"]
#[inline]
pub fn weight_expansion_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Trivector<T> {
    Trivector::new(-(a.e01() * b.e01()) - a.e02() * b.e02())
}
#[doc = "weight expansion: Line ∧ b☆ Motor -> Line"]
#[inline]
pub fn weight_expansion_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Line<T> {
    Line::new(
        -(a.e12() * b.e012()),
        -(a.e01() * b.e012()),
        -(a.e02() * b.e012()),
    )
}
#[doc = "weight expansion: Line ∧ b☆ Trivector -> Line"]
#[inline]
pub fn weight_expansion_line_trivector<T: Float>(a: &Line<T>, b: &Trivector<T>) -> Line<T> {
    Line::new(
        -(a.e12() * b.e012()),
        -(a.e01() * b.e012()),
        -(a.e02() * b.e012()),
    )
}
#[doc = "weight expansion: Motor ∧ b☆ Flector -> Line"]
#[inline]
pub fn weight_expansion_motor_flector<T: Float>(a: &Motor<T>, b: &Flector<T>) -> Line<T> {
    Line::new(
        a.e1() * b.e01() + a.e2() * b.e02(),
        a.e0() * b.e02(),
        -(a.e0() * b.e01()),
    )
}
#[doc = "weight expansion: Motor ∧ b☆ Line -> Line"]
#[inline]
pub fn weight_expansion_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Line<T> {
    Line::new(
        a.e1() * b.e01() + a.e2() * b.e02(),
        a.e0() * b.e02(),
        -(a.e0() * b.e01()),
    )
}
#[doc = "weight expansion: Motor ∧ b☆ Motor -> Motor"]
#[inline]
pub fn weight_expansion_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        -(a.e1() * b.e012()),
        -(a.e2() * b.e012()),
        -(a.e0() * b.e012()),
        -(a.e0() * b.e0()) - a.e012() * b.e012(),
    )
}
#[doc = "weight expansion: Motor ∧ b☆ Point -> Trivector"]
#[inline]
pub fn weight_expansion_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Trivector<T> {
    Trivector::new(-(a.e0() * b.e0()))
}
#[doc = "weight expansion: Motor ∧ b☆ Trivector -> Motor"]
#[inline]
pub fn weight_expansion_motor_trivector<T: Float>(a: &Motor<T>, b: &Trivector<T>) -> Motor<T> {
    Motor::new(
        -(a.e1() * b.e012()),
        -(a.e2() * b.e012()),
        -(a.e0() * b.e012()),
        -(a.e012() * b.e012()),
    )
}
#[doc = "weight expansion: Point ∧ b☆ Flector -> Line"]
#[inline]
pub fn weight_expansion_point_flector<T: Float>(a: &Point<T>, b: &Flector<T>) -> Line<T> {
    Line::new(
        a.e1() * b.e01() + a.e2() * b.e02(),
        a.e0() * b.e02(),
        -(a.e0() * b.e01()),
    )
}
#[doc = "weight expansion: Point ∧ b☆ Line -> Line"]
#[inline]
pub fn weight_expansion_point_line<T: Float>(a: &Point<T>, b: &Line<T>) -> Line<T> {
    Line::new(
        a.e1() * b.e01() + a.e2() * b.e02(),
        a.e0() * b.e02(),
        -(a.e0() * b.e01()),
    )
}
#[doc = "weight expansion: Point ∧ b☆ Motor -> Motor"]
#[inline]
pub fn weight_expansion_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        -(a.e1() * b.e012()),
        -(a.e2() * b.e012()),
        -(a.e0() * b.e012()),
        -(a.e0() * b.e0()),
    )
}
#[doc = "weight expansion: Point ∧ b☆ Point -> Trivector"]
#[inline]
pub fn weight_expansion_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> Trivector<T> {
    Trivector::new(-(a.e0() * b.e0()))
}
#[doc = "weight expansion: Point ∧ b☆ Trivector -> Point"]
#[inline]
pub fn weight_expansion_point_trivector<T: Float>(a: &Point<T>, b: &Trivector<T>) -> Point<T> {
    Point::new(
        -(a.e1() * b.e012()),
        -(a.e2() * b.e012()),
        -(a.e0() * b.e012()),
    )
}
#[doc = "weight expansion: Scalar ∧ b☆ Flector -> Point"]
#[inline]
pub fn weight_expansion_scalar_flector<T: Float>(a: &Scalar<T>, b: &Flector<T>) -> Point<T> {
    Point::new(-(a.s() * b.e02()), a.s() * b.e01(), T::zero())
}
#[doc = "weight expansion: Scalar ∧ b☆ Line -> Point"]
#[inline]
pub fn weight_expansion_scalar_line<T: Float>(a: &Scalar<T>, b: &Line<T>) -> Point<T> {
    Point::new(-(a.s() * b.e02()), a.s() * b.e01(), T::zero())
}
#[doc = "weight expansion: Scalar ∧ b☆ Motor -> Flector"]
#[inline]
pub fn weight_expansion_scalar_motor<T: Float>(a: &Scalar<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(-(a.s() * b.e012()), -(a.s() * b.e0()), T::zero(), T::zero())
}
#[doc = "weight expansion: Scalar ∧ b☆ Point -> Line"]
#[inline]
pub fn weight_expansion_scalar_point<T: Float>(a: &Scalar<T>, b: &Point<T>) -> Line<T> {
    Line::new(-(a.s() * b.e0()), T::zero(), T::zero())
}
#[doc = "weight expansion: Scalar ∧ b☆ Trivector -> Scalar"]
#[inline]
pub fn weight_expansion_scalar_trivector<T: Float>(a: &Scalar<T>, b: &Trivector<T>) -> Scalar<T> {
    Scalar::new(-(a.s() * b.e012()))
}
#[doc = "weight expansion: Trivector ∧ b☆ Motor -> Trivector"]
#[inline]
pub fn weight_expansion_trivector_motor<T: Float>(a: &Trivector<T>, b: &Motor<T>) -> Trivector<T> {
    Trivector::new(-(a.e012() * b.e012()))
}
#[doc = "weight expansion: Trivector ∧ b☆ Trivector -> Trivector"]
#[inline]
pub fn weight_expansion_trivector_trivector<T: Float>(
    a: &Trivector<T>,
    b: &Trivector<T>,
) -> Trivector<T> {
    Trivector::new(-(a.e012() * b.e012()))
}
#[doc = "Sandwich product: Flector * Point * rev(Flector) -> Point"]
#[inline]
pub fn sandwich_flector_point<T: Float>(v: &Flector<T>, x: &Point<T>) -> Point<T> {
    Point::new(
        v.e12() * x.e2() * v.s() + v.s() * x.e2() * v.e12() + v.s() * x.e1() * v.s()
            - v.e12() * x.e1() * v.e12(),
        -(v.s() * x.e1() * v.e12()) - v.e12() * x.e2() * v.e12() - v.e12() * x.e1() * v.s()
            + v.s() * x.e2() * v.s(),
        -(v.e01() * x.e1() * v.s()) - v.s() * x.e2() * v.e02() - v.s() * x.e1() * v.e01()
            + v.e02() * x.e1() * v.e12()
            + v.s() * x.e0() * v.s()
            + v.e12() * x.e1() * v.e02()
            - v.e01() * x.e2() * v.e12()
            - v.e02() * x.e2() * v.s()
            - v.e12() * x.e2() * v.e01()
            + v.e12() * x.e0() * v.e12(),
    )
}
#[doc = "Sandwich product: Flector * Line * rev(Flector) -> Line"]
#[inline]
pub fn sandwich_flector_line<T: Float>(v: &Flector<T>, x: &Line<T>) -> Line<T> {
    Line::new(
        v.e12() * x.e12() * v.e12() + v.s() * x.e12() * v.s(),
        -(v.e02() * x.e12() * v.s()) + v.s() * x.e01() * v.s() + v.e01() * x.e12() * v.e12()
            - v.s() * x.e12() * v.e02()
            + v.e12() * x.e02() * v.s()
            + v.s() * x.e02() * v.e12()
            + v.e12() * x.e12() * v.e01()
            - v.e12() * x.e01() * v.e12(),
        v.s() * x.e02() * v.s() + v.s() * x.e12() * v.e01() - v.e12() * x.e01() * v.s()
            + v.e12() * x.e12() * v.e02()
            - v.e12() * x.e02() * v.e12()
            + v.e02() * x.e12() * v.e12()
            + v.e01() * x.e12() * v.s()
            - v.s() * x.e01() * v.e12(),
    )
}
#[doc = "Sandwich product: Flector * Motor * rev(Flector) -> Motor"]
#[inline]
pub fn sandwich_flector_motor<T: Float>(v: &Flector<T>, x: &Motor<T>) -> Motor<T> {
    Motor::new(
        v.s() * x.e1() * v.s() + v.s() * x.e2() * v.e12() - v.e12() * x.e1() * v.e12()
            + v.e12() * x.e2() * v.s(),
        -(v.e12() * x.e2() * v.e12()) - v.e12() * x.e1() * v.s() + v.s() * x.e2() * v.s()
            - v.s() * x.e1() * v.e12(),
        v.s() * x.e012() * v.e12() + v.e12() * x.e1() * v.e02() + v.s() * x.e0() * v.s()
            - v.e12() * x.e012() * v.s()
            + v.e02() * x.e1() * v.e12()
            - v.s() * x.e2() * v.e02()
            - v.s() * x.e1() * v.e01()
            - v.e12() * x.e2() * v.e01()
            - v.e01() * x.e1() * v.s()
            + v.e12() * x.e0() * v.e12()
            - v.e01() * x.e2() * v.e12()
            - v.e02() * x.e2() * v.s(),
        -(v.e12() * x.e1() * v.e01()) - v.s() * x.e1() * v.e02()
            + v.e02() * x.e2() * v.e12()
            + v.e12() * x.e012() * v.e12()
            + v.s() * x.e2() * v.e01()
            + v.e01() * x.e1() * v.e12()
            - v.e01() * x.e2() * v.s()
            - v.e12() * x.e2() * v.e02()
            - v.s() * x.e0() * v.e12()
            + v.s() * x.e012() * v.s()
            + v.e12() * x.e0() * v.s()
            + v.e02() * x.e1() * v.s(),
    )
}
#[doc = "Sandwich product: Flector * Flector * rev(Flector) -> Flector"]
#[inline]
pub fn sandwich_flector_flector<T: Float>(v: &Flector<T>, x: &Flector<T>) -> Flector<T> {
    Flector::new(
        -(v.e12() * x.e12() * v.s())
            + v.e12() * x.s() * v.e12()
            + v.s() * x.s() * v.s()
            + v.s() * x.e12() * v.e12(),
        v.e12() * x.s() * v.s() - v.s() * x.s() * v.e12()
            + v.e12() * x.e12() * v.e12()
            + v.s() * x.e12() * v.s(),
        v.e12() * x.e12() * v.e01() - v.s() * x.s() * v.e01() - v.e12() * x.s() * v.e02()
            + v.e12() * x.e02() * v.s()
            + v.e01() * x.s() * v.s()
            + v.e02() * x.s() * v.e12()
            - v.e12() * x.e01() * v.e12()
            - v.e02() * x.e12() * v.s()
            + v.s() * x.e02() * v.e12()
            - v.s() * x.e12() * v.e02()
            + v.e01() * x.e12() * v.e12()
            + v.s() * x.e01() * v.s(),
        v.e12() * x.e12() * v.e02() - v.e01() * x.s() * v.e12() + v.s() * x.e02() * v.s()
            - v.s() * x.e01() * v.e12()
            + v.e12() * x.s() * v.e01()
            - v.e12() * x.e01() * v.s()
            - v.s() * x.s() * v.e02()
            + v.e01() * x.e12() * v.s()
            + v.s() * x.e12() * v.e01()
            + v.e02() * x.s() * v.s()
            + v.e02() * x.e12() * v.e12()
            - v.e12() * x.e02() * v.e12(),
    )
}
#[doc = "Sandwich product: Motor * Point * rev(Motor) -> Point"]
#[inline]
pub fn sandwich_motor_point<T: Float>(v: &Motor<T>, x: &Point<T>) -> Point<T> {
    Point::new(
        v.e1() * x.e1() * v.e1() + v.e1() * x.e2() * v.e2() + v.e2() * x.e2() * v.e1()
            - v.e2() * x.e1() * v.e2(),
        v.e1() * x.e1() * v.e2() + v.e2() * x.e2() * v.e2() - v.e1() * x.e2() * v.e1()
            + v.e2() * x.e1() * v.e1(),
        -(v.e2() * x.e0() * v.e2()) + v.e0() * x.e1() * v.e1() - v.e2() * x.e1() * v.e012()
            + v.e012() * x.e2() * v.e1()
            + v.e1() * x.e2() * v.e012()
            + v.e2() * x.e2() * v.e0()
            - v.e1() * x.e0() * v.e1()
            + v.e0() * x.e2() * v.e2()
            - v.e012() * x.e1() * v.e2()
            + v.e1() * x.e1() * v.e0(),
    )
}
#[doc = "Sandwich product: Motor * Line * rev(Motor) -> Line"]
#[inline]
pub fn sandwich_motor_line<T: Float>(v: &Motor<T>, x: &Line<T>) -> Line<T> {
    Line::new(
        -(v.e2() * x.e12() * v.e2()) - v.e1() * x.e12() * v.e1(),
        v.e012() * x.e12() * v.e1() + v.e1() * x.e12() * v.e012()
            - v.e2() * x.e02() * v.e1()
            - v.e0() * x.e12() * v.e2()
            - v.e1() * x.e02() * v.e2()
            - v.e2() * x.e12() * v.e0()
            - v.e1() * x.e01() * v.e1()
            + v.e2() * x.e01() * v.e2(),
        -(v.e2() * x.e02() * v.e2()) + v.e0() * x.e12() * v.e1() - v.e2() * x.e01() * v.e1()
            + v.e1() * x.e12() * v.e0()
            + v.e1() * x.e02() * v.e1()
            + v.e2() * x.e12() * v.e012()
            - v.e1() * x.e01() * v.e2()
            + v.e012() * x.e12() * v.e2(),
    )
}
#[doc = "Sandwich product: Motor * Motor * rev(Motor) -> Motor"]
#[inline]
pub fn sandwich_motor_motor<T: Float>(v: &Motor<T>, x: &Motor<T>) -> Motor<T> {
    Motor::new(
        v.e1() * x.e1() * v.e1() - v.e2() * x.e1() * v.e2()
            + v.e1() * x.e2() * v.e2()
            + v.e2() * x.e2() * v.e1(),
        v.e1() * x.e1() * v.e2() + v.e2() * x.e2() * v.e2() + v.e2() * x.e1() * v.e1()
            - v.e1() * x.e2() * v.e1(),
        -(v.e1() * x.e012() * v.e2()) - v.e2() * x.e1() * v.e012()
            + v.e1() * x.e2() * v.e012()
            + v.e2() * x.e2() * v.e0()
            + v.e2() * x.e012() * v.e1()
            - v.e1() * x.e0() * v.e1()
            + v.e0() * x.e1() * v.e1()
            - v.e2() * x.e0() * v.e2()
            + v.e0() * x.e2() * v.e2()
            + v.e1() * x.e1() * v.e0()
            - v.e012() * x.e1() * v.e2()
            + v.e012() * x.e2() * v.e1(),
        -(v.e2() * x.e2() * v.e012()) - v.e1() * x.e1() * v.e012()
            + v.e1() * x.e012() * v.e1()
            + v.e2() * x.e0() * v.e1()
            + v.e2() * x.e012() * v.e2()
            - v.e0() * x.e2() * v.e1()
            - v.e1() * x.e0() * v.e2()
            + v.e1() * x.e2() * v.e0()
            - v.e2() * x.e1() * v.e0()
            + v.e012() * x.e2() * v.e2()
            + v.e0() * x.e1() * v.e2()
            + v.e012() * x.e1() * v.e1(),
    )
}
#[doc = "Sandwich product: Motor * Flector * rev(Motor) -> Flector"]
#[inline]
pub fn sandwich_motor_flector<T: Float>(v: &Motor<T>, x: &Flector<T>) -> Flector<T> {
    Flector::new(
        v.e1() * x.e12() * v.e2() - v.e2() * x.e12() * v.e1()
            + v.e1() * x.s() * v.e1()
            + v.e2() * x.s() * v.e2(),
        -(v.e1() * x.e12() * v.e1()) + v.e1() * x.s() * v.e2()
            - v.e2() * x.s() * v.e1()
            - v.e2() * x.e12() * v.e2(),
        -(v.e2() * x.e12() * v.e0()) + v.e1() * x.e12() * v.e012()
            - v.e1() * x.e01() * v.e1()
            - v.e1() * x.e02() * v.e2()
            + v.e2() * x.s() * v.e012()
            - v.e0() * x.e12() * v.e2()
            + v.e1() * x.s() * v.e0()
            - v.e0() * x.s() * v.e1()
            - v.e012() * x.s() * v.e2()
            + v.e012() * x.e12() * v.e1()
            - v.e2() * x.e02() * v.e1()
            + v.e2() * x.e01() * v.e2(),
        -(v.e1() * x.e01() * v.e2()) + v.e1() * x.e02() * v.e1() - v.e0() * x.s() * v.e2()
            + v.e0() * x.e12() * v.e1()
            - v.e2() * x.e01() * v.e1()
            + v.e012() * x.s() * v.e1()
            - v.e2() * x.e02() * v.e2()
            + v.e2() * x.e12() * v.e012()
            + v.e012() * x.e12() * v.e2()
            - v.e1() * x.s() * v.e012()
            + v.e2() * x.s() * v.e0()
            + v.e1() * x.e12() * v.e0(),
    )
}
#[doc = "Antisandwich product: Flector ⊛ Point ⊛ antirev(Flector) -> Point\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_flector_point<T: Float>(v: &Flector<T>, x: &Point<T>) -> Point<T> {
    Point::new(
        -(v.s() * x.e0() * v.e01()) - v.e01() * x.e1() * v.e01() - v.e01() * x.e2() * v.e02()
            + v.e12() * x.e0() * v.e02()
            - v.e02() * x.e2() * v.e01()
            + v.e02() * x.e0() * v.e12()
            + v.e02() * x.e1() * v.e02()
            - v.e01() * x.e0() * v.s(),
        -(v.e02() * x.e1() * v.e01())
            - v.e01() * x.e0() * v.e12()
            - v.e01() * x.e1() * v.e02()
            - v.e02() * x.e2() * v.e02()
            - v.s() * x.e0() * v.e02()
            + v.e01() * x.e2() * v.e01()
            - v.e12() * x.e0() * v.e01()
            - v.e02() * x.e0() * v.s(),
        -(v.e02() * x.e0() * v.e02()) - v.e01() * x.e0() * v.e01(),
    )
}
#[doc = "Antisandwich product: Flector ⊛ Line ⊛ antirev(Flector) -> Line\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_flector_line<T: Float>(v: &Flector<T>, x: &Line<T>) -> Line<T> {
    Line::new(
        -(v.e02() * x.e01() * v.s()) + v.e12() * x.e01() * v.e01() - v.s() * x.e01() * v.e02()
            + v.e02() * x.e02() * v.e12()
            - v.e02() * x.e12() * v.e02()
            + v.e01() * x.e02() * v.s()
            + v.e01() * x.e01() * v.e12()
            + v.s() * x.e02() * v.e01()
            + v.e12() * x.e02() * v.e02()
            - v.e01() * x.e12() * v.e01(),
        v.e01() * x.e02() * v.e02() + v.e01() * x.e01() * v.e01() + v.e02() * x.e02() * v.e01()
            - v.e02() * x.e01() * v.e02(),
        v.e02() * x.e01() * v.e01() + v.e02() * x.e02() * v.e02() + v.e01() * x.e01() * v.e02()
            - v.e01() * x.e02() * v.e01(),
    )
}
#[doc = "Antisandwich product: Flector ⊛ Motor ⊛ antirev(Flector) -> Motor\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_flector_motor<T: Float>(v: &Flector<T>, x: &Motor<T>) -> Motor<T> {
    Motor::new(
        -(v.e02() * x.e2() * v.e01()) - v.e01() * x.e1() * v.e01() + v.e02() * x.e1() * v.e02()
            - v.e02() * x.e012() * v.s()
            + v.s() * x.e012() * v.e02()
            + v.e12() * x.e0() * v.e02()
            - v.e01() * x.e2() * v.e02()
            - v.e01() * x.e012() * v.e12()
            + v.e02() * x.e0() * v.e12()
            + v.e12() * x.e012() * v.e01()
            - v.s() * x.e0() * v.e01()
            - v.e01() * x.e0() * v.s(),
        -(v.s() * x.e012() * v.e01()) - v.e01() * x.e1() * v.e02()
            + v.e12() * x.e012() * v.e02()
            + v.e01() * x.e2() * v.e01()
            - v.e02() * x.e1() * v.e01()
            - v.e02() * x.e0() * v.s()
            - v.e02() * x.e012() * v.e12()
            - v.e12() * x.e0() * v.e01()
            - v.e01() * x.e0() * v.e12()
            - v.e02() * x.e2() * v.e02()
            + v.e01() * x.e012() * v.s()
            - v.s() * x.e0() * v.e02(),
        -(v.e02() * x.e012() * v.e01()) - v.e02() * x.e0() * v.e02() - v.e01() * x.e0() * v.e01()
            + v.e01() * x.e012() * v.e02(),
        v.e01() * x.e012() * v.e01() + v.e01() * x.e0() * v.e02() - v.e02() * x.e0() * v.e01()
            + v.e02() * x.e012() * v.e02(),
    )
}
#[doc = "Antisandwich product: Flector ⊛ Flector ⊛ antirev(Flector) -> Flector\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_flector_flector<T: Float>(v: &Flector<T>, x: &Flector<T>) -> Flector<T> {
    Flector::new(
        v.e02() * x.s() * v.e02() - v.e02() * x.e01() * v.e12() - v.e12() * x.e02() * v.e01()
            + v.e01() * x.s() * v.e01()
            + v.s() * x.e01() * v.e01()
            - v.e01() * x.e12() * v.e02()
            + v.e12() * x.e01() * v.e02()
            + v.e01() * x.e02() * v.e12()
            - v.e02() * x.e02() * v.s()
            - v.e01() * x.e01() * v.s()
            + v.e02() * x.e12() * v.e01()
            + v.s() * x.e02() * v.e02(),
        -(v.s() * x.e01() * v.e02()) + v.e12() * x.e01() * v.e01() - v.e02() * x.e12() * v.e02()
            + v.s() * x.e02() * v.e01()
            - v.e02() * x.e01() * v.s()
            + v.e12() * x.e02() * v.e02()
            - v.e01() * x.e12() * v.e01()
            + v.e01() * x.e01() * v.e12()
            + v.e02() * x.s() * v.e01()
            - v.e01() * x.s() * v.e02()
            + v.e02() * x.e02() * v.e12()
            + v.e01() * x.e02() * v.s(),
        v.e01() * x.e02() * v.e02() - v.e02() * x.e01() * v.e02()
            + v.e02() * x.e02() * v.e01()
            + v.e01() * x.e01() * v.e01(),
        v.e02() * x.e02() * v.e02() + v.e01() * x.e01() * v.e02() - v.e01() * x.e02() * v.e01()
            + v.e02() * x.e01() * v.e01(),
    )
}
#[doc = "Antisandwich product: Motor ⊛ Point ⊛ antirev(Motor) -> Point\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_motor_point<T: Float>(v: &Motor<T>, x: &Point<T>) -> Point<T> {
    Point::new(
        v.e0() * x.e0() * v.e1() - v.e0() * x.e1() * v.e0()
            + v.e012() * x.e1() * v.e012()
            + v.e0() * x.e2() * v.e012()
            + v.e012() * x.e2() * v.e0()
            - v.e2() * x.e0() * v.e012()
            - v.e012() * x.e0() * v.e2()
            + v.e1() * x.e0() * v.e0(),
        -(v.e0() * x.e1() * v.e012())
            + v.e012() * x.e2() * v.e012()
            + v.e0() * x.e0() * v.e2()
            + v.e012() * x.e0() * v.e1()
            - v.e0() * x.e2() * v.e0()
            + v.e2() * x.e0() * v.e0()
            - v.e012() * x.e1() * v.e0()
            + v.e1() * x.e0() * v.e012(),
        v.e0() * x.e0() * v.e0() + v.e012() * x.e0() * v.e012(),
    )
}
#[doc = "Antisandwich product: Motor ⊛ Line ⊛ antirev(Motor) -> Line\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_motor_line<T: Float>(v: &Motor<T>, x: &Line<T>) -> Line<T> {
    Line::new(
        v.e012() * x.e01() * v.e1() + v.e0() * x.e12() * v.e0() - v.e0() * x.e01() * v.e2()
            + v.e012() * x.e12() * v.e012()
            + v.e2() * x.e02() * v.e012()
            + v.e0() * x.e02() * v.e1()
            + v.e1() * x.e02() * v.e0()
            - v.e2() * x.e01() * v.e0()
            + v.e012() * x.e02() * v.e2()
            + v.e1() * x.e01() * v.e012(),
        -(v.e0() * x.e01() * v.e0())
            + v.e0() * x.e02() * v.e012()
            + v.e012() * x.e01() * v.e012()
            + v.e012() * x.e02() * v.e0(),
        -(v.e0() * x.e01() * v.e012()) - v.e0() * x.e02() * v.e0() - v.e012() * x.e01() * v.e0()
            + v.e012() * x.e02() * v.e012(),
    )
}
#[doc = "Antisandwich product: Motor ⊛ Motor ⊛ antirev(Motor) -> Motor\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_motor_motor<T: Float>(v: &Motor<T>, x: &Motor<T>) -> Motor<T> {
    Motor::new(
        v.e012() * x.e2() * v.e0()
            + v.e1() * x.e012() * v.e012()
            + v.e2() * x.e012() * v.e0()
            + v.e012() * x.e1() * v.e012()
            + v.e0() * x.e0() * v.e1()
            - v.e012() * x.e0() * v.e2()
            - v.e0() * x.e012() * v.e2()
            - v.e012() * x.e012() * v.e1()
            + v.e0() * x.e2() * v.e012()
            + v.e1() * x.e0() * v.e0()
            - v.e2() * x.e0() * v.e012()
            - v.e0() * x.e1() * v.e0(),
        v.e1() * x.e0() * v.e012() - v.e012() * x.e1() * v.e0()
            + v.e012() * x.e2() * v.e012()
            + v.e012() * x.e0() * v.e1()
            - v.e012() * x.e012() * v.e2()
            - v.e1() * x.e012() * v.e0()
            - v.e0() * x.e2() * v.e0()
            + v.e2() * x.e012() * v.e012()
            - v.e0() * x.e1() * v.e012()
            + v.e0() * x.e0() * v.e2()
            + v.e2() * x.e0() * v.e0()
            + v.e0() * x.e012() * v.e1(),
        -(v.e012() * x.e012() * v.e0())
            + v.e0() * x.e012() * v.e012()
            + v.e0() * x.e0() * v.e0()
            + v.e012() * x.e0() * v.e012(),
        v.e0() * x.e012() * v.e0() + v.e012() * x.e0() * v.e0() + v.e012() * x.e012() * v.e012()
            - v.e0() * x.e0() * v.e012(),
    )
}
#[doc = "Antisandwich product: Motor ⊛ Flector ⊛ antirev(Motor) -> Flector\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_motor_flector<T: Float>(v: &Motor<T>, x: &Flector<T>) -> Flector<T> {
    Flector::new(
        v.e0() * x.e01() * v.e1()
            - v.e1() * x.e01() * v.e0()
            - v.e012() * x.e02() * v.e1()
            - v.e012() * x.e12() * v.e0()
            - v.e2() * x.e02() * v.e0()
            - v.e2() * x.e01() * v.e012()
            + v.e1() * x.e02() * v.e012()
            + v.e0() * x.e12() * v.e012()
            + v.e0() * x.s() * v.e0()
            + v.e0() * x.e02() * v.e2()
            + v.e012() * x.s() * v.e012()
            + v.e012() * x.e01() * v.e2(),
        v.e2() * x.e02() * v.e012() - v.e0() * x.s() * v.e012() - v.e0() * x.e01() * v.e2()
            + v.e1() * x.e01() * v.e012()
            + v.e0() * x.e02() * v.e1()
            + v.e1() * x.e02() * v.e0()
            + v.e012() * x.s() * v.e0()
            - v.e2() * x.e01() * v.e0()
            + v.e012() * x.e01() * v.e1()
            + v.e012() * x.e12() * v.e012()
            + v.e0() * x.e12() * v.e0()
            + v.e012() * x.e02() * v.e2(),
        v.e0() * x.e02() * v.e012() + v.e012() * x.e02() * v.e0() + v.e012() * x.e01() * v.e012()
            - v.e0() * x.e01() * v.e0(),
        v.e012() * x.e02() * v.e012()
            - v.e0() * x.e01() * v.e012()
            - v.e0() * x.e02() * v.e0()
            - v.e012() * x.e01() * v.e0(),
    )
}
#[doc = "Reverses the Flector (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_flector<T: Float>(a: &Flector<T>) -> Flector<T> {
    Flector::new(a.s(), -a.e12(), -a.e01(), -a.e02())
}
#[doc = "Reverses the Line (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_line<T: Float>(a: &Line<T>) -> Line<T> {
    Line::new(-a.e12(), -a.e01(), -a.e02())
}
#[doc = "Reverses the Motor (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_motor<T: Float>(a: &Motor<T>) -> Motor<T> {
    Motor::new(a.e1(), a.e2(), a.e0(), -a.e012())
}
#[doc = "Reverses the Point (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_point<T: Float>(a: &Point<T>) -> Point<T> {
    Point::new(a.e1(), a.e2(), a.e0())
}
#[doc = "Reverses the Scalar (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_scalar<T: Float>(a: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.s())
}
#[doc = "Reverses the Trivector (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_trivector<T: Float>(a: &Trivector<T>) -> Trivector<T> {
    Trivector::new(-a.e012())
}
#[doc = "Antireverses the Flector (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_flector<T: Float>(a: &Flector<T>) -> Flector<T> {
    Flector::new(-a.s(), a.e12(), a.e01(), a.e02())
}
#[doc = "Antireverses the Line (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_line<T: Float>(a: &Line<T>) -> Line<T> {
    Line::new(a.e12(), a.e01(), a.e02())
}
#[doc = "Antireverses the Motor (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_motor<T: Float>(a: &Motor<T>) -> Motor<T> {
    Motor::new(-a.e1(), -a.e2(), -a.e0(), a.e012())
}
#[doc = "Antireverses the Point (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_point<T: Float>(a: &Point<T>) -> Point<T> {
    Point::new(-a.e1(), -a.e2(), -a.e0())
}
#[doc = "Antireverses the Scalar (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_scalar<T: Float>(a: &Scalar<T>) -> Scalar<T> {
    Scalar::new(-a.s())
}
#[doc = "Antireverses the Trivector (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_trivector<T: Float>(a: &Trivector<T>) -> Trivector<T> {
    Trivector::new(a.e012())
}
#[doc = "Computes the right complement of Flector -> Motor."]
#[inline]
pub fn complement_flector<T: Float>(a: &Flector<T>) -> Motor<T> {
    Motor::new(a.e02(), -a.e01(), a.e12(), a.s())
}
#[doc = "Computes the right complement of Line -> Point."]
#[inline]
pub fn complement_line<T: Float>(a: &Line<T>) -> Point<T> {
    Point::new(a.e02(), -a.e01(), a.e12())
}
#[doc = "Computes the right complement of Motor -> Flector."]
#[inline]
pub fn complement_motor<T: Float>(a: &Motor<T>) -> Flector<T> {
    Flector::new(a.e012(), a.e0(), -a.e2(), a.e1())
}
#[doc = "Computes the right complement of Point -> Line."]
#[inline]
pub fn complement_point<T: Float>(a: &Point<T>) -> Line<T> {
    Line::new(a.e0(), -a.e2(), a.e1())
}
#[doc = "Computes the right complement of Scalar -> Trivector."]
#[inline]
pub fn complement_scalar<T: Float>(a: &Scalar<T>) -> Trivector<T> {
    Trivector::new(a.s())
}
#[doc = "Computes the right complement of Trivector -> Scalar."]
#[inline]
pub fn complement_trivector<T: Float>(a: &Trivector<T>) -> Scalar<T> {
    Scalar::new(a.e012())
}
