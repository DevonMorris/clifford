#![doc = " Product functions for the euclidean2 algebra."]
#![doc = ""]
#![doc = " This module provides all algebraic products between types in the algebra."]
#![doc = " Each function is named `{product}_{lhs}_{rhs}` where:"]
#![doc = " - `product` is one of: `geometric`, `exterior`, `left_contract`, `inner`, `scalar`"]
#![doc = " - `lhs` and `rhs` are the input type names in lowercase"]
#![doc = ""]
#![doc = " # Available Products"]
#![doc = ""]
#![doc = " | Product | Symbol | Description |"]
#![doc = " |---------|--------|-------------|"]
#![doc = " | `geometric_*` | `×` | Full geometric product |"]
#![doc = " | `exterior_*` | `∧` | Wedge/exterior product (grade sum) |"]
#![doc = " | `left_contract_*` | `⌋` | Left contraction |"]
#![doc = " | `inner_*` | `·` | Symmetric inner product (grade diff) |"]
#![doc = " | `scalar_*` | `⟨⟩₀` | Scalar (grade-0) product |"]
#![doc = ""]
#![doc = " # Sandwich Products"]
#![doc = ""]
#![doc = " For versor types (rotors, motors), sandwich products are provided:"]
#![doc = " - `sandwich_{versor}_{operand}(v, x)` computes `v × x × rev(v)`"]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen. Do not edit manually."]
use super::types::{Bivector, Rotor, Scalar, Vector};
use crate::scalar::Float;
#[doc = "Exterior product: Bivector ^ Rotor -> Bivector"]
#[inline]
pub fn exterior_bivector_rotor<T: Float>(a: &Bivector<T>, b: &Rotor<T>) -> Bivector<T> {
    Bivector::new(a.xy() * b.s())
}
#[doc = "Exterior product: Bivector ^ Scalar -> Bivector"]
#[inline]
pub fn exterior_bivector_scalar<T: Float>(a: &Bivector<T>, b: &Scalar<T>) -> Bivector<T> {
    Bivector::new(a.xy() * b.s())
}
#[doc = "Exterior product: Rotor ^ Bivector -> Bivector"]
#[inline]
pub fn exterior_rotor_bivector<T: Float>(a: &Rotor<T>, b: &Bivector<T>) -> Bivector<T> {
    Bivector::new(b.xy() * a.s())
}
#[doc = "Exterior product: Rotor ^ Rotor -> Rotor"]
#[inline]
pub fn exterior_rotor_rotor<T: Float>(a: &Rotor<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(b.s() * a.s(), a.xy() * b.s() + b.xy() * a.s())
}
#[doc = "Exterior product: Rotor ^ Scalar -> Rotor"]
#[inline]
pub fn exterior_rotor_scalar<T: Float>(a: &Rotor<T>, b: &Scalar<T>) -> Rotor<T> {
    Rotor::new(b.s() * a.s(), a.xy() * b.s())
}
#[doc = "Exterior product: Rotor ^ Vector -> Vector"]
#[inline]
pub fn exterior_rotor_vector<T: Float>(a: &Rotor<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(a.s() * b.x(), a.s() * b.y())
}
#[doc = "Exterior product: Scalar ^ Bivector -> Bivector"]
#[inline]
pub fn exterior_scalar_bivector<T: Float>(a: &Scalar<T>, b: &Bivector<T>) -> Bivector<T> {
    Bivector::new(b.xy() * a.s())
}
#[doc = "Exterior product: Scalar ^ Rotor -> Rotor"]
#[inline]
pub fn exterior_scalar_rotor<T: Float>(a: &Scalar<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(b.s() * a.s(), b.xy() * a.s())
}
#[doc = "Exterior product: Scalar ^ Scalar -> Scalar"]
#[inline]
pub fn exterior_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(b.s() * a.s())
}
#[doc = "Exterior product: Scalar ^ Vector -> Vector"]
#[inline]
pub fn exterior_scalar_vector<T: Float>(a: &Scalar<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(a.s() * b.x(), a.s() * b.y())
}
#[doc = "Exterior product: Vector ^ Rotor -> Vector"]
#[inline]
pub fn exterior_vector_rotor<T: Float>(a: &Vector<T>, b: &Rotor<T>) -> Vector<T> {
    Vector::new(b.s() * a.x(), b.s() * a.y())
}
#[doc = "Exterior product: Vector ^ Scalar -> Vector"]
#[inline]
pub fn exterior_vector_scalar<T: Float>(a: &Vector<T>, b: &Scalar<T>) -> Vector<T> {
    Vector::new(b.s() * a.x(), b.s() * a.y())
}
#[doc = "Exterior product: Vector ^ Vector -> Bivector"]
#[inline]
pub fn exterior_vector_vector<T: Float>(a: &Vector<T>, b: &Vector<T>) -> Bivector<T> {
    Bivector::new(-(b.x() * a.y()) + b.y() * a.x())
}
#[doc = "Interior product (symmetric inner): Bivector · Bivector -> Scalar"]
#[inline]
pub fn interior_bivector_bivector<T: Float>(a: &Bivector<T>, b: &Bivector<T>) -> Scalar<T> {
    Scalar::new(-(a.xy() * b.xy()))
}
#[doc = "Interior product (symmetric inner): Bivector · Rotor -> Rotor"]
#[inline]
pub fn interior_bivector_rotor<T: Float>(a: &Bivector<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(-(a.xy() * b.xy()), a.xy() * b.s())
}
#[doc = "Interior product (symmetric inner): Bivector · Scalar -> Bivector"]
#[inline]
pub fn interior_bivector_scalar<T: Float>(a: &Bivector<T>, b: &Scalar<T>) -> Bivector<T> {
    Bivector::new(a.xy() * b.s())
}
#[doc = "Interior product (symmetric inner): Bivector · Vector -> Vector"]
#[inline]
pub fn interior_bivector_vector<T: Float>(a: &Bivector<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(a.xy() * b.y(), -(a.xy() * b.x()))
}
#[doc = "Interior product (symmetric inner): Rotor · Bivector -> Rotor"]
#[inline]
pub fn interior_rotor_bivector<T: Float>(a: &Rotor<T>, b: &Bivector<T>) -> Rotor<T> {
    Rotor::new(-(a.xy() * b.xy()), b.xy() * a.s())
}
#[doc = "Interior product (symmetric inner): Rotor · Rotor -> Rotor"]
#[inline]
pub fn interior_rotor_rotor<T: Float>(a: &Rotor<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(
        -(a.xy() * b.xy()) + b.s() * a.s(),
        a.xy() * b.s() + b.xy() * a.s(),
    )
}
#[doc = "Interior product (symmetric inner): Rotor · Scalar -> Rotor"]
#[inline]
pub fn interior_rotor_scalar<T: Float>(a: &Rotor<T>, b: &Scalar<T>) -> Rotor<T> {
    Rotor::new(b.s() * a.s(), a.xy() * b.s())
}
#[doc = "Interior product (symmetric inner): Rotor · Vector -> Vector"]
#[inline]
pub fn interior_rotor_vector<T: Float>(a: &Rotor<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(
        a.xy() * b.y() + a.s() * b.x(),
        -(a.xy() * b.x()) + a.s() * b.y(),
    )
}
#[doc = "Interior product (symmetric inner): Scalar · Bivector -> Bivector"]
#[inline]
pub fn interior_scalar_bivector<T: Float>(a: &Scalar<T>, b: &Bivector<T>) -> Bivector<T> {
    Bivector::new(b.xy() * a.s())
}
#[doc = "Interior product (symmetric inner): Scalar · Rotor -> Rotor"]
#[inline]
pub fn interior_scalar_rotor<T: Float>(a: &Scalar<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(b.s() * a.s(), b.xy() * a.s())
}
#[doc = "Interior product (symmetric inner): Scalar · Scalar -> Scalar"]
#[inline]
pub fn interior_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(b.s() * a.s())
}
#[doc = "Interior product (symmetric inner): Scalar · Vector -> Vector"]
#[inline]
pub fn interior_scalar_vector<T: Float>(a: &Scalar<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(a.s() * b.x(), a.s() * b.y())
}
#[doc = "Interior product (symmetric inner): Vector · Bivector -> Vector"]
#[inline]
pub fn interior_vector_bivector<T: Float>(a: &Vector<T>, b: &Bivector<T>) -> Vector<T> {
    Vector::new(-(b.xy() * a.y()), b.xy() * a.x())
}
#[doc = "Interior product (symmetric inner): Vector · Rotor -> Vector"]
#[inline]
pub fn interior_vector_rotor<T: Float>(a: &Vector<T>, b: &Rotor<T>) -> Vector<T> {
    Vector::new(
        b.s() * a.x() + -(b.xy() * a.y()),
        b.s() * a.y() + b.xy() * a.x(),
    )
}
#[doc = "Interior product (symmetric inner): Vector · Scalar -> Vector"]
#[inline]
pub fn interior_vector_scalar<T: Float>(a: &Vector<T>, b: &Scalar<T>) -> Vector<T> {
    Vector::new(b.s() * a.x(), b.s() * a.y())
}
#[doc = "Interior product (symmetric inner): Vector · Vector -> Scalar"]
#[inline]
pub fn interior_vector_vector<T: Float>(a: &Vector<T>, b: &Vector<T>) -> Scalar<T> {
    Scalar::new(b.x() * a.x() + b.y() * a.y())
}
#[doc = "Left contraction: Bivector | Bivector -> Scalar"]
#[inline]
pub fn left_contract_bivector_bivector<T: Float>(a: &Bivector<T>, b: &Bivector<T>) -> Scalar<T> {
    Scalar::new(-(a.xy() * b.xy()))
}
#[doc = "Left contraction: Bivector | Rotor -> Scalar"]
#[inline]
pub fn left_contract_bivector_rotor<T: Float>(a: &Bivector<T>, b: &Rotor<T>) -> Scalar<T> {
    Scalar::new(-(a.xy() * b.xy()))
}
#[doc = "Left contraction: Rotor | Bivector -> Rotor"]
#[inline]
pub fn left_contract_rotor_bivector<T: Float>(a: &Rotor<T>, b: &Bivector<T>) -> Rotor<T> {
    Rotor::new(-(a.xy() * b.xy()), b.xy() * a.s())
}
#[doc = "Left contraction: Rotor | Rotor -> Rotor"]
#[inline]
pub fn left_contract_rotor_rotor<T: Float>(a: &Rotor<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(-(a.xy() * b.xy()) + b.s() * a.s(), b.xy() * a.s())
}
#[doc = "Left contraction: Rotor | Scalar -> Scalar"]
#[inline]
pub fn left_contract_rotor_scalar<T: Float>(a: &Rotor<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(b.s() * a.s())
}
#[doc = "Left contraction: Rotor | Vector -> Vector"]
#[inline]
pub fn left_contract_rotor_vector<T: Float>(a: &Rotor<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(a.s() * b.x(), a.s() * b.y())
}
#[doc = "Left contraction: Scalar | Bivector -> Bivector"]
#[inline]
pub fn left_contract_scalar_bivector<T: Float>(a: &Scalar<T>, b: &Bivector<T>) -> Bivector<T> {
    Bivector::new(b.xy() * a.s())
}
#[doc = "Left contraction: Scalar | Rotor -> Rotor"]
#[inline]
pub fn left_contract_scalar_rotor<T: Float>(a: &Scalar<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(b.s() * a.s(), b.xy() * a.s())
}
#[doc = "Left contraction: Scalar | Scalar -> Scalar"]
#[inline]
pub fn left_contract_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(b.s() * a.s())
}
#[doc = "Left contraction: Scalar | Vector -> Vector"]
#[inline]
pub fn left_contract_scalar_vector<T: Float>(a: &Scalar<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(a.s() * b.x(), a.s() * b.y())
}
#[doc = "Left contraction: Vector | Bivector -> Vector"]
#[inline]
pub fn left_contract_vector_bivector<T: Float>(a: &Vector<T>, b: &Bivector<T>) -> Vector<T> {
    Vector::new(-(b.xy() * a.y()), b.xy() * a.x())
}
#[doc = "Left contraction: Vector | Rotor -> Vector"]
#[inline]
pub fn left_contract_vector_rotor<T: Float>(a: &Vector<T>, b: &Rotor<T>) -> Vector<T> {
    Vector::new(-(b.xy() * a.y()), b.xy() * a.x())
}
#[doc = "Left contraction: Vector | Vector -> Scalar"]
#[inline]
pub fn left_contract_vector_vector<T: Float>(a: &Vector<T>, b: &Vector<T>) -> Scalar<T> {
    Scalar::new(b.x() * a.x() + b.y() * a.y())
}
#[doc = "Right contraction: Bivector ⌊ Bivector -> Scalar"]
#[inline]
pub fn right_contract_bivector_bivector<T: Float>(a: &Bivector<T>, b: &Bivector<T>) -> Scalar<T> {
    Scalar::new(-(a.xy() * b.xy()))
}
#[doc = "Right contraction: Bivector ⌊ Rotor -> Rotor"]
#[inline]
pub fn right_contract_bivector_rotor<T: Float>(a: &Bivector<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(-(a.xy() * b.xy()), a.xy() * b.s())
}
#[doc = "Right contraction: Bivector ⌊ Scalar -> Bivector"]
#[inline]
pub fn right_contract_bivector_scalar<T: Float>(a: &Bivector<T>, b: &Scalar<T>) -> Bivector<T> {
    Bivector::new(a.xy() * b.s())
}
#[doc = "Right contraction: Bivector ⌊ Vector -> Vector"]
#[inline]
pub fn right_contract_bivector_vector<T: Float>(a: &Bivector<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(a.xy() * b.y(), -(a.xy() * b.x()))
}
#[doc = "Right contraction: Rotor ⌊ Bivector -> Scalar"]
#[inline]
pub fn right_contract_rotor_bivector<T: Float>(a: &Rotor<T>, b: &Bivector<T>) -> Scalar<T> {
    Scalar::new(-(a.xy() * b.xy()))
}
#[doc = "Right contraction: Rotor ⌊ Rotor -> Rotor"]
#[inline]
pub fn right_contract_rotor_rotor<T: Float>(a: &Rotor<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(
        -(a.xy() * b.xy()) + b.s() * a.s(),
        a.xy() * b.s() + b.xy() * a.s(),
    )
}
#[doc = "Right contraction: Rotor ⌊ Scalar -> Rotor"]
#[inline]
pub fn right_contract_rotor_scalar<T: Float>(a: &Rotor<T>, b: &Scalar<T>) -> Rotor<T> {
    Rotor::new(b.s() * a.s(), a.xy() * b.s())
}
#[doc = "Right contraction: Rotor ⌊ Vector -> Vector"]
#[inline]
pub fn right_contract_rotor_vector<T: Float>(a: &Rotor<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(
        a.xy() * b.y() + a.s() * b.x(),
        -(a.xy() * b.x()) + a.s() * b.y(),
    )
}
#[doc = "Right contraction: Scalar ⌊ Rotor -> Scalar"]
#[inline]
pub fn right_contract_scalar_rotor<T: Float>(a: &Scalar<T>, b: &Rotor<T>) -> Scalar<T> {
    Scalar::new(b.s() * a.s())
}
#[doc = "Right contraction: Scalar ⌊ Scalar -> Scalar"]
#[inline]
pub fn right_contract_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(b.s() * a.s())
}
#[doc = "Right contraction: Vector ⌊ Rotor -> Vector"]
#[inline]
pub fn right_contract_vector_rotor<T: Float>(a: &Vector<T>, b: &Rotor<T>) -> Vector<T> {
    Vector::new(
        b.s() * a.x() + -(b.xy() * a.y()),
        b.s() * a.y() + b.xy() * a.x(),
    )
}
#[doc = "Right contraction: Vector ⌊ Scalar -> Vector"]
#[inline]
pub fn right_contract_vector_scalar<T: Float>(a: &Vector<T>, b: &Scalar<T>) -> Vector<T> {
    Vector::new(b.s() * a.x(), b.s() * a.y())
}
#[doc = "Right contraction: Vector ⌊ Vector -> Scalar"]
#[inline]
pub fn right_contract_vector_vector<T: Float>(a: &Vector<T>, b: &Vector<T>) -> Scalar<T> {
    Scalar::new(b.x() * a.x() + b.y() * a.y())
}
#[doc = "Regressive product (meet): Bivector ∨ Bivector -> Bivector"]
#[inline]
pub fn regressive_bivector_bivector<T: Float>(a: &Bivector<T>, b: &Bivector<T>) -> Bivector<T> {
    Bivector::new(a.xy() * b.xy())
}
#[doc = "Regressive product (meet): Bivector ∨ Rotor -> Rotor"]
#[inline]
pub fn regressive_bivector_rotor<T: Float>(a: &Bivector<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(a.xy() * b.s(), a.xy() * b.xy())
}
#[doc = "Regressive product (meet): Bivector ∨ Scalar -> Scalar"]
#[inline]
pub fn regressive_bivector_scalar<T: Float>(a: &Bivector<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.xy() * b.s())
}
#[doc = "Regressive product (meet): Bivector ∨ Vector -> Vector"]
#[inline]
pub fn regressive_bivector_vector<T: Float>(a: &Bivector<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(-(a.xy() * b.x()), -(a.xy() * b.y()))
}
#[doc = "Regressive product (meet): Rotor ∨ Bivector -> Rotor"]
#[inline]
pub fn regressive_rotor_bivector<T: Float>(a: &Rotor<T>, b: &Bivector<T>) -> Rotor<T> {
    Rotor::new(a.s() * b.xy(), a.xy() * b.xy())
}
#[doc = "Regressive product (meet): Rotor ∨ Rotor -> Rotor"]
#[inline]
pub fn regressive_rotor_rotor<T: Float>(a: &Rotor<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(a.s() * b.xy() + a.xy() * b.s(), a.xy() * b.xy())
}
#[doc = "Regressive product (meet): Rotor ∨ Scalar -> Scalar"]
#[inline]
pub fn regressive_rotor_scalar<T: Float>(a: &Rotor<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.xy() * b.s())
}
#[doc = "Regressive product (meet): Rotor ∨ Vector -> Vector"]
#[inline]
pub fn regressive_rotor_vector<T: Float>(a: &Rotor<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(-(a.xy() * b.x()), -(a.xy() * b.y()))
}
#[doc = "Regressive product (meet): Scalar ∨ Bivector -> Scalar"]
#[inline]
pub fn regressive_scalar_bivector<T: Float>(a: &Scalar<T>, b: &Bivector<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.xy())
}
#[doc = "Regressive product (meet): Scalar ∨ Rotor -> Scalar"]
#[inline]
pub fn regressive_scalar_rotor<T: Float>(a: &Scalar<T>, b: &Rotor<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.xy())
}
#[doc = "Regressive product (meet): Vector ∨ Bivector -> Vector"]
#[inline]
pub fn regressive_vector_bivector<T: Float>(a: &Vector<T>, b: &Bivector<T>) -> Vector<T> {
    Vector::new(-(a.x() * b.xy()), -(a.y() * b.xy()))
}
#[doc = "Regressive product (meet): Vector ∨ Rotor -> Vector"]
#[inline]
pub fn regressive_vector_rotor<T: Float>(a: &Vector<T>, b: &Rotor<T>) -> Vector<T> {
    Vector::new(-(a.x() * b.xy()), -(a.y() * b.xy()))
}
#[doc = "Regressive product (meet): Vector ∨ Vector -> Scalar"]
#[inline]
pub fn regressive_vector_vector<T: Float>(a: &Vector<T>, b: &Vector<T>) -> Scalar<T> {
    Scalar::new(a.x() * b.y() - a.y() * b.x())
}
#[doc = "Scalar product: Bivector * Bivector -> T (grade-0 part)"]
#[inline]
pub fn scalar_bivector_bivector<T: Float>(a: &Bivector<T>, b: &Bivector<T>) -> T {
    -(a.xy() * b.xy())
}
#[doc = "Scalar product: Bivector * Rotor -> T (grade-0 part)"]
#[inline]
pub fn scalar_bivector_rotor<T: Float>(a: &Bivector<T>, b: &Rotor<T>) -> T {
    -(a.xy() * b.xy())
}
#[doc = "Scalar product: Rotor * Bivector -> T (grade-0 part)"]
#[inline]
pub fn scalar_rotor_bivector<T: Float>(a: &Rotor<T>, b: &Bivector<T>) -> T {
    -(a.xy() * b.xy())
}
#[doc = "Scalar product: Rotor * Rotor -> T (grade-0 part)"]
#[inline]
pub fn scalar_rotor_rotor<T: Float>(a: &Rotor<T>, b: &Rotor<T>) -> T {
    a.s() * b.s() - a.xy() * b.xy()
}
#[doc = "Scalar product: Rotor * Scalar -> T (grade-0 part)"]
#[inline]
pub fn scalar_rotor_scalar<T: Float>(a: &Rotor<T>, b: &Scalar<T>) -> T {
    a.s() * b.s()
}
#[doc = "Scalar product: Scalar * Rotor -> T (grade-0 part)"]
#[inline]
pub fn scalar_scalar_rotor<T: Float>(a: &Scalar<T>, b: &Rotor<T>) -> T {
    a.s() * b.s()
}
#[doc = "Scalar product: Scalar * Scalar -> T (grade-0 part)"]
#[inline]
pub fn scalar_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> T {
    a.s() * b.s()
}
#[doc = "Scalar product: Vector * Vector -> T (grade-0 part)"]
#[inline]
pub fn scalar_vector_vector<T: Float>(a: &Vector<T>, b: &Vector<T>) -> T {
    a.x() * b.x() + a.y() * b.y()
}
#[doc = "Dot product: Bivector • Bivector -> T (same-grade metric inner)"]
#[inline]
pub fn dot_bivector_bivector<T: Float>(a: &Bivector<T>, b: &Bivector<T>) -> T {
    -(a.xy() * b.xy())
}
#[doc = "Dot product: Bivector • Rotor -> T (same-grade metric inner)"]
#[inline]
pub fn dot_bivector_rotor<T: Float>(a: &Bivector<T>, b: &Rotor<T>) -> T {
    -(a.xy() * b.xy())
}
#[doc = "Dot product: Rotor • Bivector -> T (same-grade metric inner)"]
#[inline]
pub fn dot_rotor_bivector<T: Float>(a: &Rotor<T>, b: &Bivector<T>) -> T {
    -(a.xy() * b.xy())
}
#[doc = "Dot product: Rotor • Rotor -> T (same-grade metric inner)"]
#[inline]
pub fn dot_rotor_rotor<T: Float>(a: &Rotor<T>, b: &Rotor<T>) -> T {
    a.s() * b.s() - a.xy() * b.xy()
}
#[doc = "Dot product: Rotor • Scalar -> T (same-grade metric inner)"]
#[inline]
pub fn dot_rotor_scalar<T: Float>(a: &Rotor<T>, b: &Scalar<T>) -> T {
    a.s() * b.s()
}
#[doc = "Dot product: Scalar • Rotor -> T (same-grade metric inner)"]
#[inline]
pub fn dot_scalar_rotor<T: Float>(a: &Scalar<T>, b: &Rotor<T>) -> T {
    a.s() * b.s()
}
#[doc = "Dot product: Scalar • Scalar -> T (same-grade metric inner)"]
#[inline]
pub fn dot_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> T {
    a.s() * b.s()
}
#[doc = "Dot product: Vector • Vector -> T (same-grade metric inner)"]
#[inline]
pub fn dot_vector_vector<T: Float>(a: &Vector<T>, b: &Vector<T>) -> T {
    a.x() * b.x() + a.y() * b.y()
}
#[doc = "Antidot product: Bivector ⊚ Bivector -> T (same-antigrade metric anti-inner)"]
#[inline]
pub fn antidot_bivector_bivector<T: Float>(a: &Bivector<T>, b: &Bivector<T>) -> T {
    a.xy() * b.xy()
}
#[doc = "Antidot product: Bivector ⊚ Rotor -> T (same-antigrade metric anti-inner)"]
#[inline]
pub fn antidot_bivector_rotor<T: Float>(a: &Bivector<T>, b: &Rotor<T>) -> T {
    a.xy() * b.xy()
}
#[doc = "Antidot product: Rotor ⊚ Bivector -> T (same-antigrade metric anti-inner)"]
#[inline]
pub fn antidot_rotor_bivector<T: Float>(a: &Rotor<T>, b: &Bivector<T>) -> T {
    a.xy() * b.xy()
}
#[doc = "Antidot product: Rotor ⊚ Rotor -> T (same-antigrade metric anti-inner)"]
#[inline]
pub fn antidot_rotor_rotor<T: Float>(a: &Rotor<T>, b: &Rotor<T>) -> T {
    -(a.s() * b.s()) + a.xy() * b.xy()
}
#[doc = "Antidot product: Rotor ⊚ Scalar -> T (same-antigrade metric anti-inner)"]
#[inline]
pub fn antidot_rotor_scalar<T: Float>(a: &Rotor<T>, b: &Scalar<T>) -> T {
    -(a.s() * b.s())
}
#[doc = "Antidot product: Scalar ⊚ Rotor -> T (same-antigrade metric anti-inner)"]
#[inline]
pub fn antidot_scalar_rotor<T: Float>(a: &Scalar<T>, b: &Rotor<T>) -> T {
    -(a.s() * b.s())
}
#[doc = "Antidot product: Scalar ⊚ Scalar -> T (same-antigrade metric anti-inner)"]
#[inline]
pub fn antidot_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> T {
    -(a.s() * b.s())
}
#[doc = "Antidot product: Vector ⊚ Vector -> T (same-antigrade metric anti-inner)"]
#[inline]
pub fn antidot_vector_vector<T: Float>(a: &Vector<T>, b: &Vector<T>) -> T {
    a.x() * b.x() + a.y() * b.y()
}
#[doc = "bulk contraction: Bivector ∨ b★ Bivector -> Scalar"]
#[inline]
pub fn bulk_contraction_bivector_bivector<T: Float>(a: &Bivector<T>, b: &Bivector<T>) -> Scalar<T> {
    Scalar::new(a.xy() * b.xy())
}
#[doc = "bulk contraction: Bivector ∨ b★ Rotor -> Rotor"]
#[inline]
pub fn bulk_contraction_bivector_rotor<T: Float>(a: &Bivector<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(a.xy() * b.xy(), a.xy() * b.s())
}
#[doc = "bulk contraction: Bivector ∨ b★ Scalar -> Bivector"]
#[inline]
pub fn bulk_contraction_bivector_scalar<T: Float>(a: &Bivector<T>, b: &Scalar<T>) -> Bivector<T> {
    Bivector::new(a.xy() * b.s())
}
#[doc = "bulk contraction: Bivector ∨ b★ Vector -> Vector"]
#[inline]
pub fn bulk_contraction_bivector_vector<T: Float>(a: &Bivector<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(a.xy() * b.y(), -(a.xy() * b.x()))
}
#[doc = "bulk contraction: Rotor ∨ b★ Bivector -> Scalar"]
#[inline]
pub fn bulk_contraction_rotor_bivector<T: Float>(a: &Rotor<T>, b: &Bivector<T>) -> Scalar<T> {
    Scalar::new(a.xy() * b.xy())
}
#[doc = "bulk contraction: Rotor ∨ b★ Rotor -> Rotor"]
#[inline]
pub fn bulk_contraction_rotor_rotor<T: Float>(a: &Rotor<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(a.s() * b.s() + a.xy() * b.xy(), a.xy() * b.s())
}
#[doc = "bulk contraction: Rotor ∨ b★ Scalar -> Rotor"]
#[inline]
pub fn bulk_contraction_rotor_scalar<T: Float>(a: &Rotor<T>, b: &Scalar<T>) -> Rotor<T> {
    Rotor::new(a.s() * b.s(), a.xy() * b.s())
}
#[doc = "bulk contraction: Rotor ∨ b★ Vector -> Vector"]
#[inline]
pub fn bulk_contraction_rotor_vector<T: Float>(a: &Rotor<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(a.xy() * b.y(), -(a.xy() * b.x()))
}
#[doc = "bulk contraction: Scalar ∨ b★ Rotor -> Scalar"]
#[inline]
pub fn bulk_contraction_scalar_rotor<T: Float>(a: &Scalar<T>, b: &Rotor<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.s())
}
#[doc = "bulk contraction: Scalar ∨ b★ Scalar -> Scalar"]
#[inline]
pub fn bulk_contraction_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.s())
}
#[doc = "bulk contraction: Vector ∨ b★ Rotor -> Vector"]
#[inline]
pub fn bulk_contraction_vector_rotor<T: Float>(a: &Vector<T>, b: &Rotor<T>) -> Vector<T> {
    Vector::new(-(a.x() * b.s()), -(a.y() * b.s()))
}
#[doc = "bulk contraction: Vector ∨ b★ Scalar -> Vector"]
#[inline]
pub fn bulk_contraction_vector_scalar<T: Float>(a: &Vector<T>, b: &Scalar<T>) -> Vector<T> {
    Vector::new(-(a.x() * b.s()), -(a.y() * b.s()))
}
#[doc = "bulk contraction: Vector ∨ b★ Vector -> Scalar"]
#[inline]
pub fn bulk_contraction_vector_vector<T: Float>(a: &Vector<T>, b: &Vector<T>) -> Scalar<T> {
    Scalar::new(a.x() * b.x() + a.y() * b.y())
}
#[doc = "weight contraction: Bivector ∨ b☆ Bivector -> Scalar"]
#[inline]
pub fn weight_contraction_bivector_bivector<T: Float>(
    a: &Bivector<T>,
    b: &Bivector<T>,
) -> Scalar<T> {
    Scalar::new(-(a.xy() * b.xy()))
}
#[doc = "weight contraction: Bivector ∨ b☆ Rotor -> Rotor"]
#[inline]
pub fn weight_contraction_bivector_rotor<T: Float>(a: &Bivector<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(-(a.xy() * b.xy()), -(a.xy() * b.s()))
}
#[doc = "weight contraction: Bivector ∨ b☆ Scalar -> Bivector"]
#[inline]
pub fn weight_contraction_bivector_scalar<T: Float>(a: &Bivector<T>, b: &Scalar<T>) -> Bivector<T> {
    Bivector::new(-(a.xy() * b.s()))
}
#[doc = "weight contraction: Bivector ∨ b☆ Vector -> Vector"]
#[inline]
pub fn weight_contraction_bivector_vector<T: Float>(a: &Bivector<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(-(a.xy() * b.y()), a.xy() * b.x())
}
#[doc = "weight contraction: Rotor ∨ b☆ Bivector -> Scalar"]
#[inline]
pub fn weight_contraction_rotor_bivector<T: Float>(a: &Rotor<T>, b: &Bivector<T>) -> Scalar<T> {
    Scalar::new(-(a.xy() * b.xy()))
}
#[doc = "weight contraction: Rotor ∨ b☆ Rotor -> Rotor"]
#[inline]
pub fn weight_contraction_rotor_rotor<T: Float>(a: &Rotor<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(-(a.s() * b.s()) - a.xy() * b.xy(), -(a.xy() * b.s()))
}
#[doc = "weight contraction: Rotor ∨ b☆ Scalar -> Rotor"]
#[inline]
pub fn weight_contraction_rotor_scalar<T: Float>(a: &Rotor<T>, b: &Scalar<T>) -> Rotor<T> {
    Rotor::new(-(a.s() * b.s()), -(a.xy() * b.s()))
}
#[doc = "weight contraction: Rotor ∨ b☆ Vector -> Vector"]
#[inline]
pub fn weight_contraction_rotor_vector<T: Float>(a: &Rotor<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(-(a.xy() * b.y()), a.xy() * b.x())
}
#[doc = "weight contraction: Scalar ∨ b☆ Rotor -> Scalar"]
#[inline]
pub fn weight_contraction_scalar_rotor<T: Float>(a: &Scalar<T>, b: &Rotor<T>) -> Scalar<T> {
    Scalar::new(-(a.s() * b.s()))
}
#[doc = "weight contraction: Scalar ∨ b☆ Scalar -> Scalar"]
#[inline]
pub fn weight_contraction_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(-(a.s() * b.s()))
}
#[doc = "weight contraction: Vector ∨ b☆ Rotor -> Vector"]
#[inline]
pub fn weight_contraction_vector_rotor<T: Float>(a: &Vector<T>, b: &Rotor<T>) -> Vector<T> {
    Vector::new(a.x() * b.s(), a.y() * b.s())
}
#[doc = "weight contraction: Vector ∨ b☆ Scalar -> Vector"]
#[inline]
pub fn weight_contraction_vector_scalar<T: Float>(a: &Vector<T>, b: &Scalar<T>) -> Vector<T> {
    Vector::new(a.x() * b.s(), a.y() * b.s())
}
#[doc = "weight contraction: Vector ∨ b☆ Vector -> Scalar"]
#[inline]
pub fn weight_contraction_vector_vector<T: Float>(a: &Vector<T>, b: &Vector<T>) -> Scalar<T> {
    Scalar::new(-(a.x() * b.x()) - a.y() * b.y())
}
#[doc = "bulk expansion: Bivector ∧ b★ Bivector -> Bivector"]
#[inline]
pub fn bulk_expansion_bivector_bivector<T: Float>(a: &Bivector<T>, b: &Bivector<T>) -> Bivector<T> {
    Bivector::new(a.xy() * b.xy())
}
#[doc = "bulk expansion: Bivector ∧ b★ Rotor -> Bivector"]
#[inline]
pub fn bulk_expansion_bivector_rotor<T: Float>(a: &Bivector<T>, b: &Rotor<T>) -> Bivector<T> {
    Bivector::new(a.xy() * b.xy())
}
#[doc = "bulk expansion: Rotor ∧ b★ Bivector -> Rotor"]
#[inline]
pub fn bulk_expansion_rotor_bivector<T: Float>(a: &Rotor<T>, b: &Bivector<T>) -> Rotor<T> {
    Rotor::new(a.s() * b.xy(), a.xy() * b.xy())
}
#[doc = "bulk expansion: Rotor ∧ b★ Rotor -> Rotor"]
#[inline]
pub fn bulk_expansion_rotor_rotor<T: Float>(a: &Rotor<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(a.s() * b.xy(), a.s() * b.s() + a.xy() * b.xy())
}
#[doc = "bulk expansion: Rotor ∧ b★ Scalar -> Bivector"]
#[inline]
pub fn bulk_expansion_rotor_scalar<T: Float>(a: &Rotor<T>, b: &Scalar<T>) -> Bivector<T> {
    Bivector::new(a.s() * b.s())
}
#[doc = "bulk expansion: Rotor ∧ b★ Vector -> Vector"]
#[inline]
pub fn bulk_expansion_rotor_vector<T: Float>(a: &Rotor<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(-(a.s() * b.y()), a.s() * b.x())
}
#[doc = "bulk expansion: Scalar ∧ b★ Bivector -> Scalar"]
#[inline]
pub fn bulk_expansion_scalar_bivector<T: Float>(a: &Scalar<T>, b: &Bivector<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.xy())
}
#[doc = "bulk expansion: Scalar ∧ b★ Rotor -> Rotor"]
#[inline]
pub fn bulk_expansion_scalar_rotor<T: Float>(a: &Scalar<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(a.s() * b.xy(), a.s() * b.s())
}
#[doc = "bulk expansion: Scalar ∧ b★ Scalar -> Bivector"]
#[inline]
pub fn bulk_expansion_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Bivector<T> {
    Bivector::new(a.s() * b.s())
}
#[doc = "bulk expansion: Scalar ∧ b★ Vector -> Vector"]
#[inline]
pub fn bulk_expansion_scalar_vector<T: Float>(a: &Scalar<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(-(a.s() * b.y()), a.s() * b.x())
}
#[doc = "bulk expansion: Vector ∧ b★ Bivector -> Vector"]
#[inline]
pub fn bulk_expansion_vector_bivector<T: Float>(a: &Vector<T>, b: &Bivector<T>) -> Vector<T> {
    Vector::new(a.x() * b.xy(), a.y() * b.xy())
}
#[doc = "bulk expansion: Vector ∧ b★ Rotor -> Vector"]
#[inline]
pub fn bulk_expansion_vector_rotor<T: Float>(a: &Vector<T>, b: &Rotor<T>) -> Vector<T> {
    Vector::new(a.x() * b.xy(), a.y() * b.xy())
}
#[doc = "bulk expansion: Vector ∧ b★ Vector -> Bivector"]
#[inline]
pub fn bulk_expansion_vector_vector<T: Float>(a: &Vector<T>, b: &Vector<T>) -> Bivector<T> {
    Bivector::new(a.x() * b.x() + a.y() * b.y())
}
#[doc = "weight expansion: Bivector ∧ b☆ Bivector -> Bivector"]
#[inline]
pub fn weight_expansion_bivector_bivector<T: Float>(
    a: &Bivector<T>,
    b: &Bivector<T>,
) -> Bivector<T> {
    Bivector::new(-(a.xy() * b.xy()))
}
#[doc = "weight expansion: Bivector ∧ b☆ Rotor -> Bivector"]
#[inline]
pub fn weight_expansion_bivector_rotor<T: Float>(a: &Bivector<T>, b: &Rotor<T>) -> Bivector<T> {
    Bivector::new(-(a.xy() * b.xy()))
}
#[doc = "weight expansion: Rotor ∧ b☆ Bivector -> Rotor"]
#[inline]
pub fn weight_expansion_rotor_bivector<T: Float>(a: &Rotor<T>, b: &Bivector<T>) -> Rotor<T> {
    Rotor::new(-(a.s() * b.xy()), -(a.xy() * b.xy()))
}
#[doc = "weight expansion: Rotor ∧ b☆ Rotor -> Rotor"]
#[inline]
pub fn weight_expansion_rotor_rotor<T: Float>(a: &Rotor<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(-(a.s() * b.xy()), -(a.s() * b.s()) - a.xy() * b.xy())
}
#[doc = "weight expansion: Rotor ∧ b☆ Scalar -> Bivector"]
#[inline]
pub fn weight_expansion_rotor_scalar<T: Float>(a: &Rotor<T>, b: &Scalar<T>) -> Bivector<T> {
    Bivector::new(-(a.s() * b.s()))
}
#[doc = "weight expansion: Rotor ∧ b☆ Vector -> Vector"]
#[inline]
pub fn weight_expansion_rotor_vector<T: Float>(a: &Rotor<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(a.s() * b.y(), -(a.s() * b.x()))
}
#[doc = "weight expansion: Scalar ∧ b☆ Bivector -> Scalar"]
#[inline]
pub fn weight_expansion_scalar_bivector<T: Float>(a: &Scalar<T>, b: &Bivector<T>) -> Scalar<T> {
    Scalar::new(-(a.s() * b.xy()))
}
#[doc = "weight expansion: Scalar ∧ b☆ Rotor -> Rotor"]
#[inline]
pub fn weight_expansion_scalar_rotor<T: Float>(a: &Scalar<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(-(a.s() * b.xy()), -(a.s() * b.s()))
}
#[doc = "weight expansion: Scalar ∧ b☆ Scalar -> Bivector"]
#[inline]
pub fn weight_expansion_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Bivector<T> {
    Bivector::new(-(a.s() * b.s()))
}
#[doc = "weight expansion: Scalar ∧ b☆ Vector -> Vector"]
#[inline]
pub fn weight_expansion_scalar_vector<T: Float>(a: &Scalar<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(a.s() * b.y(), -(a.s() * b.x()))
}
#[doc = "weight expansion: Vector ∧ b☆ Bivector -> Vector"]
#[inline]
pub fn weight_expansion_vector_bivector<T: Float>(a: &Vector<T>, b: &Bivector<T>) -> Vector<T> {
    Vector::new(-(a.x() * b.xy()), -(a.y() * b.xy()))
}
#[doc = "weight expansion: Vector ∧ b☆ Rotor -> Vector"]
#[inline]
pub fn weight_expansion_vector_rotor<T: Float>(a: &Vector<T>, b: &Rotor<T>) -> Vector<T> {
    Vector::new(-(a.x() * b.xy()), -(a.y() * b.xy()))
}
#[doc = "weight expansion: Vector ∧ b☆ Vector -> Bivector"]
#[inline]
pub fn weight_expansion_vector_vector<T: Float>(a: &Vector<T>, b: &Vector<T>) -> Bivector<T> {
    Bivector::new(-(a.x() * b.x()) - a.y() * b.y())
}
#[doc = "Sandwich product: Rotor * Rotor * rev(Rotor) -> Rotor"]
#[inline]
pub fn sandwich_rotor_rotor<T: Float>(v: &Rotor<T>, x: &Rotor<T>) -> Rotor<T> {
    Rotor::new(
        v.xy() * x.s() * v.xy() + v.s() * x.s() * v.s() - v.xy() * x.xy() * v.s()
            + v.s() * x.xy() * v.xy(),
        v.s() * x.xy() * v.s() - v.s() * x.s() * v.xy()
            + v.xy() * x.s() * v.s()
            + v.xy() * x.xy() * v.xy(),
    )
}
#[doc = "Sandwich product: Rotor * Vector * rev(Rotor) -> Vector"]
#[inline]
pub fn sandwich_rotor_vector<T: Float>(v: &Rotor<T>, x: &Vector<T>) -> Vector<T> {
    Vector::new(
        -(v.xy() * x.x() * v.xy())
            + v.s() * x.x() * v.s()
            + v.xy() * x.y() * v.s()
            + v.s() * x.y() * v.xy(),
        -(v.s() * x.x() * v.xy()) + v.s() * x.y() * v.s()
            - v.xy() * x.y() * v.xy()
            - v.xy() * x.x() * v.s(),
    )
}
#[doc = "Antisandwich product: Rotor ⊛ Rotor ⊛ antirev(Rotor) -> Rotor\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_rotor_rotor<T: Float>(v: &Rotor<T>, x: &Rotor<T>) -> Rotor<T> {
    Rotor::new(
        -(v.xy() * x.xy() * v.s())
            + v.xy() * x.s() * v.xy()
            + v.s() * x.xy() * v.xy()
            + v.s() * x.s() * v.s(),
        v.xy() * x.xy() * v.xy() - v.s() * x.s() * v.xy()
            + v.s() * x.xy() * v.s()
            + v.xy() * x.s() * v.s(),
    )
}
#[doc = "Antisandwich product: Rotor ⊛ Vector ⊛ antirev(Rotor) -> Vector\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_rotor_vector<T: Float>(v: &Rotor<T>, x: &Vector<T>) -> Vector<T> {
    Vector::new(
        v.xy() * x.y() * v.s() + v.xy() * x.x() * v.xy() - v.s() * x.x() * v.s()
            + v.s() * x.y() * v.xy(),
        -(v.s() * x.y() * v.s()) + v.xy() * x.y() * v.xy()
            - v.s() * x.x() * v.xy()
            - v.xy() * x.x() * v.s(),
    )
}
#[doc = "Reverses the Bivector (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_bivector<T: Float>(a: &Bivector<T>) -> Bivector<T> {
    Bivector::new(-a.xy())
}
#[doc = "Reverses the Rotor (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_rotor<T: Float>(a: &Rotor<T>) -> Rotor<T> {
    Rotor::new(a.s(), -a.xy())
}
#[doc = "Reverses the Scalar (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_scalar<T: Float>(a: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.s())
}
#[doc = "Reverses the Vector (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_vector<T: Float>(a: &Vector<T>) -> Vector<T> {
    Vector::new(a.x(), a.y())
}
#[doc = "Antireverses the Bivector (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_bivector<T: Float>(a: &Bivector<T>) -> Bivector<T> {
    Bivector::new(a.xy())
}
#[doc = "Antireverses the Rotor (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_rotor<T: Float>(a: &Rotor<T>) -> Rotor<T> {
    Rotor::new(-a.s(), a.xy())
}
#[doc = "Antireverses the Scalar (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_scalar<T: Float>(a: &Scalar<T>) -> Scalar<T> {
    Scalar::new(-a.s())
}
#[doc = "Antireverses the Vector (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_vector<T: Float>(a: &Vector<T>) -> Vector<T> {
    Vector::new(a.x(), a.y())
}
#[doc = "Computes the right complement of Bivector -> Scalar."]
#[inline]
pub fn complement_bivector<T: Float>(a: &Bivector<T>) -> Scalar<T> {
    Scalar::new(a.xy())
}
#[doc = "Computes the right complement of Rotor -> Rotor."]
#[inline]
pub fn complement_rotor<T: Float>(a: &Rotor<T>) -> Rotor<T> {
    Rotor::new(a.xy(), a.s())
}
#[doc = "Computes the right complement of Scalar -> Bivector."]
#[inline]
pub fn complement_scalar<T: Float>(a: &Scalar<T>) -> Bivector<T> {
    Bivector::new(a.s())
}
#[doc = "Computes the right complement of Vector -> Vector."]
#[inline]
pub fn complement_vector<T: Float>(a: &Vector<T>) -> Vector<T> {
    Vector::new(-a.y(), a.x())
}
