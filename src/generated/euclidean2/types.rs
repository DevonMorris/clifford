#![doc = " Type definitions for euclidean2."]
#![doc = ""]
#![doc = " 2D Euclidean Geometric Algebra Cl(2,0,0)"]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
#![allow(clippy::too_many_arguments)]
use crate::scalar::Float;
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
#[doc = "2D bivector (pseudoscalar)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 3 | e1e2 | `xy` |\n\n\n# Example\n\n```ignore\nuse clifford::euclidean/dim2::Bivector;\n\nlet v = Bivector::new(1.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Bivector<T: Float> {
    #[doc = "Coefficient of `xy`."]
    xy: T,
}
impl<T: Float> Bivector<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(xy: T) -> Self {
        Self { xy }
    }
    #[doc = "Returns the `xy` coefficient."]
    #[inline]
    pub fn xy(&self) -> T {
        self.xy
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new(T::zero())
    }
    #[doc = "Creates the unit e1e2 element."]
    #[inline]
    pub fn unit_xy() -> Self {
        Self::new(T::one())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.xy * self.xy
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new(self.xy * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new(-self.xy)
    }
}
impl<T: Float> Default for Bivector<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "2D rotor (unit versor for rotations)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 0 | s | `s` |\n| 3 | e1e2 | `xy` |\n\n\n# Example\n\n```ignore\nuse clifford::euclidean/dim2::Rotor;\n\nlet v = Rotor::new(1.0, 2.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Rotor<T: Float> {
    #[doc = "Coefficient of `s`."]
    s: T,
    #[doc = "Coefficient of `xy`."]
    xy: T,
}
impl<T: Float> Rotor<T> {
    #[doc = "Creates a new element from 1 independent coefficients.\n\nThe `s` coefficient(s) are computed from geometric constraints.\n\nReturns `None` if the constraint cannot be satisfied (e.g., when the\nsqrt argument would be negative)."]
    #[inline]
    pub fn new(xy: T) -> Option<Self> {
        let sqrt_arg = T::from_i8(1) - xy * xy;
        if sqrt_arg < T::zero() {
            return None;
        }
        let s = sqrt_arg.sqrt();
        Some(Self { s, xy })
    }
    #[doc = "Creates a new element from all coefficients with constraint validation.\n\nReturns an error if the geometric constraint is not satisfied within\nthe given tolerance.\n\n# Errors\n\nReturns `ConstraintError` if `|s*s + xy*xy - 1| > tolerance`."]
    #[inline]
    pub fn new_checked(s: T, xy: T, tolerance: T) -> Result<Self, crate::ConstraintError> {
        let residual_0 = (s * s + xy * xy) - (T::from_i8(1));
        if residual_0.abs() > tolerance {
            return Err(crate::ConstraintError::new(
                "Rotor",
                "s*s + xy*xy = 1",
                residual_0.to_f64().unwrap_or(0.0),
            ));
        }
        Ok(Self { s, xy })
    }
    #[doc = r" Creates a new element from all coefficients without validation."]
    #[doc = r""]
    #[doc = r" # Safety (Logical)"]
    #[doc = r""]
    #[doc = r" Caller must ensure the geometric constraint is satisfied."]
    #[doc = r" Use this for performance-critical code, automatic differentiation,"]
    #[doc = r" or when coefficients come from trusted sources (e.g., product operations)."]
    #[inline]
    pub fn new_unchecked(s: T, xy: T) -> Self {
        Self { s, xy }
    }
    #[doc = "Returns the `s` coefficient."]
    #[inline]
    pub fn s(&self) -> T {
        self.s
    }
    #[doc = "Returns the `xy` coefficient."]
    #[inline]
    pub fn xy(&self) -> T {
        self.xy
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero(), T::zero())
    }
    #[doc = r" Creates the identity element (scalar = 1, rest = 0)."]
    #[inline]
    pub fn identity() -> Self {
        Self::new_unchecked(T::one(), T::zero())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.s * self.s + self.xy * self.xy
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.s * s, self.xy * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.s, -self.xy)
    }
}
impl<T: Float> Default for Rotor<T> {
    fn default() -> Self {
        Self::identity()
    }
}
#[doc = "Scalar (grade-0 element)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 0 | s | `s` |\n\n\n# Example\n\n```ignore\nuse clifford::euclidean/dim2::Scalar;\n\nlet v = Scalar::new(1.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Scalar<T: Float> {
    #[doc = "Coefficient of `s`."]
    s: T,
}
impl<T: Float> Scalar<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(s: T) -> Self {
        Self { s }
    }
    #[doc = "Returns the `s` coefficient."]
    #[inline]
    pub fn s(&self) -> T {
        self.s
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new(T::zero())
    }
    #[doc = r" Creates the identity element (scalar = 1, rest = 0)."]
    #[inline]
    pub fn identity() -> Self {
        Self::new(T::one())
    }
    #[doc = "Creates the unit s element."]
    #[inline]
    pub fn unit_s() -> Self {
        Self::new(T::one())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.s * self.s
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new(self.s * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new(self.s)
    }
}
impl<T: Float> Default for Scalar<T> {
    fn default() -> Self {
        Self::identity()
    }
}
#[doc = "2D vector\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 1 | e1 | `x` |\n| 2 | e2 | `y` |\n\n\n# Example\n\n```ignore\nuse clifford::euclidean/dim2::Vector;\n\nlet v = Vector::new(1.0, 2.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Vector<T: Float> {
    #[doc = "Coefficient of `x`."]
    x: T,
    #[doc = "Coefficient of `y`."]
    y: T,
}
impl<T: Float> Vector<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
    #[doc = "Returns the `x` coefficient."]
    #[inline]
    pub fn x(&self) -> T {
        self.x
    }
    #[doc = "Returns the `y` coefficient."]
    #[inline]
    pub fn y(&self) -> T {
        self.y
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new(T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1 element."]
    #[inline]
    pub fn unit_x() -> Self {
        Self::new(T::one(), T::zero())
    }
    #[doc = "Creates the unit e2 element."]
    #[inline]
    pub fn unit_y() -> Self {
        Self::new(T::zero(), T::one())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.x * self.x + self.y * self.y
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new(self.x * s, self.y * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new(self.x, self.y)
    }
}
impl<T: Float> Default for Vector<T> {
    fn default() -> Self {
        Self::zero()
    }
}
