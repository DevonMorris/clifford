#![doc = " Trait implementations for hyperbolic."]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
use super::types::{HypUnit, Hyperbolic, Scalar};
#[allow(unused_imports)]
use crate::ops::{
    Antidot, Antireverse, Antisandwich, Antiwedge, BulkContract, BulkExpand, Dot, Involute,
    LeftContract, Reverse, RightComplement, RightContract, Sandwich, ScalarProduct, Transform,
    Wedge, WeightContract, WeightDual, WeightExpand,
};
use crate::scalar::Float;
use approx::{AbsDiffEq, RelativeEq, UlpsEq};
use std::ops::{Add, Mul, Neg, Sub};
impl<T: Float> Add for HypUnit<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.j() + rhs.j())
    }
}
impl<T: Float> Sub for HypUnit<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.j() - rhs.j())
    }
}
impl<T: Float> Neg for HypUnit<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.j())
    }
}
impl<T: Float> Mul<T> for HypUnit<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<HypUnit<f32>> for f32 {
    type Output = HypUnit<f32>;
    #[inline]
    fn mul(self, v: HypUnit<f32>) -> HypUnit<f32> {
        v.scale(self)
    }
}
impl Mul<HypUnit<f64>> for f64 {
    type Output = HypUnit<f64>;
    #[inline]
    fn mul(self, v: HypUnit<f64>) -> HypUnit<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<HypUnit<T>> for HypUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn mul(self, rhs: HypUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.j() * rhs.j())
    }
}
impl<T: Float> Mul<Hyperbolic<T>> for HypUnit<T> {
    type Output = Hyperbolic<T>;
    #[inline]
    fn mul(self, rhs: Hyperbolic<T>) -> Hyperbolic<T> {
        Hyperbolic::new_unchecked(self.j() * rhs.hyp(), self.j() * rhs.real())
    }
}
impl<T: Float> Mul<Scalar<T>> for HypUnit<T> {
    type Output = HypUnit<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> HypUnit<T> {
        HypUnit::new_unchecked(rhs.s() * self.j())
    }
}
impl<T: Float> Add for Hyperbolic<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.real() + rhs.real(), self.hyp() + rhs.hyp())
    }
}
impl<T: Float> Sub for Hyperbolic<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.real() - rhs.real(), self.hyp() - rhs.hyp())
    }
}
impl<T: Float> Neg for Hyperbolic<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.real(), -self.hyp())
    }
}
impl<T: Float> Mul<T> for Hyperbolic<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Hyperbolic<f32>> for f32 {
    type Output = Hyperbolic<f32>;
    #[inline]
    fn mul(self, v: Hyperbolic<f32>) -> Hyperbolic<f32> {
        v.scale(self)
    }
}
impl Mul<Hyperbolic<f64>> for f64 {
    type Output = Hyperbolic<f64>;
    #[inline]
    fn mul(self, v: Hyperbolic<f64>) -> Hyperbolic<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<HypUnit<T>> for Hyperbolic<T> {
    type Output = Hyperbolic<T>;
    #[inline]
    fn mul(self, rhs: HypUnit<T>) -> Hyperbolic<T> {
        Hyperbolic::new_unchecked(self.hyp() * rhs.j(), self.real() * rhs.j())
    }
}
impl<T: Float> Mul<Hyperbolic<T>> for Hyperbolic<T> {
    type Output = Hyperbolic<T>;
    #[inline]
    fn mul(self, rhs: Hyperbolic<T>) -> Hyperbolic<T> {
        Hyperbolic::new_unchecked(
            self.real() * rhs.real() + self.hyp() * rhs.hyp(),
            self.real() * rhs.hyp() + self.hyp() * rhs.real(),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Hyperbolic<T> {
    type Output = Hyperbolic<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Hyperbolic<T> {
        Hyperbolic::new_unchecked(rhs.s() * self.real(), rhs.s() * self.hyp())
    }
}
impl<T: Float> Add for Scalar<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.s() + rhs.s())
    }
}
impl<T: Float> Sub for Scalar<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.s() - rhs.s())
    }
}
impl<T: Float> Neg for Scalar<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.s())
    }
}
impl<T: Float> Mul<T> for Scalar<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Scalar<f32>> for f32 {
    type Output = Scalar<f32>;
    #[inline]
    fn mul(self, v: Scalar<f32>) -> Scalar<f32> {
        v.scale(self)
    }
}
impl Mul<Scalar<f64>> for f64 {
    type Output = Scalar<f64>;
    #[inline]
    fn mul(self, v: Scalar<f64>) -> Scalar<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<HypUnit<T>> for Scalar<T> {
    type Output = HypUnit<T>;
    #[inline]
    fn mul(self, rhs: HypUnit<T>) -> HypUnit<T> {
        HypUnit::new_unchecked(self.s() * rhs.j())
    }
}
impl<T: Float> Mul<Hyperbolic<T>> for Scalar<T> {
    type Output = Hyperbolic<T>;
    #[inline]
    fn mul(self, rhs: Hyperbolic<T>) -> Hyperbolic<T> {
        Hyperbolic::new_unchecked(self.s() * rhs.real(), self.s() * rhs.hyp())
    }
}
impl<T: Float> Mul<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
impl<T: Float> Wedge<Scalar<T>> for HypUnit<T> {
    type Output = HypUnit<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> HypUnit<T> {
        HypUnit::new_unchecked(rhs.s() * self.j())
    }
}
impl<T: Float> Wedge<HypUnit<T>> for Scalar<T> {
    type Output = HypUnit<T>;
    #[inline]
    fn wedge(&self, rhs: &HypUnit<T>) -> HypUnit<T> {
        HypUnit::new_unchecked(self.s() * rhs.j())
    }
}
impl<T: Float> Wedge<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
impl<T: Float> Antiwedge<HypUnit<T>> for HypUnit<T> {
    type Output = HypUnit<T>;
    #[inline]
    fn antiwedge(&self, rhs: &HypUnit<T>) -> HypUnit<T> {
        HypUnit::new_unchecked(self.j() * rhs.j())
    }
}
impl<T: Float> Antiwedge<Scalar<T>> for HypUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.j())
    }
}
impl<T: Float> Antiwedge<HypUnit<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &HypUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.j())
    }
}
impl<T: Float> LeftContract<HypUnit<T>> for HypUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &HypUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.j() * rhs.j())
    }
}
impl<T: Float> LeftContract<HypUnit<T>> for Scalar<T> {
    type Output = HypUnit<T>;
    #[inline]
    fn left_contract(&self, rhs: &HypUnit<T>) -> HypUnit<T> {
        HypUnit::new_unchecked(self.s() * rhs.j())
    }
}
impl<T: Float> LeftContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
impl<T: Float> RightContract<HypUnit<T>> for HypUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &HypUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.j() * rhs.j())
    }
}
impl<T: Float> RightContract<Scalar<T>> for HypUnit<T> {
    type Output = HypUnit<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> HypUnit<T> {
        HypUnit::new_unchecked(rhs.s() * self.j())
    }
}
impl<T: Float> RightContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
impl<T: Float> ScalarProduct<HypUnit<T>> for HypUnit<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &HypUnit<T>) -> T {
        self.j() * rhs.j()
    }
}
impl<T: Float> ScalarProduct<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
impl<T: Float> BulkContract<HypUnit<T>> for HypUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &HypUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.j() * rhs.j())
    }
}
impl<T: Float> BulkContract<Scalar<T>> for HypUnit<T> {
    type Output = HypUnit<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> HypUnit<T> {
        HypUnit::new_unchecked(rhs.s() * self.j())
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
impl<T: Float> WeightContract<HypUnit<T>> for HypUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &HypUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.j() * rhs.j())
    }
}
impl<T: Float> WeightContract<Scalar<T>> for HypUnit<T> {
    type Output = HypUnit<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> HypUnit<T> {
        HypUnit::new_unchecked(rhs.s() * self.j())
    }
}
impl<T: Float> WeightContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
impl<T: Float> BulkExpand<HypUnit<T>> for HypUnit<T> {
    type Output = HypUnit<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &HypUnit<T>) -> HypUnit<T> {
        HypUnit::new_unchecked(self.j() * rhs.j())
    }
}
impl<T: Float> BulkExpand<HypUnit<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &HypUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.j())
    }
}
impl<T: Float> BulkExpand<Scalar<T>> for Scalar<T> {
    type Output = HypUnit<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Scalar<T>) -> HypUnit<T> {
        HypUnit::new_unchecked(self.s() * rhs.s())
    }
}
impl<T: Float> WeightExpand<HypUnit<T>> for HypUnit<T> {
    type Output = HypUnit<T>;
    #[inline]
    fn weight_expand(&self, rhs: &HypUnit<T>) -> HypUnit<T> {
        HypUnit::new_unchecked(self.j() * rhs.j())
    }
}
impl<T: Float> WeightExpand<HypUnit<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &HypUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.j())
    }
}
impl<T: Float> WeightExpand<Scalar<T>> for Scalar<T> {
    type Output = HypUnit<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Scalar<T>) -> HypUnit<T> {
        HypUnit::new_unchecked(self.s() * rhs.s())
    }
}
impl<T: Float> Dot<HypUnit<T>> for HypUnit<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &HypUnit<T>) -> T {
        self.j() * rhs.j()
    }
}
impl<T: Float> Dot<Hyperbolic<T>> for HypUnit<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Hyperbolic<T>) -> T {
        self.j() * rhs.hyp()
    }
}
impl<T: Float> Dot<HypUnit<T>> for Hyperbolic<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &HypUnit<T>) -> T {
        self.hyp() * rhs.j()
    }
}
impl<T: Float> Dot<Hyperbolic<T>> for Hyperbolic<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Hyperbolic<T>) -> T {
        self.real() * rhs.real() + self.hyp() * rhs.hyp()
    }
}
impl<T: Float> Dot<Scalar<T>> for Hyperbolic<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.real() * rhs.s()
    }
}
impl<T: Float> Dot<Hyperbolic<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Hyperbolic<T>) -> T {
        self.s() * rhs.real()
    }
}
impl<T: Float> Dot<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
impl<T: Float> Antidot<HypUnit<T>> for HypUnit<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &HypUnit<T>) -> T {
        self.j() * rhs.j()
    }
}
impl<T: Float> Antidot<Hyperbolic<T>> for HypUnit<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Hyperbolic<T>) -> T {
        self.j() * rhs.hyp()
    }
}
impl<T: Float> Antidot<HypUnit<T>> for Hyperbolic<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &HypUnit<T>) -> T {
        self.hyp() * rhs.j()
    }
}
impl<T: Float> Antidot<Hyperbolic<T>> for Hyperbolic<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Hyperbolic<T>) -> T {
        self.real() * rhs.real() + self.hyp() * rhs.hyp()
    }
}
impl<T: Float> Antidot<Scalar<T>> for Hyperbolic<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        self.real() * rhs.s()
    }
}
impl<T: Float> Antidot<Hyperbolic<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Hyperbolic<T>) -> T {
        self.s() * rhs.real()
    }
}
impl<T: Float> Antidot<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
impl<T: Float> Reverse for HypUnit<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.j())
    }
}
impl<T: Float> Reverse for Hyperbolic<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.real(), self.hyp())
    }
}
impl<T: Float> Reverse for Scalar<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> Antireverse for HypUnit<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.j())
    }
}
impl<T: Float> Antireverse for Hyperbolic<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.real(), self.hyp())
    }
}
impl<T: Float> Antireverse for Scalar<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> Involute for HypUnit<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(-self.j())
    }
}
impl<T: Float> Involute for Hyperbolic<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.real(), -self.hyp())
    }
}
impl<T: Float> Involute for Scalar<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> RightComplement for HypUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_complement(&self) -> Scalar<T> {
        Scalar::new_unchecked(self.j())
    }
}
impl<T: Float> RightComplement for Hyperbolic<T> {
    type Output = Hyperbolic<T>;
    #[inline]
    fn right_complement(&self) -> Hyperbolic<T> {
        Hyperbolic::new_unchecked(self.hyp(), self.real())
    }
}
impl<T: Float> RightComplement for Scalar<T> {
    type Output = HypUnit<T>;
    #[inline]
    fn right_complement(&self) -> HypUnit<T> {
        HypUnit::new_unchecked(self.s())
    }
}
impl<T: Float> WeightDual for HypUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_dual(&self) -> Scalar<T> {
        Scalar::new_unchecked(self.j())
    }
}
impl<T: Float> WeightDual for Hyperbolic<T> {
    type Output = Hyperbolic<T>;
    #[inline]
    fn weight_dual(&self) -> Hyperbolic<T> {
        Hyperbolic::new_unchecked(self.hyp(), self.real())
    }
}
impl<T: Float> WeightDual for Scalar<T> {
    type Output = HypUnit<T>;
    #[inline]
    fn weight_dual(&self) -> HypUnit<T> {
        HypUnit::new_unchecked(self.s())
    }
}
impl<T: Float> crate::norm::Normed for HypUnit<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        -self.j() * self.j()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.j() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Hyperbolic<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.real() * self.real() + -self.hyp() * self.hyp()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.real() * factor, self.hyp() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.s() * self.s()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.s() * factor)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for HypUnit<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.j().abs_diff_eq(&other.j(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for HypUnit<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.j().relative_eq(&other.j(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for HypUnit<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.j().ulps_eq(&other.j(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Hyperbolic<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.real().abs_diff_eq(&other.real(), epsilon)
            && self.hyp().abs_diff_eq(&other.hyp(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Hyperbolic<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.real()
            .relative_eq(&other.real(), epsilon, max_relative)
            && self.hyp().relative_eq(&other.hyp(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Hyperbolic<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.real().ulps_eq(&other.real(), epsilon, max_ulps)
            && self.hyp().ulps_eq(&other.hyp(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Scalar<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Scalar<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Scalar<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
    }
}
#[cfg(any(test, feature = "proptest-support"))]
#[allow(clippy::missing_docs_in_private_items)]
mod arbitrary_impls {
    use super::*;
    use proptest::prelude::*;
    use proptest::strategy::BoxedStrategy;
    use std::fmt::Debug;
    impl<T: Float + Debug + 'static> Arbitrary for HypUnit<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| HypUnit::new_unchecked(T::from_f64(x0)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Hyperbolic<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0, -100.0f64..100.0)
                .prop_map(|(x0, x1)| Hyperbolic::new_unchecked(T::from_f64(x0), T::from_f64(x1)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Scalar<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| Scalar::new_unchecked(T::from_f64(x0)))
                .boxed()
        }
    }
}

// ============================================================
// Verification Tests (compare against Multivector)
// ============================================================

#[cfg(test)]
#[allow(clippy::missing_docs_in_private_items)]
mod verification_tests {
    use super::*;
    use crate::algebra::Multivector;
    use crate::signature::Cl1_0_0;
    #[allow(unused_imports)]
    use crate::wrappers::Unit;
    use approx::relative_eq;
    use proptest::prelude::*;

    /// Relative epsilon for floating-point comparisons in verification tests.
    /// Using relative comparison handles varying magnitudes better than absolute.
    const REL_EPSILON: f64 = 1e-10;

    proptest! {
        #[test]
        fn hypunit_add_matches_multivector(a in any::<HypUnit<f64>>(), b in any::<HypUnit<f64>>()) {
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn hypunit_sub_matches_multivector(a in any::<HypUnit<f64>>(), b in any::<HypUnit<f64>>()) {
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn hypunit_neg_matches_multivector(a in any::<HypUnit<f64>>()) {
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn hyperbolic_add_matches_multivector(a in any::<Hyperbolic<f64>>(), b in any::<Hyperbolic<f64>>()) {
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn hyperbolic_sub_matches_multivector(a in any::<Hyperbolic<f64>>(), b in any::<Hyperbolic<f64>>()) {
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn hyperbolic_neg_matches_multivector(a in any::<Hyperbolic<f64>>()) {
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn scalar_add_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn scalar_sub_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn scalar_neg_matches_multivector(a in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_hypunit_scalar_hypunit_matches_multivector(a in any::<HypUnit<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result: HypUnit<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_scalar_hypunit_hypunit_matches_multivector(a in any::<Scalar<f64>>(), b in any::<HypUnit<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result: HypUnit<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_scalar_scalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result: Scalar<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_hypunit_hypunit_scalar_matches_multivector(a in any::<HypUnit<f64>>(), b in any::<HypUnit<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result: Scalar<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_hypunit_scalar_hypunit_matches_multivector(a in any::<HypUnit<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result: HypUnit<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_scalar_scalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result: Scalar<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_hypunit_hypunit_scalar_matches_multivector(a in any::<HypUnit<f64>>(), b in any::<HypUnit<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result: Scalar<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_hypunit_scalar_hypunit_matches_multivector(a in any::<HypUnit<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result: HypUnit<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_scalar_scalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result: Scalar<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_hypunit_hypunit_hypunit_matches_multivector(a in any::<HypUnit<f64>>(), b in any::<HypUnit<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result: HypUnit<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_scalar_hypunit_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<HypUnit<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result: Scalar<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_scalar_scalar_hypunit_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result: HypUnit<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_hypunit_hypunit_hypunit_matches_multivector(a in any::<HypUnit<f64>>(), b in any::<HypUnit<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result: HypUnit<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_scalar_hypunit_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<HypUnit<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result: Scalar<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_scalar_scalar_hypunit_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            let specialized_result: HypUnit<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl1_0_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a) ⋇ complement(b)
        #[test]
        fn de_morgan_geometric_hypunit(a in any::<HypUnit<f64>>(), b in any::<HypUnit<f64>>()) {
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            // LHS: complement(a * b)
            let lhs = (&mv_a * &mv_b).complement();

            // RHS: complement(a) ⋇ complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)⋇complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a ⋇ b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_hypunit(a in any::<HypUnit<f64>>(), b in any::<HypUnit<f64>>()) {
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            // LHS: complement(a ⋇ b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = &mv_a.complement() * &mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(a⋇b)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a) ⋇ complement(b)
        #[test]
        fn de_morgan_geometric_hyperbolic(a in any::<Hyperbolic<f64>>(), b in any::<Hyperbolic<f64>>()) {
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            // LHS: complement(a * b)
            let lhs = (&mv_a * &mv_b).complement();

            // RHS: complement(a) ⋇ complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)⋇complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a ⋇ b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_hyperbolic(a in any::<Hyperbolic<f64>>(), b in any::<Hyperbolic<f64>>()) {
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            // LHS: complement(a ⋇ b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = &mv_a.complement() * &mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(a⋇b)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a) ⋇ complement(b)
        #[test]
        fn de_morgan_geometric_scalar(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            // LHS: complement(a * b)
            let lhs = (&mv_a * &mv_b).complement();

            // RHS: complement(a) ⋇ complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)⋇complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a ⋇ b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_scalar(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl1_0_0> = a.into();
            let mv_b: Multivector<f64, Cl1_0_0> = b.into();

            // LHS: complement(a ⋇ b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = &mv_a.complement() * &mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(a⋇b)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }
}
