#![doc = " Product operations for euclidean3."]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
use super::types::{Bivector, Rotor, Scalar, Trivector, Vector};
use crate::scalar::Float;
#[doc = "Geometric product: Bivector * Bivector -> Rotor"]
#[inline]
pub fn geometric_bivector_bivector<T: Float>(a: &Bivector<T>, b: &Bivector<T>) -> Rotor<T> {
    Rotor::new(
        -(a.xy() * b.xy()) - a.xz() * b.xz() - a.yz() * b.yz(),
        -(a.xz() * b.yz()) + a.yz() * b.xz(),
        a.xy() * b.yz() - a.yz() * b.xy(),
        -(a.xy() * b.xz()) + a.xz() * b.xy(),
    )
}
#[doc = "Geometric product: Bivector * Rotor -> Rotor"]
#[inline]
pub fn geometric_bivector_rotor<T: Float>(a: &Bivector<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(
        -(a.xy() * b.xy()) - a.xz() * b.xz() - a.yz() * b.yz(),
        a.xy() * b.s() - a.xz() * b.yz() + a.yz() * b.xz(),
        a.xy() * b.yz() + a.xz() * b.s() - a.yz() * b.xy(),
        -(a.xy() * b.xz()) + a.xz() * b.xy() + a.yz() * b.s(),
    )
}
#[doc = "Geometric product: Bivector * Scalar -> Bivector"]
#[inline]
pub fn geometric_bivector_scalar<T: Float>(a: &Bivector<T>, b: &Scalar<T>) -> Bivector<T> {
    Bivector::new(a.xy() * b.s(), a.xz() * b.s(), a.yz() * b.s())
}
#[doc = "Geometric product: Bivector * Trivector -> Vector"]
#[inline]
pub fn geometric_bivector_trivector<T: Float>(a: &Bivector<T>, b: &Trivector<T>) -> Vector<T> {
    Vector::new(-(a.yz() * b.xyz()), a.xz() * b.xyz(), -(a.xy() * b.xyz()))
}
#[doc = "Geometric product: Rotor * Bivector -> Rotor"]
#[inline]
pub fn geometric_rotor_bivector<T: Float>(a: &Rotor<T>, b: &Bivector<T>) -> Rotor<T> {
    Rotor::new(
        -(a.xy() * b.xy()) - a.xz() * b.xz() - a.yz() * b.yz(),
        a.s() * b.xy() - a.xz() * b.yz() + a.yz() * b.xz(),
        a.s() * b.xz() + a.xy() * b.yz() - a.yz() * b.xy(),
        a.s() * b.yz() - a.xy() * b.xz() + a.xz() * b.xy(),
    )
}
#[doc = "Geometric product: Rotor * Rotor -> Rotor"]
#[inline]
pub fn geometric_rotor_rotor<T: Float>(a: &Rotor<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(
        a.s() * b.s() - a.xy() * b.xy() - a.xz() * b.xz() - a.yz() * b.yz(),
        a.s() * b.xy() + a.xy() * b.s() - a.xz() * b.yz() + a.yz() * b.xz(),
        a.s() * b.xz() + a.xy() * b.yz() + a.xz() * b.s() - a.yz() * b.xy(),
        a.s() * b.yz() - a.xy() * b.xz() + a.xz() * b.xy() + a.yz() * b.s(),
    )
}
#[doc = "Geometric product: Rotor * Scalar -> Rotor"]
#[inline]
pub fn geometric_rotor_scalar<T: Float>(a: &Rotor<T>, b: &Scalar<T>) -> Rotor<T> {
    Rotor::new(
        a.s() * b.s(),
        a.xy() * b.s(),
        a.xz() * b.s(),
        a.yz() * b.s(),
    )
}
#[doc = "Geometric product: Scalar * Bivector -> Bivector"]
#[inline]
pub fn geometric_scalar_bivector<T: Float>(a: &Scalar<T>, b: &Bivector<T>) -> Bivector<T> {
    Bivector::new(a.s() * b.xy(), a.s() * b.xz(), a.s() * b.yz())
}
#[doc = "Geometric product: Scalar * Rotor -> Rotor"]
#[inline]
pub fn geometric_scalar_rotor<T: Float>(a: &Scalar<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(
        a.s() * b.s(),
        a.s() * b.xy(),
        a.s() * b.xz(),
        a.s() * b.yz(),
    )
}
#[doc = "Geometric product: Scalar * Scalar -> Scalar"]
#[inline]
pub fn geometric_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.s())
}
#[doc = "Geometric product: Scalar * Trivector -> Trivector"]
#[inline]
pub fn geometric_scalar_trivector<T: Float>(a: &Scalar<T>, b: &Trivector<T>) -> Trivector<T> {
    Trivector::new(a.s() * b.xyz())
}
#[doc = "Geometric product: Scalar * Vector -> Vector"]
#[inline]
pub fn geometric_scalar_vector<T: Float>(a: &Scalar<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(a.s() * b.x(), a.s() * b.y(), a.s() * b.z())
}
#[doc = "Geometric product: Trivector * Bivector -> Vector"]
#[inline]
pub fn geometric_trivector_bivector<T: Float>(a: &Trivector<T>, b: &Bivector<T>) -> Vector<T> {
    Vector::new(-(a.xyz() * b.yz()), a.xyz() * b.xz(), -(a.xyz() * b.xy()))
}
#[doc = "Geometric product: Trivector * Scalar -> Trivector"]
#[inline]
pub fn geometric_trivector_scalar<T: Float>(a: &Trivector<T>, b: &Scalar<T>) -> Trivector<T> {
    Trivector::new(a.xyz() * b.s())
}
#[doc = "Geometric product: Trivector * Trivector -> Scalar"]
#[inline]
pub fn geometric_trivector_trivector<T: Float>(a: &Trivector<T>, b: &Trivector<T>) -> Scalar<T> {
    Scalar::new(-(a.xyz() * b.xyz()))
}
#[doc = "Geometric product: Trivector * Vector -> Bivector"]
#[inline]
pub fn geometric_trivector_vector<T: Float>(a: &Trivector<T>, b: &Vector<T>) -> Bivector<T> {
    Bivector::new(a.xyz() * b.z(), -(a.xyz() * b.y()), a.xyz() * b.x())
}
#[doc = "Geometric product: Vector * Scalar -> Vector"]
#[inline]
pub fn geometric_vector_scalar<T: Float>(a: &Vector<T>, b: &Scalar<T>) -> Vector<T> {
    Vector::new(a.x() * b.s(), a.y() * b.s(), a.z() * b.s())
}
#[doc = "Geometric product: Vector * Trivector -> Bivector"]
#[inline]
pub fn geometric_vector_trivector<T: Float>(a: &Vector<T>, b: &Trivector<T>) -> Bivector<T> {
    Bivector::new(a.z() * b.xyz(), -(a.y() * b.xyz()), a.x() * b.xyz())
}
#[doc = "Geometric product: Vector * Vector -> Rotor"]
#[inline]
pub fn geometric_vector_vector<T: Float>(a: &Vector<T>, b: &Vector<T>) -> Rotor<T> {
    Rotor::new(
        a.x() * b.x() + a.y() * b.y() + a.z() * b.z(),
        a.x() * b.y() - a.y() * b.x(),
        a.x() * b.z() - a.z() * b.x(),
        a.y() * b.z() - a.z() * b.y(),
    )
}
#[doc = "Outer product: Bivector ^ Rotor -> Bivector"]
#[inline]
pub fn outer_bivector_rotor<T: Float>(a: &Bivector<T>, b: &Rotor<T>) -> Bivector<T> {
    Bivector::new(a.xy() * b.s(), a.xz() * b.s(), a.yz() * b.s())
}
#[doc = "Outer product: Bivector ^ Scalar -> Bivector"]
#[inline]
pub fn outer_bivector_scalar<T: Float>(a: &Bivector<T>, b: &Scalar<T>) -> Bivector<T> {
    Bivector::new(a.xy() * b.s(), a.xz() * b.s(), a.yz() * b.s())
}
#[doc = "Outer product: Bivector ^ Vector -> Trivector"]
#[inline]
pub fn outer_bivector_vector<T: Float>(a: &Bivector<T>, b: &Vector<T>) -> Trivector<T> {
    Trivector::new(a.xy() * b.z() - a.xz() * b.y() + a.yz() * b.x())
}
#[doc = "Outer product: Rotor ^ Bivector -> Bivector"]
#[inline]
pub fn outer_rotor_bivector<T: Float>(a: &Rotor<T>, b: &Bivector<T>) -> Bivector<T> {
    Bivector::new(a.s() * b.xy(), a.s() * b.xz(), a.s() * b.yz())
}
#[doc = "Outer product: Rotor ^ Rotor -> Rotor"]
#[inline]
pub fn outer_rotor_rotor<T: Float>(a: &Rotor<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(
        a.s() * b.s(),
        a.s() * b.xy() + a.xy() * b.s(),
        a.s() * b.xz() + a.xz() * b.s(),
        a.s() * b.yz() + a.yz() * b.s(),
    )
}
#[doc = "Outer product: Rotor ^ Scalar -> Rotor"]
#[inline]
pub fn outer_rotor_scalar<T: Float>(a: &Rotor<T>, b: &Scalar<T>) -> Rotor<T> {
    Rotor::new(
        a.s() * b.s(),
        a.xy() * b.s(),
        a.xz() * b.s(),
        a.yz() * b.s(),
    )
}
#[doc = "Outer product: Rotor ^ Trivector -> Trivector"]
#[inline]
pub fn outer_rotor_trivector<T: Float>(a: &Rotor<T>, b: &Trivector<T>) -> Trivector<T> {
    Trivector::new(a.s() * b.xyz())
}
#[doc = "Outer product: Scalar ^ Bivector -> Bivector"]
#[inline]
pub fn outer_scalar_bivector<T: Float>(a: &Scalar<T>, b: &Bivector<T>) -> Bivector<T> {
    Bivector::new(a.s() * b.xy(), a.s() * b.xz(), a.s() * b.yz())
}
#[doc = "Outer product: Scalar ^ Rotor -> Rotor"]
#[inline]
pub fn outer_scalar_rotor<T: Float>(a: &Scalar<T>, b: &Rotor<T>) -> Rotor<T> {
    Rotor::new(
        a.s() * b.s(),
        a.s() * b.xy(),
        a.s() * b.xz(),
        a.s() * b.yz(),
    )
}
#[doc = "Outer product: Scalar ^ Scalar -> Scalar"]
#[inline]
pub fn outer_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.s())
}
#[doc = "Outer product: Scalar ^ Trivector -> Trivector"]
#[inline]
pub fn outer_scalar_trivector<T: Float>(a: &Scalar<T>, b: &Trivector<T>) -> Trivector<T> {
    Trivector::new(a.s() * b.xyz())
}
#[doc = "Outer product: Scalar ^ Vector -> Vector"]
#[inline]
pub fn outer_scalar_vector<T: Float>(a: &Scalar<T>, b: &Vector<T>) -> Vector<T> {
    Vector::new(a.s() * b.x(), a.s() * b.y(), a.s() * b.z())
}
#[doc = "Outer product: Trivector ^ Rotor -> Trivector"]
#[inline]
pub fn outer_trivector_rotor<T: Float>(a: &Trivector<T>, b: &Rotor<T>) -> Trivector<T> {
    Trivector::new(a.xyz() * b.s())
}
#[doc = "Outer product: Trivector ^ Scalar -> Trivector"]
#[inline]
pub fn outer_trivector_scalar<T: Float>(a: &Trivector<T>, b: &Scalar<T>) -> Trivector<T> {
    Trivector::new(a.xyz() * b.s())
}
#[doc = "Outer product: Vector ^ Bivector -> Trivector"]
#[inline]
pub fn outer_vector_bivector<T: Float>(a: &Vector<T>, b: &Bivector<T>) -> Trivector<T> {
    Trivector::new(a.x() * b.yz() - a.y() * b.xz() + a.z() * b.xy())
}
#[doc = "Outer product: Vector ^ Scalar -> Vector"]
#[inline]
pub fn outer_vector_scalar<T: Float>(a: &Vector<T>, b: &Scalar<T>) -> Vector<T> {
    Vector::new(a.x() * b.s(), a.y() * b.s(), a.z() * b.s())
}
#[doc = "Outer product: Vector ^ Vector -> Bivector"]
#[inline]
pub fn outer_vector_vector<T: Float>(a: &Vector<T>, b: &Vector<T>) -> Bivector<T> {
    Bivector::new(
        a.x() * b.y() - a.y() * b.x(),
        a.x() * b.z() - a.z() * b.x(),
        a.y() * b.z() - a.z() * b.y(),
    )
}
