#![doc = " Trait implementations for euclidean3."]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
use super::products::*;
use super::types::{Bivector, Rotor, Scalar, Trivector, Vector};
use crate::ops::{
    Antigeometric, Antireverse, Antisandwich, Antiwedge, BulkContract, BulkExpand,
    GeometricProduct, Inner, LeftContract, Reverse, RightComplement, RightContract, Sandwich,
    ScalarProduct, Wedge, WeightContract, WeightExpand,
};
use crate::scalar::Float;
use approx::{AbsDiffEq, RelativeEq, UlpsEq};
use std::ops::{Add, BitXor, Mul, Neg, Sub};
impl<T: Float> Add for Bivector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new(
            self.xy() + rhs.xy(),
            self.xz() + rhs.xz(),
            self.yz() + rhs.yz(),
        )
    }
}
impl<T: Float> Sub for Bivector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new(
            self.xy() - rhs.xy(),
            self.xz() - rhs.xz(),
            self.yz() - rhs.yz(),
        )
    }
}
impl<T: Float> Neg for Bivector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new(-self.xy(), -self.xz(), -self.yz())
    }
}
impl<T: Float> Mul<T> for Bivector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Bivector<f32>> for f32 {
    type Output = Bivector<f32>;
    #[inline]
    fn mul(self, v: Bivector<f32>) -> Bivector<f32> {
        v.scale(self)
    }
}
impl Mul<Bivector<f64>> for f64 {
    type Output = Bivector<f64>;
    #[inline]
    fn mul(self, v: Bivector<f64>) -> Bivector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Bivector<T> {
    type Output = Rotor<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Rotor<T> {
        geometric_bivector_bivector(&self, &rhs)
    }
}
impl<T: Float> Mul<Rotor<T>> for Bivector<T> {
    type Output = Rotor<T>;
    #[inline]
    fn mul(self, rhs: Rotor<T>) -> Rotor<T> {
        geometric_bivector_rotor(&self, &rhs)
    }
}
impl<T: Float> Mul<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Bivector<T> {
        geometric_bivector_scalar(&self, &rhs)
    }
}
impl<T: Float> Mul<Trivector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Trivector<T>) -> Vector<T> {
        geometric_bivector_trivector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Rotor<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bitxor(self, rhs: Rotor<T>) -> Bivector<T> {
        exterior_bivector_rotor(&self, &rhs)
    }
}
impl<T: Float> BitXor<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bitxor(self, rhs: Scalar<T>) -> Bivector<T> {
        exterior_bivector_scalar(&self, &rhs)
    }
}
impl<T: Float> BitXor<Vector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Vector<T>) -> Trivector<T> {
        exterior_bivector_vector(&self, &rhs)
    }
}
impl<T: Float> Add for Rotor<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new(
            self.s() + rhs.s(),
            self.xy() + rhs.xy(),
            self.xz() + rhs.xz(),
            self.yz() + rhs.yz(),
        )
    }
}
impl<T: Float> Sub for Rotor<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new(
            self.s() - rhs.s(),
            self.xy() - rhs.xy(),
            self.xz() - rhs.xz(),
            self.yz() - rhs.yz(),
        )
    }
}
impl<T: Float> Neg for Rotor<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new(-self.s(), -self.xy(), -self.xz(), -self.yz())
    }
}
impl<T: Float> Mul<T> for Rotor<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Rotor<f32>> for f32 {
    type Output = Rotor<f32>;
    #[inline]
    fn mul(self, v: Rotor<f32>) -> Rotor<f32> {
        v.scale(self)
    }
}
impl Mul<Rotor<f64>> for f64 {
    type Output = Rotor<f64>;
    #[inline]
    fn mul(self, v: Rotor<f64>) -> Rotor<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Rotor<T> {
        geometric_rotor_bivector(&self, &rhs)
    }
}
impl<T: Float> Mul<Rotor<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn mul(self, rhs: Rotor<T>) -> Rotor<T> {
        geometric_rotor_rotor(&self, &rhs)
    }
}
impl<T: Float> Mul<Scalar<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Rotor<T> {
        geometric_rotor_scalar(&self, &rhs)
    }
}
impl<T: Float> BitXor<Bivector<T>> for Rotor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bitxor(self, rhs: Bivector<T>) -> Bivector<T> {
        exterior_rotor_bivector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Rotor<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn bitxor(self, rhs: Rotor<T>) -> Rotor<T> {
        exterior_rotor_rotor(&self, &rhs)
    }
}
impl<T: Float> BitXor<Scalar<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn bitxor(self, rhs: Scalar<T>) -> Rotor<T> {
        exterior_rotor_scalar(&self, &rhs)
    }
}
impl<T: Float> BitXor<Trivector<T>> for Rotor<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Trivector<T>) -> Trivector<T> {
        exterior_rotor_trivector(&self, &rhs)
    }
}
impl<T: Float> Add for Scalar<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new(self.s() + rhs.s())
    }
}
impl<T: Float> Sub for Scalar<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new(self.s() - rhs.s())
    }
}
impl<T: Float> Neg for Scalar<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new(-self.s())
    }
}
impl<T: Float> Mul<T> for Scalar<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Scalar<f32>> for f32 {
    type Output = Scalar<f32>;
    #[inline]
    fn mul(self, v: Scalar<f32>) -> Scalar<f32> {
        v.scale(self)
    }
}
impl Mul<Scalar<f64>> for f64 {
    type Output = Scalar<f64>;
    #[inline]
    fn mul(self, v: Scalar<f64>) -> Scalar<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Bivector<T> {
        geometric_scalar_bivector(&self, &rhs)
    }
}
impl<T: Float> Mul<Rotor<T>> for Scalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn mul(self, rhs: Rotor<T>) -> Rotor<T> {
        geometric_scalar_rotor(&self, &rhs)
    }
}
impl<T: Float> Mul<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Scalar<T> {
        geometric_scalar_scalar(&self, &rhs)
    }
}
impl<T: Float> Mul<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn mul(self, rhs: Trivector<T>) -> Trivector<T> {
        geometric_scalar_trivector(&self, &rhs)
    }
}
impl<T: Float> Mul<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Vector<T>) -> Vector<T> {
        geometric_scalar_vector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bitxor(self, rhs: Bivector<T>) -> Bivector<T> {
        exterior_scalar_bivector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Rotor<T>> for Scalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn bitxor(self, rhs: Rotor<T>) -> Rotor<T> {
        exterior_scalar_rotor(&self, &rhs)
    }
}
impl<T: Float> BitXor<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bitxor(self, rhs: Scalar<T>) -> Scalar<T> {
        exterior_scalar_scalar(&self, &rhs)
    }
}
impl<T: Float> BitXor<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Trivector<T>) -> Trivector<T> {
        exterior_scalar_trivector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn bitxor(self, rhs: Vector<T>) -> Vector<T> {
        exterior_scalar_vector(&self, &rhs)
    }
}
impl<T: Float> Add for Trivector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new(self.xyz() + rhs.xyz())
    }
}
impl<T: Float> Sub for Trivector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new(self.xyz() - rhs.xyz())
    }
}
impl<T: Float> Neg for Trivector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new(-self.xyz())
    }
}
impl<T: Float> Mul<T> for Trivector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Trivector<f32>> for f32 {
    type Output = Trivector<f32>;
    #[inline]
    fn mul(self, v: Trivector<f32>) -> Trivector<f32> {
        v.scale(self)
    }
}
impl Mul<Trivector<f64>> for f64 {
    type Output = Trivector<f64>;
    #[inline]
    fn mul(self, v: Trivector<f64>) -> Trivector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Vector<T> {
        geometric_trivector_bivector(&self, &rhs)
    }
}
impl<T: Float> Mul<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Trivector<T> {
        geometric_trivector_scalar(&self, &rhs)
    }
}
impl<T: Float> Mul<Trivector<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn mul(self, rhs: Trivector<T>) -> Scalar<T> {
        geometric_trivector_trivector(&self, &rhs)
    }
}
impl<T: Float> Mul<Vector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn mul(self, rhs: Vector<T>) -> Bivector<T> {
        geometric_trivector_vector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Rotor<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Rotor<T>) -> Trivector<T> {
        exterior_trivector_rotor(&self, &rhs)
    }
}
impl<T: Float> BitXor<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Scalar<T>) -> Trivector<T> {
        exterior_trivector_scalar(&self, &rhs)
    }
}
impl<T: Float> Add for Vector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new(self.x() + rhs.x(), self.y() + rhs.y(), self.z() + rhs.z())
    }
}
impl<T: Float> Sub for Vector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new(self.x() - rhs.x(), self.y() - rhs.y(), self.z() - rhs.z())
    }
}
impl<T: Float> Neg for Vector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new(-self.x(), -self.y(), -self.z())
    }
}
impl<T: Float> Mul<T> for Vector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Vector<f32>> for f32 {
    type Output = Vector<f32>;
    #[inline]
    fn mul(self, v: Vector<f32>) -> Vector<f32> {
        v.scale(self)
    }
}
impl Mul<Vector<f64>> for f64 {
    type Output = Vector<f64>;
    #[inline]
    fn mul(self, v: Vector<f64>) -> Vector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Vector<T> {
        geometric_vector_scalar(&self, &rhs)
    }
}
impl<T: Float> Mul<Trivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn mul(self, rhs: Trivector<T>) -> Bivector<T> {
        geometric_vector_trivector(&self, &rhs)
    }
}
impl<T: Float> Mul<Vector<T>> for Vector<T> {
    type Output = Rotor<T>;
    #[inline]
    fn mul(self, rhs: Vector<T>) -> Rotor<T> {
        geometric_vector_vector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Bivector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Bivector<T>) -> Trivector<T> {
        exterior_vector_bivector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bitxor(self, rhs: Scalar<T>) -> Vector<T> {
        exterior_vector_scalar(&self, &rhs)
    }
}
impl<T: Float> BitXor<Vector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bitxor(self, rhs: Vector<T>) -> Bivector<T> {
        exterior_vector_vector(&self, &rhs)
    }
}
impl<T: Float> GeometricProduct<Bivector<T>> for Bivector<T> {
    type Output = Rotor<T>;
    #[inline]
    fn geometric(&self, rhs: &Bivector<T>) -> Rotor<T> {
        geometric_bivector_bivector(self, rhs)
    }
}
impl<T: Float> GeometricProduct<Rotor<T>> for Bivector<T> {
    type Output = Rotor<T>;
    #[inline]
    fn geometric(&self, rhs: &Rotor<T>) -> Rotor<T> {
        geometric_bivector_rotor(self, rhs)
    }
}
impl<T: Float> GeometricProduct<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn geometric(&self, rhs: &Scalar<T>) -> Bivector<T> {
        geometric_bivector_scalar(self, rhs)
    }
}
impl<T: Float> GeometricProduct<Trivector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn geometric(&self, rhs: &Trivector<T>) -> Vector<T> {
        geometric_bivector_trivector(self, rhs)
    }
}
impl<T: Float> GeometricProduct<Bivector<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn geometric(&self, rhs: &Bivector<T>) -> Rotor<T> {
        geometric_rotor_bivector(self, rhs)
    }
}
impl<T: Float> GeometricProduct<Rotor<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn geometric(&self, rhs: &Rotor<T>) -> Rotor<T> {
        geometric_rotor_rotor(self, rhs)
    }
}
impl<T: Float> GeometricProduct<Scalar<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn geometric(&self, rhs: &Scalar<T>) -> Rotor<T> {
        geometric_rotor_scalar(self, rhs)
    }
}
impl<T: Float> GeometricProduct<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn geometric(&self, rhs: &Bivector<T>) -> Bivector<T> {
        geometric_scalar_bivector(self, rhs)
    }
}
impl<T: Float> GeometricProduct<Rotor<T>> for Scalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn geometric(&self, rhs: &Rotor<T>) -> Rotor<T> {
        geometric_scalar_rotor(self, rhs)
    }
}
impl<T: Float> GeometricProduct<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn geometric(&self, rhs: &Scalar<T>) -> Scalar<T> {
        geometric_scalar_scalar(self, rhs)
    }
}
impl<T: Float> GeometricProduct<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn geometric(&self, rhs: &Trivector<T>) -> Trivector<T> {
        geometric_scalar_trivector(self, rhs)
    }
}
impl<T: Float> GeometricProduct<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn geometric(&self, rhs: &Vector<T>) -> Vector<T> {
        geometric_scalar_vector(self, rhs)
    }
}
impl<T: Float> GeometricProduct<Bivector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn geometric(&self, rhs: &Bivector<T>) -> Vector<T> {
        geometric_trivector_bivector(self, rhs)
    }
}
impl<T: Float> GeometricProduct<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn geometric(&self, rhs: &Scalar<T>) -> Trivector<T> {
        geometric_trivector_scalar(self, rhs)
    }
}
impl<T: Float> GeometricProduct<Trivector<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn geometric(&self, rhs: &Trivector<T>) -> Scalar<T> {
        geometric_trivector_trivector(self, rhs)
    }
}
impl<T: Float> GeometricProduct<Vector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn geometric(&self, rhs: &Vector<T>) -> Bivector<T> {
        geometric_trivector_vector(self, rhs)
    }
}
impl<T: Float> GeometricProduct<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn geometric(&self, rhs: &Scalar<T>) -> Vector<T> {
        geometric_vector_scalar(self, rhs)
    }
}
impl<T: Float> GeometricProduct<Trivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn geometric(&self, rhs: &Trivector<T>) -> Bivector<T> {
        geometric_vector_trivector(self, rhs)
    }
}
impl<T: Float> GeometricProduct<Vector<T>> for Vector<T> {
    type Output = Rotor<T>;
    #[inline]
    fn geometric(&self, rhs: &Vector<T>) -> Rotor<T> {
        geometric_vector_vector(self, rhs)
    }
}
impl<T: Float> Wedge<Rotor<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Rotor<T>) -> Bivector<T> {
        exterior_bivector_rotor(self, rhs)
    }
}
impl<T: Float> Wedge<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Bivector<T> {
        exterior_bivector_scalar(self, rhs)
    }
}
impl<T: Float> Wedge<Vector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Trivector<T> {
        exterior_bivector_vector(self, rhs)
    }
}
impl<T: Float> Wedge<Bivector<T>> for Rotor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Bivector<T>) -> Bivector<T> {
        exterior_rotor_bivector(self, rhs)
    }
}
impl<T: Float> Wedge<Rotor<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn wedge(&self, rhs: &Rotor<T>) -> Rotor<T> {
        exterior_rotor_rotor(self, rhs)
    }
}
impl<T: Float> Wedge<Scalar<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Rotor<T> {
        exterior_rotor_scalar(self, rhs)
    }
}
impl<T: Float> Wedge<Trivector<T>> for Rotor<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Trivector<T>) -> Trivector<T> {
        exterior_rotor_trivector(self, rhs)
    }
}
impl<T: Float> Wedge<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Bivector<T>) -> Bivector<T> {
        exterior_scalar_bivector(self, rhs)
    }
}
impl<T: Float> Wedge<Rotor<T>> for Scalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn wedge(&self, rhs: &Rotor<T>) -> Rotor<T> {
        exterior_scalar_rotor(self, rhs)
    }
}
impl<T: Float> Wedge<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        exterior_scalar_scalar(self, rhs)
    }
}
impl<T: Float> Wedge<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Trivector<T>) -> Trivector<T> {
        exterior_scalar_trivector(self, rhs)
    }
}
impl<T: Float> Wedge<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Vector<T> {
        exterior_scalar_vector(self, rhs)
    }
}
impl<T: Float> Wedge<Rotor<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Rotor<T>) -> Trivector<T> {
        exterior_trivector_rotor(self, rhs)
    }
}
impl<T: Float> Wedge<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Trivector<T> {
        exterior_trivector_scalar(self, rhs)
    }
}
impl<T: Float> Wedge<Bivector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Bivector<T>) -> Trivector<T> {
        exterior_vector_bivector(self, rhs)
    }
}
impl<T: Float> Wedge<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Vector<T> {
        exterior_vector_scalar(self, rhs)
    }
}
impl<T: Float> Wedge<Vector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Bivector<T> {
        exterior_vector_vector(self, rhs)
    }
}
impl<T: Float> Antiwedge<Bivector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Vector<T> {
        regressive_bivector_bivector(self, rhs)
    }
}
impl<T: Float> Antiwedge<Rotor<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Rotor<T>) -> Vector<T> {
        regressive_bivector_rotor(self, rhs)
    }
}
impl<T: Float> Antiwedge<Trivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Bivector<T> {
        regressive_bivector_trivector(self, rhs)
    }
}
impl<T: Float> Antiwedge<Vector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Vector<T>) -> Scalar<T> {
        regressive_bivector_vector(self, rhs)
    }
}
impl<T: Float> Antiwedge<Bivector<T>> for Rotor<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Vector<T> {
        regressive_rotor_bivector(self, rhs)
    }
}
impl<T: Float> Antiwedge<Rotor<T>> for Rotor<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Rotor<T>) -> Vector<T> {
        regressive_rotor_rotor(self, rhs)
    }
}
impl<T: Float> Antiwedge<Trivector<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Rotor<T> {
        regressive_rotor_trivector(self, rhs)
    }
}
impl<T: Float> Antiwedge<Vector<T>> for Rotor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Vector<T>) -> Scalar<T> {
        regressive_rotor_vector(self, rhs)
    }
}
impl<T: Float> Antiwedge<Trivector<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Scalar<T> {
        regressive_scalar_trivector(self, rhs)
    }
}
impl<T: Float> Antiwedge<Bivector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Bivector<T> {
        regressive_trivector_bivector(self, rhs)
    }
}
impl<T: Float> Antiwedge<Rotor<T>> for Trivector<T> {
    type Output = Rotor<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Rotor<T>) -> Rotor<T> {
        regressive_trivector_rotor(self, rhs)
    }
}
impl<T: Float> Antiwedge<Scalar<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        regressive_trivector_scalar(self, rhs)
    }
}
impl<T: Float> Antiwedge<Trivector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Trivector<T> {
        regressive_trivector_trivector(self, rhs)
    }
}
impl<T: Float> Antiwedge<Vector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Vector<T>) -> Vector<T> {
        regressive_trivector_vector(self, rhs)
    }
}
impl<T: Float> Antiwedge<Bivector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Scalar<T> {
        regressive_vector_bivector(self, rhs)
    }
}
impl<T: Float> Antiwedge<Rotor<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Rotor<T>) -> Scalar<T> {
        regressive_vector_rotor(self, rhs)
    }
}
impl<T: Float> Antiwedge<Trivector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Vector<T> {
        regressive_vector_trivector(self, rhs)
    }
}
impl<T: Float> Inner<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn inner(&self, rhs: &Bivector<T>) -> Scalar<T> {
        interior_bivector_bivector(self, rhs)
    }
}
impl<T: Float> Inner<Rotor<T>> for Bivector<T> {
    type Output = Rotor<T>;
    #[inline]
    fn inner(&self, rhs: &Rotor<T>) -> Rotor<T> {
        interior_bivector_rotor(self, rhs)
    }
}
impl<T: Float> Inner<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn inner(&self, rhs: &Scalar<T>) -> Bivector<T> {
        interior_bivector_scalar(self, rhs)
    }
}
impl<T: Float> Inner<Trivector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn inner(&self, rhs: &Trivector<T>) -> Vector<T> {
        interior_bivector_trivector(self, rhs)
    }
}
impl<T: Float> Inner<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn inner(&self, rhs: &Vector<T>) -> Vector<T> {
        interior_bivector_vector(self, rhs)
    }
}
impl<T: Float> Inner<Bivector<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn inner(&self, rhs: &Bivector<T>) -> Rotor<T> {
        interior_rotor_bivector(self, rhs)
    }
}
impl<T: Float> Inner<Rotor<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn inner(&self, rhs: &Rotor<T>) -> Rotor<T> {
        interior_rotor_rotor(self, rhs)
    }
}
impl<T: Float> Inner<Scalar<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn inner(&self, rhs: &Scalar<T>) -> Rotor<T> {
        interior_rotor_scalar(self, rhs)
    }
}
impl<T: Float> Inner<Vector<T>> for Rotor<T> {
    type Output = Vector<T>;
    #[inline]
    fn inner(&self, rhs: &Vector<T>) -> Vector<T> {
        interior_rotor_vector(self, rhs)
    }
}
impl<T: Float> Inner<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn inner(&self, rhs: &Bivector<T>) -> Bivector<T> {
        interior_scalar_bivector(self, rhs)
    }
}
impl<T: Float> Inner<Rotor<T>> for Scalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn inner(&self, rhs: &Rotor<T>) -> Rotor<T> {
        interior_scalar_rotor(self, rhs)
    }
}
impl<T: Float> Inner<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn inner(&self, rhs: &Scalar<T>) -> Scalar<T> {
        interior_scalar_scalar(self, rhs)
    }
}
impl<T: Float> Inner<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn inner(&self, rhs: &Trivector<T>) -> Trivector<T> {
        interior_scalar_trivector(self, rhs)
    }
}
impl<T: Float> Inner<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn inner(&self, rhs: &Vector<T>) -> Vector<T> {
        interior_scalar_vector(self, rhs)
    }
}
impl<T: Float> Inner<Bivector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn inner(&self, rhs: &Bivector<T>) -> Vector<T> {
        interior_trivector_bivector(self, rhs)
    }
}
impl<T: Float> Inner<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn inner(&self, rhs: &Scalar<T>) -> Trivector<T> {
        interior_trivector_scalar(self, rhs)
    }
}
impl<T: Float> Inner<Trivector<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn inner(&self, rhs: &Trivector<T>) -> Scalar<T> {
        interior_trivector_trivector(self, rhs)
    }
}
impl<T: Float> Inner<Vector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn inner(&self, rhs: &Vector<T>) -> Bivector<T> {
        interior_trivector_vector(self, rhs)
    }
}
impl<T: Float> Inner<Bivector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn inner(&self, rhs: &Bivector<T>) -> Vector<T> {
        interior_vector_bivector(self, rhs)
    }
}
impl<T: Float> Inner<Rotor<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn inner(&self, rhs: &Rotor<T>) -> Vector<T> {
        interior_vector_rotor(self, rhs)
    }
}
impl<T: Float> Inner<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn inner(&self, rhs: &Scalar<T>) -> Vector<T> {
        interior_vector_scalar(self, rhs)
    }
}
impl<T: Float> Inner<Trivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn inner(&self, rhs: &Trivector<T>) -> Bivector<T> {
        interior_vector_trivector(self, rhs)
    }
}
impl<T: Float> Inner<Vector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn inner(&self, rhs: &Vector<T>) -> Scalar<T> {
        interior_vector_vector(self, rhs)
    }
}
impl<T: Float> LeftContract<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        left_contract_bivector_bivector(self, rhs)
    }
}
impl<T: Float> LeftContract<Rotor<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Rotor<T>) -> Scalar<T> {
        left_contract_bivector_rotor(self, rhs)
    }
}
impl<T: Float> LeftContract<Trivector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Trivector<T>) -> Vector<T> {
        left_contract_bivector_trivector(self, rhs)
    }
}
impl<T: Float> LeftContract<Bivector<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Rotor<T> {
        left_contract_rotor_bivector(self, rhs)
    }
}
impl<T: Float> LeftContract<Rotor<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn left_contract(&self, rhs: &Rotor<T>) -> Rotor<T> {
        left_contract_rotor_rotor(self, rhs)
    }
}
impl<T: Float> LeftContract<Scalar<T>> for Rotor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        left_contract_rotor_scalar(self, rhs)
    }
}
impl<T: Float> LeftContract<Vector<T>> for Rotor<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        left_contract_rotor_vector(self, rhs)
    }
}
impl<T: Float> LeftContract<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Bivector<T> {
        left_contract_scalar_bivector(self, rhs)
    }
}
impl<T: Float> LeftContract<Rotor<T>> for Scalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn left_contract(&self, rhs: &Rotor<T>) -> Rotor<T> {
        left_contract_scalar_rotor(self, rhs)
    }
}
impl<T: Float> LeftContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        left_contract_scalar_scalar(self, rhs)
    }
}
impl<T: Float> LeftContract<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Trivector<T>) -> Trivector<T> {
        left_contract_scalar_trivector(self, rhs)
    }
}
impl<T: Float> LeftContract<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        left_contract_scalar_vector(self, rhs)
    }
}
impl<T: Float> LeftContract<Trivector<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Trivector<T>) -> Scalar<T> {
        left_contract_trivector_trivector(self, rhs)
    }
}
impl<T: Float> LeftContract<Bivector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        left_contract_vector_bivector(self, rhs)
    }
}
impl<T: Float> LeftContract<Rotor<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Rotor<T>) -> Vector<T> {
        left_contract_vector_rotor(self, rhs)
    }
}
impl<T: Float> LeftContract<Trivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Trivector<T>) -> Bivector<T> {
        left_contract_vector_trivector(self, rhs)
    }
}
impl<T: Float> LeftContract<Vector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        left_contract_vector_vector(self, rhs)
    }
}
impl<T: Float> RightContract<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        right_contract_bivector_bivector(self, rhs)
    }
}
impl<T: Float> RightContract<Rotor<T>> for Bivector<T> {
    type Output = Rotor<T>;
    #[inline]
    fn right_contract(&self, rhs: &Rotor<T>) -> Rotor<T> {
        right_contract_bivector_rotor(self, rhs)
    }
}
impl<T: Float> RightContract<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Bivector<T> {
        right_contract_bivector_scalar(self, rhs)
    }
}
impl<T: Float> RightContract<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        right_contract_bivector_vector(self, rhs)
    }
}
impl<T: Float> RightContract<Bivector<T>> for Rotor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        right_contract_rotor_bivector(self, rhs)
    }
}
impl<T: Float> RightContract<Rotor<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn right_contract(&self, rhs: &Rotor<T>) -> Rotor<T> {
        right_contract_rotor_rotor(self, rhs)
    }
}
impl<T: Float> RightContract<Scalar<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Rotor<T> {
        right_contract_rotor_scalar(self, rhs)
    }
}
impl<T: Float> RightContract<Vector<T>> for Rotor<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        right_contract_rotor_vector(self, rhs)
    }
}
impl<T: Float> RightContract<Rotor<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Rotor<T>) -> Scalar<T> {
        right_contract_scalar_rotor(self, rhs)
    }
}
impl<T: Float> RightContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        right_contract_scalar_scalar(self, rhs)
    }
}
impl<T: Float> RightContract<Bivector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        right_contract_trivector_bivector(self, rhs)
    }
}
impl<T: Float> RightContract<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Trivector<T> {
        right_contract_trivector_scalar(self, rhs)
    }
}
impl<T: Float> RightContract<Trivector<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Trivector<T>) -> Scalar<T> {
        right_contract_trivector_trivector(self, rhs)
    }
}
impl<T: Float> RightContract<Vector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Bivector<T> {
        right_contract_trivector_vector(self, rhs)
    }
}
impl<T: Float> RightContract<Rotor<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Rotor<T>) -> Vector<T> {
        right_contract_vector_rotor(self, rhs)
    }
}
impl<T: Float> RightContract<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Vector<T> {
        right_contract_vector_scalar(self, rhs)
    }
}
impl<T: Float> RightContract<Vector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        right_contract_vector_vector(self, rhs)
    }
}
impl<T: Float> Sandwich<Vector<T>> for Rotor<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        sandwich_rotor_vector(self, operand)
    }
}
impl<T: Float> Sandwich<Bivector<T>> for Rotor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        sandwich_rotor_bivector(self, operand)
    }
}
impl<T: Float> Sandwich<Rotor<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        sandwich_rotor_rotor(self, operand)
    }
}
impl<T: Float> Antisandwich<Vector<T>> for Rotor<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        antisandwich_rotor_vector(self, operand)
    }
}
impl<T: Float> Antisandwich<Bivector<T>> for Rotor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        antisandwich_rotor_bivector(self, operand)
    }
}
impl<T: Float> Antisandwich<Rotor<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        antisandwich_rotor_rotor(self, operand)
    }
}
impl<T: Float> ScalarProduct<Bivector<T>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Bivector<T>) -> T {
        scalar_bivector_bivector(self, rhs)
    }
}
impl<T: Float> ScalarProduct<Rotor<T>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Rotor<T>) -> T {
        scalar_bivector_rotor(self, rhs)
    }
}
impl<T: Float> ScalarProduct<Bivector<T>> for Rotor<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Bivector<T>) -> T {
        scalar_rotor_bivector(self, rhs)
    }
}
impl<T: Float> ScalarProduct<Rotor<T>> for Rotor<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Rotor<T>) -> T {
        scalar_rotor_rotor(self, rhs)
    }
}
impl<T: Float> ScalarProduct<Scalar<T>> for Rotor<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Scalar<T>) -> T {
        scalar_rotor_scalar(self, rhs)
    }
}
impl<T: Float> ScalarProduct<Rotor<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Rotor<T>) -> T {
        scalar_scalar_rotor(self, rhs)
    }
}
impl<T: Float> ScalarProduct<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Scalar<T>) -> T {
        scalar_scalar_scalar(self, rhs)
    }
}
impl<T: Float> ScalarProduct<Trivector<T>> for Trivector<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Trivector<T>) -> T {
        scalar_trivector_trivector(self, rhs)
    }
}
impl<T: Float> ScalarProduct<Vector<T>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Vector<T>) -> T {
        scalar_vector_vector(self, rhs)
    }
}
impl<T: Float> BulkContract<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        bulk_contraction_bivector_bivector(self, rhs)
    }
}
impl<T: Float> BulkContract<Rotor<T>> for Bivector<T> {
    type Output = Rotor<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Rotor<T>) -> Rotor<T> {
        bulk_contraction_bivector_rotor(self, rhs)
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Bivector<T> {
        bulk_contraction_bivector_scalar(self, rhs)
    }
}
impl<T: Float> BulkContract<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        bulk_contraction_bivector_vector(self, rhs)
    }
}
impl<T: Float> BulkContract<Bivector<T>> for Rotor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        bulk_contraction_rotor_bivector(self, rhs)
    }
}
impl<T: Float> BulkContract<Rotor<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Rotor<T>) -> Rotor<T> {
        bulk_contraction_rotor_rotor(self, rhs)
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Rotor<T> {
        bulk_contraction_rotor_scalar(self, rhs)
    }
}
impl<T: Float> BulkContract<Vector<T>> for Rotor<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        bulk_contraction_rotor_vector(self, rhs)
    }
}
impl<T: Float> BulkContract<Rotor<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Rotor<T>) -> Scalar<T> {
        bulk_contraction_scalar_rotor(self, rhs)
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        bulk_contraction_scalar_scalar(self, rhs)
    }
}
impl<T: Float> BulkContract<Bivector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        bulk_contraction_trivector_bivector(self, rhs)
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Trivector<T> {
        bulk_contraction_trivector_scalar(self, rhs)
    }
}
impl<T: Float> BulkContract<Trivector<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Trivector<T>) -> Scalar<T> {
        bulk_contraction_trivector_trivector(self, rhs)
    }
}
impl<T: Float> BulkContract<Vector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Bivector<T> {
        bulk_contraction_trivector_vector(self, rhs)
    }
}
impl<T: Float> BulkContract<Rotor<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Rotor<T>) -> Vector<T> {
        bulk_contraction_vector_rotor(self, rhs)
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Vector<T> {
        bulk_contraction_vector_scalar(self, rhs)
    }
}
impl<T: Float> BulkContract<Vector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        bulk_contraction_vector_vector(self, rhs)
    }
}
impl<T: Float> WeightContract<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        weight_contraction_bivector_bivector(self, rhs)
    }
}
impl<T: Float> WeightContract<Rotor<T>> for Bivector<T> {
    type Output = Rotor<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Rotor<T>) -> Rotor<T> {
        weight_contraction_bivector_rotor(self, rhs)
    }
}
impl<T: Float> WeightContract<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Bivector<T> {
        weight_contraction_bivector_scalar(self, rhs)
    }
}
impl<T: Float> WeightContract<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        weight_contraction_bivector_vector(self, rhs)
    }
}
impl<T: Float> WeightContract<Bivector<T>> for Rotor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        weight_contraction_rotor_bivector(self, rhs)
    }
}
impl<T: Float> WeightContract<Rotor<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Rotor<T>) -> Rotor<T> {
        weight_contraction_rotor_rotor(self, rhs)
    }
}
impl<T: Float> WeightContract<Scalar<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Rotor<T> {
        weight_contraction_rotor_scalar(self, rhs)
    }
}
impl<T: Float> WeightContract<Vector<T>> for Rotor<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        weight_contraction_rotor_vector(self, rhs)
    }
}
impl<T: Float> WeightContract<Rotor<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Rotor<T>) -> Scalar<T> {
        weight_contraction_scalar_rotor(self, rhs)
    }
}
impl<T: Float> WeightContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        weight_contraction_scalar_scalar(self, rhs)
    }
}
impl<T: Float> WeightContract<Bivector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        weight_contraction_trivector_bivector(self, rhs)
    }
}
impl<T: Float> WeightContract<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Trivector<T> {
        weight_contraction_trivector_scalar(self, rhs)
    }
}
impl<T: Float> WeightContract<Trivector<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Trivector<T>) -> Scalar<T> {
        weight_contraction_trivector_trivector(self, rhs)
    }
}
impl<T: Float> WeightContract<Vector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Bivector<T> {
        weight_contraction_trivector_vector(self, rhs)
    }
}
impl<T: Float> WeightContract<Rotor<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Rotor<T>) -> Vector<T> {
        weight_contraction_vector_rotor(self, rhs)
    }
}
impl<T: Float> WeightContract<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Vector<T> {
        weight_contraction_vector_scalar(self, rhs)
    }
}
impl<T: Float> WeightContract<Vector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        weight_contraction_vector_vector(self, rhs)
    }
}
impl<T: Float> BulkExpand<Bivector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Trivector<T> {
        bulk_expansion_bivector_bivector(self, rhs)
    }
}
impl<T: Float> BulkExpand<Rotor<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Rotor<T>) -> Trivector<T> {
        bulk_expansion_bivector_rotor(self, rhs)
    }
}
impl<T: Float> BulkExpand<Trivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Trivector<T>) -> Bivector<T> {
        bulk_expansion_bivector_trivector(self, rhs)
    }
}
impl<T: Float> BulkExpand<Scalar<T>> for Rotor<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Scalar<T>) -> Trivector<T> {
        bulk_expansion_rotor_scalar(self, rhs)
    }
}
impl<T: Float> BulkExpand<Trivector<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Trivector<T>) -> Rotor<T> {
        bulk_expansion_rotor_trivector(self, rhs)
    }
}
impl<T: Float> BulkExpand<Vector<T>> for Rotor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Vector<T>) -> Bivector<T> {
        bulk_expansion_rotor_vector(self, rhs)
    }
}
impl<T: Float> BulkExpand<Bivector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Vector<T> {
        bulk_expansion_scalar_bivector(self, rhs)
    }
}
impl<T: Float> BulkExpand<Scalar<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Scalar<T>) -> Trivector<T> {
        bulk_expansion_scalar_scalar(self, rhs)
    }
}
impl<T: Float> BulkExpand<Trivector<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Trivector<T>) -> Scalar<T> {
        bulk_expansion_scalar_trivector(self, rhs)
    }
}
impl<T: Float> BulkExpand<Vector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Vector<T>) -> Bivector<T> {
        bulk_expansion_scalar_vector(self, rhs)
    }
}
impl<T: Float> BulkExpand<Trivector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Trivector<T>) -> Trivector<T> {
        bulk_expansion_trivector_trivector(self, rhs)
    }
}
impl<T: Float> BulkExpand<Bivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Bivector<T> {
        bulk_expansion_vector_bivector(self, rhs)
    }
}
impl<T: Float> BulkExpand<Rotor<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Rotor<T>) -> Bivector<T> {
        bulk_expansion_vector_rotor(self, rhs)
    }
}
impl<T: Float> BulkExpand<Trivector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Trivector<T>) -> Vector<T> {
        bulk_expansion_vector_trivector(self, rhs)
    }
}
impl<T: Float> BulkExpand<Vector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Vector<T>) -> Trivector<T> {
        bulk_expansion_vector_vector(self, rhs)
    }
}
impl<T: Float> WeightExpand<Bivector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Trivector<T> {
        weight_expansion_bivector_bivector(self, rhs)
    }
}
impl<T: Float> WeightExpand<Rotor<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Rotor<T>) -> Trivector<T> {
        weight_expansion_bivector_rotor(self, rhs)
    }
}
impl<T: Float> WeightExpand<Trivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Bivector<T> {
        weight_expansion_bivector_trivector(self, rhs)
    }
}
impl<T: Float> WeightExpand<Scalar<T>> for Rotor<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Scalar<T>) -> Trivector<T> {
        weight_expansion_rotor_scalar(self, rhs)
    }
}
impl<T: Float> WeightExpand<Trivector<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Rotor<T> {
        weight_expansion_rotor_trivector(self, rhs)
    }
}
impl<T: Float> WeightExpand<Vector<T>> for Rotor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Vector<T>) -> Bivector<T> {
        weight_expansion_rotor_vector(self, rhs)
    }
}
impl<T: Float> WeightExpand<Bivector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Vector<T> {
        weight_expansion_scalar_bivector(self, rhs)
    }
}
impl<T: Float> WeightExpand<Scalar<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Scalar<T>) -> Trivector<T> {
        weight_expansion_scalar_scalar(self, rhs)
    }
}
impl<T: Float> WeightExpand<Trivector<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Scalar<T> {
        weight_expansion_scalar_trivector(self, rhs)
    }
}
impl<T: Float> WeightExpand<Vector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Vector<T>) -> Bivector<T> {
        weight_expansion_scalar_vector(self, rhs)
    }
}
impl<T: Float> WeightExpand<Trivector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Trivector<T> {
        weight_expansion_trivector_trivector(self, rhs)
    }
}
impl<T: Float> WeightExpand<Bivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Bivector<T> {
        weight_expansion_vector_bivector(self, rhs)
    }
}
impl<T: Float> WeightExpand<Rotor<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Rotor<T>) -> Bivector<T> {
        weight_expansion_vector_rotor(self, rhs)
    }
}
impl<T: Float> WeightExpand<Trivector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Vector<T> {
        weight_expansion_vector_trivector(self, rhs)
    }
}
impl<T: Float> WeightExpand<Vector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Vector<T>) -> Trivector<T> {
        weight_expansion_vector_vector(self, rhs)
    }
}
impl<T: Float> Antigeometric<Scalar<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antigeometric(&self, rhs: &Scalar<T>) -> Vector<T> {
        antigeometric_bivector_scalar(self, rhs)
    }
}
impl<T: Float> Antigeometric<Trivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antigeometric(&self, rhs: &Trivector<T>) -> Bivector<T> {
        antigeometric_bivector_trivector(self, rhs)
    }
}
impl<T: Float> Antigeometric<Vector<T>> for Bivector<T> {
    type Output = Rotor<T>;
    #[inline]
    fn antigeometric(&self, rhs: &Vector<T>) -> Rotor<T> {
        antigeometric_bivector_vector(self, rhs)
    }
}
impl<T: Float> Antigeometric<Trivector<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn antigeometric(&self, rhs: &Trivector<T>) -> Rotor<T> {
        antigeometric_rotor_trivector(self, rhs)
    }
}
impl<T: Float> Antigeometric<Vector<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn antigeometric(&self, rhs: &Vector<T>) -> Rotor<T> {
        antigeometric_rotor_vector(self, rhs)
    }
}
impl<T: Float> Antigeometric<Bivector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn antigeometric(&self, rhs: &Bivector<T>) -> Vector<T> {
        antigeometric_scalar_bivector(self, rhs)
    }
}
impl<T: Float> Antigeometric<Scalar<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antigeometric(&self, rhs: &Scalar<T>) -> Trivector<T> {
        antigeometric_scalar_scalar(self, rhs)
    }
}
impl<T: Float> Antigeometric<Trivector<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antigeometric(&self, rhs: &Trivector<T>) -> Scalar<T> {
        antigeometric_scalar_trivector(self, rhs)
    }
}
impl<T: Float> Antigeometric<Vector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antigeometric(&self, rhs: &Vector<T>) -> Bivector<T> {
        antigeometric_scalar_vector(self, rhs)
    }
}
impl<T: Float> Antigeometric<Bivector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antigeometric(&self, rhs: &Bivector<T>) -> Bivector<T> {
        antigeometric_trivector_bivector(self, rhs)
    }
}
impl<T: Float> Antigeometric<Rotor<T>> for Trivector<T> {
    type Output = Rotor<T>;
    #[inline]
    fn antigeometric(&self, rhs: &Rotor<T>) -> Rotor<T> {
        antigeometric_trivector_rotor(self, rhs)
    }
}
impl<T: Float> Antigeometric<Scalar<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antigeometric(&self, rhs: &Scalar<T>) -> Scalar<T> {
        antigeometric_trivector_scalar(self, rhs)
    }
}
impl<T: Float> Antigeometric<Trivector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antigeometric(&self, rhs: &Trivector<T>) -> Trivector<T> {
        antigeometric_trivector_trivector(self, rhs)
    }
}
impl<T: Float> Antigeometric<Vector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antigeometric(&self, rhs: &Vector<T>) -> Vector<T> {
        antigeometric_trivector_vector(self, rhs)
    }
}
impl<T: Float> Antigeometric<Bivector<T>> for Vector<T> {
    type Output = Rotor<T>;
    #[inline]
    fn antigeometric(&self, rhs: &Bivector<T>) -> Rotor<T> {
        antigeometric_vector_bivector(self, rhs)
    }
}
impl<T: Float> Antigeometric<Rotor<T>> for Vector<T> {
    type Output = Rotor<T>;
    #[inline]
    fn antigeometric(&self, rhs: &Rotor<T>) -> Rotor<T> {
        antigeometric_vector_rotor(self, rhs)
    }
}
impl<T: Float> Antigeometric<Scalar<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antigeometric(&self, rhs: &Scalar<T>) -> Bivector<T> {
        antigeometric_vector_scalar(self, rhs)
    }
}
impl<T: Float> Antigeometric<Trivector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antigeometric(&self, rhs: &Trivector<T>) -> Vector<T> {
        antigeometric_vector_trivector(self, rhs)
    }
}
impl<T: Float> Reverse for Bivector<T> {
    #[inline]
    fn reverse(&self) -> Self {
        reverse_bivector(self)
    }
}
impl<T: Float> Reverse for Rotor<T> {
    #[inline]
    fn reverse(&self) -> Self {
        reverse_rotor(self)
    }
}
impl<T: Float> Reverse for Scalar<T> {
    #[inline]
    fn reverse(&self) -> Self {
        reverse_scalar(self)
    }
}
impl<T: Float> Reverse for Trivector<T> {
    #[inline]
    fn reverse(&self) -> Self {
        reverse_trivector(self)
    }
}
impl<T: Float> Reverse for Vector<T> {
    #[inline]
    fn reverse(&self) -> Self {
        reverse_vector(self)
    }
}
impl<T: Float> Antireverse for Bivector<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        antireverse_bivector(self)
    }
}
impl<T: Float> Antireverse for Rotor<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        antireverse_rotor(self)
    }
}
impl<T: Float> Antireverse for Scalar<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        antireverse_scalar(self)
    }
}
impl<T: Float> Antireverse for Trivector<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        antireverse_trivector(self)
    }
}
impl<T: Float> Antireverse for Vector<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        antireverse_vector(self)
    }
}
impl<T: Float> RightComplement for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_complement(&self) -> Vector<T> {
        complement_bivector(self)
    }
}
impl<T: Float> RightComplement for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn right_complement(&self) -> Trivector<T> {
        complement_scalar(self)
    }
}
impl<T: Float> RightComplement for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_complement(&self) -> Scalar<T> {
        complement_trivector(self)
    }
}
impl<T: Float> RightComplement for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn right_complement(&self) -> Bivector<T> {
        complement_vector(self)
    }
}
impl<T: Float> crate::norm::Normed for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.xy() * self.xy() + self.xz() * self.xz() + self.yz() * self.yz()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new(self.xy() * factor, self.xz() * factor, self.yz() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Rotor<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.s() * self.s() + self.xy() * self.xy() + self.xz() * self.xz() + self.yz() * self.yz()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new(
            self.s() * factor,
            self.xy() * factor,
            self.xz() * factor,
            self.yz() * factor,
        )
    }
}
impl<T: Float> crate::norm::Normed for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.s() * self.s()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new(self.s() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Trivector<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.xyz() * self.xyz()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new(self.xyz() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Vector<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.x() * self.x() + self.y() * self.y() + self.z() * self.z()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new(self.x() * factor, self.y() * factor, self.z() * factor)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Bivector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.xy().abs_diff_eq(&other.xy(), epsilon)
            && self.xz().abs_diff_eq(&other.xz(), epsilon)
            && self.yz().abs_diff_eq(&other.yz(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Bivector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.xy().relative_eq(&other.xy(), epsilon, max_relative)
            && self.xz().relative_eq(&other.xz(), epsilon, max_relative)
            && self.yz().relative_eq(&other.yz(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Bivector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.xy().ulps_eq(&other.xy(), epsilon, max_ulps)
            && self.xz().ulps_eq(&other.xz(), epsilon, max_ulps)
            && self.yz().ulps_eq(&other.yz(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Rotor<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon)
            && self.xy().abs_diff_eq(&other.xy(), epsilon)
            && self.xz().abs_diff_eq(&other.xz(), epsilon)
            && self.yz().abs_diff_eq(&other.yz(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Rotor<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
            && self.xy().relative_eq(&other.xy(), epsilon, max_relative)
            && self.xz().relative_eq(&other.xz(), epsilon, max_relative)
            && self.yz().relative_eq(&other.yz(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Rotor<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
            && self.xy().ulps_eq(&other.xy(), epsilon, max_ulps)
            && self.xz().ulps_eq(&other.xz(), epsilon, max_ulps)
            && self.yz().ulps_eq(&other.yz(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Scalar<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Scalar<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Scalar<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Trivector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.xyz().abs_diff_eq(&other.xyz(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Trivector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.xyz().relative_eq(&other.xyz(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Trivector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.xyz().ulps_eq(&other.xyz(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Vector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.x().abs_diff_eq(&other.x(), epsilon)
            && self.y().abs_diff_eq(&other.y(), epsilon)
            && self.z().abs_diff_eq(&other.z(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Vector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.x().relative_eq(&other.x(), epsilon, max_relative)
            && self.y().relative_eq(&other.y(), epsilon, max_relative)
            && self.z().relative_eq(&other.z(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Vector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.x().ulps_eq(&other.x(), epsilon, max_ulps)
            && self.y().ulps_eq(&other.y(), epsilon, max_ulps)
            && self.z().ulps_eq(&other.z(), epsilon, max_ulps)
    }
}
#[cfg(any(test, feature = "proptest-support"))]
#[allow(clippy::missing_docs_in_private_items)]
mod arbitrary_impls {
    use super::*;
    use proptest::prelude::*;
    use proptest::strategy::BoxedStrategy;
    use std::fmt::Debug;
    impl<T: Float + Debug + 'static> Arbitrary for Bivector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0, -100.0f64..100.0, -100.0f64..100.0)
                .prop_map(|(x0, x1, x2)| {
                    Bivector::new(T::from_f64(x0), T::from_f64(x1), T::from_f64(x2))
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Rotor<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
            )
                .prop_map(|(x0, x1, x2, x3)| {
                    Rotor::new(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64(x3),
                    )
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Scalar<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| Scalar::new(T::from_f64(x0)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Trivector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| Trivector::new(T::from_f64(x0)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Vector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0, -100.0f64..100.0, -100.0f64..100.0)
                .prop_map(|(x0, x1, x2)| {
                    Vector::new(T::from_f64(x0), T::from_f64(x1), T::from_f64(x2))
                })
                .boxed()
        }
    }
}

// ============================================================
// Verification Tests (compare against Multivector)
// ============================================================

#[cfg(test)]
#[allow(clippy::missing_docs_in_private_items)]
mod verification_tests {
    use super::*;
    use crate::algebra::Multivector;
    use crate::signature::Euclidean3;
    use approx::relative_eq;
    use proptest::prelude::*;

    /// Relative epsilon for floating-point comparisons in verification tests.
    /// Using relative comparison handles varying magnitudes better than absolute.
    const REL_EPSILON: f64 = 1e-10;

    proptest! {
        #[test]
        fn bivector_add_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn bivector_sub_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn bivector_neg_matches_multivector(a in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn rotor_add_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn rotor_sub_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn rotor_neg_matches_multivector(a in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn scalar_add_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn scalar_sub_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn scalar_neg_matches_multivector(a in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn trivector_add_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn trivector_sub_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn trivector_neg_matches_multivector(a in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn vector_add_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn vector_sub_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn vector_neg_matches_multivector(a in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_bivector_bivector_rotor_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Rotor<f64> = geometric_bivector_bivector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_bivector_rotor_rotor_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Rotor<f64> = geometric_bivector_rotor(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_bivector_scalar_bivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = geometric_bivector_scalar(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_bivector_trivector_vector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = geometric_bivector_trivector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_rotor_bivector_rotor_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Rotor<f64> = geometric_rotor_bivector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_rotor_rotor_rotor_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Rotor<f64> = geometric_rotor_rotor(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_rotor_scalar_rotor_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Rotor<f64> = geometric_rotor_scalar(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_scalar_bivector_bivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = geometric_scalar_bivector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_scalar_rotor_rotor_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Rotor<f64> = geometric_scalar_rotor(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_scalar_scalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Scalar<f64> = geometric_scalar_scalar(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_scalar_trivector_trivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = geometric_scalar_trivector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_scalar_vector_vector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = geometric_scalar_vector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_trivector_bivector_vector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = geometric_trivector_bivector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_trivector_scalar_trivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = geometric_trivector_scalar(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_trivector_trivector_scalar_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Scalar<f64> = geometric_trivector_trivector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_trivector_vector_bivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = geometric_trivector_vector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_vector_scalar_vector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = geometric_vector_scalar(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_vector_trivector_bivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = geometric_vector_trivector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_vector_vector_rotor_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Rotor<f64> = geometric_vector_vector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_bivector_rotor_bivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = exterior_bivector_rotor(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_bivector_scalar_bivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = exterior_bivector_scalar(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_bivector_vector_trivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = exterior_bivector_vector(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_rotor_bivector_bivector_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = exterior_rotor_bivector(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_rotor_rotor_rotor_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Rotor<f64> = exterior_rotor_rotor(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_rotor_scalar_rotor_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Rotor<f64> = exterior_rotor_scalar(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_rotor_trivector_trivector_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = exterior_rotor_trivector(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_scalar_bivector_bivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = exterior_scalar_bivector(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_scalar_rotor_rotor_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Rotor<f64> = exterior_scalar_rotor(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_scalar_scalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Scalar<f64> = exterior_scalar_scalar(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_scalar_trivector_trivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = exterior_scalar_trivector(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_scalar_vector_vector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = exterior_scalar_vector(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_trivector_rotor_trivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = exterior_trivector_rotor(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_trivector_scalar_trivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = exterior_trivector_scalar(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_vector_bivector_trivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = exterior_vector_bivector(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_vector_scalar_vector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = exterior_vector_scalar(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_vector_vector_bivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = exterior_vector_vector(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_bivector_bivector_scalar_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Scalar<f64> = bulk_contraction_bivector_bivector(&a, &b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_bivector_rotor_rotor_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Rotor<f64> = bulk_contraction_bivector_rotor(&a, &b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_bivector_scalar_bivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = bulk_contraction_bivector_scalar(&a, &b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_bivector_vector_vector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = bulk_contraction_bivector_vector(&a, &b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_rotor_bivector_scalar_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Scalar<f64> = bulk_contraction_rotor_bivector(&a, &b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_rotor_rotor_rotor_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Rotor<f64> = bulk_contraction_rotor_rotor(&a, &b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_rotor_scalar_rotor_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Rotor<f64> = bulk_contraction_rotor_scalar(&a, &b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_rotor_vector_vector_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = bulk_contraction_rotor_vector(&a, &b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_scalar_rotor_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Scalar<f64> = bulk_contraction_scalar_rotor(&a, &b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_scalar_scalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Scalar<f64> = bulk_contraction_scalar_scalar(&a, &b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_trivector_bivector_vector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = bulk_contraction_trivector_bivector(&a, &b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_trivector_scalar_trivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = bulk_contraction_trivector_scalar(&a, &b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_trivector_trivector_scalar_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Scalar<f64> = bulk_contraction_trivector_trivector(&a, &b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_trivector_vector_bivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = bulk_contraction_trivector_vector(&a, &b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_vector_rotor_vector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = bulk_contraction_vector_rotor(&a, &b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_vector_scalar_vector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = bulk_contraction_vector_scalar(&a, &b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_vector_vector_scalar_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Scalar<f64> = bulk_contraction_vector_vector(&a, &b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_bivector_bivector_scalar_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Scalar<f64> = weight_contraction_bivector_bivector(&a, &b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_bivector_rotor_rotor_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Rotor<f64> = weight_contraction_bivector_rotor(&a, &b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_bivector_scalar_bivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = weight_contraction_bivector_scalar(&a, &b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_bivector_vector_vector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = weight_contraction_bivector_vector(&a, &b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_rotor_bivector_scalar_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Scalar<f64> = weight_contraction_rotor_bivector(&a, &b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_rotor_rotor_rotor_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Rotor<f64> = weight_contraction_rotor_rotor(&a, &b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_rotor_scalar_rotor_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Rotor<f64> = weight_contraction_rotor_scalar(&a, &b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_rotor_vector_vector_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = weight_contraction_rotor_vector(&a, &b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_scalar_rotor_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Scalar<f64> = weight_contraction_scalar_rotor(&a, &b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_scalar_scalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Scalar<f64> = weight_contraction_scalar_scalar(&a, &b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_trivector_bivector_vector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = weight_contraction_trivector_bivector(&a, &b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_trivector_scalar_trivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = weight_contraction_trivector_scalar(&a, &b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_trivector_trivector_scalar_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Scalar<f64> = weight_contraction_trivector_trivector(&a, &b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_trivector_vector_bivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = weight_contraction_trivector_vector(&a, &b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_vector_rotor_vector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = weight_contraction_vector_rotor(&a, &b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_vector_scalar_vector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = weight_contraction_vector_scalar(&a, &b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_vector_vector_scalar_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Scalar<f64> = weight_contraction_vector_vector(&a, &b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_bivector_bivector_trivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = bulk_expansion_bivector_bivector(&a, &b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_bivector_rotor_trivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = bulk_expansion_bivector_rotor(&a, &b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_bivector_trivector_bivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = bulk_expansion_bivector_trivector(&a, &b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_rotor_scalar_trivector_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = bulk_expansion_rotor_scalar(&a, &b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_rotor_trivector_rotor_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Rotor<f64> = bulk_expansion_rotor_trivector(&a, &b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_rotor_vector_bivector_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = bulk_expansion_rotor_vector(&a, &b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_scalar_bivector_vector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = bulk_expansion_scalar_bivector(&a, &b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_scalar_scalar_trivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = bulk_expansion_scalar_scalar(&a, &b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_scalar_trivector_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Scalar<f64> = bulk_expansion_scalar_trivector(&a, &b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_scalar_vector_bivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = bulk_expansion_scalar_vector(&a, &b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_trivector_trivector_trivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = bulk_expansion_trivector_trivector(&a, &b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_vector_bivector_bivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = bulk_expansion_vector_bivector(&a, &b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_vector_rotor_bivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = bulk_expansion_vector_rotor(&a, &b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_vector_trivector_vector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = bulk_expansion_vector_trivector(&a, &b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_vector_vector_trivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = bulk_expansion_vector_vector(&a, &b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_bivector_bivector_trivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = weight_expansion_bivector_bivector(&a, &b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_bivector_rotor_trivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = weight_expansion_bivector_rotor(&a, &b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_bivector_trivector_bivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = weight_expansion_bivector_trivector(&a, &b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_rotor_scalar_trivector_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = weight_expansion_rotor_scalar(&a, &b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_rotor_trivector_rotor_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Rotor<f64> = weight_expansion_rotor_trivector(&a, &b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_rotor_vector_bivector_matches_multivector(a in any::<Rotor<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = weight_expansion_rotor_vector(&a, &b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_scalar_bivector_vector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = weight_expansion_scalar_bivector(&a, &b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_scalar_scalar_trivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = weight_expansion_scalar_scalar(&a, &b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_scalar_trivector_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Scalar<f64> = weight_expansion_scalar_trivector(&a, &b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_scalar_vector_bivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = weight_expansion_scalar_vector(&a, &b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_trivector_trivector_trivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = weight_expansion_trivector_trivector(&a, &b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_vector_bivector_bivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = weight_expansion_vector_bivector(&a, &b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_vector_rotor_bivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Bivector<f64> = weight_expansion_vector_rotor(&a, &b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_vector_trivector_vector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Vector<f64> = weight_expansion_vector_trivector(&a, &b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_vector_vector_trivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            let specialized_result: Trivector<f64> = weight_expansion_vector_vector(&a, &b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Euclidean3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_bivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            // LHS: complement(a * b)
            let lhs = (&mv_a * &mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_bivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = &mv_a.complement() * &mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_rotor(a in any::<Rotor<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            // LHS: complement(a * b)
            let lhs = (&mv_a * &mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_rotor(a in any::<Rotor<f64>>(), b in any::<Rotor<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = &mv_a.complement() * &mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_scalar(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            // LHS: complement(a * b)
            let lhs = (&mv_a * &mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_scalar(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = &mv_a.complement() * &mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_trivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            // LHS: complement(a * b)
            let lhs = (&mv_a * &mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_trivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = &mv_a.complement() * &mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_vector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            // LHS: complement(a * b)
            let lhs = (&mv_a * &mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_vector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Euclidean3> = a.into();
            let mv_b: Multivector<f64, Euclidean3> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = &mv_a.complement() * &mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }
}
