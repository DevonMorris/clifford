#![doc = " Trait implementations for projective2."]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
use super::products::*;
use super::types::{Flector, Line, Motor, Point, Scalar, Trivector};
use crate::scalar::Float;
use approx::{AbsDiffEq, RelativeEq, UlpsEq};
use std::ops::{Add, BitXor, Mul, Neg, Sub};
impl<T: Float> Add for Flector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new(
            self.e1() + rhs.e1(),
            self.e2() + rhs.e2(),
            self.e0() + rhs.e0(),
            self.e012() + rhs.e012(),
        )
    }
}
impl<T: Float> Sub for Flector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new(
            self.e1() - rhs.e1(),
            self.e2() - rhs.e2(),
            self.e0() - rhs.e0(),
            self.e012() - rhs.e012(),
        )
    }
}
impl<T: Float> Neg for Flector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new(-self.e1(), -self.e2(), -self.e0(), -self.e012())
    }
}
impl<T: Float> Mul<T> for Flector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Flector<f32>> for f32 {
    type Output = Flector<f32>;
    #[inline]
    fn mul(self, v: Flector<f32>) -> Flector<f32> {
        v.scale(self)
    }
}
impl Mul<Flector<f64>> for f64 {
    type Output = Flector<f64>;
    #[inline]
    fn mul(self, v: Flector<f64>) -> Flector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Flector<T>> for Flector<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Motor<T> {
        geometric_flector_flector(&self, &rhs)
    }
}
impl<T: Float> Mul<Line<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Line<T>) -> Flector<T> {
        geometric_flector_line(&self, &rhs)
    }
}
impl<T: Float> Mul<Motor<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Motor<T>) -> Flector<T> {
        geometric_flector_motor(&self, &rhs)
    }
}
impl<T: Float> Mul<Point<T>> for Flector<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Point<T>) -> Motor<T> {
        geometric_flector_point(&self, &rhs)
    }
}
impl<T: Float> Mul<Scalar<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Flector<T> {
        geometric_flector_scalar(&self, &rhs)
    }
}
impl<T: Float> Mul<Trivector<T>> for Flector<T> {
    type Output = Line<T>;
    #[inline]
    fn mul(self, rhs: Trivector<T>) -> Line<T> {
        geometric_flector_trivector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Flector<T>> for Flector<T> {
    type Output = Line<T>;
    #[inline]
    fn bitxor(self, rhs: Flector<T>) -> Line<T> {
        exterior_flector_flector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Line<T>> for Flector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Line<T>) -> Trivector<T> {
        exterior_flector_line(&self, &rhs)
    }
}
impl<T: Float> BitXor<Motor<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn bitxor(self, rhs: Motor<T>) -> Flector<T> {
        exterior_flector_motor(&self, &rhs)
    }
}
impl<T: Float> BitXor<Point<T>> for Flector<T> {
    type Output = Line<T>;
    #[inline]
    fn bitxor(self, rhs: Point<T>) -> Line<T> {
        exterior_flector_point(&self, &rhs)
    }
}
impl<T: Float> BitXor<Scalar<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn bitxor(self, rhs: Scalar<T>) -> Flector<T> {
        exterior_flector_scalar(&self, &rhs)
    }
}
impl<T: Float> Add for Line<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new(
            self.e12() + rhs.e12(),
            self.e01() + rhs.e01(),
            self.e02() + rhs.e02(),
        )
    }
}
impl<T: Float> Sub for Line<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new(
            self.e12() - rhs.e12(),
            self.e01() - rhs.e01(),
            self.e02() - rhs.e02(),
        )
    }
}
impl<T: Float> Neg for Line<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new(-self.e12(), -self.e01(), -self.e02())
    }
}
impl<T: Float> Mul<T> for Line<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Line<f32>> for f32 {
    type Output = Line<f32>;
    #[inline]
    fn mul(self, v: Line<f32>) -> Line<f32> {
        v.scale(self)
    }
}
impl Mul<Line<f64>> for f64 {
    type Output = Line<f64>;
    #[inline]
    fn mul(self, v: Line<f64>) -> Line<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Flector<T>> for Line<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Flector<T> {
        geometric_line_flector(&self, &rhs)
    }
}
impl<T: Float> Mul<Line<T>> for Line<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Line<T>) -> Motor<T> {
        geometric_line_line(&self, &rhs)
    }
}
impl<T: Float> Mul<Motor<T>> for Line<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Motor<T>) -> Motor<T> {
        geometric_line_motor(&self, &rhs)
    }
}
impl<T: Float> Mul<Point<T>> for Line<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Point<T>) -> Flector<T> {
        geometric_line_point(&self, &rhs)
    }
}
impl<T: Float> Mul<Scalar<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Line<T> {
        geometric_line_scalar(&self, &rhs)
    }
}
impl<T: Float> Mul<Trivector<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn mul(self, rhs: Trivector<T>) -> Point<T> {
        geometric_line_trivector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Flector<T>> for Line<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Flector<T>) -> Trivector<T> {
        exterior_line_flector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Motor<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn bitxor(self, rhs: Motor<T>) -> Line<T> {
        exterior_line_motor(&self, &rhs)
    }
}
impl<T: Float> BitXor<Point<T>> for Line<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Point<T>) -> Trivector<T> {
        exterior_line_point(&self, &rhs)
    }
}
impl<T: Float> BitXor<Scalar<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn bitxor(self, rhs: Scalar<T>) -> Line<T> {
        exterior_line_scalar(&self, &rhs)
    }
}
impl<T: Float> Add for Motor<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new(
            self.s() + rhs.s(),
            self.e12() + rhs.e12(),
            self.e01() + rhs.e01(),
            self.e02() + rhs.e02(),
        )
    }
}
impl<T: Float> Sub for Motor<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new(
            self.s() - rhs.s(),
            self.e12() - rhs.e12(),
            self.e01() - rhs.e01(),
            self.e02() - rhs.e02(),
        )
    }
}
impl<T: Float> Neg for Motor<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new(-self.s(), -self.e12(), -self.e01(), -self.e02())
    }
}
impl<T: Float> Mul<T> for Motor<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Motor<f32>> for f32 {
    type Output = Motor<f32>;
    #[inline]
    fn mul(self, v: Motor<f32>) -> Motor<f32> {
        v.scale(self)
    }
}
impl Mul<Motor<f64>> for f64 {
    type Output = Motor<f64>;
    #[inline]
    fn mul(self, v: Motor<f64>) -> Motor<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Flector<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Flector<T> {
        geometric_motor_flector(&self, &rhs)
    }
}
impl<T: Float> Mul<Line<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Line<T>) -> Motor<T> {
        geometric_motor_line(&self, &rhs)
    }
}
impl<T: Float> Mul<Motor<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Motor<T>) -> Motor<T> {
        geometric_motor_motor(&self, &rhs)
    }
}
impl<T: Float> Mul<Point<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Point<T>) -> Flector<T> {
        geometric_motor_point(&self, &rhs)
    }
}
impl<T: Float> Mul<Scalar<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Motor<T> {
        geometric_motor_scalar(&self, &rhs)
    }
}
impl<T: Float> Mul<Trivector<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Trivector<T>) -> Flector<T> {
        geometric_motor_trivector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Flector<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn bitxor(self, rhs: Flector<T>) -> Flector<T> {
        exterior_motor_flector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Line<T>> for Motor<T> {
    type Output = Line<T>;
    #[inline]
    fn bitxor(self, rhs: Line<T>) -> Line<T> {
        exterior_motor_line(&self, &rhs)
    }
}
impl<T: Float> BitXor<Motor<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn bitxor(self, rhs: Motor<T>) -> Motor<T> {
        exterior_motor_motor(&self, &rhs)
    }
}
impl<T: Float> BitXor<Point<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn bitxor(self, rhs: Point<T>) -> Flector<T> {
        exterior_motor_point(&self, &rhs)
    }
}
impl<T: Float> BitXor<Scalar<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn bitxor(self, rhs: Scalar<T>) -> Motor<T> {
        exterior_motor_scalar(&self, &rhs)
    }
}
impl<T: Float> BitXor<Trivector<T>> for Motor<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Trivector<T>) -> Trivector<T> {
        exterior_motor_trivector(&self, &rhs)
    }
}
impl<T: Float> Add for Point<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new(
            self.e1() + rhs.e1(),
            self.e2() + rhs.e2(),
            self.e0() + rhs.e0(),
        )
    }
}
impl<T: Float> Sub for Point<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new(
            self.e1() - rhs.e1(),
            self.e2() - rhs.e2(),
            self.e0() - rhs.e0(),
        )
    }
}
impl<T: Float> Neg for Point<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new(-self.e1(), -self.e2(), -self.e0())
    }
}
impl<T: Float> Mul<T> for Point<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Point<f32>> for f32 {
    type Output = Point<f32>;
    #[inline]
    fn mul(self, v: Point<f32>) -> Point<f32> {
        v.scale(self)
    }
}
impl Mul<Point<f64>> for f64 {
    type Output = Point<f64>;
    #[inline]
    fn mul(self, v: Point<f64>) -> Point<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Flector<T>> for Point<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Motor<T> {
        geometric_point_flector(&self, &rhs)
    }
}
impl<T: Float> Mul<Line<T>> for Point<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Line<T>) -> Flector<T> {
        geometric_point_line(&self, &rhs)
    }
}
impl<T: Float> Mul<Motor<T>> for Point<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Motor<T>) -> Flector<T> {
        geometric_point_motor(&self, &rhs)
    }
}
impl<T: Float> Mul<Point<T>> for Point<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Point<T>) -> Motor<T> {
        geometric_point_point(&self, &rhs)
    }
}
impl<T: Float> Mul<Scalar<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Point<T> {
        geometric_point_scalar(&self, &rhs)
    }
}
impl<T: Float> Mul<Trivector<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn mul(self, rhs: Trivector<T>) -> Line<T> {
        geometric_point_trivector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Flector<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn bitxor(self, rhs: Flector<T>) -> Line<T> {
        exterior_point_flector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Line<T>> for Point<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Line<T>) -> Trivector<T> {
        exterior_point_line(&self, &rhs)
    }
}
impl<T: Float> BitXor<Motor<T>> for Point<T> {
    type Output = Flector<T>;
    #[inline]
    fn bitxor(self, rhs: Motor<T>) -> Flector<T> {
        exterior_point_motor(&self, &rhs)
    }
}
impl<T: Float> BitXor<Point<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn bitxor(self, rhs: Point<T>) -> Line<T> {
        exterior_point_point(&self, &rhs)
    }
}
impl<T: Float> BitXor<Scalar<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn bitxor(self, rhs: Scalar<T>) -> Point<T> {
        exterior_point_scalar(&self, &rhs)
    }
}
impl<T: Float> Add for Scalar<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new(self.s() + rhs.s())
    }
}
impl<T: Float> Sub for Scalar<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new(self.s() - rhs.s())
    }
}
impl<T: Float> Neg for Scalar<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new(-self.s())
    }
}
impl<T: Float> Mul<T> for Scalar<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Scalar<f32>> for f32 {
    type Output = Scalar<f32>;
    #[inline]
    fn mul(self, v: Scalar<f32>) -> Scalar<f32> {
        v.scale(self)
    }
}
impl Mul<Scalar<f64>> for f64 {
    type Output = Scalar<f64>;
    #[inline]
    fn mul(self, v: Scalar<f64>) -> Scalar<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Flector<T>> for Scalar<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Flector<T> {
        geometric_scalar_flector(&self, &rhs)
    }
}
impl<T: Float> Mul<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn mul(self, rhs: Line<T>) -> Line<T> {
        geometric_scalar_line(&self, &rhs)
    }
}
impl<T: Float> Mul<Motor<T>> for Scalar<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Motor<T>) -> Motor<T> {
        geometric_scalar_motor(&self, &rhs)
    }
}
impl<T: Float> Mul<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn mul(self, rhs: Point<T>) -> Point<T> {
        geometric_scalar_point(&self, &rhs)
    }
}
impl<T: Float> Mul<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Scalar<T> {
        geometric_scalar_scalar(&self, &rhs)
    }
}
impl<T: Float> Mul<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn mul(self, rhs: Trivector<T>) -> Trivector<T> {
        geometric_scalar_trivector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Flector<T>> for Scalar<T> {
    type Output = Flector<T>;
    #[inline]
    fn bitxor(self, rhs: Flector<T>) -> Flector<T> {
        exterior_scalar_flector(&self, &rhs)
    }
}
impl<T: Float> BitXor<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn bitxor(self, rhs: Line<T>) -> Line<T> {
        exterior_scalar_line(&self, &rhs)
    }
}
impl<T: Float> BitXor<Motor<T>> for Scalar<T> {
    type Output = Motor<T>;
    #[inline]
    fn bitxor(self, rhs: Motor<T>) -> Motor<T> {
        exterior_scalar_motor(&self, &rhs)
    }
}
impl<T: Float> BitXor<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn bitxor(self, rhs: Point<T>) -> Point<T> {
        exterior_scalar_point(&self, &rhs)
    }
}
impl<T: Float> BitXor<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bitxor(self, rhs: Scalar<T>) -> Scalar<T> {
        exterior_scalar_scalar(&self, &rhs)
    }
}
impl<T: Float> BitXor<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Trivector<T>) -> Trivector<T> {
        exterior_scalar_trivector(&self, &rhs)
    }
}
impl<T: Float> Add for Trivector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new(self.e012() + rhs.e012())
    }
}
impl<T: Float> Sub for Trivector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new(self.e012() - rhs.e012())
    }
}
impl<T: Float> Neg for Trivector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new(-self.e012())
    }
}
impl<T: Float> Mul<T> for Trivector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Trivector<f32>> for f32 {
    type Output = Trivector<f32>;
    #[inline]
    fn mul(self, v: Trivector<f32>) -> Trivector<f32> {
        v.scale(self)
    }
}
impl Mul<Trivector<f64>> for f64 {
    type Output = Trivector<f64>;
    #[inline]
    fn mul(self, v: Trivector<f64>) -> Trivector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Flector<T>> for Trivector<T> {
    type Output = Line<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Line<T> {
        geometric_trivector_flector(&self, &rhs)
    }
}
impl<T: Float> Mul<Line<T>> for Trivector<T> {
    type Output = Point<T>;
    #[inline]
    fn mul(self, rhs: Line<T>) -> Point<T> {
        geometric_trivector_line(&self, &rhs)
    }
}
impl<T: Float> Mul<Motor<T>> for Trivector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Motor<T>) -> Flector<T> {
        geometric_trivector_motor(&self, &rhs)
    }
}
impl<T: Float> Mul<Point<T>> for Trivector<T> {
    type Output = Line<T>;
    #[inline]
    fn mul(self, rhs: Point<T>) -> Line<T> {
        geometric_trivector_point(&self, &rhs)
    }
}
impl<T: Float> Mul<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Trivector<T> {
        geometric_trivector_scalar(&self, &rhs)
    }
}
impl<T: Float> BitXor<Motor<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Motor<T>) -> Trivector<T> {
        exterior_trivector_motor(&self, &rhs)
    }
}
impl<T: Float> BitXor<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bitxor(self, rhs: Scalar<T>) -> Trivector<T> {
        exterior_trivector_scalar(&self, &rhs)
    }
}
impl<T: Float> crate::norm::Normed for Flector<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.e1() * self.e1()
            + self.e2() * self.e2()
            + self.e0() * self.e0()
            + self.e012() * self.e012()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new(
            self.e1() * factor,
            self.e2() * factor,
            self.e0() * factor,
            self.e012() * factor,
        )
    }
}
impl<T: Float> crate::norm::Normed for Line<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.e12() * self.e12() + self.e01() * self.e01() + self.e02() * self.e02()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new(
            self.e12() * factor,
            self.e01() * factor,
            self.e02() * factor,
        )
    }
}
impl<T: Float> crate::norm::Normed for Motor<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.s() * self.s()
            + self.e12() * self.e12()
            + self.e01() * self.e01()
            + self.e02() * self.e02()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new(
            self.s() * factor,
            self.e12() * factor,
            self.e01() * factor,
            self.e02() * factor,
        )
    }
}
impl<T: Float> crate::norm::Normed for Point<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.e1() * self.e1() + self.e2() * self.e2() + self.e0() * self.e0()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new(self.e1() * factor, self.e2() * factor, self.e0() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.s() * self.s()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new(self.s() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Trivector<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.e012() * self.e012()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new(self.e012() * factor)
    }
}
impl<T: Float> crate::norm::DegenerateNormed for Flector<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        self.e1() * self.e1() + self.e2() * self.e2()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        self.e0() * self.e0() + self.e012() * self.e012()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new(
                self.e1() * inv_w,
                self.e2() * inv_w,
                self.e0() * inv_w,
                self.e012() * inv_w,
            ))
        }
    }
}
impl<T: Float> crate::norm::DegenerateNormed for Line<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        self.e12() * self.e12()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        self.e01() * self.e01() + self.e02() * self.e02()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new(
                self.e12() * inv_w,
                self.e01() * inv_w,
                self.e02() * inv_w,
            ))
        }
    }
}
impl<T: Float> crate::norm::DegenerateNormed for Motor<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        self.s() * self.s() + self.e12() * self.e12()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        self.e01() * self.e01() + self.e02() * self.e02()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new(
                self.s() * inv_w,
                self.e12() * inv_w,
                self.e01() * inv_w,
                self.e02() * inv_w,
            ))
        }
    }
}
impl<T: Float> crate::norm::DegenerateNormed for Point<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        self.e1() * self.e1() + self.e2() * self.e2()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        self.e0() * self.e0()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new(
                self.e1() * inv_w,
                self.e2() * inv_w,
                self.e0() * inv_w,
            ))
        }
    }
}
impl<T: Float> crate::norm::DegenerateNormed for Scalar<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        self.s() * self.s()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        T::zero()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new(self.s() * inv_w))
        }
    }
}
impl<T: Float> crate::norm::DegenerateNormed for Trivector<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        T::zero()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        self.e012() * self.e012()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new(self.e012() * inv_w))
        }
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Flector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.e1().abs_diff_eq(&other.e1(), epsilon)
            && self.e2().abs_diff_eq(&other.e2(), epsilon)
            && self.e0().abs_diff_eq(&other.e0(), epsilon)
            && self.e012().abs_diff_eq(&other.e012(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Flector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.e1().relative_eq(&other.e1(), epsilon, max_relative)
            && self.e2().relative_eq(&other.e2(), epsilon, max_relative)
            && self.e0().relative_eq(&other.e0(), epsilon, max_relative)
            && self
                .e012()
                .relative_eq(&other.e012(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Flector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.e1().ulps_eq(&other.e1(), epsilon, max_ulps)
            && self.e2().ulps_eq(&other.e2(), epsilon, max_ulps)
            && self.e0().ulps_eq(&other.e0(), epsilon, max_ulps)
            && self.e012().ulps_eq(&other.e012(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Line<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.e12().abs_diff_eq(&other.e12(), epsilon)
            && self.e01().abs_diff_eq(&other.e01(), epsilon)
            && self.e02().abs_diff_eq(&other.e02(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Line<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.e12().relative_eq(&other.e12(), epsilon, max_relative)
            && self.e01().relative_eq(&other.e01(), epsilon, max_relative)
            && self.e02().relative_eq(&other.e02(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Line<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.e12().ulps_eq(&other.e12(), epsilon, max_ulps)
            && self.e01().ulps_eq(&other.e01(), epsilon, max_ulps)
            && self.e02().ulps_eq(&other.e02(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Motor<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon)
            && self.e12().abs_diff_eq(&other.e12(), epsilon)
            && self.e01().abs_diff_eq(&other.e01(), epsilon)
            && self.e02().abs_diff_eq(&other.e02(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Motor<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
            && self.e12().relative_eq(&other.e12(), epsilon, max_relative)
            && self.e01().relative_eq(&other.e01(), epsilon, max_relative)
            && self.e02().relative_eq(&other.e02(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Motor<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
            && self.e12().ulps_eq(&other.e12(), epsilon, max_ulps)
            && self.e01().ulps_eq(&other.e01(), epsilon, max_ulps)
            && self.e02().ulps_eq(&other.e02(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Point<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.e1().abs_diff_eq(&other.e1(), epsilon)
            && self.e2().abs_diff_eq(&other.e2(), epsilon)
            && self.e0().abs_diff_eq(&other.e0(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Point<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.e1().relative_eq(&other.e1(), epsilon, max_relative)
            && self.e2().relative_eq(&other.e2(), epsilon, max_relative)
            && self.e0().relative_eq(&other.e0(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Point<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.e1().ulps_eq(&other.e1(), epsilon, max_ulps)
            && self.e2().ulps_eq(&other.e2(), epsilon, max_ulps)
            && self.e0().ulps_eq(&other.e0(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Scalar<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Scalar<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Scalar<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Trivector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.e012().abs_diff_eq(&other.e012(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Trivector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.e012()
            .relative_eq(&other.e012(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Trivector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.e012().ulps_eq(&other.e012(), epsilon, max_ulps)
    }
}
#[cfg(any(test, feature = "proptest-support"))]
#[allow(clippy::missing_docs_in_private_items)]
mod arbitrary_impls {
    use super::*;
    use proptest::prelude::*;
    use proptest::strategy::BoxedStrategy;
    use std::fmt::Debug;
    impl<T: Float + Debug + 'static> Arbitrary for Flector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
            )
                .prop_map(|(x0, x1, x2, x3)| {
                    Flector::new(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64(x3),
                    )
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Line<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0, -100.0f64..100.0, -100.0f64..100.0)
                .prop_map(|(x0, x1, x2)| {
                    Line::new(T::from_f64(x0), T::from_f64(x1), T::from_f64(x2))
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Motor<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
            )
                .prop_map(|(x0, x1, x2, x3)| {
                    Motor::new(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64(x3),
                    )
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Point<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0, -100.0f64..100.0, -100.0f64..100.0)
                .prop_map(|(x0, x1, x2)| {
                    Point::new(T::from_f64(x0), T::from_f64(x1), T::from_f64(x2))
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Scalar<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| Scalar::new(T::from_f64(x0)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Trivector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| Trivector::new(T::from_f64(x0)))
                .boxed()
        }
    }
}

// ============================================================
// Verification Tests (compare against Multivector)
// ============================================================

#[cfg(test)]
#[allow(clippy::missing_docs_in_private_items)]
mod verification_tests {
    use super::*;
    use crate::algebra::Multivector;
    use crate::signature::Projective2;
    use approx::relative_eq;
    use proptest::prelude::*;

    /// Relative epsilon for floating-point comparisons in verification tests.
    /// Using relative comparison handles varying magnitudes better than absolute.
    const REL_EPSILON: f64 = 1e-10;

    proptest! {
        #[test]
        fn flector_add_matches_multivector(a in any::<Flector<f64>>(), b in any::<Flector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn flector_sub_matches_multivector(a in any::<Flector<f64>>(), b in any::<Flector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn flector_neg_matches_multivector(a in any::<Flector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn line_add_matches_multivector(a in any::<Line<f64>>(), b in any::<Line<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn line_sub_matches_multivector(a in any::<Line<f64>>(), b in any::<Line<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn line_neg_matches_multivector(a in any::<Line<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn motor_add_matches_multivector(a in any::<Motor<f64>>(), b in any::<Motor<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn motor_sub_matches_multivector(a in any::<Motor<f64>>(), b in any::<Motor<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn motor_neg_matches_multivector(a in any::<Motor<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn point_add_matches_multivector(a in any::<Point<f64>>(), b in any::<Point<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn point_sub_matches_multivector(a in any::<Point<f64>>(), b in any::<Point<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn point_neg_matches_multivector(a in any::<Point<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn scalar_add_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn scalar_sub_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn scalar_neg_matches_multivector(a in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn trivector_add_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn trivector_sub_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn trivector_neg_matches_multivector(a in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_flector_flector_motor_matches_multivector(a in any::<Flector<f64>>(), b in any::<Flector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Motor<f64> = geometric_flector_flector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_flector_line_flector_matches_multivector(a in any::<Flector<f64>>(), b in any::<Line<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Flector<f64> = geometric_flector_line(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_flector_motor_flector_matches_multivector(a in any::<Flector<f64>>(), b in any::<Motor<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Flector<f64> = geometric_flector_motor(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_flector_point_motor_matches_multivector(a in any::<Flector<f64>>(), b in any::<Point<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Motor<f64> = geometric_flector_point(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_flector_scalar_flector_matches_multivector(a in any::<Flector<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Flector<f64> = geometric_flector_scalar(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_flector_trivector_line_matches_multivector(a in any::<Flector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Line<f64> = geometric_flector_trivector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_line_flector_flector_matches_multivector(a in any::<Line<f64>>(), b in any::<Flector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Flector<f64> = geometric_line_flector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_line_line_motor_matches_multivector(a in any::<Line<f64>>(), b in any::<Line<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Motor<f64> = geometric_line_line(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_line_motor_motor_matches_multivector(a in any::<Line<f64>>(), b in any::<Motor<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Motor<f64> = geometric_line_motor(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_line_point_flector_matches_multivector(a in any::<Line<f64>>(), b in any::<Point<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Flector<f64> = geometric_line_point(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_line_scalar_line_matches_multivector(a in any::<Line<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Line<f64> = geometric_line_scalar(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_line_trivector_point_matches_multivector(a in any::<Line<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Point<f64> = geometric_line_trivector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_motor_flector_flector_matches_multivector(a in any::<Motor<f64>>(), b in any::<Flector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Flector<f64> = geometric_motor_flector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_motor_line_motor_matches_multivector(a in any::<Motor<f64>>(), b in any::<Line<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Motor<f64> = geometric_motor_line(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_motor_motor_motor_matches_multivector(a in any::<Motor<f64>>(), b in any::<Motor<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Motor<f64> = geometric_motor_motor(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_motor_point_flector_matches_multivector(a in any::<Motor<f64>>(), b in any::<Point<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Flector<f64> = geometric_motor_point(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_motor_scalar_motor_matches_multivector(a in any::<Motor<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Motor<f64> = geometric_motor_scalar(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_motor_trivector_flector_matches_multivector(a in any::<Motor<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Flector<f64> = geometric_motor_trivector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_point_flector_motor_matches_multivector(a in any::<Point<f64>>(), b in any::<Flector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Motor<f64> = geometric_point_flector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_point_line_flector_matches_multivector(a in any::<Point<f64>>(), b in any::<Line<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Flector<f64> = geometric_point_line(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_point_motor_flector_matches_multivector(a in any::<Point<f64>>(), b in any::<Motor<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Flector<f64> = geometric_point_motor(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_point_point_motor_matches_multivector(a in any::<Point<f64>>(), b in any::<Point<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Motor<f64> = geometric_point_point(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_point_scalar_point_matches_multivector(a in any::<Point<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Point<f64> = geometric_point_scalar(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_point_trivector_line_matches_multivector(a in any::<Point<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Line<f64> = geometric_point_trivector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_scalar_flector_flector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Flector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Flector<f64> = geometric_scalar_flector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_scalar_line_line_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Line<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Line<f64> = geometric_scalar_line(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_scalar_motor_motor_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Motor<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Motor<f64> = geometric_scalar_motor(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_scalar_point_point_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Point<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Point<f64> = geometric_scalar_point(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_scalar_scalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Scalar<f64> = geometric_scalar_scalar(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_scalar_trivector_trivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Trivector<f64> = geometric_scalar_trivector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_trivector_flector_line_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Flector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Line<f64> = geometric_trivector_flector(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_trivector_line_point_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Line<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Point<f64> = geometric_trivector_line(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_trivector_motor_flector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Motor<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Flector<f64> = geometric_trivector_motor(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_trivector_point_line_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Point<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Line<f64> = geometric_trivector_point(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn geometric_trivector_scalar_trivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Trivector<f64> = geometric_trivector_scalar(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_flector_flector_line_matches_multivector(a in any::<Flector<f64>>(), b in any::<Flector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Line<f64> = exterior_flector_flector(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_flector_line_trivector_matches_multivector(a in any::<Flector<f64>>(), b in any::<Line<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Trivector<f64> = exterior_flector_line(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_flector_motor_flector_matches_multivector(a in any::<Flector<f64>>(), b in any::<Motor<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Flector<f64> = exterior_flector_motor(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_flector_point_line_matches_multivector(a in any::<Flector<f64>>(), b in any::<Point<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Line<f64> = exterior_flector_point(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_flector_scalar_flector_matches_multivector(a in any::<Flector<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Flector<f64> = exterior_flector_scalar(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_line_flector_trivector_matches_multivector(a in any::<Line<f64>>(), b in any::<Flector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Trivector<f64> = exterior_line_flector(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_line_motor_line_matches_multivector(a in any::<Line<f64>>(), b in any::<Motor<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Line<f64> = exterior_line_motor(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_line_point_trivector_matches_multivector(a in any::<Line<f64>>(), b in any::<Point<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Trivector<f64> = exterior_line_point(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_line_scalar_line_matches_multivector(a in any::<Line<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Line<f64> = exterior_line_scalar(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_motor_flector_flector_matches_multivector(a in any::<Motor<f64>>(), b in any::<Flector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Flector<f64> = exterior_motor_flector(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_motor_line_line_matches_multivector(a in any::<Motor<f64>>(), b in any::<Line<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Line<f64> = exterior_motor_line(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_motor_motor_motor_matches_multivector(a in any::<Motor<f64>>(), b in any::<Motor<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Motor<f64> = exterior_motor_motor(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_motor_point_flector_matches_multivector(a in any::<Motor<f64>>(), b in any::<Point<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Flector<f64> = exterior_motor_point(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_motor_scalar_motor_matches_multivector(a in any::<Motor<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Motor<f64> = exterior_motor_scalar(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_motor_trivector_trivector_matches_multivector(a in any::<Motor<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Trivector<f64> = exterior_motor_trivector(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_point_flector_line_matches_multivector(a in any::<Point<f64>>(), b in any::<Flector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Line<f64> = exterior_point_flector(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_point_line_trivector_matches_multivector(a in any::<Point<f64>>(), b in any::<Line<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Trivector<f64> = exterior_point_line(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_point_motor_flector_matches_multivector(a in any::<Point<f64>>(), b in any::<Motor<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Flector<f64> = exterior_point_motor(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_point_point_line_matches_multivector(a in any::<Point<f64>>(), b in any::<Point<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Line<f64> = exterior_point_point(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_point_scalar_point_matches_multivector(a in any::<Point<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Point<f64> = exterior_point_scalar(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_scalar_flector_flector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Flector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Flector<f64> = exterior_scalar_flector(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_scalar_line_line_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Line<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Line<f64> = exterior_scalar_line(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_scalar_motor_motor_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Motor<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Motor<f64> = exterior_scalar_motor(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_scalar_point_point_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Point<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Point<f64> = exterior_scalar_point(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_scalar_scalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Scalar<f64> = exterior_scalar_scalar(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_scalar_trivector_trivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Trivector<f64> = exterior_scalar_trivector(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_trivector_motor_trivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Motor<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Trivector<f64> = exterior_trivector_motor(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn exterior_trivector_scalar_trivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective2> = a.into();
            let mv_b: Multivector<f64, Projective2> = b.into();

            let specialized_result: Trivector<f64> = exterior_trivector_scalar(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective2> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }
}
