#![doc = " Type definitions for projective2."]
#![doc = ""]
#![doc = " 2D Projective Geometric Algebra"]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
#![allow(clippy::too_many_arguments)]
use crate::scalar::Float;
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
#[doc = "2D reflection/glide transformation via antisandwich\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 0 | s | `s` |\n| 5 | e1e3 | `e01` |\n| 6 | e2e3 | `e02` |\n| 3 | e1e2 | `e12` |\n\n\n# Example\n\n```\nuse clifford::specialized::projective::dim2::Flector;\n\nlet v = Flector::new(1.0, 2.0, 3.0, 4.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Flector<T: Float> {
    #[doc = "Coefficient of `s`."]
    s: T,
    #[doc = "Coefficient of `e01`."]
    e01: T,
    #[doc = "Coefficient of `e02`."]
    e02: T,
    #[doc = "Coefficient of `e12`."]
    e12: T,
}
impl<T: Float> Flector<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(s: T, e01: T, e02: T, e12: T) -> Self {
        Self { s, e01, e02, e12 }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(s: T, e01: T, e02: T, e12: T) -> Self {
        Self::new(s, e01, e02, e12)
    }
    #[doc = "Returns the `s` coefficient."]
    #[inline]
    pub fn s(&self) -> T {
        self.s
    }
    #[doc = "Returns the `e01` coefficient."]
    #[inline]
    pub fn e01(&self) -> T {
        self.e01
    }
    #[doc = "Returns the `e02` coefficient."]
    #[inline]
    pub fn e02(&self) -> T {
        self.e02
    }
    #[doc = "Returns the `e12` coefficient."]
    #[inline]
    pub fn e12(&self) -> T {
        self.e12
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new(T::zero(), T::zero(), T::zero(), T::zero())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.s * self.s + self.e01 * self.e01 + self.e02 * self.e02 + self.e12 * self.e12
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new(self.s * s, self.e01 * s, self.e02 * s, self.e12 * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new(self.s, -self.e01, -self.e02, -self.e12)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new(-self.s, self.e01, self.e02, self.e12)
    }
}
impl<T: Float> Default for Flector<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "2D line\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 5 | e1e3 | `e01` |\n| 6 | e2e3 | `e02` |\n| 3 | e1e2 | `e12` |\n\n\n# Example\n\n```\nuse clifford::specialized::projective::dim2::Line;\n\nlet v = Line::new(1.0, 2.0, 3.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Line<T: Float> {
    #[doc = "Coefficient of `e01`."]
    e01: T,
    #[doc = "Coefficient of `e02`."]
    e02: T,
    #[doc = "Coefficient of `e12`."]
    e12: T,
}
impl<T: Float> Line<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(e01: T, e02: T, e12: T) -> Self {
        Self { e01, e02, e12 }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(e01: T, e02: T, e12: T) -> Self {
        Self::new(e01, e02, e12)
    }
    #[doc = "Returns the `e01` coefficient."]
    #[inline]
    pub fn e01(&self) -> T {
        self.e01
    }
    #[doc = "Returns the `e02` coefficient."]
    #[inline]
    pub fn e02(&self) -> T {
        self.e02
    }
    #[doc = "Returns the `e12` coefficient."]
    #[inline]
    pub fn e12(&self) -> T {
        self.e12
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new(T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e3 element."]
    #[inline]
    pub fn unit_e01() -> Self {
        Self::new(T::one(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e2e3 element."]
    #[inline]
    pub fn unit_e02() -> Self {
        Self::new(T::zero(), T::one(), T::zero())
    }
    #[doc = "Creates the unit e1e2 element."]
    #[inline]
    pub fn unit_e12() -> Self {
        Self::new(T::zero(), T::zero(), T::one())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.e01 * self.e01 + self.e02 * self.e02 + self.e12 * self.e12
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new(self.e01 * s, self.e02 * s, self.e12 * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new(-self.e01, -self.e02, -self.e12)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new(self.e01, self.e02, self.e12)
    }
}
impl<T: Float> Default for Line<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "2D rigid transformation (rotation + translation) via antisandwich\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 1 | e1 | `e1` |\n| 2 | e2 | `e2` |\n| 4 | e3 | `e0` |\n| 7 | e1e2e3 | `e012` |\n\n\n# Example\n\n```\nuse clifford::specialized::projective::dim2::Motor;\n\nlet v = Motor::new(1.0, 2.0, 3.0, 4.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Motor<T: Float> {
    #[doc = "Coefficient of `e1`."]
    e1: T,
    #[doc = "Coefficient of `e2`."]
    e2: T,
    #[doc = "Coefficient of `e0`."]
    e0: T,
    #[doc = "Coefficient of `e012`."]
    e012: T,
}
impl<T: Float> Motor<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(e1: T, e2: T, e0: T, e012: T) -> Self {
        Self { e1, e2, e0, e012 }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(e1: T, e2: T, e0: T, e012: T) -> Self {
        Self::new(e1, e2, e0, e012)
    }
    #[doc = "Returns the `e1` coefficient."]
    #[inline]
    pub fn e1(&self) -> T {
        self.e1
    }
    #[doc = "Returns the `e2` coefficient."]
    #[inline]
    pub fn e2(&self) -> T {
        self.e2
    }
    #[doc = "Returns the `e0` coefficient."]
    #[inline]
    pub fn e0(&self) -> T {
        self.e0
    }
    #[doc = "Returns the `e012` coefficient."]
    #[inline]
    pub fn e012(&self) -> T {
        self.e012
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new(T::zero(), T::zero(), T::zero(), T::zero())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.e1 * self.e1 + self.e2 * self.e2 + self.e0 * self.e0 + self.e012 * self.e012
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new(self.e1 * s, self.e2 * s, self.e0 * s, self.e012 * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new(self.e1, self.e2, self.e0, -self.e012)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new(-self.e1, -self.e2, -self.e0, self.e012)
    }
}
impl<T: Float> Default for Motor<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "2D point in homogeneous coordinates\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 1 | e1 | `e1` |\n| 2 | e2 | `e2` |\n| 4 | e3 | `e0` |\n\n\n# Example\n\n```\nuse clifford::specialized::projective::dim2::Point;\n\nlet v = Point::new(1.0, 2.0, 3.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Point<T: Float> {
    #[doc = "Coefficient of `e1`."]
    e1: T,
    #[doc = "Coefficient of `e2`."]
    e2: T,
    #[doc = "Coefficient of `e0`."]
    e0: T,
}
impl<T: Float> Point<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(e1: T, e2: T, e0: T) -> Self {
        Self { e1, e2, e0 }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(e1: T, e2: T, e0: T) -> Self {
        Self::new(e1, e2, e0)
    }
    #[doc = "Returns the `e1` coefficient."]
    #[inline]
    pub fn e1(&self) -> T {
        self.e1
    }
    #[doc = "Returns the `e2` coefficient."]
    #[inline]
    pub fn e2(&self) -> T {
        self.e2
    }
    #[doc = "Returns the `e0` coefficient."]
    #[inline]
    pub fn e0(&self) -> T {
        self.e0
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new(T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1 element."]
    #[inline]
    pub fn unit_e1() -> Self {
        Self::new(T::one(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e2 element."]
    #[inline]
    pub fn unit_e2() -> Self {
        Self::new(T::zero(), T::one(), T::zero())
    }
    #[doc = "Creates the unit e3 element."]
    #[inline]
    pub fn unit_e0() -> Self {
        Self::new(T::zero(), T::zero(), T::one())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.e1 * self.e1 + self.e2 * self.e2 + self.e0 * self.e0
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new(self.e1 * s, self.e2 * s, self.e0 * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new(self.e1, self.e2, self.e0)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new(-self.e1, -self.e2, -self.e0)
    }
}
impl<T: Float> Default for Point<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Scalar\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 0 | s | `s` |\n\n\n# Example\n\n```\nuse clifford::specialized::projective::dim2::Scalar;\n\nlet v = Scalar::new(1.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Scalar<T: Float> {
    #[doc = "Coefficient of `s`."]
    s: T,
}
impl<T: Float> Scalar<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(s: T) -> Self {
        Self { s }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(s: T) -> Self {
        Self::new(s)
    }
    #[doc = "Returns the `s` coefficient."]
    #[inline]
    pub fn s(&self) -> T {
        self.s
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new(T::zero())
    }
    #[doc = "Creates the unit s element."]
    #[inline]
    pub fn unit_s() -> Self {
        Self::new(T::one())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.s * self.s
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new(self.s * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new(self.s)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new(-self.s)
    }
}
impl<T: Float> Default for Scalar<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Trivector\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 7 | e1e2e3 | `e012` |\n\n\n# Example\n\n```\nuse clifford::specialized::projective::dim2::Trivector;\n\nlet v = Trivector::new(1.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Trivector<T: Float> {
    #[doc = "Coefficient of `e012`."]
    e012: T,
}
impl<T: Float> Trivector<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(e012: T) -> Self {
        Self { e012 }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(e012: T) -> Self {
        Self::new(e012)
    }
    #[doc = "Returns the `e012` coefficient."]
    #[inline]
    pub fn e012(&self) -> T {
        self.e012
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new(T::zero())
    }
    #[doc = "Creates the unit e1e2e3 element."]
    #[inline]
    pub fn unit_e012() -> Self {
        Self::new(T::one())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.e012 * self.e012
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new(self.e012 * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new(-self.e012)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new(self.e012)
    }
}
impl<T: Float> Default for Trivector<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "A bulk-normalized Flector (bulk norm = 1).\n\nThis type alias wraps Flector in `Bulk<T>`, which normalizes by the bulk (non-degenerate) part of the norm."]
pub type BulkFlector<T> = crate::wrappers::Bulk<Flector<T>>;
#[doc = "A unitized Flector (weight norm = 1).\n\nThis type alias wraps Flector in `Unitized<T>`, which normalizes by the weight (degenerate) part of the norm."]
pub type UnitizedFlector<T> = crate::wrappers::Unitized<Flector<T>>;
#[doc = "A bulk-normalized Line (bulk norm = 1).\n\nThis type alias wraps Line in `Bulk<T>`, which normalizes by the bulk (non-degenerate) part of the norm."]
pub type BulkLine<T> = crate::wrappers::Bulk<Line<T>>;
#[doc = "A unitized Line (weight norm = 1).\n\nThis type alias wraps Line in `Unitized<T>`, which normalizes by the weight (degenerate) part of the norm."]
pub type UnitizedLine<T> = crate::wrappers::Unitized<Line<T>>;
#[doc = "A bulk-normalized Motor (bulk norm = 1).\n\nThis type alias wraps Motor in `Bulk<T>`, which normalizes by the bulk (non-degenerate) part of the norm."]
pub type BulkMotor<T> = crate::wrappers::Bulk<Motor<T>>;
#[doc = "A unitized Motor (weight norm = 1).\n\nThis type alias wraps Motor in `Unitized<T>`, which normalizes by the weight (degenerate) part of the norm."]
pub type UnitizedMotor<T> = crate::wrappers::Unitized<Motor<T>>;
#[doc = "A bulk-normalized Point (bulk norm = 1).\n\nThis type alias wraps Point in `Bulk<T>`, which normalizes by the bulk (non-degenerate) part of the norm."]
pub type BulkPoint<T> = crate::wrappers::Bulk<Point<T>>;
#[doc = "A unitized Point (weight norm = 1).\n\nThis type alias wraps Point in `Unitized<T>`, which normalizes by the weight (degenerate) part of the norm."]
pub type UnitizedPoint<T> = crate::wrappers::Unitized<Point<T>>;
#[doc = "A bulk-normalized Trivector (bulk norm = 1).\n\nThis type alias wraps Trivector in `Bulk<T>`, which normalizes by the bulk (non-degenerate) part of the norm."]
pub type BulkTrivector<T> = crate::wrappers::Bulk<Trivector<T>>;
#[doc = "A unitized Trivector (weight norm = 1).\n\nThis type alias wraps Trivector in `Unitized<T>`, which normalizes by the weight (degenerate) part of the norm."]
pub type UnitizedTrivector<T> = crate::wrappers::Unitized<Trivector<T>>;
