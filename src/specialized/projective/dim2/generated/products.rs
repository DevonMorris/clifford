#![doc = " Product functions for the projective2 algebra."]
#![doc = ""]
#![doc = " This module provides all algebraic products between types in the algebra."]
#![doc = " Each function is named `{product}_{lhs}_{rhs}` where:"]
#![doc = " - `product` is one of: `geometric`, `exterior`, `left_contract`, `inner`, `scalar`"]
#![doc = " - `lhs` and `rhs` are the input type names in lowercase"]
#![doc = ""]
#![doc = " # Available Products"]
#![doc = ""]
#![doc = " | Product | Symbol | Description |"]
#![doc = " |---------|--------|-------------|"]
#![doc = " | `geometric_*` | `×` | Full geometric product |"]
#![doc = " | `exterior_*` | `∧` | Wedge/exterior product (grade sum) |"]
#![doc = " | `left_contract_*` | `⌋` | Left contraction |"]
#![doc = " | `inner_*` | `·` | Symmetric inner product (grade diff) |"]
#![doc = " | `scalar_*` | `⟨⟩₀` | Scalar (grade-0) product |"]
#![doc = ""]
#![doc = " # Sandwich Products"]
#![doc = ""]
#![doc = " For versor types (rotors, motors), sandwich products are provided:"]
#![doc = " - `sandwich_{versor}_{operand}(v, x)` computes `v × x × rev(v)`"]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen. Do not edit manually."]
use super::types::{Line, Motor, Point, Scalar, Trivector};
use crate::scalar::Float;
#[doc = "Geometric product: Line * Line -> Motor"]
#[inline]
pub fn geometric_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Motor<T> {
    Motor::new(
        -(a.e12() * b.e12()),
        T::zero(),
        a.e12() * b.e02() + -(a.e02() * b.e12()),
        -(a.e12() * b.e01()) + a.e01() * b.e12(),
    )
}
#[doc = "Geometric product: Line * Motor -> Motor"]
#[inline]
pub fn geometric_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        -(a.e12() * b.e12()),
        a.e12() * b.s(),
        a.e12() * b.e02() + a.e01() * b.s() + -(a.e02() * b.e12()),
        -(a.e12() * b.e01()) + a.e01() * b.e12() + a.e02() * b.s(),
    )
}
#[doc = "Geometric product: Line * Scalar -> Line"]
#[inline]
pub fn geometric_line_scalar<T: Float>(a: &Line<T>, b: &Scalar<T>) -> Line<T> {
    Line::new(a.e12() * b.s(), a.e01() * b.s(), a.e02() * b.s())
}
#[doc = "Geometric product: Line * Trivector -> Point"]
#[inline]
pub fn geometric_line_trivector<T: Float>(a: &Line<T>, b: &Trivector<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), -(a.e12() * b.e012()))
}
#[doc = "Geometric product: Motor * Line -> Motor"]
#[inline]
pub fn geometric_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Motor<T> {
    Motor::new(
        -(a.e12() * b.e12()),
        b.e12() * a.s(),
        a.e12() * b.e02() + -(a.e02() * b.e12()) + b.e01() * a.s(),
        -(a.e12() * b.e01()) + a.e01() * b.e12() + b.e02() * a.s(),
    )
}
#[doc = "Geometric product: Motor * Motor -> Motor"]
#[inline]
pub fn geometric_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        -(a.e12() * b.e12()) + b.s() * a.s(),
        a.e12() * b.s() + b.e12() * a.s(),
        a.e12() * b.e02() + a.e01() * b.s() + -(a.e02() * b.e12()) + b.e01() * a.s(),
        -(a.e12() * b.e01()) + a.e01() * b.e12() + a.e02() * b.s() + b.e02() * a.s(),
    )
}
#[doc = "Geometric product: Motor * Scalar -> Motor"]
#[inline]
pub fn geometric_motor_scalar<T: Float>(a: &Motor<T>, b: &Scalar<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.s(),
        a.e12() * b.s(),
        a.e01() * b.s(),
        a.e02() * b.s(),
    )
}
#[doc = "Geometric product: Point * Point -> Motor"]
#[inline]
pub fn geometric_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> Motor<T> {
    Motor::new(
        a.e1() * b.e1() + a.e2() * b.e2(),
        a.e1() * b.e2() + -(a.e2() * b.e1()),
        a.e1() * b.e0() + -(a.e0() * b.e1()),
        a.e2() * b.e0() + -(a.e0() * b.e2()),
    )
}
#[doc = "Geometric product: Point * Scalar -> Point"]
#[inline]
pub fn geometric_point_scalar<T: Float>(a: &Point<T>, b: &Scalar<T>) -> Point<T> {
    Point::new(b.s() * a.e1(), b.s() * a.e2(), b.s() * a.e0())
}
#[doc = "Geometric product: Point * Trivector -> Line"]
#[inline]
pub fn geometric_point_trivector<T: Float>(a: &Point<T>, b: &Trivector<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e012() * a.e2()), b.e012() * a.e1())
}
#[doc = "Geometric product: Scalar * Line -> Line"]
#[inline]
pub fn geometric_scalar_line<T: Float>(a: &Scalar<T>, b: &Line<T>) -> Line<T> {
    Line::new(b.e12() * a.s(), b.e01() * a.s(), b.e02() * a.s())
}
#[doc = "Geometric product: Scalar * Motor -> Motor"]
#[inline]
pub fn geometric_scalar_motor<T: Float>(a: &Scalar<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.s(),
        b.e12() * a.s(),
        b.e01() * a.s(),
        b.e02() * a.s(),
    )
}
#[doc = "Geometric product: Scalar * Point -> Point"]
#[inline]
pub fn geometric_scalar_point<T: Float>(a: &Scalar<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.s() * b.e1(), a.s() * b.e2(), a.s() * b.e0())
}
#[doc = "Geometric product: Scalar * Scalar -> Scalar"]
#[inline]
pub fn geometric_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(b.s() * a.s())
}
#[doc = "Geometric product: Scalar * Trivector -> Trivector"]
#[inline]
pub fn geometric_scalar_trivector<T: Float>(a: &Scalar<T>, b: &Trivector<T>) -> Trivector<T> {
    Trivector::new(b.e012() * a.s())
}
#[doc = "Geometric product: Trivector * Line -> Point"]
#[inline]
pub fn geometric_trivector_line<T: Float>(a: &Trivector<T>, b: &Line<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), -(b.e12() * a.e012()))
}
#[doc = "Geometric product: Trivector * Point -> Line"]
#[inline]
pub fn geometric_trivector_point<T: Float>(a: &Trivector<T>, b: &Point<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e2() * a.e012()), b.e1() * a.e012())
}
#[doc = "Geometric product: Trivector * Scalar -> Trivector"]
#[inline]
pub fn geometric_trivector_scalar<T: Float>(a: &Trivector<T>, b: &Scalar<T>) -> Trivector<T> {
    Trivector::new(b.s() * a.e012())
}
#[doc = "Exterior product: Line ^ Motor -> Line"]
#[inline]
pub fn exterior_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Line<T> {
    Line::new(a.e12() * b.s(), a.e01() * b.s(), a.e02() * b.s())
}
#[doc = "Exterior product: Line ^ Point -> Trivector"]
#[inline]
pub fn exterior_line_point<T: Float>(a: &Line<T>, b: &Point<T>) -> Trivector<T> {
    Trivector::new(a.e12() * b.e0() + -(a.e01() * b.e2()) + a.e02() * b.e1())
}
#[doc = "Exterior product: Line ^ Scalar -> Line"]
#[inline]
pub fn exterior_line_scalar<T: Float>(a: &Line<T>, b: &Scalar<T>) -> Line<T> {
    Line::new(a.e12() * b.s(), a.e01() * b.s(), a.e02() * b.s())
}
#[doc = "Exterior product: Motor ^ Line -> Line"]
#[inline]
pub fn exterior_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Line<T> {
    Line::new(b.e12() * a.s(), b.e01() * a.s(), b.e02() * a.s())
}
#[doc = "Exterior product: Motor ^ Motor -> Motor"]
#[inline]
pub fn exterior_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.s(),
        a.e12() * b.s() + b.e12() * a.s(),
        a.e01() * b.s() + b.e01() * a.s(),
        a.e02() * b.s() + b.e02() * a.s(),
    )
}
#[doc = "Exterior product: Motor ^ Scalar -> Motor"]
#[inline]
pub fn exterior_motor_scalar<T: Float>(a: &Motor<T>, b: &Scalar<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.s(),
        a.e12() * b.s(),
        a.e01() * b.s(),
        a.e02() * b.s(),
    )
}
#[doc = "Exterior product: Motor ^ Trivector -> Trivector"]
#[inline]
pub fn exterior_motor_trivector<T: Float>(a: &Motor<T>, b: &Trivector<T>) -> Trivector<T> {
    Trivector::new(b.e012() * a.s())
}
#[doc = "Exterior product: Point ^ Line -> Trivector"]
#[inline]
pub fn exterior_point_line<T: Float>(a: &Point<T>, b: &Line<T>) -> Trivector<T> {
    Trivector::new(b.e12() * a.e0() + -(b.e01() * a.e2()) + b.e02() * a.e1())
}
#[doc = "Exterior product: Point ^ Point -> Line"]
#[inline]
pub fn exterior_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> Line<T> {
    Line::new(
        a.e1() * b.e2() + -(a.e2() * b.e1()),
        a.e1() * b.e0() + -(a.e0() * b.e1()),
        a.e2() * b.e0() + -(a.e0() * b.e2()),
    )
}
#[doc = "Exterior product: Point ^ Scalar -> Point"]
#[inline]
pub fn exterior_point_scalar<T: Float>(a: &Point<T>, b: &Scalar<T>) -> Point<T> {
    Point::new(b.s() * a.e1(), b.s() * a.e2(), b.s() * a.e0())
}
#[doc = "Exterior product: Scalar ^ Line -> Line"]
#[inline]
pub fn exterior_scalar_line<T: Float>(a: &Scalar<T>, b: &Line<T>) -> Line<T> {
    Line::new(b.e12() * a.s(), b.e01() * a.s(), b.e02() * a.s())
}
#[doc = "Exterior product: Scalar ^ Motor -> Motor"]
#[inline]
pub fn exterior_scalar_motor<T: Float>(a: &Scalar<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.s(),
        b.e12() * a.s(),
        b.e01() * a.s(),
        b.e02() * a.s(),
    )
}
#[doc = "Exterior product: Scalar ^ Point -> Point"]
#[inline]
pub fn exterior_scalar_point<T: Float>(a: &Scalar<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.s() * b.e1(), a.s() * b.e2(), a.s() * b.e0())
}
#[doc = "Exterior product: Scalar ^ Scalar -> Scalar"]
#[inline]
pub fn exterior_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(b.s() * a.s())
}
#[doc = "Exterior product: Scalar ^ Trivector -> Trivector"]
#[inline]
pub fn exterior_scalar_trivector<T: Float>(a: &Scalar<T>, b: &Trivector<T>) -> Trivector<T> {
    Trivector::new(b.e012() * a.s())
}
#[doc = "Exterior product: Trivector ^ Motor -> Trivector"]
#[inline]
pub fn exterior_trivector_motor<T: Float>(a: &Trivector<T>, b: &Motor<T>) -> Trivector<T> {
    Trivector::new(b.s() * a.e012())
}
#[doc = "Exterior product: Trivector ^ Scalar -> Trivector"]
#[inline]
pub fn exterior_trivector_scalar<T: Float>(a: &Trivector<T>, b: &Scalar<T>) -> Trivector<T> {
    Trivector::new(b.s() * a.e012())
}
#[doc = "Interior product (symmetric inner): Line · Line -> Scalar"]
#[inline]
pub fn interior_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(-(a.e12() * b.e12()))
}
#[doc = "Interior product (symmetric inner): Line · Motor -> Motor"]
#[inline]
pub fn interior_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        -(a.e12() * b.e12()),
        a.e12() * b.s(),
        a.e12() * b.e02() + a.e01() * b.s() + -(a.e02() * b.e12()),
        -(a.e12() * b.e01()) + a.e01() * b.e12() + a.e02() * b.s(),
    )
}
#[doc = "Interior product (symmetric inner): Line · Point -> Point"]
#[inline]
pub fn interior_line_point<T: Float>(a: &Line<T>, b: &Point<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e2(),
        -(a.e12() * b.e1()),
        -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
    )
}
#[doc = "Interior product (symmetric inner): Line · Scalar -> Line"]
#[inline]
pub fn interior_line_scalar<T: Float>(a: &Line<T>, b: &Scalar<T>) -> Line<T> {
    Line::new(a.e12() * b.s(), a.e01() * b.s(), a.e02() * b.s())
}
#[doc = "Interior product (symmetric inner): Line · Trivector -> Point"]
#[inline]
pub fn interior_line_trivector<T: Float>(a: &Line<T>, b: &Trivector<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), -(a.e12() * b.e012()))
}
#[doc = "Interior product (symmetric inner): Motor · Line -> Motor"]
#[inline]
pub fn interior_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Motor<T> {
    Motor::new(
        -(a.e12() * b.e12()),
        b.e12() * a.s(),
        a.e12() * b.e02() + -(a.e02() * b.e12()) + b.e01() * a.s(),
        -(a.e12() * b.e01()) + a.e01() * b.e12() + b.e02() * a.s(),
    )
}
#[doc = "Interior product (symmetric inner): Motor · Motor -> Motor"]
#[inline]
pub fn interior_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        -(a.e12() * b.e12()) + b.s() * a.s(),
        a.e12() * b.s() + b.e12() * a.s(),
        a.e12() * b.e02() + a.e01() * b.s() + -(a.e02() * b.e12()) + b.e01() * a.s(),
        -(a.e12() * b.e01()) + a.e01() * b.e12() + a.e02() * b.s() + b.e02() * a.s(),
    )
}
#[doc = "Interior product (symmetric inner): Motor · Point -> Point"]
#[inline]
pub fn interior_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e2() + a.s() * b.e1(),
        -(a.e12() * b.e1()) + a.s() * b.e2(),
        -(a.e01() * b.e1()) + -(a.e02() * b.e2()) + a.s() * b.e0(),
    )
}
#[doc = "Interior product (symmetric inner): Motor · Scalar -> Motor"]
#[inline]
pub fn interior_motor_scalar<T: Float>(a: &Motor<T>, b: &Scalar<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.s(),
        a.e12() * b.s(),
        a.e01() * b.s(),
        a.e02() * b.s(),
    )
}
#[doc = "Interior product (symmetric inner): Point · Line -> Point"]
#[inline]
pub fn interior_point_line<T: Float>(a: &Point<T>, b: &Line<T>) -> Point<T> {
    Point::new(
        -(b.e12() * a.e2()),
        b.e12() * a.e1(),
        b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Interior product (symmetric inner): Point · Motor -> Point"]
#[inline]
pub fn interior_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Point<T> {
    Point::new(
        -(b.e12() * a.e2()) + b.s() * a.e1(),
        b.e12() * a.e1() + b.s() * a.e2(),
        b.e01() * a.e1() + b.e02() * a.e2() + b.s() * a.e0(),
    )
}
#[doc = "Interior product (symmetric inner): Point · Point -> Scalar"]
#[inline]
pub fn interior_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> Scalar<T> {
    Scalar::new(a.e1() * b.e1() + a.e2() * b.e2())
}
#[doc = "Interior product (symmetric inner): Point · Scalar -> Point"]
#[inline]
pub fn interior_point_scalar<T: Float>(a: &Point<T>, b: &Scalar<T>) -> Point<T> {
    Point::new(b.s() * a.e1(), b.s() * a.e2(), b.s() * a.e0())
}
#[doc = "Interior product (symmetric inner): Point · Trivector -> Line"]
#[inline]
pub fn interior_point_trivector<T: Float>(a: &Point<T>, b: &Trivector<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e012() * a.e2()), b.e012() * a.e1())
}
#[doc = "Interior product (symmetric inner): Scalar · Line -> Line"]
#[inline]
pub fn interior_scalar_line<T: Float>(a: &Scalar<T>, b: &Line<T>) -> Line<T> {
    Line::new(b.e12() * a.s(), b.e01() * a.s(), b.e02() * a.s())
}
#[doc = "Interior product (symmetric inner): Scalar · Motor -> Motor"]
#[inline]
pub fn interior_scalar_motor<T: Float>(a: &Scalar<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.s(),
        b.e12() * a.s(),
        b.e01() * a.s(),
        b.e02() * a.s(),
    )
}
#[doc = "Interior product (symmetric inner): Scalar · Point -> Point"]
#[inline]
pub fn interior_scalar_point<T: Float>(a: &Scalar<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.s() * b.e1(), a.s() * b.e2(), a.s() * b.e0())
}
#[doc = "Interior product (symmetric inner): Scalar · Scalar -> Scalar"]
#[inline]
pub fn interior_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(b.s() * a.s())
}
#[doc = "Interior product (symmetric inner): Scalar · Trivector -> Trivector"]
#[inline]
pub fn interior_scalar_trivector<T: Float>(a: &Scalar<T>, b: &Trivector<T>) -> Trivector<T> {
    Trivector::new(b.e012() * a.s())
}
#[doc = "Interior product (symmetric inner): Trivector · Line -> Point"]
#[inline]
pub fn interior_trivector_line<T: Float>(a: &Trivector<T>, b: &Line<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), -(b.e12() * a.e012()))
}
#[doc = "Interior product (symmetric inner): Trivector · Point -> Line"]
#[inline]
pub fn interior_trivector_point<T: Float>(a: &Trivector<T>, b: &Point<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e2() * a.e012()), b.e1() * a.e012())
}
#[doc = "Interior product (symmetric inner): Trivector · Scalar -> Trivector"]
#[inline]
pub fn interior_trivector_scalar<T: Float>(a: &Trivector<T>, b: &Scalar<T>) -> Trivector<T> {
    Trivector::new(b.s() * a.e012())
}
#[doc = "Left contraction: Line | Line -> Scalar"]
#[inline]
pub fn left_contract_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(-(a.e12() * b.e12()))
}
#[doc = "Left contraction: Line | Motor -> Scalar"]
#[inline]
pub fn left_contract_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Scalar<T> {
    Scalar::new(-(a.e12() * b.e12()))
}
#[doc = "Left contraction: Line | Trivector -> Point"]
#[inline]
pub fn left_contract_line_trivector<T: Float>(a: &Line<T>, b: &Trivector<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), -(a.e12() * b.e012()))
}
#[doc = "Left contraction: Motor | Line -> Motor"]
#[inline]
pub fn left_contract_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Motor<T> {
    Motor::new(
        -(a.e12() * b.e12()),
        b.e12() * a.s(),
        b.e01() * a.s(),
        b.e02() * a.s(),
    )
}
#[doc = "Left contraction: Motor | Motor -> Motor"]
#[inline]
pub fn left_contract_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        -(a.e12() * b.e12()) + b.s() * a.s(),
        b.e12() * a.s(),
        b.e01() * a.s(),
        b.e02() * a.s(),
    )
}
#[doc = "Left contraction: Motor | Point -> Point"]
#[inline]
pub fn left_contract_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.s() * b.e1(), a.s() * b.e2(), a.s() * b.e0())
}
#[doc = "Left contraction: Motor | Scalar -> Scalar"]
#[inline]
pub fn left_contract_motor_scalar<T: Float>(a: &Motor<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(b.s() * a.s())
}
#[doc = "Left contraction: Point | Line -> Point"]
#[inline]
pub fn left_contract_point_line<T: Float>(a: &Point<T>, b: &Line<T>) -> Point<T> {
    Point::new(
        -(b.e12() * a.e2()),
        b.e12() * a.e1(),
        b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Left contraction: Point | Motor -> Point"]
#[inline]
pub fn left_contract_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Point<T> {
    Point::new(
        -(b.e12() * a.e2()),
        b.e12() * a.e1(),
        b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Left contraction: Point | Point -> Scalar"]
#[inline]
pub fn left_contract_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> Scalar<T> {
    Scalar::new(a.e1() * b.e1() + a.e2() * b.e2())
}
#[doc = "Left contraction: Point | Trivector -> Line"]
#[inline]
pub fn left_contract_point_trivector<T: Float>(a: &Point<T>, b: &Trivector<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e012() * a.e2()), b.e012() * a.e1())
}
#[doc = "Left contraction: Scalar | Line -> Line"]
#[inline]
pub fn left_contract_scalar_line<T: Float>(a: &Scalar<T>, b: &Line<T>) -> Line<T> {
    Line::new(b.e12() * a.s(), b.e01() * a.s(), b.e02() * a.s())
}
#[doc = "Left contraction: Scalar | Motor -> Motor"]
#[inline]
pub fn left_contract_scalar_motor<T: Float>(a: &Scalar<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.s(),
        b.e12() * a.s(),
        b.e01() * a.s(),
        b.e02() * a.s(),
    )
}
#[doc = "Left contraction: Scalar | Point -> Point"]
#[inline]
pub fn left_contract_scalar_point<T: Float>(a: &Scalar<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.s() * b.e1(), a.s() * b.e2(), a.s() * b.e0())
}
#[doc = "Left contraction: Scalar | Scalar -> Scalar"]
#[inline]
pub fn left_contract_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(b.s() * a.s())
}
#[doc = "Left contraction: Scalar | Trivector -> Trivector"]
#[inline]
pub fn left_contract_scalar_trivector<T: Float>(a: &Scalar<T>, b: &Trivector<T>) -> Trivector<T> {
    Trivector::new(b.e012() * a.s())
}
#[doc = "Right contraction: Line ⌊ Line -> Scalar"]
#[inline]
pub fn right_contract_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(-(a.e12() * b.e12()))
}
#[doc = "Right contraction: Line ⌊ Motor -> Motor"]
#[inline]
pub fn right_contract_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        -(a.e12() * b.e12()),
        a.e12() * b.s(),
        a.e12() * b.e02() + a.e01() * b.s() + -(a.e02() * b.e12()),
        -(a.e12() * b.e01()) + a.e01() * b.e12() + a.e02() * b.s(),
    )
}
#[doc = "Right contraction: Line ⌊ Point -> Point"]
#[inline]
pub fn right_contract_line_point<T: Float>(a: &Line<T>, b: &Point<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e2(),
        -(a.e12() * b.e1()),
        -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
    )
}
#[doc = "Right contraction: Line ⌊ Scalar -> Line"]
#[inline]
pub fn right_contract_line_scalar<T: Float>(a: &Line<T>, b: &Scalar<T>) -> Line<T> {
    Line::new(a.e12() * b.s(), a.e01() * b.s(), a.e02() * b.s())
}
#[doc = "Right contraction: Motor ⌊ Line -> Scalar"]
#[inline]
pub fn right_contract_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(-(a.e12() * b.e12()))
}
#[doc = "Right contraction: Motor ⌊ Motor -> Motor"]
#[inline]
pub fn right_contract_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        -(a.e12() * b.e12()) + b.s() * a.s(),
        a.e12() * b.s() + b.e12() * a.s(),
        a.e12() * b.e02() + a.e01() * b.s() + -(a.e02() * b.e12()) + b.e01() * a.s(),
        -(a.e12() * b.e01()) + a.e01() * b.e12() + a.e02() * b.s() + b.e02() * a.s(),
    )
}
#[doc = "Right contraction: Motor ⌊ Point -> Point"]
#[inline]
pub fn right_contract_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e2() + a.s() * b.e1(),
        -(a.e12() * b.e1()) + a.s() * b.e2(),
        -(a.e01() * b.e1()) + -(a.e02() * b.e2()) + a.s() * b.e0(),
    )
}
#[doc = "Right contraction: Motor ⌊ Scalar -> Motor"]
#[inline]
pub fn right_contract_motor_scalar<T: Float>(a: &Motor<T>, b: &Scalar<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.s(),
        a.e12() * b.s(),
        a.e01() * b.s(),
        a.e02() * b.s(),
    )
}
#[doc = "Right contraction: Point ⌊ Motor -> Point"]
#[inline]
pub fn right_contract_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Point<T> {
    Point::new(
        -(b.e12() * a.e2()) + b.s() * a.e1(),
        b.e12() * a.e1() + b.s() * a.e2(),
        b.e01() * a.e1() + b.e02() * a.e2() + b.s() * a.e0(),
    )
}
#[doc = "Right contraction: Point ⌊ Point -> Scalar"]
#[inline]
pub fn right_contract_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> Scalar<T> {
    Scalar::new(a.e1() * b.e1() + a.e2() * b.e2())
}
#[doc = "Right contraction: Point ⌊ Scalar -> Point"]
#[inline]
pub fn right_contract_point_scalar<T: Float>(a: &Point<T>, b: &Scalar<T>) -> Point<T> {
    Point::new(b.s() * a.e1(), b.s() * a.e2(), b.s() * a.e0())
}
#[doc = "Right contraction: Scalar ⌊ Motor -> Scalar"]
#[inline]
pub fn right_contract_scalar_motor<T: Float>(a: &Scalar<T>, b: &Motor<T>) -> Scalar<T> {
    Scalar::new(b.s() * a.s())
}
#[doc = "Right contraction: Scalar ⌊ Scalar -> Scalar"]
#[inline]
pub fn right_contract_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(b.s() * a.s())
}
#[doc = "Right contraction: Trivector ⌊ Line -> Point"]
#[inline]
pub fn right_contract_trivector_line<T: Float>(a: &Trivector<T>, b: &Line<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), -(b.e12() * a.e012()))
}
#[doc = "Right contraction: Trivector ⌊ Point -> Line"]
#[inline]
pub fn right_contract_trivector_point<T: Float>(a: &Trivector<T>, b: &Point<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e2() * a.e012()), b.e1() * a.e012())
}
#[doc = "Right contraction: Trivector ⌊ Scalar -> Trivector"]
#[inline]
pub fn right_contract_trivector_scalar<T: Float>(a: &Trivector<T>, b: &Scalar<T>) -> Trivector<T> {
    Trivector::new(b.s() * a.e012())
}
#[doc = "Regressive product (meet): Line ∨ Line -> Point"]
#[inline]
pub fn regressive_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e01() - a.e01() * b.e12(),
        a.e12() * b.e02() - a.e02() * b.e12(),
        a.e01() * b.e02() - a.e02() * b.e01(),
    )
}
#[doc = "Regressive product (meet): Line ∨ Motor -> Point"]
#[inline]
pub fn regressive_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e01() - a.e01() * b.e12(),
        a.e12() * b.e02() - a.e02() * b.e12(),
        a.e01() * b.e02() - a.e02() * b.e01(),
    )
}
#[doc = "Regressive product (meet): Line ∨ Point -> Scalar"]
#[inline]
pub fn regressive_line_point<T: Float>(a: &Line<T>, b: &Point<T>) -> Scalar<T> {
    Scalar::new(a.e12() * b.e0() - a.e01() * b.e2() + a.e02() * b.e1())
}
#[doc = "Regressive product (meet): Line ∨ Trivector -> Line"]
#[inline]
pub fn regressive_line_trivector<T: Float>(a: &Line<T>, b: &Trivector<T>) -> Line<T> {
    Line::new(a.e12() * b.e012(), a.e01() * b.e012(), a.e02() * b.e012())
}
#[doc = "Regressive product (meet): Motor ∨ Line -> Point"]
#[inline]
pub fn regressive_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e01() - a.e01() * b.e12(),
        a.e12() * b.e02() - a.e02() * b.e12(),
        a.e01() * b.e02() - a.e02() * b.e01(),
    )
}
#[doc = "Regressive product (meet): Motor ∨ Motor -> Point"]
#[inline]
pub fn regressive_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e01() - a.e01() * b.e12(),
        a.e12() * b.e02() - a.e02() * b.e12(),
        a.e01() * b.e02() - a.e02() * b.e01(),
    )
}
#[doc = "Regressive product (meet): Motor ∨ Point -> Scalar"]
#[inline]
pub fn regressive_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Scalar<T> {
    Scalar::new(a.e12() * b.e0() - a.e01() * b.e2() + a.e02() * b.e1())
}
#[doc = "Regressive product (meet): Motor ∨ Trivector -> Motor"]
#[inline]
pub fn regressive_motor_trivector<T: Float>(a: &Motor<T>, b: &Trivector<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e012(),
        a.e12() * b.e012(),
        a.e01() * b.e012(),
        a.e02() * b.e012(),
    )
}
#[doc = "Regressive product (meet): Point ∨ Line -> Scalar"]
#[inline]
pub fn regressive_point_line<T: Float>(a: &Point<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(a.e1() * b.e02() - a.e2() * b.e01() + a.e0() * b.e12())
}
#[doc = "Regressive product (meet): Point ∨ Motor -> Scalar"]
#[inline]
pub fn regressive_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Scalar<T> {
    Scalar::new(a.e1() * b.e02() - a.e2() * b.e01() + a.e0() * b.e12())
}
#[doc = "Regressive product (meet): Point ∨ Trivector -> Point"]
#[inline]
pub fn regressive_point_trivector<T: Float>(a: &Point<T>, b: &Trivector<T>) -> Point<T> {
    Point::new(a.e1() * b.e012(), a.e2() * b.e012(), a.e0() * b.e012())
}
#[doc = "Regressive product (meet): Scalar ∨ Trivector -> Scalar"]
#[inline]
pub fn regressive_scalar_trivector<T: Float>(a: &Scalar<T>, b: &Trivector<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.e012())
}
#[doc = "Regressive product (meet): Trivector ∨ Line -> Line"]
#[inline]
pub fn regressive_trivector_line<T: Float>(a: &Trivector<T>, b: &Line<T>) -> Line<T> {
    Line::new(a.e012() * b.e12(), a.e012() * b.e01(), a.e012() * b.e02())
}
#[doc = "Regressive product (meet): Trivector ∨ Motor -> Motor"]
#[inline]
pub fn regressive_trivector_motor<T: Float>(a: &Trivector<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.e012() * b.s(),
        a.e012() * b.e12(),
        a.e012() * b.e01(),
        a.e012() * b.e02(),
    )
}
#[doc = "Regressive product (meet): Trivector ∨ Point -> Point"]
#[inline]
pub fn regressive_trivector_point<T: Float>(a: &Trivector<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.e012() * b.e1(), a.e012() * b.e2(), a.e012() * b.e0())
}
#[doc = "Regressive product (meet): Trivector ∨ Scalar -> Scalar"]
#[inline]
pub fn regressive_trivector_scalar<T: Float>(a: &Trivector<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.e012() * b.s())
}
#[doc = "Regressive product (meet): Trivector ∨ Trivector -> Trivector"]
#[inline]
pub fn regressive_trivector_trivector<T: Float>(
    a: &Trivector<T>,
    b: &Trivector<T>,
) -> Trivector<T> {
    Trivector::new(a.e012() * b.e012())
}
#[doc = "Scalar product: Line * Line -> T (grade-0 part)"]
#[inline]
pub fn scalar_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> T {
    -(a.e12() * b.e12())
}
#[doc = "Scalar product: Line * Motor -> T (grade-0 part)"]
#[inline]
pub fn scalar_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> T {
    -(a.e12() * b.e12())
}
#[doc = "Scalar product: Motor * Line -> T (grade-0 part)"]
#[inline]
pub fn scalar_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> T {
    -(a.e12() * b.e12())
}
#[doc = "Scalar product: Motor * Motor -> T (grade-0 part)"]
#[inline]
pub fn scalar_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> T {
    a.s() * b.s() - a.e12() * b.e12()
}
#[doc = "Scalar product: Motor * Scalar -> T (grade-0 part)"]
#[inline]
pub fn scalar_motor_scalar<T: Float>(a: &Motor<T>, b: &Scalar<T>) -> T {
    a.s() * b.s()
}
#[doc = "Scalar product: Point * Point -> T (grade-0 part)"]
#[inline]
pub fn scalar_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> T {
    a.e1() * b.e1() + a.e2() * b.e2()
}
#[doc = "Scalar product: Scalar * Motor -> T (grade-0 part)"]
#[inline]
pub fn scalar_scalar_motor<T: Float>(a: &Scalar<T>, b: &Motor<T>) -> T {
    a.s() * b.s()
}
#[doc = "Scalar product: Scalar * Scalar -> T (grade-0 part)"]
#[inline]
pub fn scalar_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> T {
    a.s() * b.s()
}
#[doc = "Sandwich product: Motor * Point * rev(Motor) -> Point"]
#[inline]
pub fn sandwich_motor_point<T: Float>(v: &Motor<T>, x: &Point<T>) -> Point<T> {
    Point::new(
        v.s() * x.e1() * v.s() + v.e12() * x.e2() * v.s() + v.s() * x.e2() * v.e12()
            - v.e12() * x.e1() * v.e12(),
        -(v.s() * x.e1() * v.e12()) + v.s() * x.e2() * v.s()
            - v.e12() * x.e2() * v.e12()
            - v.e12() * x.e1() * v.s(),
        -(v.e01() * x.e2() * v.e12())
            - v.s() * x.e1() * v.e01()
            - v.e01() * x.e1() * v.s()
            - v.e12() * x.e2() * v.e01()
            + v.e02() * x.e1() * v.e12()
            - v.s() * x.e2() * v.e02()
            + v.e12() * x.e1() * v.e02()
            - v.e02() * x.e2() * v.s()
            + v.e12() * x.e0() * v.e12()
            + v.s() * x.e0() * v.s(),
    )
}
#[doc = "Sandwich product: Motor * Line * rev(Motor) -> Line"]
#[inline]
pub fn sandwich_motor_line<T: Float>(v: &Motor<T>, x: &Line<T>) -> Line<T> {
    Line::new(
        v.s() * x.e12() * v.s() + v.e12() * x.e12() * v.e12(),
        v.e12() * x.e12() * v.e01() + v.e01() * x.e12() * v.e12() - v.e02() * x.e12() * v.s()
            + v.e12() * x.e02() * v.s()
            + v.s() * x.e01() * v.s()
            - v.s() * x.e12() * v.e02()
            + v.s() * x.e02() * v.e12()
            - v.e12() * x.e01() * v.e12(),
        v.e12() * x.e12() * v.e02()
            + v.e02() * x.e12() * v.e12()
            + v.s() * x.e02() * v.s()
            + v.s() * x.e12() * v.e01()
            + v.e01() * x.e12() * v.s()
            - v.e12() * x.e01() * v.s()
            - v.s() * x.e01() * v.e12()
            - v.e12() * x.e02() * v.e12(),
    )
}
#[doc = "Sandwich product: Motor * Motor * rev(Motor) -> Motor"]
#[inline]
pub fn sandwich_motor_motor<T: Float>(v: &Motor<T>, x: &Motor<T>) -> Motor<T> {
    Motor::new(
        v.s() * x.e12() * v.e12() - v.e12() * x.e12() * v.s()
            + v.e12() * x.s() * v.e12()
            + v.s() * x.s() * v.s(),
        -(v.s() * x.s() * v.e12())
            + v.s() * x.e12() * v.s()
            + v.e12() * x.s() * v.s()
            + v.e12() * x.e12() * v.e12(),
        v.e12() * x.e12() * v.e01() - v.s() * x.s() * v.e01() - v.e12() * x.e01() * v.e12()
            + v.e01() * x.s() * v.s()
            + v.e01() * x.e12() * v.e12()
            + v.e12() * x.e02() * v.s()
            + v.e02() * x.s() * v.e12()
            - v.e02() * x.e12() * v.s()
            + v.s() * x.e01() * v.s()
            - v.s() * x.e12() * v.e02()
            - v.e12() * x.s() * v.e02()
            + v.s() * x.e02() * v.e12(),
        v.e01() * x.e12() * v.s()
            + v.e12() * x.s() * v.e01()
            + v.s() * x.e12() * v.e01()
            + v.s() * x.e02() * v.s()
            - v.e12() * x.e02() * v.e12()
            + v.e02() * x.s() * v.s()
            - v.s() * x.e01() * v.e12()
            + v.e12() * x.e12() * v.e02()
            - v.e01() * x.s() * v.e12()
            - v.s() * x.s() * v.e02()
            - v.e12() * x.e01() * v.s()
            + v.e02() * x.e12() * v.e12(),
    )
}
#[doc = "Antisandwich product: Motor ⊛ Point ⊛ antirev(Motor) -> Point\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_motor_point<T: Float>(v: &Motor<T>, x: &Point<T>) -> Point<T> {
    Point::new(
        v.e02() * x.e1() * v.e02()
            - v.e12() * x.e1() * v.e12()
            - v.e12() * x.e2() * v.s()
            - v.e01() * x.e1() * v.e01()
            - v.e01() * x.e0() * v.s()
            + v.s() * x.e1() * v.s()
            + v.e02() * x.e0() * v.e12()
            - v.e02() * x.e2() * v.e01()
            - v.s() * x.e2() * v.e12()
            + v.e12() * x.e0() * v.e02()
            - v.e01() * x.e2() * v.e02(),
        v.s() * x.e1() * v.e12() - v.e12() * x.e2() * v.e12() + v.s() * x.e2() * v.s()
            - v.e02() * x.e0() * v.s()
            + v.e12() * x.e1() * v.s()
            - v.e12() * x.e0() * v.e01()
            - v.e01() * x.e0() * v.e12()
            - v.e02() * x.e2() * v.e02()
            - v.e01() * x.e1() * v.e02()
            - v.e02() * x.e1() * v.e01()
            + v.e01() * x.e2() * v.e01(),
        v.s() * x.e1() * v.e01() + v.e12() * x.e1() * v.e02()
            - v.e12() * x.e2() * v.e01()
            - v.e01() * x.e2() * v.e12()
            + v.e02() * x.e1() * v.e12()
            + v.s() * x.e2() * v.e02()
            + v.e02() * x.e2() * v.s()
            - v.e02() * x.e0() * v.e02()
            - v.e01() * x.e0() * v.e01()
            + v.e12() * x.e0() * v.e12()
            + v.e01() * x.e1() * v.s(),
    )
}
#[doc = "Antisandwich product: Motor ⊛ Line ⊛ antirev(Motor) -> Line\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_motor_line<T: Float>(v: &Motor<T>, x: &Line<T>) -> Line<T> {
    Line::new(
        v.e12() * x.e01() * v.e01() - v.e01() * x.e12() * v.e01() + v.e01() * x.e01() * v.e12()
            - v.s() * x.e01() * v.e02()
            + v.e12() * x.e02() * v.e02()
            - v.e02() * x.e12() * v.e02()
            + v.e12() * x.e12() * v.e12()
            + v.e02() * x.e02() * v.e12()
            + v.s() * x.e02() * v.e01(),
        -(v.s() * x.e02() * v.e12())
            + v.s() * x.e01() * v.s()
            + v.s() * x.e12() * v.e02()
            + v.e01() * x.e12() * v.e12()
            + v.e12() * x.e12() * v.e01()
            - v.e12() * x.e01() * v.e12()
            + v.e01() * x.e01() * v.e01()
            + v.e01() * x.e02() * v.e02()
            + v.e02() * x.e12() * v.s()
            - v.e12() * x.e02() * v.s()
            - v.e02() * x.e01() * v.e02()
            + v.e02() * x.e02() * v.e01(),
        v.e01() * x.e01() * v.e02() + v.s() * x.e02() * v.s() - v.e01() * x.e02() * v.e01()
            + v.e02() * x.e02() * v.e02()
            - v.e12() * x.e02() * v.e12()
            + v.e02() * x.e12() * v.e12()
            - v.s() * x.e12() * v.e01()
            + v.s() * x.e01() * v.e12()
            + v.e12() * x.e12() * v.e02()
            - v.e01() * x.e12() * v.s()
            + v.e12() * x.e01() * v.s()
            + v.e02() * x.e01() * v.e01(),
    )
}
#[doc = "Antisandwich product: Motor ⊛ Motor ⊛ antirev(Motor) -> Motor\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_motor_motor<T: Float>(v: &Motor<T>, x: &Motor<T>) -> Motor<T> {
    Motor::new(
        v.s() * x.e02() * v.e02() - v.e12() * x.e12() * v.s() - v.e12() * x.e02() * v.e01()
            + v.e02() * x.e12() * v.e01()
            - v.e02() * x.e02() * v.s()
            + v.e02() * x.s() * v.e02()
            - v.e01() * x.e12() * v.e02()
            + v.e12() * x.e01() * v.e02()
            + v.e01() * x.e02() * v.e12()
            + v.s() * x.s() * v.s()
            + v.s() * x.e12() * v.e12()
            + v.e01() * x.s() * v.e01()
            + v.s() * x.e01() * v.e01()
            + v.e12() * x.s() * v.e12()
            - v.e01() * x.e01() * v.s()
            - v.e02() * x.e01() * v.e12(),
        -(v.s() * x.e01() * v.e02()) - v.e01() * x.s() * v.e02()
            + v.e02() * x.s() * v.e01()
            + v.e12() * x.e12() * v.e12()
            - v.s() * x.s() * v.e12()
            + v.s() * x.e02() * v.e01()
            + v.e12() * x.e02() * v.e02()
            - v.e01() * x.e12() * v.e01()
            - v.e02() * x.e12() * v.e02()
            + v.e02() * x.e02() * v.e12()
            + v.e12() * x.e01() * v.e01()
            + v.e01() * x.e01() * v.e12(),
        v.e01() * x.e12() * v.e12() - v.s() * x.s() * v.e01() + v.e01() * x.e02() * v.e02()
            - v.e02() * x.s() * v.e12()
            + v.e02() * x.e12() * v.s()
            + v.e01() * x.e01() * v.e01()
            - v.e12() * x.e01() * v.e12()
            + v.e02() * x.e02() * v.e01()
            + v.s() * x.e01() * v.s()
            - v.e12() * x.e02() * v.s()
            + v.e01() * x.s() * v.s()
            - v.s() * x.e02() * v.e12()
            + v.e12() * x.s() * v.e02()
            + v.s() * x.e12() * v.e02()
            + v.e12() * x.e12() * v.e01()
            - v.e02() * x.e01() * v.e02(),
        -(v.e01() * x.e02() * v.e01()) + v.e02() * x.e02() * v.e02()
            - v.e12() * x.e02() * v.e12()
            - v.s() * x.s() * v.e02()
            + v.e12() * x.e01() * v.s()
            + v.e02() * x.e01() * v.e01()
            + v.s() * x.e02() * v.s()
            + v.e01() * x.s() * v.e12()
            + v.s() * x.e01() * v.e12()
            - v.e01() * x.e12() * v.s()
            + v.e01() * x.e01() * v.e02()
            + v.e02() * x.s() * v.s()
            - v.e12() * x.s() * v.e01()
            + v.e02() * x.e12() * v.e12()
            + v.e12() * x.e12() * v.e02()
            - v.s() * x.e12() * v.e01(),
    )
}
#[doc = "Reverses the Line (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_line<T: Float>(a: &Line<T>) -> Line<T> {
    Line::new(-a.e12(), -a.e01(), -a.e02())
}
#[doc = "Reverses the Motor (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_motor<T: Float>(a: &Motor<T>) -> Motor<T> {
    Motor::new(a.s(), -a.e12(), -a.e01(), -a.e02())
}
#[doc = "Reverses the Point (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_point<T: Float>(a: &Point<T>) -> Point<T> {
    Point::new(a.e1(), a.e2(), a.e0())
}
#[doc = "Reverses the Scalar (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_scalar<T: Float>(a: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.s())
}
#[doc = "Reverses the Trivector (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_trivector<T: Float>(a: &Trivector<T>) -> Trivector<T> {
    Trivector::new(-a.e012())
}
#[doc = "Antireverses the Line (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_line<T: Float>(a: &Line<T>) -> Line<T> {
    Line::new(a.e12(), a.e01(), a.e02())
}
#[doc = "Antireverses the Motor (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_motor<T: Float>(a: &Motor<T>) -> Motor<T> {
    Motor::new(-a.s(), a.e12(), a.e01(), a.e02())
}
#[doc = "Antireverses the Point (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_point<T: Float>(a: &Point<T>) -> Point<T> {
    Point::new(-a.e1(), -a.e2(), -a.e0())
}
#[doc = "Antireverses the Scalar (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_scalar<T: Float>(a: &Scalar<T>) -> Scalar<T> {
    Scalar::new(-a.s())
}
#[doc = "Antireverses the Trivector (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_trivector<T: Float>(a: &Trivector<T>) -> Trivector<T> {
    Trivector::new(a.e012())
}
#[doc = "Computes the right complement of Line -> Point."]
#[inline]
pub fn complement_line<T: Float>(a: &Line<T>) -> Point<T> {
    Point::new(a.e02(), -a.e01(), a.e12())
}
#[doc = "Computes the right complement of Point -> Line."]
#[inline]
pub fn complement_point<T: Float>(a: &Point<T>) -> Line<T> {
    Line::new(a.e0(), -a.e2(), a.e1())
}
#[doc = "Computes the right complement of Scalar -> Trivector."]
#[inline]
pub fn complement_scalar<T: Float>(a: &Scalar<T>) -> Trivector<T> {
    Trivector::new(a.s())
}
#[doc = "Computes the right complement of Trivector -> Scalar."]
#[inline]
pub fn complement_trivector<T: Float>(a: &Trivector<T>) -> Scalar<T> {
    Scalar::new(a.e012())
}
