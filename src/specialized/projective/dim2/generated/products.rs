#![doc = " Product functions for the projective2 algebra."]
#![doc = ""]
#![doc = " This module provides all algebraic products between types in the algebra."]
#![doc = " Each function is named `{product}_{lhs}_{rhs}` where:"]
#![doc = " - `product` is one of: `geometric`, `exterior`, `left_contract`, `inner`, `scalar`"]
#![doc = " - `lhs` and `rhs` are the input type names in lowercase"]
#![doc = ""]
#![doc = " # Available Products"]
#![doc = ""]
#![doc = " | Product | Symbol | Description |"]
#![doc = " |---------|--------|-------------|"]
#![doc = " | `geometric_*` | `×` | Full geometric product |"]
#![doc = " | `exterior_*` | `∧` | Wedge/exterior product (grade sum) |"]
#![doc = " | `left_contract_*` | `⌋` | Left contraction |"]
#![doc = " | `inner_*` | `·` | Symmetric inner product (grade diff) |"]
#![doc = " | `scalar_*` | `⟨⟩₀` | Scalar (grade-0) product |"]
#![doc = ""]
#![doc = " # Sandwich Products"]
#![doc = ""]
#![doc = " For versor types (rotors, motors), sandwich products are provided:"]
#![doc = " - `sandwich_{versor}_{operand}(v, x)` computes `v × x × rev(v)`"]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen. Do not edit manually."]
use super::types::{Flector, Line, Motor, Point, Scalar, Trivector};
use crate::scalar::Float;
#[doc = "Geometric product: Flector * Flector -> Flector"]
#[inline]
pub fn geometric_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s() + -(a.e12() * b.e12()),
        a.s() * b.e12() + a.e12() * b.s(),
        a.s() * b.e01() + a.e12() * b.e02() + a.e01() * b.s() + -(a.e02() * b.e12()),
        a.s() * b.e02() + -(a.e12() * b.e01()) + a.e01() * b.e12() + a.e02() * b.s(),
    )
}
#[doc = "Geometric product: Flector * Line -> Flector"]
#[inline]
pub fn geometric_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> Flector<T> {
    Flector::new(
        -(a.e12() * b.e12()),
        a.s() * b.e12(),
        a.s() * b.e01() + a.e12() * b.e02() + -(a.e02() * b.e12()),
        a.s() * b.e02() + -(a.e12() * b.e01()) + a.e01() * b.e12(),
    )
}
#[doc = "Geometric product: Flector * Motor -> Motor"]
#[inline]
pub fn geometric_flector_motor<T: Float>(a: &Flector<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e1() + a.e12() * b.e2(),
        a.s() * b.e2() + -(a.e12() * b.e1()),
        a.s() * b.e0() + -(a.e12() * b.e012()) + -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
        a.s() * b.e012() + a.e12() * b.e0() + -(a.e01() * b.e2()) + a.e02() * b.e1(),
    )
}
#[doc = "Geometric product: Flector * Point -> Motor"]
#[inline]
pub fn geometric_flector_point<T: Float>(a: &Flector<T>, b: &Point<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e1() + a.e12() * b.e2(),
        a.s() * b.e2() + -(a.e12() * b.e1()),
        a.s() * b.e0() + -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
        a.e12() * b.e0() + -(a.e01() * b.e2()) + a.e02() * b.e1(),
    )
}
#[doc = "Geometric product: Flector * Scalar -> Flector"]
#[inline]
pub fn geometric_flector_scalar<T: Float>(a: &Flector<T>, b: &Scalar<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s(),
        a.e12() * b.s(),
        a.e01() * b.s(),
        a.e02() * b.s(),
    )
}
#[doc = "Geometric product: Flector * Trivector -> Motor"]
#[inline]
pub fn geometric_flector_trivector<T: Float>(a: &Flector<T>, b: &Trivector<T>) -> Motor<T> {
    Motor::new(
        T::zero(),
        T::zero(),
        -(a.e12() * b.e012()),
        a.s() * b.e012(),
    )
}
#[doc = "Geometric product: Line * Flector -> Flector"]
#[inline]
pub fn geometric_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        -(a.e12() * b.e12()),
        a.e12() * b.s(),
        a.e12() * b.e02() + a.e01() * b.s() + -(a.e02() * b.e12()),
        -(a.e12() * b.e01()) + a.e01() * b.e12() + a.e02() * b.s(),
    )
}
#[doc = "Geometric product: Line * Line -> Flector"]
#[inline]
pub fn geometric_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Flector<T> {
    Flector::new(
        -(a.e12() * b.e12()),
        T::zero(),
        a.e12() * b.e02() + -(a.e02() * b.e12()),
        -(a.e12() * b.e01()) + a.e01() * b.e12(),
    )
}
#[doc = "Geometric product: Line * Motor -> Motor"]
#[inline]
pub fn geometric_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.e12() * b.e2(),
        -(a.e12() * b.e1()),
        -(a.e12() * b.e012()) + -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
        a.e12() * b.e0() + -(a.e01() * b.e2()) + a.e02() * b.e1(),
    )
}
#[doc = "Geometric product: Line * Point -> Motor"]
#[inline]
pub fn geometric_line_point<T: Float>(a: &Line<T>, b: &Point<T>) -> Motor<T> {
    Motor::new(
        a.e12() * b.e2(),
        -(a.e12() * b.e1()),
        -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
        a.e12() * b.e0() + -(a.e01() * b.e2()) + a.e02() * b.e1(),
    )
}
#[doc = "Geometric product: Line * Scalar -> Line"]
#[inline]
pub fn geometric_line_scalar<T: Float>(a: &Line<T>, b: &Scalar<T>) -> Line<T> {
    Line::new(a.e12() * b.s(), a.e01() * b.s(), a.e02() * b.s())
}
#[doc = "Geometric product: Line * Trivector -> Point"]
#[inline]
pub fn geometric_line_trivector<T: Float>(a: &Line<T>, b: &Trivector<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), -(a.e12() * b.e012()))
}
#[doc = "Geometric product: Motor * Flector -> Motor"]
#[inline]
pub fn geometric_motor_flector<T: Float>(a: &Motor<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.e1() + -(b.e12() * a.e2()),
        b.s() * a.e2() + b.e12() * a.e1(),
        b.s() * a.e0() + -(b.e12() * a.e012()) + b.e01() * a.e1() + b.e02() * a.e2(),
        b.s() * a.e012() + b.e12() * a.e0() + -(b.e01() * a.e2()) + b.e02() * a.e1(),
    )
}
#[doc = "Geometric product: Motor * Line -> Motor"]
#[inline]
pub fn geometric_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Motor<T> {
    Motor::new(
        -(b.e12() * a.e2()),
        b.e12() * a.e1(),
        -(b.e12() * a.e012()) + b.e01() * a.e1() + b.e02() * a.e2(),
        b.e12() * a.e0() + -(b.e01() * a.e2()) + b.e02() * a.e1(),
    )
}
#[doc = "Geometric product: Motor * Motor -> Flector"]
#[inline]
pub fn geometric_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        b.e1() * a.e1() + b.e2() * a.e2(),
        -(b.e1() * a.e2()) + b.e2() * a.e1(),
        -(b.e1() * a.e0()) + -(b.e2() * a.e012()) + b.e0() * a.e1() + -(b.e012() * a.e2()),
        b.e1() * a.e012() + -(b.e2() * a.e0()) + b.e0() * a.e2() + b.e012() * a.e1(),
    )
}
#[doc = "Geometric product: Motor * Point -> Flector"]
#[inline]
pub fn geometric_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Flector<T> {
    Flector::new(
        b.e1() * a.e1() + b.e2() * a.e2(),
        -(b.e1() * a.e2()) + b.e2() * a.e1(),
        -(b.e1() * a.e0()) + -(b.e2() * a.e012()) + b.e0() * a.e1(),
        b.e1() * a.e012() + -(b.e2() * a.e0()) + b.e0() * a.e2(),
    )
}
#[doc = "Geometric product: Motor * Scalar -> Motor"]
#[inline]
pub fn geometric_motor_scalar<T: Float>(a: &Motor<T>, b: &Scalar<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.e1(),
        b.s() * a.e2(),
        b.s() * a.e0(),
        b.s() * a.e012(),
    )
}
#[doc = "Geometric product: Motor * Trivector -> Line"]
#[inline]
pub fn geometric_motor_trivector<T: Float>(a: &Motor<T>, b: &Trivector<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e012() * a.e2()), b.e012() * a.e1())
}
#[doc = "Geometric product: Point * Flector -> Motor"]
#[inline]
pub fn geometric_point_flector<T: Float>(a: &Point<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.e1() + -(b.e12() * a.e2()),
        b.s() * a.e2() + b.e12() * a.e1(),
        b.s() * a.e0() + b.e01() * a.e1() + b.e02() * a.e2(),
        b.e12() * a.e0() + -(b.e01() * a.e2()) + b.e02() * a.e1(),
    )
}
#[doc = "Geometric product: Point * Line -> Motor"]
#[inline]
pub fn geometric_point_line<T: Float>(a: &Point<T>, b: &Line<T>) -> Motor<T> {
    Motor::new(
        -(b.e12() * a.e2()),
        b.e12() * a.e1(),
        b.e01() * a.e1() + b.e02() * a.e2(),
        b.e12() * a.e0() + -(b.e01() * a.e2()) + b.e02() * a.e1(),
    )
}
#[doc = "Geometric product: Point * Motor -> Flector"]
#[inline]
pub fn geometric_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        b.e1() * a.e1() + b.e2() * a.e2(),
        -(b.e1() * a.e2()) + b.e2() * a.e1(),
        -(b.e1() * a.e0()) + b.e0() * a.e1() + -(b.e012() * a.e2()),
        -(b.e2() * a.e0()) + b.e0() * a.e2() + b.e012() * a.e1(),
    )
}
#[doc = "Geometric product: Point * Point -> Flector"]
#[inline]
pub fn geometric_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> Flector<T> {
    Flector::new(
        b.e1() * a.e1() + b.e2() * a.e2(),
        -(b.e1() * a.e2()) + b.e2() * a.e1(),
        -(b.e1() * a.e0()) + b.e0() * a.e1(),
        -(b.e2() * a.e0()) + b.e0() * a.e2(),
    )
}
#[doc = "Geometric product: Point * Scalar -> Point"]
#[inline]
pub fn geometric_point_scalar<T: Float>(a: &Point<T>, b: &Scalar<T>) -> Point<T> {
    Point::new(b.s() * a.e1(), b.s() * a.e2(), b.s() * a.e0())
}
#[doc = "Geometric product: Point * Trivector -> Line"]
#[inline]
pub fn geometric_point_trivector<T: Float>(a: &Point<T>, b: &Trivector<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e012() * a.e2()), b.e012() * a.e1())
}
#[doc = "Geometric product: Scalar * Flector -> Flector"]
#[inline]
pub fn geometric_scalar_flector<T: Float>(a: &Scalar<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s(),
        a.s() * b.e12(),
        a.s() * b.e01(),
        a.s() * b.e02(),
    )
}
#[doc = "Geometric product: Scalar * Line -> Line"]
#[inline]
pub fn geometric_scalar_line<T: Float>(a: &Scalar<T>, b: &Line<T>) -> Line<T> {
    Line::new(a.s() * b.e12(), a.s() * b.e01(), a.s() * b.e02())
}
#[doc = "Geometric product: Scalar * Motor -> Motor"]
#[inline]
pub fn geometric_scalar_motor<T: Float>(a: &Scalar<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e1(),
        a.s() * b.e2(),
        a.s() * b.e0(),
        a.s() * b.e012(),
    )
}
#[doc = "Geometric product: Scalar * Point -> Point"]
#[inline]
pub fn geometric_scalar_point<T: Float>(a: &Scalar<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.s() * b.e1(), a.s() * b.e2(), a.s() * b.e0())
}
#[doc = "Geometric product: Scalar * Scalar -> Scalar"]
#[inline]
pub fn geometric_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.s())
}
#[doc = "Geometric product: Scalar * Trivector -> Trivector"]
#[inline]
pub fn geometric_scalar_trivector<T: Float>(a: &Scalar<T>, b: &Trivector<T>) -> Trivector<T> {
    Trivector::new(a.s() * b.e012())
}
#[doc = "Geometric product: Trivector * Flector -> Motor"]
#[inline]
pub fn geometric_trivector_flector<T: Float>(a: &Trivector<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        T::zero(),
        T::zero(),
        -(b.e12() * a.e012()),
        b.s() * a.e012(),
    )
}
#[doc = "Geometric product: Trivector * Line -> Point"]
#[inline]
pub fn geometric_trivector_line<T: Float>(a: &Trivector<T>, b: &Line<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), -(b.e12() * a.e012()))
}
#[doc = "Geometric product: Trivector * Motor -> Line"]
#[inline]
pub fn geometric_trivector_motor<T: Float>(a: &Trivector<T>, b: &Motor<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e2() * a.e012()), b.e1() * a.e012())
}
#[doc = "Geometric product: Trivector * Point -> Line"]
#[inline]
pub fn geometric_trivector_point<T: Float>(a: &Trivector<T>, b: &Point<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e2() * a.e012()), b.e1() * a.e012())
}
#[doc = "Geometric product: Trivector * Scalar -> Trivector"]
#[inline]
pub fn geometric_trivector_scalar<T: Float>(a: &Trivector<T>, b: &Scalar<T>) -> Trivector<T> {
    Trivector::new(b.s() * a.e012())
}
#[doc = "Exterior product: Flector ^ Flector -> Flector"]
#[inline]
pub fn exterior_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s(),
        a.s() * b.e12() + a.e12() * b.s(),
        a.s() * b.e01() + a.e01() * b.s(),
        a.s() * b.e02() + a.e02() * b.s(),
    )
}
#[doc = "Exterior product: Flector ^ Line -> Line"]
#[inline]
pub fn exterior_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> Line<T> {
    Line::new(a.s() * b.e12(), a.s() * b.e01(), a.s() * b.e02())
}
#[doc = "Exterior product: Flector ^ Motor -> Motor"]
#[inline]
pub fn exterior_flector_motor<T: Float>(a: &Flector<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e1(),
        a.s() * b.e2(),
        a.s() * b.e0(),
        a.s() * b.e012() + a.e12() * b.e0() + -(a.e01() * b.e2()) + a.e02() * b.e1(),
    )
}
#[doc = "Exterior product: Flector ^ Point -> Motor"]
#[inline]
pub fn exterior_flector_point<T: Float>(a: &Flector<T>, b: &Point<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e1(),
        a.s() * b.e2(),
        a.s() * b.e0(),
        a.e12() * b.e0() + -(a.e01() * b.e2()) + a.e02() * b.e1(),
    )
}
#[doc = "Exterior product: Flector ^ Scalar -> Flector"]
#[inline]
pub fn exterior_flector_scalar<T: Float>(a: &Flector<T>, b: &Scalar<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s(),
        a.e12() * b.s(),
        a.e01() * b.s(),
        a.e02() * b.s(),
    )
}
#[doc = "Exterior product: Flector ^ Trivector -> Trivector"]
#[inline]
pub fn exterior_flector_trivector<T: Float>(a: &Flector<T>, b: &Trivector<T>) -> Trivector<T> {
    Trivector::new(a.s() * b.e012())
}
#[doc = "Exterior product: Line ^ Flector -> Line"]
#[inline]
pub fn exterior_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> Line<T> {
    Line::new(a.e12() * b.s(), a.e01() * b.s(), a.e02() * b.s())
}
#[doc = "Exterior product: Line ^ Motor -> Trivector"]
#[inline]
pub fn exterior_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Trivector<T> {
    Trivector::new(a.e12() * b.e0() + -(a.e01() * b.e2()) + a.e02() * b.e1())
}
#[doc = "Exterior product: Line ^ Point -> Trivector"]
#[inline]
pub fn exterior_line_point<T: Float>(a: &Line<T>, b: &Point<T>) -> Trivector<T> {
    Trivector::new(a.e12() * b.e0() + -(a.e01() * b.e2()) + a.e02() * b.e1())
}
#[doc = "Exterior product: Line ^ Scalar -> Line"]
#[inline]
pub fn exterior_line_scalar<T: Float>(a: &Line<T>, b: &Scalar<T>) -> Line<T> {
    Line::new(a.e12() * b.s(), a.e01() * b.s(), a.e02() * b.s())
}
#[doc = "Exterior product: Motor ^ Flector -> Motor"]
#[inline]
pub fn exterior_motor_flector<T: Float>(a: &Motor<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.e1(),
        b.s() * a.e2(),
        b.s() * a.e0(),
        b.s() * a.e012() + b.e12() * a.e0() + -(b.e01() * a.e2()) + b.e02() * a.e1(),
    )
}
#[doc = "Exterior product: Motor ^ Line -> Trivector"]
#[inline]
pub fn exterior_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Trivector<T> {
    Trivector::new(b.e12() * a.e0() + -(b.e01() * a.e2()) + b.e02() * a.e1())
}
#[doc = "Exterior product: Motor ^ Motor -> Line"]
#[inline]
pub fn exterior_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Line<T> {
    Line::new(
        -(b.e1() * a.e2()) + b.e2() * a.e1(),
        -(b.e1() * a.e0()) + b.e0() * a.e1(),
        -(b.e2() * a.e0()) + b.e0() * a.e2(),
    )
}
#[doc = "Exterior product: Motor ^ Point -> Line"]
#[inline]
pub fn exterior_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Line<T> {
    Line::new(
        -(b.e1() * a.e2()) + b.e2() * a.e1(),
        -(b.e1() * a.e0()) + b.e0() * a.e1(),
        -(b.e2() * a.e0()) + b.e0() * a.e2(),
    )
}
#[doc = "Exterior product: Motor ^ Scalar -> Motor"]
#[inline]
pub fn exterior_motor_scalar<T: Float>(a: &Motor<T>, b: &Scalar<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.e1(),
        b.s() * a.e2(),
        b.s() * a.e0(),
        b.s() * a.e012(),
    )
}
#[doc = "Exterior product: Point ^ Flector -> Motor"]
#[inline]
pub fn exterior_point_flector<T: Float>(a: &Point<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.e1(),
        b.s() * a.e2(),
        b.s() * a.e0(),
        b.e12() * a.e0() + -(b.e01() * a.e2()) + b.e02() * a.e1(),
    )
}
#[doc = "Exterior product: Point ^ Line -> Trivector"]
#[inline]
pub fn exterior_point_line<T: Float>(a: &Point<T>, b: &Line<T>) -> Trivector<T> {
    Trivector::new(b.e12() * a.e0() + -(b.e01() * a.e2()) + b.e02() * a.e1())
}
#[doc = "Exterior product: Point ^ Motor -> Line"]
#[inline]
pub fn exterior_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Line<T> {
    Line::new(
        -(b.e1() * a.e2()) + b.e2() * a.e1(),
        -(b.e1() * a.e0()) + b.e0() * a.e1(),
        -(b.e2() * a.e0()) + b.e0() * a.e2(),
    )
}
#[doc = "Exterior product: Point ^ Point -> Line"]
#[inline]
pub fn exterior_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> Line<T> {
    Line::new(
        -(b.e1() * a.e2()) + b.e2() * a.e1(),
        -(b.e1() * a.e0()) + b.e0() * a.e1(),
        -(b.e2() * a.e0()) + b.e0() * a.e2(),
    )
}
#[doc = "Exterior product: Point ^ Scalar -> Point"]
#[inline]
pub fn exterior_point_scalar<T: Float>(a: &Point<T>, b: &Scalar<T>) -> Point<T> {
    Point::new(b.s() * a.e1(), b.s() * a.e2(), b.s() * a.e0())
}
#[doc = "Exterior product: Scalar ^ Flector -> Flector"]
#[inline]
pub fn exterior_scalar_flector<T: Float>(a: &Scalar<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s(),
        a.s() * b.e12(),
        a.s() * b.e01(),
        a.s() * b.e02(),
    )
}
#[doc = "Exterior product: Scalar ^ Line -> Line"]
#[inline]
pub fn exterior_scalar_line<T: Float>(a: &Scalar<T>, b: &Line<T>) -> Line<T> {
    Line::new(a.s() * b.e12(), a.s() * b.e01(), a.s() * b.e02())
}
#[doc = "Exterior product: Scalar ^ Motor -> Motor"]
#[inline]
pub fn exterior_scalar_motor<T: Float>(a: &Scalar<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e1(),
        a.s() * b.e2(),
        a.s() * b.e0(),
        a.s() * b.e012(),
    )
}
#[doc = "Exterior product: Scalar ^ Point -> Point"]
#[inline]
pub fn exterior_scalar_point<T: Float>(a: &Scalar<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.s() * b.e1(), a.s() * b.e2(), a.s() * b.e0())
}
#[doc = "Exterior product: Scalar ^ Scalar -> Scalar"]
#[inline]
pub fn exterior_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.s())
}
#[doc = "Exterior product: Scalar ^ Trivector -> Trivector"]
#[inline]
pub fn exterior_scalar_trivector<T: Float>(a: &Scalar<T>, b: &Trivector<T>) -> Trivector<T> {
    Trivector::new(a.s() * b.e012())
}
#[doc = "Exterior product: Trivector ^ Flector -> Trivector"]
#[inline]
pub fn exterior_trivector_flector<T: Float>(a: &Trivector<T>, b: &Flector<T>) -> Trivector<T> {
    Trivector::new(b.s() * a.e012())
}
#[doc = "Exterior product: Trivector ^ Scalar -> Trivector"]
#[inline]
pub fn exterior_trivector_scalar<T: Float>(a: &Trivector<T>, b: &Scalar<T>) -> Trivector<T> {
    Trivector::new(b.s() * a.e012())
}
#[doc = "Interior product (symmetric inner): Flector · Flector -> Flector"]
#[inline]
pub fn interior_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s() + -(a.e12() * b.e12()),
        a.s() * b.e12() + a.e12() * b.s(),
        a.s() * b.e01() + a.e12() * b.e02() + a.e01() * b.s() + -(a.e02() * b.e12()),
        a.s() * b.e02() + -(a.e12() * b.e01()) + a.e01() * b.e12() + a.e02() * b.s(),
    )
}
#[doc = "Interior product (symmetric inner): Flector · Line -> Flector"]
#[inline]
pub fn interior_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> Flector<T> {
    Flector::new(
        -(a.e12() * b.e12()),
        a.s() * b.e12(),
        a.s() * b.e01() + a.e12() * b.e02() + -(a.e02() * b.e12()),
        a.s() * b.e02() + -(a.e12() * b.e01()) + a.e01() * b.e12(),
    )
}
#[doc = "Interior product (symmetric inner): Flector · Motor -> Motor"]
#[inline]
pub fn interior_flector_motor<T: Float>(a: &Flector<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e1() + a.e12() * b.e2(),
        a.s() * b.e2() + -(a.e12() * b.e1()),
        a.s() * b.e0() + -(a.e12() * b.e012()) + -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
        a.s() * b.e012() + a.e12() * b.e0() + -(a.e01() * b.e2()) + a.e02() * b.e1(),
    )
}
#[doc = "Interior product (symmetric inner): Flector · Point -> Point"]
#[inline]
pub fn interior_flector_point<T: Float>(a: &Flector<T>, b: &Point<T>) -> Point<T> {
    Point::new(
        a.s() * b.e1() + a.e12() * b.e2(),
        a.s() * b.e2() + -(a.e12() * b.e1()),
        a.s() * b.e0() + -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
    )
}
#[doc = "Interior product (symmetric inner): Flector · Scalar -> Flector"]
#[inline]
pub fn interior_flector_scalar<T: Float>(a: &Flector<T>, b: &Scalar<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s(),
        a.e12() * b.s(),
        a.e01() * b.s(),
        a.e02() * b.s(),
    )
}
#[doc = "Interior product (symmetric inner): Flector · Trivector -> Motor"]
#[inline]
pub fn interior_flector_trivector<T: Float>(a: &Flector<T>, b: &Trivector<T>) -> Motor<T> {
    Motor::new(
        T::zero(),
        T::zero(),
        -(a.e12() * b.e012()),
        a.s() * b.e012(),
    )
}
#[doc = "Interior product (symmetric inner): Line · Flector -> Flector"]
#[inline]
pub fn interior_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        -(a.e12() * b.e12()),
        a.e12() * b.s(),
        a.e12() * b.e02() + a.e01() * b.s() + -(a.e02() * b.e12()),
        -(a.e12() * b.e01()) + a.e01() * b.e12() + a.e02() * b.s(),
    )
}
#[doc = "Interior product (symmetric inner): Line · Line -> Scalar"]
#[inline]
pub fn interior_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(-(a.e12() * b.e12()))
}
#[doc = "Interior product (symmetric inner): Line · Motor -> Point"]
#[inline]
pub fn interior_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e2(),
        -(a.e12() * b.e1()),
        -(a.e12() * b.e012()) + -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
    )
}
#[doc = "Interior product (symmetric inner): Line · Point -> Point"]
#[inline]
pub fn interior_line_point<T: Float>(a: &Line<T>, b: &Point<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e2(),
        -(a.e12() * b.e1()),
        -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
    )
}
#[doc = "Interior product (symmetric inner): Line · Scalar -> Line"]
#[inline]
pub fn interior_line_scalar<T: Float>(a: &Line<T>, b: &Scalar<T>) -> Line<T> {
    Line::new(a.e12() * b.s(), a.e01() * b.s(), a.e02() * b.s())
}
#[doc = "Interior product (symmetric inner): Line · Trivector -> Point"]
#[inline]
pub fn interior_line_trivector<T: Float>(a: &Line<T>, b: &Trivector<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), -(a.e12() * b.e012()))
}
#[doc = "Interior product (symmetric inner): Motor · Flector -> Motor"]
#[inline]
pub fn interior_motor_flector<T: Float>(a: &Motor<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.e1() + -(b.e12() * a.e2()),
        b.s() * a.e2() + b.e12() * a.e1(),
        b.s() * a.e0() + -(b.e12() * a.e012()) + b.e01() * a.e1() + b.e02() * a.e2(),
        b.s() * a.e012() + b.e12() * a.e0() + -(b.e01() * a.e2()) + b.e02() * a.e1(),
    )
}
#[doc = "Interior product (symmetric inner): Motor · Line -> Point"]
#[inline]
pub fn interior_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Point<T> {
    Point::new(
        -(b.e12() * a.e2()),
        b.e12() * a.e1(),
        -(b.e12() * a.e012()) + b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Interior product (symmetric inner): Motor · Motor -> Flector"]
#[inline]
pub fn interior_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        b.e1() * a.e1() + b.e2() * a.e2(),
        -(b.e1() * a.e2()) + b.e2() * a.e1(),
        -(b.e1() * a.e0()) + -(b.e2() * a.e012()) + b.e0() * a.e1() + -(b.e012() * a.e2()),
        b.e1() * a.e012() + -(b.e2() * a.e0()) + b.e0() * a.e2() + b.e012() * a.e1(),
    )
}
#[doc = "Interior product (symmetric inner): Motor · Point -> Flector"]
#[inline]
pub fn interior_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Flector<T> {
    Flector::new(
        b.e1() * a.e1() + b.e2() * a.e2(),
        -(b.e1() * a.e2()) + b.e2() * a.e1(),
        -(b.e1() * a.e0()) + -(b.e2() * a.e012()) + b.e0() * a.e1(),
        b.e1() * a.e012() + -(b.e2() * a.e0()) + b.e0() * a.e2(),
    )
}
#[doc = "Interior product (symmetric inner): Motor · Scalar -> Motor"]
#[inline]
pub fn interior_motor_scalar<T: Float>(a: &Motor<T>, b: &Scalar<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.e1(),
        b.s() * a.e2(),
        b.s() * a.e0(),
        b.s() * a.e012(),
    )
}
#[doc = "Interior product (symmetric inner): Motor · Trivector -> Line"]
#[inline]
pub fn interior_motor_trivector<T: Float>(a: &Motor<T>, b: &Trivector<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e012() * a.e2()), b.e012() * a.e1())
}
#[doc = "Interior product (symmetric inner): Point · Flector -> Point"]
#[inline]
pub fn interior_point_flector<T: Float>(a: &Point<T>, b: &Flector<T>) -> Point<T> {
    Point::new(
        b.s() * a.e1() + -(b.e12() * a.e2()),
        b.s() * a.e2() + b.e12() * a.e1(),
        b.s() * a.e0() + b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Interior product (symmetric inner): Point · Line -> Point"]
#[inline]
pub fn interior_point_line<T: Float>(a: &Point<T>, b: &Line<T>) -> Point<T> {
    Point::new(
        -(b.e12() * a.e2()),
        b.e12() * a.e1(),
        b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Interior product (symmetric inner): Point · Motor -> Flector"]
#[inline]
pub fn interior_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        b.e1() * a.e1() + b.e2() * a.e2(),
        -(b.e1() * a.e2()) + b.e2() * a.e1(),
        -(b.e1() * a.e0()) + b.e0() * a.e1() + -(b.e012() * a.e2()),
        -(b.e2() * a.e0()) + b.e0() * a.e2() + b.e012() * a.e1(),
    )
}
#[doc = "Interior product (symmetric inner): Point · Point -> Scalar"]
#[inline]
pub fn interior_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> Scalar<T> {
    Scalar::new(b.e1() * a.e1() + b.e2() * a.e2())
}
#[doc = "Interior product (symmetric inner): Point · Scalar -> Point"]
#[inline]
pub fn interior_point_scalar<T: Float>(a: &Point<T>, b: &Scalar<T>) -> Point<T> {
    Point::new(b.s() * a.e1(), b.s() * a.e2(), b.s() * a.e0())
}
#[doc = "Interior product (symmetric inner): Point · Trivector -> Line"]
#[inline]
pub fn interior_point_trivector<T: Float>(a: &Point<T>, b: &Trivector<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e012() * a.e2()), b.e012() * a.e1())
}
#[doc = "Interior product (symmetric inner): Scalar · Flector -> Flector"]
#[inline]
pub fn interior_scalar_flector<T: Float>(a: &Scalar<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s(),
        a.s() * b.e12(),
        a.s() * b.e01(),
        a.s() * b.e02(),
    )
}
#[doc = "Interior product (symmetric inner): Scalar · Line -> Line"]
#[inline]
pub fn interior_scalar_line<T: Float>(a: &Scalar<T>, b: &Line<T>) -> Line<T> {
    Line::new(a.s() * b.e12(), a.s() * b.e01(), a.s() * b.e02())
}
#[doc = "Interior product (symmetric inner): Scalar · Motor -> Motor"]
#[inline]
pub fn interior_scalar_motor<T: Float>(a: &Scalar<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e1(),
        a.s() * b.e2(),
        a.s() * b.e0(),
        a.s() * b.e012(),
    )
}
#[doc = "Interior product (symmetric inner): Scalar · Point -> Point"]
#[inline]
pub fn interior_scalar_point<T: Float>(a: &Scalar<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.s() * b.e1(), a.s() * b.e2(), a.s() * b.e0())
}
#[doc = "Interior product (symmetric inner): Scalar · Scalar -> Scalar"]
#[inline]
pub fn interior_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.s())
}
#[doc = "Interior product (symmetric inner): Scalar · Trivector -> Trivector"]
#[inline]
pub fn interior_scalar_trivector<T: Float>(a: &Scalar<T>, b: &Trivector<T>) -> Trivector<T> {
    Trivector::new(a.s() * b.e012())
}
#[doc = "Interior product (symmetric inner): Trivector · Flector -> Motor"]
#[inline]
pub fn interior_trivector_flector<T: Float>(a: &Trivector<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        T::zero(),
        T::zero(),
        -(b.e12() * a.e012()),
        b.s() * a.e012(),
    )
}
#[doc = "Interior product (symmetric inner): Trivector · Line -> Point"]
#[inline]
pub fn interior_trivector_line<T: Float>(a: &Trivector<T>, b: &Line<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), -(b.e12() * a.e012()))
}
#[doc = "Interior product (symmetric inner): Trivector · Motor -> Line"]
#[inline]
pub fn interior_trivector_motor<T: Float>(a: &Trivector<T>, b: &Motor<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e2() * a.e012()), b.e1() * a.e012())
}
#[doc = "Interior product (symmetric inner): Trivector · Point -> Line"]
#[inline]
pub fn interior_trivector_point<T: Float>(a: &Trivector<T>, b: &Point<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e2() * a.e012()), b.e1() * a.e012())
}
#[doc = "Interior product (symmetric inner): Trivector · Scalar -> Trivector"]
#[inline]
pub fn interior_trivector_scalar<T: Float>(a: &Trivector<T>, b: &Scalar<T>) -> Trivector<T> {
    Trivector::new(b.s() * a.e012())
}
#[doc = "Left contraction: Flector | Flector -> Flector"]
#[inline]
pub fn left_contract_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s() + -(a.e12() * b.e12()),
        a.s() * b.e12(),
        a.s() * b.e01(),
        a.s() * b.e02(),
    )
}
#[doc = "Left contraction: Flector | Line -> Flector"]
#[inline]
pub fn left_contract_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> Flector<T> {
    Flector::new(
        -(a.e12() * b.e12()),
        a.s() * b.e12(),
        a.s() * b.e01(),
        a.s() * b.e02(),
    )
}
#[doc = "Left contraction: Flector | Motor -> Motor"]
#[inline]
pub fn left_contract_flector_motor<T: Float>(a: &Flector<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e1(),
        a.s() * b.e2(),
        a.s() * b.e0() + -(a.e12() * b.e012()),
        a.s() * b.e012(),
    )
}
#[doc = "Left contraction: Flector | Point -> Point"]
#[inline]
pub fn left_contract_flector_point<T: Float>(a: &Flector<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.s() * b.e1(), a.s() * b.e2(), a.s() * b.e0())
}
#[doc = "Left contraction: Flector | Scalar -> Scalar"]
#[inline]
pub fn left_contract_flector_scalar<T: Float>(a: &Flector<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.s())
}
#[doc = "Left contraction: Flector | Trivector -> Motor"]
#[inline]
pub fn left_contract_flector_trivector<T: Float>(a: &Flector<T>, b: &Trivector<T>) -> Motor<T> {
    Motor::new(
        T::zero(),
        T::zero(),
        -(a.e12() * b.e012()),
        a.s() * b.e012(),
    )
}
#[doc = "Left contraction: Line | Flector -> Scalar"]
#[inline]
pub fn left_contract_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> Scalar<T> {
    Scalar::new(-(a.e12() * b.e12()))
}
#[doc = "Left contraction: Line | Line -> Scalar"]
#[inline]
pub fn left_contract_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(-(a.e12() * b.e12()))
}
#[doc = "Left contraction: Line | Motor -> Point"]
#[inline]
pub fn left_contract_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), -(a.e12() * b.e012()))
}
#[doc = "Left contraction: Line | Trivector -> Point"]
#[inline]
pub fn left_contract_line_trivector<T: Float>(a: &Line<T>, b: &Trivector<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), -(a.e12() * b.e012()))
}
#[doc = "Left contraction: Motor | Flector -> Point"]
#[inline]
pub fn left_contract_motor_flector<T: Float>(a: &Motor<T>, b: &Flector<T>) -> Point<T> {
    Point::new(
        -(b.e12() * a.e2()),
        b.e12() * a.e1(),
        b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Left contraction: Motor | Line -> Point"]
#[inline]
pub fn left_contract_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Point<T> {
    Point::new(
        -(b.e12() * a.e2()),
        b.e12() * a.e1(),
        b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Left contraction: Motor | Motor -> Flector"]
#[inline]
pub fn left_contract_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        b.e1() * a.e1() + b.e2() * a.e2(),
        T::zero(),
        -(b.e012() * a.e2()),
        b.e012() * a.e1(),
    )
}
#[doc = "Left contraction: Motor | Point -> Scalar"]
#[inline]
pub fn left_contract_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Scalar<T> {
    Scalar::new(b.e1() * a.e1() + b.e2() * a.e2())
}
#[doc = "Left contraction: Motor | Trivector -> Line"]
#[inline]
pub fn left_contract_motor_trivector<T: Float>(a: &Motor<T>, b: &Trivector<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e012() * a.e2()), b.e012() * a.e1())
}
#[doc = "Left contraction: Point | Flector -> Point"]
#[inline]
pub fn left_contract_point_flector<T: Float>(a: &Point<T>, b: &Flector<T>) -> Point<T> {
    Point::new(
        -(b.e12() * a.e2()),
        b.e12() * a.e1(),
        b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Left contraction: Point | Line -> Point"]
#[inline]
pub fn left_contract_point_line<T: Float>(a: &Point<T>, b: &Line<T>) -> Point<T> {
    Point::new(
        -(b.e12() * a.e2()),
        b.e12() * a.e1(),
        b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Left contraction: Point | Motor -> Flector"]
#[inline]
pub fn left_contract_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        b.e1() * a.e1() + b.e2() * a.e2(),
        T::zero(),
        -(b.e012() * a.e2()),
        b.e012() * a.e1(),
    )
}
#[doc = "Left contraction: Point | Point -> Scalar"]
#[inline]
pub fn left_contract_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> Scalar<T> {
    Scalar::new(b.e1() * a.e1() + b.e2() * a.e2())
}
#[doc = "Left contraction: Point | Trivector -> Line"]
#[inline]
pub fn left_contract_point_trivector<T: Float>(a: &Point<T>, b: &Trivector<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e012() * a.e2()), b.e012() * a.e1())
}
#[doc = "Left contraction: Scalar | Flector -> Flector"]
#[inline]
pub fn left_contract_scalar_flector<T: Float>(a: &Scalar<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s(),
        a.s() * b.e12(),
        a.s() * b.e01(),
        a.s() * b.e02(),
    )
}
#[doc = "Left contraction: Scalar | Line -> Line"]
#[inline]
pub fn left_contract_scalar_line<T: Float>(a: &Scalar<T>, b: &Line<T>) -> Line<T> {
    Line::new(a.s() * b.e12(), a.s() * b.e01(), a.s() * b.e02())
}
#[doc = "Left contraction: Scalar | Motor -> Motor"]
#[inline]
pub fn left_contract_scalar_motor<T: Float>(a: &Scalar<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e1(),
        a.s() * b.e2(),
        a.s() * b.e0(),
        a.s() * b.e012(),
    )
}
#[doc = "Left contraction: Scalar | Point -> Point"]
#[inline]
pub fn left_contract_scalar_point<T: Float>(a: &Scalar<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.s() * b.e1(), a.s() * b.e2(), a.s() * b.e0())
}
#[doc = "Left contraction: Scalar | Scalar -> Scalar"]
#[inline]
pub fn left_contract_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.s())
}
#[doc = "Left contraction: Scalar | Trivector -> Trivector"]
#[inline]
pub fn left_contract_scalar_trivector<T: Float>(a: &Scalar<T>, b: &Trivector<T>) -> Trivector<T> {
    Trivector::new(a.s() * b.e012())
}
#[doc = "Right contraction: Flector ⌊ Flector -> Flector"]
#[inline]
pub fn right_contract_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s() + -(a.e12() * b.e12()),
        a.s() * b.e12() + a.e12() * b.s(),
        a.s() * b.e01() + a.e12() * b.e02() + a.e01() * b.s() + -(a.e02() * b.e12()),
        a.s() * b.e02() + -(a.e12() * b.e01()) + a.e01() * b.e12() + a.e02() * b.s(),
    )
}
#[doc = "Right contraction: Flector ⌊ Line -> Scalar"]
#[inline]
pub fn right_contract_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(-(a.e12() * b.e12()))
}
#[doc = "Right contraction: Flector ⌊ Motor -> Point"]
#[inline]
pub fn right_contract_flector_motor<T: Float>(a: &Flector<T>, b: &Motor<T>) -> Point<T> {
    Point::new(
        a.s() * b.e1() + a.e12() * b.e2(),
        a.s() * b.e2() + -(a.e12() * b.e1()),
        a.s() * b.e0() + -(a.e12() * b.e012()) + -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
    )
}
#[doc = "Right contraction: Flector ⌊ Point -> Point"]
#[inline]
pub fn right_contract_flector_point<T: Float>(a: &Flector<T>, b: &Point<T>) -> Point<T> {
    Point::new(
        a.s() * b.e1() + a.e12() * b.e2(),
        a.s() * b.e2() + -(a.e12() * b.e1()),
        a.s() * b.e0() + -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
    )
}
#[doc = "Right contraction: Flector ⌊ Scalar -> Flector"]
#[inline]
pub fn right_contract_flector_scalar<T: Float>(a: &Flector<T>, b: &Scalar<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.s(),
        a.e12() * b.s(),
        a.e01() * b.s(),
        a.e02() * b.s(),
    )
}
#[doc = "Right contraction: Line ⌊ Flector -> Flector"]
#[inline]
pub fn right_contract_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        -(a.e12() * b.e12()),
        a.e12() * b.s(),
        a.e12() * b.e02() + a.e01() * b.s() + -(a.e02() * b.e12()),
        -(a.e12() * b.e01()) + a.e01() * b.e12() + a.e02() * b.s(),
    )
}
#[doc = "Right contraction: Line ⌊ Line -> Scalar"]
#[inline]
pub fn right_contract_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(-(a.e12() * b.e12()))
}
#[doc = "Right contraction: Line ⌊ Motor -> Point"]
#[inline]
pub fn right_contract_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e2(),
        -(a.e12() * b.e1()),
        -(a.e12() * b.e012()) + -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
    )
}
#[doc = "Right contraction: Line ⌊ Point -> Point"]
#[inline]
pub fn right_contract_line_point<T: Float>(a: &Line<T>, b: &Point<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e2(),
        -(a.e12() * b.e1()),
        -(a.e01() * b.e1()) + -(a.e02() * b.e2()),
    )
}
#[doc = "Right contraction: Line ⌊ Scalar -> Line"]
#[inline]
pub fn right_contract_line_scalar<T: Float>(a: &Line<T>, b: &Scalar<T>) -> Line<T> {
    Line::new(a.e12() * b.s(), a.e01() * b.s(), a.e02() * b.s())
}
#[doc = "Right contraction: Motor ⌊ Flector -> Motor"]
#[inline]
pub fn right_contract_motor_flector<T: Float>(a: &Motor<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.e1() + -(b.e12() * a.e2()),
        b.s() * a.e2() + b.e12() * a.e1(),
        b.s() * a.e0() + -(b.e12() * a.e012()) + b.e01() * a.e1() + b.e02() * a.e2(),
        b.s() * a.e012() + b.e12() * a.e0() + -(b.e01() * a.e2()) + b.e02() * a.e1(),
    )
}
#[doc = "Right contraction: Motor ⌊ Line -> Point"]
#[inline]
pub fn right_contract_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Point<T> {
    Point::new(
        -(b.e12() * a.e2()),
        b.e12() * a.e1(),
        -(b.e12() * a.e012()) + b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Right contraction: Motor ⌊ Motor -> Flector"]
#[inline]
pub fn right_contract_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        b.e1() * a.e1() + b.e2() * a.e2(),
        -(b.e1() * a.e2()) + b.e2() * a.e1(),
        -(b.e1() * a.e0()) + -(b.e2() * a.e012()) + b.e0() * a.e1() + -(b.e012() * a.e2()),
        b.e1() * a.e012() + -(b.e2() * a.e0()) + b.e0() * a.e2() + b.e012() * a.e1(),
    )
}
#[doc = "Right contraction: Motor ⌊ Point -> Flector"]
#[inline]
pub fn right_contract_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Flector<T> {
    Flector::new(
        b.e1() * a.e1() + b.e2() * a.e2(),
        -(b.e1() * a.e2()) + b.e2() * a.e1(),
        -(b.e1() * a.e0()) + -(b.e2() * a.e012()) + b.e0() * a.e1(),
        b.e1() * a.e012() + -(b.e2() * a.e0()) + b.e0() * a.e2(),
    )
}
#[doc = "Right contraction: Motor ⌊ Scalar -> Motor"]
#[inline]
pub fn right_contract_motor_scalar<T: Float>(a: &Motor<T>, b: &Scalar<T>) -> Motor<T> {
    Motor::new(
        b.s() * a.e1(),
        b.s() * a.e2(),
        b.s() * a.e0(),
        b.s() * a.e012(),
    )
}
#[doc = "Right contraction: Point ⌊ Flector -> Point"]
#[inline]
pub fn right_contract_point_flector<T: Float>(a: &Point<T>, b: &Flector<T>) -> Point<T> {
    Point::new(
        b.s() * a.e1() + -(b.e12() * a.e2()),
        b.s() * a.e2() + b.e12() * a.e1(),
        b.s() * a.e0() + b.e01() * a.e1() + b.e02() * a.e2(),
    )
}
#[doc = "Right contraction: Point ⌊ Motor -> Scalar"]
#[inline]
pub fn right_contract_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Scalar<T> {
    Scalar::new(b.e1() * a.e1() + b.e2() * a.e2())
}
#[doc = "Right contraction: Point ⌊ Point -> Scalar"]
#[inline]
pub fn right_contract_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> Scalar<T> {
    Scalar::new(b.e1() * a.e1() + b.e2() * a.e2())
}
#[doc = "Right contraction: Point ⌊ Scalar -> Point"]
#[inline]
pub fn right_contract_point_scalar<T: Float>(a: &Point<T>, b: &Scalar<T>) -> Point<T> {
    Point::new(b.s() * a.e1(), b.s() * a.e2(), b.s() * a.e0())
}
#[doc = "Right contraction: Scalar ⌊ Flector -> Scalar"]
#[inline]
pub fn right_contract_scalar_flector<T: Float>(a: &Scalar<T>, b: &Flector<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.s())
}
#[doc = "Right contraction: Scalar ⌊ Scalar -> Scalar"]
#[inline]
pub fn right_contract_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.s())
}
#[doc = "Right contraction: Trivector ⌊ Flector -> Motor"]
#[inline]
pub fn right_contract_trivector_flector<T: Float>(a: &Trivector<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        T::zero(),
        T::zero(),
        -(b.e12() * a.e012()),
        b.s() * a.e012(),
    )
}
#[doc = "Right contraction: Trivector ⌊ Line -> Point"]
#[inline]
pub fn right_contract_trivector_line<T: Float>(a: &Trivector<T>, b: &Line<T>) -> Point<T> {
    Point::new(T::zero(), T::zero(), -(b.e12() * a.e012()))
}
#[doc = "Right contraction: Trivector ⌊ Motor -> Line"]
#[inline]
pub fn right_contract_trivector_motor<T: Float>(a: &Trivector<T>, b: &Motor<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e2() * a.e012()), b.e1() * a.e012())
}
#[doc = "Right contraction: Trivector ⌊ Point -> Line"]
#[inline]
pub fn right_contract_trivector_point<T: Float>(a: &Trivector<T>, b: &Point<T>) -> Line<T> {
    Line::new(T::zero(), -(b.e2() * a.e012()), b.e1() * a.e012())
}
#[doc = "Right contraction: Trivector ⌊ Scalar -> Trivector"]
#[inline]
pub fn right_contract_trivector_scalar<T: Float>(a: &Trivector<T>, b: &Scalar<T>) -> Trivector<T> {
    Trivector::new(b.s() * a.e012())
}
#[doc = "Regressive product (meet): Flector ∨ Flector -> Point"]
#[inline]
pub fn regressive_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e01() - a.e01() * b.e12(),
        a.e12() * b.e02() - a.e02() * b.e12(),
        a.e01() * b.e02() - a.e02() * b.e01(),
    )
}
#[doc = "Regressive product (meet): Flector ∨ Line -> Point"]
#[inline]
pub fn regressive_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e01() - a.e01() * b.e12(),
        a.e12() * b.e02() - a.e02() * b.e12(),
        a.e01() * b.e02() - a.e02() * b.e01(),
    )
}
#[doc = "Regressive product (meet): Flector ∨ Motor -> Flector"]
#[inline]
pub fn regressive_flector_motor<T: Float>(a: &Flector<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.e012() + a.e12() * b.e0() - a.e01() * b.e2() + a.e02() * b.e1(),
        a.e12() * b.e012(),
        a.e01() * b.e012(),
        a.e02() * b.e012(),
    )
}
#[doc = "Regressive product (meet): Flector ∨ Point -> Scalar"]
#[inline]
pub fn regressive_flector_point<T: Float>(a: &Flector<T>, b: &Point<T>) -> Scalar<T> {
    Scalar::new(a.e12() * b.e0() - a.e01() * b.e2() + a.e02() * b.e1())
}
#[doc = "Regressive product (meet): Flector ∨ Trivector -> Flector"]
#[inline]
pub fn regressive_flector_trivector<T: Float>(a: &Flector<T>, b: &Trivector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.e012(),
        a.e12() * b.e012(),
        a.e01() * b.e012(),
        a.e02() * b.e012(),
    )
}
#[doc = "Regressive product (meet): Line ∨ Flector -> Point"]
#[inline]
pub fn regressive_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e01() - a.e01() * b.e12(),
        a.e12() * b.e02() - a.e02() * b.e12(),
        a.e01() * b.e02() - a.e02() * b.e01(),
    )
}
#[doc = "Regressive product (meet): Line ∨ Line -> Point"]
#[inline]
pub fn regressive_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Point<T> {
    Point::new(
        a.e12() * b.e01() - a.e01() * b.e12(),
        a.e12() * b.e02() - a.e02() * b.e12(),
        a.e01() * b.e02() - a.e02() * b.e01(),
    )
}
#[doc = "Regressive product (meet): Line ∨ Motor -> Flector"]
#[inline]
pub fn regressive_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        a.e12() * b.e0() - a.e01() * b.e2() + a.e02() * b.e1(),
        a.e12() * b.e012(),
        a.e01() * b.e012(),
        a.e02() * b.e012(),
    )
}
#[doc = "Regressive product (meet): Line ∨ Point -> Scalar"]
#[inline]
pub fn regressive_line_point<T: Float>(a: &Line<T>, b: &Point<T>) -> Scalar<T> {
    Scalar::new(a.e12() * b.e0() - a.e01() * b.e2() + a.e02() * b.e1())
}
#[doc = "Regressive product (meet): Line ∨ Trivector -> Line"]
#[inline]
pub fn regressive_line_trivector<T: Float>(a: &Line<T>, b: &Trivector<T>) -> Line<T> {
    Line::new(a.e12() * b.e012(), a.e01() * b.e012(), a.e02() * b.e012())
}
#[doc = "Regressive product (meet): Motor ∨ Flector -> Flector"]
#[inline]
pub fn regressive_motor_flector<T: Float>(a: &Motor<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.e1() * b.e02() - a.e2() * b.e01() + a.e0() * b.e12() + a.e012() * b.s(),
        a.e012() * b.e12(),
        a.e012() * b.e01(),
        a.e012() * b.e02(),
    )
}
#[doc = "Regressive product (meet): Motor ∨ Line -> Flector"]
#[inline]
pub fn regressive_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Flector<T> {
    Flector::new(
        a.e1() * b.e02() - a.e2() * b.e01() + a.e0() * b.e12(),
        a.e012() * b.e12(),
        a.e012() * b.e01(),
        a.e012() * b.e02(),
    )
}
#[doc = "Regressive product (meet): Motor ∨ Motor -> Motor"]
#[inline]
pub fn regressive_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.e1() * b.e012() + a.e012() * b.e1(),
        a.e2() * b.e012() + a.e012() * b.e2(),
        a.e0() * b.e012() + a.e012() * b.e0(),
        a.e012() * b.e012(),
    )
}
#[doc = "Regressive product (meet): Motor ∨ Point -> Point"]
#[inline]
pub fn regressive_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.e012() * b.e1(), a.e012() * b.e2(), a.e012() * b.e0())
}
#[doc = "Regressive product (meet): Motor ∨ Scalar -> Scalar"]
#[inline]
pub fn regressive_motor_scalar<T: Float>(a: &Motor<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.e012() * b.s())
}
#[doc = "Regressive product (meet): Motor ∨ Trivector -> Motor"]
#[inline]
pub fn regressive_motor_trivector<T: Float>(a: &Motor<T>, b: &Trivector<T>) -> Motor<T> {
    Motor::new(
        a.e1() * b.e012(),
        a.e2() * b.e012(),
        a.e0() * b.e012(),
        a.e012() * b.e012(),
    )
}
#[doc = "Regressive product (meet): Point ∨ Flector -> Scalar"]
#[inline]
pub fn regressive_point_flector<T: Float>(a: &Point<T>, b: &Flector<T>) -> Scalar<T> {
    Scalar::new(a.e1() * b.e02() - a.e2() * b.e01() + a.e0() * b.e12())
}
#[doc = "Regressive product (meet): Point ∨ Line -> Scalar"]
#[inline]
pub fn regressive_point_line<T: Float>(a: &Point<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(a.e1() * b.e02() - a.e2() * b.e01() + a.e0() * b.e12())
}
#[doc = "Regressive product (meet): Point ∨ Motor -> Point"]
#[inline]
pub fn regressive_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Point<T> {
    Point::new(a.e1() * b.e012(), a.e2() * b.e012(), a.e0() * b.e012())
}
#[doc = "Regressive product (meet): Point ∨ Trivector -> Point"]
#[inline]
pub fn regressive_point_trivector<T: Float>(a: &Point<T>, b: &Trivector<T>) -> Point<T> {
    Point::new(a.e1() * b.e012(), a.e2() * b.e012(), a.e0() * b.e012())
}
#[doc = "Regressive product (meet): Scalar ∨ Motor -> Scalar"]
#[inline]
pub fn regressive_scalar_motor<T: Float>(a: &Scalar<T>, b: &Motor<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.e012())
}
#[doc = "Regressive product (meet): Scalar ∨ Trivector -> Scalar"]
#[inline]
pub fn regressive_scalar_trivector<T: Float>(a: &Scalar<T>, b: &Trivector<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.e012())
}
#[doc = "Regressive product (meet): Trivector ∨ Flector -> Flector"]
#[inline]
pub fn regressive_trivector_flector<T: Float>(a: &Trivector<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.e012() * b.s(),
        a.e012() * b.e12(),
        a.e012() * b.e01(),
        a.e012() * b.e02(),
    )
}
#[doc = "Regressive product (meet): Trivector ∨ Line -> Line"]
#[inline]
pub fn regressive_trivector_line<T: Float>(a: &Trivector<T>, b: &Line<T>) -> Line<T> {
    Line::new(a.e012() * b.e12(), a.e012() * b.e01(), a.e012() * b.e02())
}
#[doc = "Regressive product (meet): Trivector ∨ Motor -> Motor"]
#[inline]
pub fn regressive_trivector_motor<T: Float>(a: &Trivector<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.e012() * b.e1(),
        a.e012() * b.e2(),
        a.e012() * b.e0(),
        a.e012() * b.e012(),
    )
}
#[doc = "Regressive product (meet): Trivector ∨ Point -> Point"]
#[inline]
pub fn regressive_trivector_point<T: Float>(a: &Trivector<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.e012() * b.e1(), a.e012() * b.e2(), a.e012() * b.e0())
}
#[doc = "Regressive product (meet): Trivector ∨ Scalar -> Scalar"]
#[inline]
pub fn regressive_trivector_scalar<T: Float>(a: &Trivector<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.e012() * b.s())
}
#[doc = "Regressive product (meet): Trivector ∨ Trivector -> Trivector"]
#[inline]
pub fn regressive_trivector_trivector<T: Float>(
    a: &Trivector<T>,
    b: &Trivector<T>,
) -> Trivector<T> {
    Trivector::new(a.e012() * b.e012())
}
#[doc = "Scalar product: Flector * Flector -> T (grade-0 part)"]
#[inline]
pub fn scalar_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> T {
    a.s() * b.s() - a.e12() * b.e12()
}
#[doc = "Scalar product: Flector * Line -> T (grade-0 part)"]
#[inline]
pub fn scalar_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> T {
    -(a.e12() * b.e12())
}
#[doc = "Scalar product: Flector * Scalar -> T (grade-0 part)"]
#[inline]
pub fn scalar_flector_scalar<T: Float>(a: &Flector<T>, b: &Scalar<T>) -> T {
    a.s() * b.s()
}
#[doc = "Scalar product: Line * Flector -> T (grade-0 part)"]
#[inline]
pub fn scalar_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> T {
    -(a.e12() * b.e12())
}
#[doc = "Scalar product: Line * Line -> T (grade-0 part)"]
#[inline]
pub fn scalar_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> T {
    -(a.e12() * b.e12())
}
#[doc = "Scalar product: Motor * Motor -> T (grade-0 part)"]
#[inline]
pub fn scalar_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> T {
    a.e1() * b.e1() + a.e2() * b.e2()
}
#[doc = "Scalar product: Motor * Point -> T (grade-0 part)"]
#[inline]
pub fn scalar_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> T {
    a.e1() * b.e1() + a.e2() * b.e2()
}
#[doc = "Scalar product: Point * Motor -> T (grade-0 part)"]
#[inline]
pub fn scalar_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> T {
    a.e1() * b.e1() + a.e2() * b.e2()
}
#[doc = "Scalar product: Point * Point -> T (grade-0 part)"]
#[inline]
pub fn scalar_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> T {
    a.e1() * b.e1() + a.e2() * b.e2()
}
#[doc = "Scalar product: Scalar * Flector -> T (grade-0 part)"]
#[inline]
pub fn scalar_scalar_flector<T: Float>(a: &Scalar<T>, b: &Flector<T>) -> T {
    a.s() * b.s()
}
#[doc = "Scalar product: Scalar * Scalar -> T (grade-0 part)"]
#[inline]
pub fn scalar_scalar_scalar<T: Float>(a: &Scalar<T>, b: &Scalar<T>) -> T {
    a.s() * b.s()
}
#[doc = "Antigeometric product: Flector ⊛ Flector -> Motor\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_flector_flector<T: Float>(a: &Flector<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e02() + a.e12() * b.e01() - a.e01() * b.e12() + a.e02() * b.s(),
        -(a.s() * b.e01()) + a.e12() * b.e02() - a.e01() * b.s() - a.e02() * b.e12(),
        a.e01() * b.e02() - a.e02() * b.e01(),
        a.e01() * b.e01() + a.e02() * b.e02(),
    )
}
#[doc = "Antigeometric product: Flector ⊛ Line -> Motor\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_flector_line<T: Float>(a: &Flector<T>, b: &Line<T>) -> Motor<T> {
    Motor::new(
        a.s() * b.e02() + a.e12() * b.e01() - a.e01() * b.e12(),
        -(a.s() * b.e01()) + a.e12() * b.e02() - a.e02() * b.e12(),
        a.e01() * b.e02() - a.e02() * b.e01(),
        a.e01() * b.e01() + a.e02() * b.e02(),
    )
}
#[doc = "Antigeometric product: Flector ⊛ Motor -> Flector\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_flector_motor<T: Float>(a: &Flector<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.e012() + a.e12() * b.e0() - a.e01() * b.e2() + a.e02() * b.e1(),
        -(a.s() * b.e0()) + a.e12() * b.e012() - a.e01() * b.e1() - a.e02() * b.e2(),
        a.e01() * b.e012() - a.e02() * b.e0(),
        a.e01() * b.e0() + a.e02() * b.e012(),
    )
}
#[doc = "Antigeometric product: Flector ⊛ Point -> Flector\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_flector_point<T: Float>(a: &Flector<T>, b: &Point<T>) -> Flector<T> {
    Flector::new(
        a.e12() * b.e0() - a.e01() * b.e2() + a.e02() * b.e1(),
        -(a.s() * b.e0()) - a.e01() * b.e1() - a.e02() * b.e2(),
        -(a.e02() * b.e0()),
        a.e01() * b.e0(),
    )
}
#[doc = "Antigeometric product: Flector ⊛ Scalar -> Point\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_flector_scalar<T: Float>(a: &Flector<T>, b: &Scalar<T>) -> Point<T> {
    Point::new(a.e02() * b.s(), -(a.e01() * b.s()), T::zero())
}
#[doc = "Antigeometric product: Flector ⊛ Trivector -> Flector\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_flector_trivector<T: Float>(a: &Flector<T>, b: &Trivector<T>) -> Flector<T> {
    Flector::new(
        a.s() * b.e012(),
        a.e12() * b.e012(),
        a.e01() * b.e012(),
        a.e02() * b.e012(),
    )
}
#[doc = "Antigeometric product: Line ⊛ Flector -> Motor\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_line_flector<T: Float>(a: &Line<T>, b: &Flector<T>) -> Motor<T> {
    Motor::new(
        a.e12() * b.e01() - a.e01() * b.e12() + a.e02() * b.s(),
        a.e12() * b.e02() - a.e01() * b.s() - a.e02() * b.e12(),
        a.e01() * b.e02() - a.e02() * b.e01(),
        a.e01() * b.e01() + a.e02() * b.e02(),
    )
}
#[doc = "Antigeometric product: Line ⊛ Line -> Motor\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Motor<T> {
    Motor::new(
        a.e12() * b.e01() - a.e01() * b.e12(),
        a.e12() * b.e02() - a.e02() * b.e12(),
        a.e01() * b.e02() - a.e02() * b.e01(),
        a.e01() * b.e01() + a.e02() * b.e02(),
    )
}
#[doc = "Antigeometric product: Line ⊛ Motor -> Flector\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_line_motor<T: Float>(a: &Line<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(
        a.e12() * b.e0() - a.e01() * b.e2() + a.e02() * b.e1(),
        a.e12() * b.e012() - a.e01() * b.e1() - a.e02() * b.e2(),
        a.e01() * b.e012() - a.e02() * b.e0(),
        a.e01() * b.e0() + a.e02() * b.e012(),
    )
}
#[doc = "Antigeometric product: Line ⊛ Point -> Flector\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_line_point<T: Float>(a: &Line<T>, b: &Point<T>) -> Flector<T> {
    Flector::new(
        a.e12() * b.e0() - a.e01() * b.e2() + a.e02() * b.e1(),
        -(a.e01() * b.e1()) - a.e02() * b.e2(),
        -(a.e02() * b.e0()),
        a.e01() * b.e0(),
    )
}
#[doc = "Antigeometric product: Line ⊛ Scalar -> Point\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_line_scalar<T: Float>(a: &Line<T>, b: &Scalar<T>) -> Point<T> {
    Point::new(a.e02() * b.s(), -(a.e01() * b.s()), T::zero())
}
#[doc = "Antigeometric product: Line ⊛ Trivector -> Line\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_line_trivector<T: Float>(a: &Line<T>, b: &Trivector<T>) -> Line<T> {
    Line::new(a.e12() * b.e012(), a.e01() * b.e012(), a.e02() * b.e012())
}
#[doc = "Antigeometric product: Motor ⊛ Flector -> Flector\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_motor_flector<T: Float>(a: &Motor<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.e1() * b.e02() - a.e2() * b.e01() + a.e0() * b.e12() + a.e012() * b.s(),
        a.e1() * b.e01() + a.e2() * b.e02() - a.e0() * b.s() + a.e012() * b.e12(),
        a.e0() * b.e02() + a.e012() * b.e01(),
        -(a.e0() * b.e01()) + a.e012() * b.e02(),
    )
}
#[doc = "Antigeometric product: Motor ⊛ Line -> Flector\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_motor_line<T: Float>(a: &Motor<T>, b: &Line<T>) -> Flector<T> {
    Flector::new(
        a.e1() * b.e02() - a.e2() * b.e01() + a.e0() * b.e12(),
        a.e1() * b.e01() + a.e2() * b.e02() + a.e012() * b.e12(),
        a.e0() * b.e02() + a.e012() * b.e01(),
        -(a.e0() * b.e01()) + a.e012() * b.e02(),
    )
}
#[doc = "Antigeometric product: Motor ⊛ Motor -> Motor\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.e1() * b.e012() - a.e2() * b.e0() + a.e0() * b.e2() + a.e012() * b.e1(),
        a.e1() * b.e0() + a.e2() * b.e012() - a.e0() * b.e1() + a.e012() * b.e2(),
        a.e0() * b.e012() + a.e012() * b.e0(),
        -(a.e0() * b.e0()) + a.e012() * b.e012(),
    )
}
#[doc = "Antigeometric product: Motor ⊛ Point -> Motor\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_motor_point<T: Float>(a: &Motor<T>, b: &Point<T>) -> Motor<T> {
    Motor::new(
        -(a.e2() * b.e0()) + a.e0() * b.e2() + a.e012() * b.e1(),
        a.e1() * b.e0() - a.e0() * b.e1() + a.e012() * b.e2(),
        a.e012() * b.e0(),
        -(a.e0() * b.e0()),
    )
}
#[doc = "Antigeometric product: Motor ⊛ Scalar -> Flector\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_motor_scalar<T: Float>(a: &Motor<T>, b: &Scalar<T>) -> Flector<T> {
    Flector::new(a.e012() * b.s(), -(a.e0() * b.s()), T::zero(), T::zero())
}
#[doc = "Antigeometric product: Motor ⊛ Trivector -> Motor\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_motor_trivector<T: Float>(a: &Motor<T>, b: &Trivector<T>) -> Motor<T> {
    Motor::new(
        a.e1() * b.e012(),
        a.e2() * b.e012(),
        a.e0() * b.e012(),
        a.e012() * b.e012(),
    )
}
#[doc = "Antigeometric product: Point ⊛ Flector -> Flector\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_point_flector<T: Float>(a: &Point<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.e1() * b.e02() - a.e2() * b.e01() + a.e0() * b.e12(),
        a.e1() * b.e01() + a.e2() * b.e02() - a.e0() * b.s(),
        a.e0() * b.e02(),
        -(a.e0() * b.e01()),
    )
}
#[doc = "Antigeometric product: Point ⊛ Line -> Flector\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_point_line<T: Float>(a: &Point<T>, b: &Line<T>) -> Flector<T> {
    Flector::new(
        a.e1() * b.e02() - a.e2() * b.e01() + a.e0() * b.e12(),
        a.e1() * b.e01() + a.e2() * b.e02(),
        a.e0() * b.e02(),
        -(a.e0() * b.e01()),
    )
}
#[doc = "Antigeometric product: Point ⊛ Motor -> Motor\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_point_motor<T: Float>(a: &Point<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.e1() * b.e012() - a.e2() * b.e0() + a.e0() * b.e2(),
        a.e1() * b.e0() + a.e2() * b.e012() - a.e0() * b.e1(),
        a.e0() * b.e012(),
        -(a.e0() * b.e0()),
    )
}
#[doc = "Antigeometric product: Point ⊛ Point -> Motor\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_point_point<T: Float>(a: &Point<T>, b: &Point<T>) -> Motor<T> {
    Motor::new(
        -(a.e2() * b.e0()) + a.e0() * b.e2(),
        a.e1() * b.e0() - a.e0() * b.e1(),
        T::zero(),
        -(a.e0() * b.e0()),
    )
}
#[doc = "Antigeometric product: Point ⊛ Scalar -> Line\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_point_scalar<T: Float>(a: &Point<T>, b: &Scalar<T>) -> Line<T> {
    Line::new(-(a.e0() * b.s()), T::zero(), T::zero())
}
#[doc = "Antigeometric product: Point ⊛ Trivector -> Point\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_point_trivector<T: Float>(a: &Point<T>, b: &Trivector<T>) -> Point<T> {
    Point::new(a.e1() * b.e012(), a.e2() * b.e012(), a.e0() * b.e012())
}
#[doc = "Antigeometric product: Scalar ⊛ Flector -> Point\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_scalar_flector<T: Float>(a: &Scalar<T>, b: &Flector<T>) -> Point<T> {
    Point::new(a.s() * b.e02(), -(a.s() * b.e01()), T::zero())
}
#[doc = "Antigeometric product: Scalar ⊛ Line -> Point\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_scalar_line<T: Float>(a: &Scalar<T>, b: &Line<T>) -> Point<T> {
    Point::new(a.s() * b.e02(), -(a.s() * b.e01()), T::zero())
}
#[doc = "Antigeometric product: Scalar ⊛ Motor -> Flector\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_scalar_motor<T: Float>(a: &Scalar<T>, b: &Motor<T>) -> Flector<T> {
    Flector::new(a.s() * b.e012(), -(a.s() * b.e0()), T::zero(), T::zero())
}
#[doc = "Antigeometric product: Scalar ⊛ Point -> Line\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_scalar_point<T: Float>(a: &Scalar<T>, b: &Point<T>) -> Line<T> {
    Line::new(-(a.s() * b.e0()), T::zero(), T::zero())
}
#[doc = "Antigeometric product: Scalar ⊛ Trivector -> Scalar\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_scalar_trivector<T: Float>(a: &Scalar<T>, b: &Trivector<T>) -> Scalar<T> {
    Scalar::new(a.s() * b.e012())
}
#[doc = "Antigeometric product: Trivector ⊛ Flector -> Flector\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_trivector_flector<T: Float>(a: &Trivector<T>, b: &Flector<T>) -> Flector<T> {
    Flector::new(
        a.e012() * b.s(),
        a.e012() * b.e12(),
        a.e012() * b.e01(),
        a.e012() * b.e02(),
    )
}
#[doc = "Antigeometric product: Trivector ⊛ Line -> Line\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_trivector_line<T: Float>(a: &Trivector<T>, b: &Line<T>) -> Line<T> {
    Line::new(a.e012() * b.e12(), a.e012() * b.e01(), a.e012() * b.e02())
}
#[doc = "Antigeometric product: Trivector ⊛ Motor -> Motor\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_trivector_motor<T: Float>(a: &Trivector<T>, b: &Motor<T>) -> Motor<T> {
    Motor::new(
        a.e012() * b.e1(),
        a.e012() * b.e2(),
        a.e012() * b.e0(),
        a.e012() * b.e012(),
    )
}
#[doc = "Antigeometric product: Trivector ⊛ Point -> Point\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_trivector_point<T: Float>(a: &Trivector<T>, b: &Point<T>) -> Point<T> {
    Point::new(a.e012() * b.e1(), a.e012() * b.e2(), a.e012() * b.e0())
}
#[doc = "Antigeometric product: Trivector ⊛ Scalar -> Scalar\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_trivector_scalar<T: Float>(a: &Trivector<T>, b: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.e012() * b.s())
}
#[doc = "Antigeometric product: Trivector ⊛ Trivector -> Trivector\n\nDefined as complement(complement(a) * complement(b))."]
#[inline]
pub fn antigeometric_trivector_trivector<T: Float>(
    a: &Trivector<T>,
    b: &Trivector<T>,
) -> Trivector<T> {
    Trivector::new(a.e012() * b.e012())
}
#[doc = "Sandwich product: Flector * Point * rev(Flector) -> Point"]
#[inline]
pub fn sandwich_flector_point<T: Float>(v: &Flector<T>, x: &Point<T>) -> Point<T> {
    Point::new(
        v.s() * x.e1() * v.s() + v.e12() * x.e2() * v.s() + v.s() * x.e2() * v.e12()
            - v.e12() * x.e1() * v.e12(),
        -(v.s() * x.e1() * v.e12()) - v.e12() * x.e1() * v.s() + v.s() * x.e2() * v.s()
            - v.e12() * x.e2() * v.e12(),
        v.e02() * x.e1() * v.e12() + v.e12() * x.e1() * v.e02()
            - v.s() * x.e2() * v.e02()
            - v.s() * x.e1() * v.e01()
            + v.s() * x.e0() * v.s()
            - v.e02() * x.e2() * v.s()
            + v.e12() * x.e0() * v.e12()
            - v.e12() * x.e2() * v.e01()
            - v.e01() * x.e1() * v.s()
            - v.e01() * x.e2() * v.e12(),
    )
}
#[doc = "Sandwich product: Flector * Line * rev(Flector) -> Line"]
#[inline]
pub fn sandwich_flector_line<T: Float>(v: &Flector<T>, x: &Line<T>) -> Line<T> {
    Line::new(
        v.s() * x.e12() * v.s() + v.e12() * x.e12() * v.e12(),
        -(v.e02() * x.e12() * v.s()) + v.e12() * x.e12() * v.e01() - v.s() * x.e12() * v.e02()
            + v.s() * x.e01() * v.s()
            - v.e12() * x.e01() * v.e12()
            + v.e12() * x.e02() * v.s()
            + v.e01() * x.e12() * v.e12()
            + v.s() * x.e02() * v.e12(),
        -(v.e12() * x.e01() * v.s()) - v.s() * x.e01() * v.e12()
            + v.s() * x.e12() * v.e01()
            + v.s() * x.e02() * v.s()
            + v.e12() * x.e12() * v.e02()
            + v.e01() * x.e12() * v.s()
            - v.e12() * x.e02() * v.e12()
            + v.e02() * x.e12() * v.e12(),
    )
}
#[doc = "Sandwich product: Flector * Motor * rev(Flector) -> Motor"]
#[inline]
pub fn sandwich_flector_motor<T: Float>(v: &Flector<T>, x: &Motor<T>) -> Motor<T> {
    Motor::new(
        -(v.e12() * x.e1() * v.e12())
            + v.s() * x.e2() * v.e12()
            + v.s() * x.e1() * v.s()
            + v.e12() * x.e2() * v.s(),
        v.s() * x.e2() * v.s()
            - v.e12() * x.e1() * v.s()
            - v.s() * x.e1() * v.e12()
            - v.e12() * x.e2() * v.e12(),
        v.e12() * x.e0() * v.e12() - v.e01() * x.e2() * v.e12() + v.e12() * x.e1() * v.e02()
            - v.s() * x.e1() * v.e01()
            - v.e12() * x.e012() * v.s()
            - v.e12() * x.e2() * v.e01()
            - v.s() * x.e2() * v.e02()
            - v.e01() * x.e1() * v.s()
            + v.e02() * x.e1() * v.e12()
            + v.s() * x.e0() * v.s()
            - v.e02() * x.e2() * v.s()
            + v.s() * x.e012() * v.e12(),
        v.s() * x.e2() * v.e01() - v.s() * x.e1() * v.e02()
            + v.e12() * x.e0() * v.s()
            + v.s() * x.e012() * v.s()
            + v.e12() * x.e012() * v.e12()
            - v.s() * x.e0() * v.e12()
            + v.e02() * x.e2() * v.e12()
            - v.e12() * x.e2() * v.e02()
            - v.e12() * x.e1() * v.e01()
            - v.e01() * x.e2() * v.s()
            + v.e01() * x.e1() * v.e12()
            + v.e02() * x.e1() * v.s(),
    )
}
#[doc = "Sandwich product: Flector * Flector * rev(Flector) -> Flector"]
#[inline]
pub fn sandwich_flector_flector<T: Float>(v: &Flector<T>, x: &Flector<T>) -> Flector<T> {
    Flector::new(
        v.e12() * x.s() * v.e12() - v.e12() * x.e12() * v.s()
            + v.s() * x.e12() * v.e12()
            + v.s() * x.s() * v.s(),
        v.e12() * x.s() * v.s() - v.s() * x.s() * v.e12()
            + v.s() * x.e12() * v.s()
            + v.e12() * x.e12() * v.e12(),
        v.e02() * x.s() * v.e12() - v.e02() * x.e12() * v.s() - v.s() * x.e12() * v.e02()
            + v.e12() * x.e12() * v.e01()
            - v.e12() * x.e01() * v.e12()
            + v.s() * x.e01() * v.s()
            + v.s() * x.e02() * v.e12()
            - v.e12() * x.s() * v.e02()
            - v.s() * x.s() * v.e01()
            + v.e12() * x.e02() * v.s()
            + v.e01() * x.s() * v.s()
            + v.e01() * x.e12() * v.e12(),
        -(v.e12() * x.e01() * v.s()) - v.e12() * x.e02() * v.e12()
            + v.e01() * x.e12() * v.s()
            + v.e12() * x.e12() * v.e02()
            + v.s() * x.e12() * v.e01()
            - v.s() * x.s() * v.e02()
            + v.s() * x.e02() * v.s()
            - v.s() * x.e01() * v.e12()
            - v.e01() * x.s() * v.e12()
            + v.e12() * x.s() * v.e01()
            + v.e02() * x.s() * v.s()
            + v.e02() * x.e12() * v.e12(),
    )
}
#[doc = "Sandwich product: Motor * Point * rev(Motor) -> Point"]
#[inline]
pub fn sandwich_motor_point<T: Float>(v: &Motor<T>, x: &Point<T>) -> Point<T> {
    Point::new(
        v.e2() * x.e2() * v.e1() + v.e1() * x.e2() * v.e2() - v.e2() * x.e1() * v.e2()
            + v.e1() * x.e1() * v.e1(),
        v.e1() * x.e1() * v.e2() + v.e2() * x.e2() * v.e2() - v.e1() * x.e2() * v.e1()
            + v.e2() * x.e1() * v.e1(),
        v.e0() * x.e1() * v.e1()
            + v.e0() * x.e2() * v.e2()
            + v.e2() * x.e2() * v.e0()
            + v.e012() * x.e2() * v.e1()
            - v.e1() * x.e0() * v.e1()
            + v.e1() * x.e1() * v.e0()
            + v.e1() * x.e2() * v.e012()
            - v.e012() * x.e1() * v.e2()
            - v.e2() * x.e1() * v.e012()
            - v.e2() * x.e0() * v.e2(),
    )
}
#[doc = "Sandwich product: Motor * Line * rev(Motor) -> Line"]
#[inline]
pub fn sandwich_motor_line<T: Float>(v: &Motor<T>, x: &Line<T>) -> Line<T> {
    Line::new(
        -(v.e2() * x.e12() * v.e2()) - v.e1() * x.e12() * v.e1(),
        -(v.e2() * x.e02() * v.e1()) + v.e1() * x.e12() * v.e012()
            - v.e2() * x.e12() * v.e0()
            - v.e1() * x.e01() * v.e1()
            - v.e0() * x.e12() * v.e2()
            + v.e012() * x.e12() * v.e1()
            - v.e1() * x.e02() * v.e2()
            + v.e2() * x.e01() * v.e2(),
        v.e1() * x.e12() * v.e0()
            + v.e1() * x.e02() * v.e1()
            + v.e0() * x.e12() * v.e1()
            + v.e012() * x.e12() * v.e2()
            - v.e2() * x.e01() * v.e1()
            - v.e2() * x.e02() * v.e2()
            - v.e1() * x.e01() * v.e2()
            + v.e2() * x.e12() * v.e012(),
    )
}
#[doc = "Sandwich product: Motor * Motor * rev(Motor) -> Motor"]
#[inline]
pub fn sandwich_motor_motor<T: Float>(v: &Motor<T>, x: &Motor<T>) -> Motor<T> {
    Motor::new(
        v.e1() * x.e1() * v.e1() + v.e2() * x.e2() * v.e1() - v.e2() * x.e1() * v.e2()
            + v.e1() * x.e2() * v.e2(),
        v.e2() * x.e2() * v.e2() - v.e1() * x.e2() * v.e1()
            + v.e1() * x.e1() * v.e2()
            + v.e2() * x.e1() * v.e1(),
        v.e0() * x.e1() * v.e1() - v.e2() * x.e0() * v.e2()
            + v.e2() * x.e012() * v.e1()
            + v.e012() * x.e2() * v.e1()
            - v.e012() * x.e1() * v.e2()
            + v.e1() * x.e1() * v.e0()
            + v.e1() * x.e2() * v.e012()
            - v.e2() * x.e1() * v.e012()
            + v.e0() * x.e2() * v.e2()
            - v.e1() * x.e012() * v.e2()
            + v.e2() * x.e2() * v.e0()
            - v.e1() * x.e0() * v.e1(),
        v.e2() * x.e0() * v.e1() + v.e2() * x.e012() * v.e2() - v.e1() * x.e1() * v.e012()
            + v.e1() * x.e2() * v.e0()
            - v.e2() * x.e1() * v.e0()
            - v.e1() * x.e0() * v.e2()
            + v.e1() * x.e012() * v.e1()
            + v.e012() * x.e1() * v.e1()
            - v.e0() * x.e2() * v.e1()
            - v.e2() * x.e2() * v.e012()
            + v.e012() * x.e2() * v.e2()
            + v.e0() * x.e1() * v.e2(),
    )
}
#[doc = "Sandwich product: Motor * Flector * rev(Motor) -> Flector"]
#[inline]
pub fn sandwich_motor_flector<T: Float>(v: &Motor<T>, x: &Flector<T>) -> Flector<T> {
    Flector::new(
        v.e1() * x.e12() * v.e2() + v.e1() * x.s() * v.e1() - v.e2() * x.e12() * v.e1()
            + v.e2() * x.s() * v.e2(),
        -(v.e1() * x.e12() * v.e1()) - v.e2() * x.e12() * v.e2() - v.e2() * x.s() * v.e1()
            + v.e1() * x.s() * v.e2(),
        v.e1() * x.e12() * v.e012() - v.e1() * x.e02() * v.e2() + v.e1() * x.s() * v.e0()
            - v.e0() * x.e12() * v.e2()
            + v.e2() * x.e01() * v.e2()
            - v.e1() * x.e01() * v.e1()
            - v.e2() * x.e02() * v.e1()
            - v.e012() * x.s() * v.e2()
            + v.e012() * x.e12() * v.e1()
            - v.e0() * x.s() * v.e1()
            - v.e2() * x.e12() * v.e0()
            + v.e2() * x.s() * v.e012(),
        -(v.e0() * x.s() * v.e2()) + v.e012() * x.s() * v.e1() - v.e2() * x.e01() * v.e1()
            + v.e0() * x.e12() * v.e1()
            + v.e012() * x.e12() * v.e2()
            + v.e2() * x.s() * v.e0()
            + v.e1() * x.e12() * v.e0()
            - v.e1() * x.s() * v.e012()
            - v.e1() * x.e01() * v.e2()
            + v.e2() * x.e12() * v.e012()
            - v.e2() * x.e02() * v.e2()
            + v.e1() * x.e02() * v.e1(),
    )
}
#[doc = "Antisandwich product: Flector ⊛ Point ⊛ antirev(Flector) -> Point\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_flector_point<T: Float>(v: &Flector<T>, x: &Point<T>) -> Point<T> {
    Point::new(
        -(v.s() * x.e0() * v.e01()) + v.e12() * x.e0() * v.e02()
            - v.e01() * x.e0() * v.s()
            - v.e02() * x.e2() * v.e01()
            + v.e02() * x.e0() * v.e12()
            - v.e01() * x.e1() * v.e01()
            - v.e01() * x.e2() * v.e02()
            + v.e02() * x.e1() * v.e02(),
        v.e01() * x.e2() * v.e01()
            - v.e02() * x.e2() * v.e02()
            - v.s() * x.e0() * v.e02()
            - v.e02() * x.e1() * v.e01()
            - v.e02() * x.e0() * v.s()
            - v.e01() * x.e1() * v.e02()
            - v.e12() * x.e0() * v.e01()
            - v.e01() * x.e0() * v.e12(),
        -(v.e01() * x.e0() * v.e01()) - v.e02() * x.e0() * v.e02(),
    )
}
#[doc = "Antisandwich product: Flector ⊛ Line ⊛ antirev(Flector) -> Line\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_flector_line<T: Float>(v: &Flector<T>, x: &Line<T>) -> Line<T> {
    Line::new(
        v.e12() * x.e01() * v.e01() - v.e02() * x.e12() * v.e02() + v.e01() * x.e02() * v.s()
            - v.s() * x.e01() * v.e02()
            + v.e12() * x.e02() * v.e02()
            + v.e02() * x.e02() * v.e12()
            + v.s() * x.e02() * v.e01()
            + v.e01() * x.e01() * v.e12()
            - v.e02() * x.e01() * v.s()
            - v.e01() * x.e12() * v.e01(),
        -(v.e02() * x.e01() * v.e02())
            + v.e01() * x.e02() * v.e02()
            + v.e01() * x.e01() * v.e01()
            + v.e02() * x.e02() * v.e01(),
        v.e01() * x.e01() * v.e02() - v.e01() * x.e02() * v.e01()
            + v.e02() * x.e02() * v.e02()
            + v.e02() * x.e01() * v.e01(),
    )
}
#[doc = "Antisandwich product: Flector ⊛ Motor ⊛ antirev(Flector) -> Motor\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_flector_motor<T: Float>(v: &Flector<T>, x: &Motor<T>) -> Motor<T> {
    Motor::new(
        v.e12() * x.e0() * v.e02() + v.e02() * x.e0() * v.e12()
            - v.e02() * x.e012() * v.s()
            - v.e01() * x.e0() * v.s()
            + v.s() * x.e012() * v.e02()
            + v.e02() * x.e1() * v.e02()
            - v.e01() * x.e1() * v.e01()
            - v.e01() * x.e2() * v.e02()
            - v.e01() * x.e012() * v.e12()
            - v.e02() * x.e2() * v.e01()
            + v.e12() * x.e012() * v.e01()
            - v.s() * x.e0() * v.e01(),
        -(v.s() * x.e0() * v.e02()) - v.e12() * x.e0() * v.e01() + v.e12() * x.e012() * v.e02()
            - v.e01() * x.e0() * v.e12()
            + v.e01() * x.e012() * v.s()
            - v.e01() * x.e1() * v.e02()
            - v.e02() * x.e1() * v.e01()
            - v.s() * x.e012() * v.e01()
            - v.e02() * x.e0() * v.s()
            - v.e02() * x.e012() * v.e12()
            + v.e01() * x.e2() * v.e01()
            - v.e02() * x.e2() * v.e02(),
        -(v.e02() * x.e0() * v.e02()) - v.e02() * x.e012() * v.e01() - v.e01() * x.e0() * v.e01()
            + v.e01() * x.e012() * v.e02(),
        -(v.e02() * x.e0() * v.e01())
            + v.e01() * x.e012() * v.e01()
            + v.e02() * x.e012() * v.e02()
            + v.e01() * x.e0() * v.e02(),
    )
}
#[doc = "Antisandwich product: Flector ⊛ Flector ⊛ antirev(Flector) -> Flector\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_flector_flector<T: Float>(v: &Flector<T>, x: &Flector<T>) -> Flector<T> {
    Flector::new(
        v.e12() * x.e01() * v.e02() + v.s() * x.e01() * v.e01() + v.e01() * x.s() * v.e01()
            - v.e12() * x.e02() * v.e01()
            - v.e01() * x.e12() * v.e02()
            - v.e01() * x.e01() * v.s()
            + v.s() * x.e02() * v.e02()
            + v.e02() * x.s() * v.e02()
            + v.e01() * x.e02() * v.e12()
            + v.e02() * x.e12() * v.e01()
            - v.e02() * x.e01() * v.e12()
            - v.e02() * x.e02() * v.s(),
        v.e01() * x.e02() * v.s() + v.e02() * x.s() * v.e01() - v.e02() * x.e12() * v.e02()
            + v.e01() * x.e01() * v.e12()
            - v.e02() * x.e01() * v.s()
            + v.e02() * x.e02() * v.e12()
            + v.e12() * x.e02() * v.e02()
            + v.e12() * x.e01() * v.e01()
            + v.s() * x.e02() * v.e01()
            - v.s() * x.e01() * v.e02()
            - v.e01() * x.s() * v.e02()
            - v.e01() * x.e12() * v.e01(),
        v.e01() * x.e01() * v.e01() - v.e02() * x.e01() * v.e02()
            + v.e01() * x.e02() * v.e02()
            + v.e02() * x.e02() * v.e01(),
        v.e02() * x.e01() * v.e01() + v.e01() * x.e01() * v.e02() + v.e02() * x.e02() * v.e02()
            - v.e01() * x.e02() * v.e01(),
    )
}
#[doc = "Antisandwich product: Motor ⊛ Point ⊛ antirev(Motor) -> Point\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_motor_point<T: Float>(v: &Motor<T>, x: &Point<T>) -> Point<T> {
    Point::new(
        v.e0() * x.e2() * v.e012() - v.e2() * x.e0() * v.e012() - v.e0() * x.e1() * v.e0()
            + v.e0() * x.e0() * v.e1()
            - v.e012() * x.e0() * v.e2()
            + v.e012() * x.e1() * v.e012()
            + v.e012() * x.e2() * v.e0()
            + v.e1() * x.e0() * v.e0(),
        -(v.e0() * x.e2() * v.e0()) - v.e012() * x.e1() * v.e0()
            + v.e012() * x.e0() * v.e1()
            + v.e0() * x.e0() * v.e2()
            + v.e2() * x.e0() * v.e0()
            - v.e0() * x.e1() * v.e012()
            + v.e012() * x.e2() * v.e012()
            + v.e1() * x.e0() * v.e012(),
        v.e0() * x.e0() * v.e0() + v.e012() * x.e0() * v.e012(),
    )
}
#[doc = "Antisandwich product: Motor ⊛ Line ⊛ antirev(Motor) -> Line\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_motor_line<T: Float>(v: &Motor<T>, x: &Line<T>) -> Line<T> {
    Line::new(
        -(v.e2() * x.e01() * v.e0())
            + v.e2() * x.e02() * v.e012()
            + v.e0() * x.e12() * v.e0()
            + v.e1() * x.e01() * v.e012()
            - v.e0() * x.e01() * v.e2()
            + v.e0() * x.e02() * v.e1()
            + v.e012() * x.e01() * v.e1()
            + v.e012() * x.e02() * v.e2()
            + v.e1() * x.e02() * v.e0()
            + v.e012() * x.e12() * v.e012(),
        -(v.e0() * x.e01() * v.e0())
            + v.e012() * x.e01() * v.e012()
            + v.e0() * x.e02() * v.e012()
            + v.e012() * x.e02() * v.e0(),
        -(v.e0() * x.e02() * v.e0()) - v.e012() * x.e01() * v.e0() - v.e0() * x.e01() * v.e012()
            + v.e012() * x.e02() * v.e012(),
    )
}
#[doc = "Antisandwich product: Motor ⊛ Motor ⊛ antirev(Motor) -> Motor\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_motor_motor<T: Float>(v: &Motor<T>, x: &Motor<T>) -> Motor<T> {
    Motor::new(
        -(v.e0() * x.e012() * v.e2()) + v.e2() * x.e012() * v.e0() - v.e2() * x.e0() * v.e012()
            + v.e0() * x.e2() * v.e012()
            - v.e012() * x.e012() * v.e1()
            + v.e012() * x.e2() * v.e0()
            - v.e012() * x.e0() * v.e2()
            - v.e0() * x.e1() * v.e0()
            + v.e1() * x.e0() * v.e0()
            + v.e012() * x.e1() * v.e012()
            + v.e0() * x.e0() * v.e1()
            + v.e1() * x.e012() * v.e012(),
        v.e012() * x.e0() * v.e1() + v.e0() * x.e0() * v.e2() + v.e0() * x.e012() * v.e1()
            - v.e012() * x.e012() * v.e2()
            - v.e012() * x.e1() * v.e0()
            - v.e1() * x.e012() * v.e0()
            - v.e0() * x.e1() * v.e012()
            + v.e1() * x.e0() * v.e012()
            + v.e2() * x.e012() * v.e012()
            + v.e2() * x.e0() * v.e0()
            - v.e0() * x.e2() * v.e0()
            + v.e012() * x.e2() * v.e012(),
        v.e0() * x.e0() * v.e0() + v.e0() * x.e012() * v.e012() + v.e012() * x.e0() * v.e012()
            - v.e012() * x.e012() * v.e0(),
        v.e0() * x.e012() * v.e0() + v.e012() * x.e0() * v.e0() - v.e0() * x.e0() * v.e012()
            + v.e012() * x.e012() * v.e012(),
    )
}
#[doc = "Antisandwich product: Motor ⊛ Flector ⊛ antirev(Motor) -> Flector\n\nUses the geometric antiproduct and antireverse. In PGA, use this\ninstead of the regular sandwich for correct motor transformations."]
#[inline]
pub fn antisandwich_motor_flector<T: Float>(v: &Motor<T>, x: &Flector<T>) -> Flector<T> {
    Flector::new(
        v.e0() * x.e12() * v.e012()
            + v.e0() * x.s() * v.e0()
            + v.e012() * x.s() * v.e012()
            + v.e1() * x.e02() * v.e012()
            + v.e0() * x.e02() * v.e2()
            - v.e1() * x.e01() * v.e0()
            - v.e2() * x.e01() * v.e012()
            + v.e012() * x.e01() * v.e2()
            + v.e0() * x.e01() * v.e1()
            - v.e012() * x.e12() * v.e0()
            - v.e012() * x.e02() * v.e1()
            - v.e2() * x.e02() * v.e0(),
        v.e0() * x.e12() * v.e0() - v.e0() * x.e01() * v.e2()
            + v.e012() * x.e01() * v.e1()
            + v.e1() * x.e02() * v.e0()
            + v.e1() * x.e01() * v.e012()
            + v.e0() * x.e02() * v.e1()
            + v.e012() * x.s() * v.e0()
            - v.e2() * x.e01() * v.e0()
            - v.e0() * x.s() * v.e012()
            + v.e012() * x.e12() * v.e012()
            + v.e012() * x.e02() * v.e2()
            + v.e2() * x.e02() * v.e012(),
        v.e012() * x.e01() * v.e012() - v.e0() * x.e01() * v.e0()
            + v.e0() * x.e02() * v.e012()
            + v.e012() * x.e02() * v.e0(),
        -(v.e012() * x.e01() * v.e0()) - v.e0() * x.e02() * v.e0() - v.e0() * x.e01() * v.e012()
            + v.e012() * x.e02() * v.e012(),
    )
}
#[doc = "Reverses the Flector (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_flector<T: Float>(a: &Flector<T>) -> Flector<T> {
    Flector::new(a.s(), -a.e12(), -a.e01(), -a.e02())
}
#[doc = "Reverses the Line (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_line<T: Float>(a: &Line<T>) -> Line<T> {
    Line::new(-a.e12(), -a.e01(), -a.e02())
}
#[doc = "Reverses the Motor (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_motor<T: Float>(a: &Motor<T>) -> Motor<T> {
    Motor::new(a.e1(), a.e2(), a.e0(), -a.e012())
}
#[doc = "Reverses the Point (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_point<T: Float>(a: &Point<T>) -> Point<T> {
    Point::new(a.e1(), a.e2(), a.e0())
}
#[doc = "Reverses the Scalar (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_scalar<T: Float>(a: &Scalar<T>) -> Scalar<T> {
    Scalar::new(a.s())
}
#[doc = "Reverses the Trivector (negates grades where k(k-1)/2 is odd)."]
#[inline]
pub fn reverse_trivector<T: Float>(a: &Trivector<T>) -> Trivector<T> {
    Trivector::new(-a.e012())
}
#[doc = "Antireverses the Flector (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_flector<T: Float>(a: &Flector<T>) -> Flector<T> {
    Flector::new(-a.s(), a.e12(), a.e01(), a.e02())
}
#[doc = "Antireverses the Line (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_line<T: Float>(a: &Line<T>) -> Line<T> {
    Line::new(a.e12(), a.e01(), a.e02())
}
#[doc = "Antireverses the Motor (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_motor<T: Float>(a: &Motor<T>) -> Motor<T> {
    Motor::new(-a.e1(), -a.e2(), -a.e0(), a.e012())
}
#[doc = "Antireverses the Point (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_point<T: Float>(a: &Point<T>) -> Point<T> {
    Point::new(-a.e1(), -a.e2(), -a.e0())
}
#[doc = "Antireverses the Scalar (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_scalar<T: Float>(a: &Scalar<T>) -> Scalar<T> {
    Scalar::new(-a.s())
}
#[doc = "Antireverses the Trivector (negates grades where (n-k)(n-k-1)/2 is odd)."]
#[inline]
pub fn antireverse_trivector<T: Float>(a: &Trivector<T>) -> Trivector<T> {
    Trivector::new(a.e012())
}
#[doc = "Computes the right complement of Line -> Point."]
#[inline]
pub fn complement_line<T: Float>(a: &Line<T>) -> Point<T> {
    Point::new(a.e02(), -a.e01(), a.e12())
}
#[doc = "Computes the right complement of Point -> Line."]
#[inline]
pub fn complement_point<T: Float>(a: &Point<T>) -> Line<T> {
    Line::new(a.e0(), -a.e2(), a.e1())
}
#[doc = "Computes the right complement of Scalar -> Trivector."]
#[inline]
pub fn complement_scalar<T: Float>(a: &Scalar<T>) -> Trivector<T> {
    Trivector::new(a.s())
}
#[doc = "Computes the right complement of Trivector -> Scalar."]
#[inline]
pub fn complement_trivector<T: Float>(a: &Trivector<T>) -> Scalar<T> {
    Scalar::new(a.e012())
}
