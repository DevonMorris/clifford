# 2D Projective Geometric Algebra (PGA)
# Cl(2,0,1) - 2 positive bases, 1 degenerate basis
#
# Point-based formulation where:
# - Grade 1 = Points (homogeneous coordinates)
# - Grade 2 = Lines
# - Grade 1+3 = Motors (rigid transformations via antisandwich)
# - Grade 0+2 = Flectors (reflections via antisandwich)
#
# Note: In 2D PGA (odd dimension n=3), complement flips parity, so the
# ODD subalgebra [1,3] is closed under antiproduct. This is why Motor
# uses [1,3] instead of the traditional [0,2] - it enables proper
# antisandwich-based transforms.

[algebra]
complete = false
name = "projective2"
module_path = "projective::dim2"
description = "2D Projective Geometric Algebra"

[signature]
positive = ["e1", "e2"]
negative = []
zero = ["e0"]

# Note: Internal basis ordering is [e1, e2, e0] with indices [0, 1, 2].
# In blade notation, we use 1-based indices, so:
# - e1 → internal index 0
# - e2 → internal index 1
# - e3 → internal index 2 (this is the e0 basis in PGA convention)

[blades]
# Scalar (grade 0)
# (implicit)

# Vectors (grade 1) - represent points in homogeneous coordinates
e1 = "e1"
e2 = "e2"
e3 = "e0"  # e3 is the degenerate basis, named e0 in PGA convention

# Bivectors (grade 2) - represent lines
# Euclidean bivector (rotation part)
e12 = "e12"
# Translation bivectors (e0 wedge ei)
e13 = "e01"
e23 = "e02"

# Trivector (grade 3) - pseudoscalar
e123 = "e012"

# ============================================================
# Types
# ============================================================

[types.Scalar]
grades = [0]
field_map = [
  { name = "s", blade = "s" }
]

[types.Point]
grades = [1]
description = "2D point in homogeneous coordinates"
field_map = [
  { name = "x", blade = "e1" },
  { name = "y", blade = "e2" },
  { name = "w", blade = "e3" }
]

[types.Line]
grades = [2]
description = "2D line"
# Line equation: nx * x + ny * y + d = 0 (standard form)
#
# From the wedge product P1 ∧ P2 of two points (x1,y1,w1) and (x2,y2,w2):
# - e12 = x1*y2 - y1*x2 = c (constant term)
# - e23 = y1*w2 - w1*y2 = a (x-coefficient)
# - e13 = x1*w2 - w1*x2 = -b (NEGATIVE of y-coefficient)
#
# We use e31 (= -e13) for ny so that ny stores the positive y-coefficient directly.
# This is enabled by PRD-51's field_map sign correction feature.
field_map = [
  { name = "d", blade = "e12" },
  { name = "nx", blade = "e23" },
  { name = "ny", blade = "e31" }
]

[types.Trivector]
grades = [3]
field_map = [
  { name = "ps", blade = "e123" }
]

[types.Motor]
grades = [1, 3]
description = "2D rigid transformation (rotation + translation) via antisandwich"
# Field names reflect what each component DOES, not which blade it is:
# - ty (e1): controls y-translation (dy goes here)
# - tx (e2): controls x-translation (-dx goes here)
# - r (e3): controls rotation (sin(θ/2) goes here)
# - ps (e123): pseudoscalar (identity for composition)
field_map = [
  { name = "ty", blade = "e1" },
  { name = "tx", blade = "e2" },
  { name = "r", blade = "e3" },
  { name = "ps", blade = "e123" }
]

[types.Flector]
grades = [0, 2]
description = "2D reflection/glide transformation via antisandwich"
# Grade 0: scalar (s)
# Grade 2: Line components representing the reflection line
# (same conventions as Line type: d, nx, ny with e31 for ny)
field_map = [
  { name = "s", blade = "s" },
  { name = "d", blade = "e12" },
  { name = "nx", blade = "e23" },
  { name = "ny", blade = "e31" }
]
