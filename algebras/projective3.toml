# 3D Projective Geometric Algebra (PGA)
# Cl(3,0,1) - 3 positive bases, 1 degenerate basis

[algebra]
name = "projective3"
module_path = "generated::projective3"
description = "3D Projective Geometric Algebra"

[signature]
positive = ["e1", "e2", "e3"]
negative = []
zero = ["e0"]

[blades]
# Vectors (grade 1) - represent planes
# e4 is the degenerate basis (e0 in PGA convention)
e1 = "e1"
e2 = "e2"
e3 = "e3"
e4 = "e0"

# Bivectors (grade 2) - represent lines
e12 = "e12"
e13 = "e13"
e23 = "e23"
e14 = "e01"
e24 = "e02"
e34 = "e03"

# Trivectors (grade 3) - represent points
e123 = "e123"
e124 = "e012"
e134 = "e013"
e234 = "e023"

# Quadvector (grade 4) - pseudoscalar
e1234 = "e0123"

# ============================================================
# Types
# ============================================================

[types.Scalar]
grades = [0]
fields = ["s"]

[types.Vector]
grades = [1]
fields = ["e1", "e2", "e3", "e0"]

[types.Bivector]
grades = [2]
fields = ["e12", "e13", "e23", "e01", "e02", "e03"]

# Plücker constraint for lines
[[types.Bivector.constraints]]
name = "plucker"
description = "Plücker constraint for valid lines"
expression = "-2*e12*e03 + 2*e13*e02 - 2*e23*e01 = 0"
solve_for = "e03"

[types.Trivector]
grades = [3]
fields = ["e123", "e012", "e013", "e023"]

[types.Quadvector]
grades = [4]
fields = ["e0123"]

[types.Motor]
grades = [0, 2, 4]
fields = ["s", "e12", "e13", "e23", "e01", "e02", "e03", "e0123"]

# Unit norm constraint for proper rigid transformations
# Must come first since study constraint depends on s
[[types.Motor.constraints]]
name = "unit"
description = "Unit motor for proper rigid transformations"
expression = "s*s + e12*e12 + e13*e13 + e23*e23 = 1"
solve_for = "s"
sign = "positive"

# Study constraint (geometric antiproduct constraint)
# Uses s computed from unit constraint
[[types.Motor.constraints]]
name = "study"
description = "Study condition for valid motors"
expression = "2*s*e0123 - 2*e12*e03 + 2*e13*e02 - 2*e23*e01 = 0"
solve_for = "e0123"

[types.Flector]
grades = [1, 3]
fields = ["e1", "e2", "e3", "e0", "e123", "e012", "e013", "e023"]

# Geometric constraint for valid flectors
[[types.Flector.constraints]]
name = "geometric"
description = "Geometric constraint for valid flectors"
expression = "-2*e1*e023 + 2*e2*e013 - 2*e3*e012 + 2*e0*e123 = 0"
solve_for = "e023"

[options]
generate_serde = true
generate_arbitrary = true
generate_nalgebra = true
