# PRD-14.5: Constrained Types (Unit, Normalized)

**Status**: Draft
**Parent**: [PRD-14: Geometric Algebra Code Generator](prd-14-codegen.md)
**Goal**: Generate type-safe wrapper types that enforce algebraic constraints

## Overview

This phase generates:
1. Constrained wrapper types (e.g., `UnitRotor<T>`)
2. Safe constructors that guarantee constraints
3. Constraint-preserving operations
4. `Deref`, `AsRef`, `From` implementations
5. `Arbitrary` implementations for testing

## Constraint Categories

### Unit Constraint

Elements with norm = 1:

```rust
#[derive(Clone, Copy, Debug, PartialEq)]
#[repr(transparent)]
pub struct UnitRotor<T: Float>(Rotor<T>);
```

**Norm types**:
- `euclidean`: `‖x‖² = Σxᵢ²`
- `motor`: PGA motor norm (complex)
- `cga`: CGA-specific norm

### NonZero Constraint

Elements with non-zero norm:

```rust
#[derive(Clone, Copy, Debug, PartialEq)]
#[repr(transparent)]
pub struct NonZeroVector<T: Float>(Vector<T>);
```

### Normalized Constraint

Context-dependent canonical form:
- **Point**: `w = 1` (homogeneous coordinate)
- **Line**: Direction has unit length
- **Plane**: Normal has unit length

```rust
#[derive(Clone, Copy, Debug, PartialEq)]
#[repr(transparent)]
pub struct NormalizedPoint<T: Float>(Point<T>);
```

### Null Constraint

Elements with zero self-inner-product (CGA):

```rust
#[derive(Clone, Copy, Debug, PartialEq)]
#[repr(transparent)]
pub struct NullVector<T: Float>(Vector<T>);  // For CGA points
```

## Generator Structure

```rust
pub struct ConstraintGenerator<'a> {
    spec: &'a AlgebraSpec,
    algebra: &'a Algebra,
}

impl<'a> ConstraintGenerator<'a> {
    pub fn generate_constrained_file(&self) -> TokenStream {
        let imports = self.generate_imports();

        let wrappers: Vec<TokenStream> = self.spec.types.iter()
            .flat_map(|ty| self.generate_constraints_for_type(ty))
            .collect();

        quote! {
            //! Constrained wrapper types.
            //!
            //! Auto-generated by clifford-codegen.

            #imports

            #(#wrappers)*
        }
    }

    fn generate_constraints_for_type(&self, ty: &TypeSpec) -> Vec<TokenStream> {
        ty.constraints.iter()
            .map(|c| self.generate_constraint(ty, c))
            .collect()
    }

    fn generate_constraint(
        &self,
        base_type: &TypeSpec,
        constraint: &ConstraintSpec,
    ) -> TokenStream {
        match constraint.kind {
            ConstraintKind::Unit => self.generate_unit_wrapper(base_type, constraint),
            ConstraintKind::NonZero => self.generate_nonzero_wrapper(base_type, constraint),
            ConstraintKind::Normalized => self.generate_normalized_wrapper(base_type, constraint),
            ConstraintKind::Null => self.generate_null_wrapper(base_type, constraint),
            ConstraintKind::Ideal => self.generate_ideal_wrapper(base_type, constraint),
        }
    }
}
```

## Unit Wrapper Generation

```rust
fn generate_unit_wrapper(
    &self,
    base_type: &TypeSpec,
    constraint: &ConstraintSpec,
) -> TokenStream {
    let base_name = format_ident!("{}", base_type.name);
    let wrapper_name = format_ident!("{}", constraint.wrapper_name);

    let doc = format!(
        "Unit {} with guaranteed norm = 1.\n\n\
        This wrapper type ensures the {} always has unit norm.",
        base_type.name, base_type.name.to_lowercase()
    );

    let constructors = self.generate_unit_constructors(base_type, constraint);
    let preserving_ops = self.generate_preserving_ops(base_type, constraint);
    let conversions = self.generate_conversions(base_type, constraint);
    let deref_impl = self.generate_deref(base_type, constraint);
    let mul_impl = self.generate_unit_mul(base_type, constraint);

    quote! {
        #[doc = #doc]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(transparent)]
        pub struct #wrapper_name<T: Float>(#base_name<T>);

        impl<T: Float> #wrapper_name<T> {
            #constructors
            #preserving_ops

            /// Creates from components without validation.
            ///
            /// # Safety (Logical)
            ///
            /// Caller must ensure the constraint is satisfied.
            #[inline]
            pub fn new_unchecked(inner: #base_name<T>) -> Self {
                Self(inner)
            }

            /// Attempts to create by normalizing the given element.
            ///
            /// Returns `None` if the norm is too small.
            #[inline]
            pub fn try_from_inner(inner: #base_name<T>) -> Option<Self> {
                inner.try_normalize().map(Self)
            }

            /// Returns the underlying element.
            #[inline]
            pub fn into_inner(self) -> #base_name<T> {
                self.0
            }
        }

        #conversions
        #deref_impl
        #mul_impl
    }
}

fn generate_unit_constructors(
    &self,
    base_type: &TypeSpec,
    constraint: &ConstraintSpec,
) -> TokenStream {
    let constructors: Vec<TokenStream> = constraint.constructors.iter()
        .map(|ctor| self.generate_constructor(base_type, ctor))
        .collect();

    quote! { #(#constructors)* }
}

fn generate_constructor(
    &self,
    base_type: &TypeSpec,
    ctor: &ConstructorSpec,
) -> TokenStream {
    let name = format_ident!("{}", ctor.name);
    let base_name = format_ident!("{}", base_type.name);

    // Parse parameters
    let params: Vec<TokenStream> = ctor.params.iter().map(|p| {
        let param_name = format_ident!("{}", p.name);
        let param_type = parse_type(&p.ty);
        quote! { #param_name: #param_type }
    }).collect();

    // Generate body based on constructor name
    let body = match ctor.name.as_str() {
        "identity" => quote! {
            Self(#base_name::identity())
        },
        "from_angle_plane" => quote! {
            let half = angle / T::TWO;
            let (sin_half, cos_half) = (half.sin(), half.cos());
            let plane_norm = plane.norm();

            if plane_norm < T::epsilon() {
                return Self::identity();
            }

            let scale = sin_half / plane_norm;
            Self(#base_name::new(
                cos_half,
                plane.xy() * scale,
                plane.xz() * scale,
                plane.yz() * scale,
            ))
        },
        // ... other constructors
        _ => {
            // Generic: try to normalize
            quote! {
                let inner = #base_name::/* constructor logic */;
                Self(inner.normalize())
            }
        }
    };

    let doc = format!("Creates a unit {} via {}.", base_type.name.to_lowercase(), ctor.name);

    quote! {
        #[doc = #doc]
        #[inline]
        pub fn #name(#(#params),*) -> Self {
            #body
        }
    }
}
```

## Constraint-Preserving Operations

```rust
fn generate_preserving_ops(
    &self,
    base_type: &TypeSpec,
    constraint: &ConstraintSpec,
) -> TokenStream {
    let wrapper_name = format_ident!("{}", constraint.wrapper_name);

    let ops: Vec<TokenStream> = constraint.preserving_ops.iter()
        .map(|op| self.generate_preserving_op(base_type, constraint, op))
        .collect();

    quote! { #(#ops)* }
}

fn generate_preserving_op(
    &self,
    base_type: &TypeSpec,
    constraint: &ConstraintSpec,
    op_name: &str,
) -> TokenStream {
    let wrapper_name = format_ident!("{}", constraint.wrapper_name);

    match op_name {
        "compose" => {
            quote! {
                /// Composes two elements. Result is always unit.
                #[inline]
                pub fn compose(self, other: Self) -> Self {
                    // Unit * Unit = Unit (algebraic fact)
                    Self::new_unchecked(
                        geometric_product(self.0, other.0)
                    )
                }
            }
        }
        "inverse" => {
            quote! {
                /// Returns the inverse.
                ///
                /// For unit elements, inverse = reverse.
                #[inline]
                pub fn inverse(self) -> Self {
                    Self(self.0.reverse())
                }
            }
        }
        "slerp" => {
            quote! {
                /// Spherical linear interpolation.
                ///
                /// Result is always unit.
                #[inline]
                pub fn slerp(self, other: Self, t: T) -> Self {
                    // SLERP implementation preserves unit
                    let dot = /* compute dot product */;
                    let theta = dot.acos();

                    if theta.abs() < T::epsilon() {
                        // Linear interpolation for small angles
                        let inner = self.0.scale(T::one() - t) + other.0.scale(t);
                        return Self(inner.normalize());
                    }

                    let sin_theta = theta.sin();
                    let s1 = ((T::one() - t) * theta).sin() / sin_theta;
                    let s2 = (t * theta).sin() / sin_theta;

                    Self::new_unchecked(
                        self.0.scale(s1) + other.0.scale(s2)
                    )
                }
            }
        }
        _ => quote! {}
    }
}
```

## Deref and Conversion Traits

```rust
fn generate_deref(
    &self,
    base_type: &TypeSpec,
    constraint: &ConstraintSpec,
) -> TokenStream {
    let base_name = format_ident!("{}", base_type.name);
    let wrapper_name = format_ident!("{}", constraint.wrapper_name);

    quote! {
        impl<T: Float> std::ops::Deref for #wrapper_name<T> {
            type Target = #base_name<T>;

            #[inline]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }

        impl<T: Float> AsRef<#base_name<T>> for #wrapper_name<T> {
            #[inline]
            fn as_ref(&self) -> &#base_name<T> {
                &self.0
            }
        }

        impl<T: Float> From<#wrapper_name<T>> for #base_name<T> {
            #[inline]
            fn from(unit: #wrapper_name<T>) -> Self {
                unit.0
            }
        }
    }
}
```

## Operator Overloads for Constrained Types

```rust
fn generate_unit_mul(
    &self,
    base_type: &TypeSpec,
    constraint: &ConstraintSpec,
) -> TokenStream {
    let wrapper_name = format_ident!("{}", constraint.wrapper_name);

    // Only generate if "compose" is a preserving op
    if !constraint.preserving_ops.contains(&"compose".to_string()) {
        return quote! {};
    }

    quote! {
        impl<T: Float> std::ops::Mul for #wrapper_name<T> {
            type Output = Self;

            #[inline]
            fn mul(self, rhs: Self) -> Self {
                self.compose(rhs)
            }
        }
    }
}
```

## Arbitrary Implementations

```rust
fn generate_arbitrary(
    &self,
    base_type: &TypeSpec,
    constraint: &ConstraintSpec,
) -> TokenStream {
    let base_name = format_ident!("{}", base_type.name);
    let wrapper_name = format_ident!("{}", constraint.wrapper_name);

    match constraint.kind {
        ConstraintKind::Unit => self.generate_unit_arbitrary(base_type, constraint),
        ConstraintKind::NonZero => self.generate_nonzero_arbitrary(base_type, constraint),
        _ => quote! {}
    }
}

fn generate_unit_arbitrary(
    &self,
    base_type: &TypeSpec,
    constraint: &ConstraintSpec,
) -> TokenStream {
    let base_name = format_ident!("{}", base_type.name);
    let wrapper_name = format_ident!("{}", constraint.wrapper_name);

    // Strategy depends on the type
    // For rotors: generate angle + unit bivector
    if base_type.name == "Rotor" {
        quote! {
            #[cfg(any(test, feature = "proptest-support"))]
            impl<T> proptest::arbitrary::Arbitrary for #wrapper_name<T>
            where
                T: Float + std::fmt::Debug + 'static,
            {
                type Parameters = ();
                type Strategy = proptest::strategy::BoxedStrategy<Self>;

                fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
                    use proptest::prelude::*;

                    (-std::f64::consts::PI..std::f64::consts::PI)
                        .prop_flat_map(|angle| {
                            any::<UnitBivector<T>>().prop_map(move |plane| {
                                #wrapper_name::from_angle_plane(
                                    T::from_f64(angle),
                                    plane.into_inner()
                                )
                            })
                        })
                        .boxed()
                }
            }
        }
    } else {
        // Generic: normalize random element
        quote! {
            #[cfg(any(test, feature = "proptest-support"))]
            impl<T> proptest::arbitrary::Arbitrary for #wrapper_name<T>
            where
                T: Float + std::fmt::Debug + 'static,
                #base_name<T>: proptest::arbitrary::Arbitrary,
            {
                type Parameters = ();
                type Strategy = proptest::strategy::BoxedStrategy<Self>;

                fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
                    use proptest::prelude::*;

                    any::<#base_name<T>>()
                        .prop_filter_map("zero element", |x| {
                            #wrapper_name::try_from_inner(x)
                        })
                        .boxed()
                }
            }
        }
    }
}

fn generate_nonzero_arbitrary(
    &self,
    base_type: &TypeSpec,
    constraint: &ConstraintSpec,
) -> TokenStream {
    let base_name = format_ident!("{}", base_type.name);
    let wrapper_name = format_ident!("{}", constraint.wrapper_name);

    quote! {
        #[cfg(any(test, feature = "proptest-support"))]
        impl<T> proptest::arbitrary::Arbitrary for #wrapper_name<T>
        where
            T: Float + std::fmt::Debug + 'static,
            #base_name<T>: proptest::arbitrary::Arbitrary,
        {
            type Parameters = ();
            type Strategy = proptest::strategy::BoxedStrategy<Self>;

            fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
                use proptest::prelude::*;

                any::<#base_name<T>>()
                    .prop_filter("zero element", |x| {
                        x.norm_squared() > T::epsilon()
                    })
                    .prop_map(|x| #wrapper_name(x))
                    .boxed()
            }
        }
    }
}
```

## Approx Trait Implementations

```rust
fn generate_approx_traits(
    &self,
    base_type: &TypeSpec,
    constraint: &ConstraintSpec,
) -> TokenStream {
    let base_name = format_ident!("{}", base_type.name);
    let wrapper_name = format_ident!("{}", constraint.wrapper_name);

    quote! {
        impl<T: Float> approx::AbsDiffEq for #wrapper_name<T> {
            type Epsilon = T;

            fn default_epsilon() -> Self::Epsilon {
                T::default_epsilon()
            }

            fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
                self.0.abs_diff_eq(&other.0, epsilon)
            }
        }

        impl<T: Float> approx::RelativeEq for #wrapper_name<T> {
            fn default_max_relative() -> Self::Epsilon {
                T::default_max_relative()
            }

            fn relative_eq(
                &self,
                other: &Self,
                epsilon: Self::Epsilon,
                max_relative: Self::Epsilon,
            ) -> bool {
                self.0.relative_eq(&other.0, epsilon, max_relative)
            }
        }

        impl<T: Float> approx::UlpsEq for #wrapper_name<T> {
            fn default_max_ulps() -> u32 {
                T::default_max_ulps()
            }

            fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
                self.0.ulps_eq(&other.0, epsilon, max_ulps)
            }
        }
    }
}
```

## Generated Products for Constrained Types

Generate specialized products that preserve constraints:

```rust
// products.rs additions

/// Geometric product: UnitRotor × UnitRotor → UnitRotor
///
/// Constraint-preserving: unit × unit = unit.
#[inline]
pub fn geometric_unit_rotor_unit_rotor<T: Float>(
    a: UnitRotor<T>,
    b: UnitRotor<T>,
) -> UnitRotor<T> {
    // Same formula as Rotor × Rotor, but return type is UnitRotor
    UnitRotor::new_unchecked(Rotor::new(
        a.s()*b.s() - a.xy()*b.xy() - a.xz()*b.xz() - a.yz()*b.yz(),
        a.s()*b.xy() + a.xy()*b.s() + a.xz()*b.yz() - a.yz()*b.xz(),
        a.s()*b.xz() + a.xz()*b.s() - a.xy()*b.yz() + a.yz()*b.xy(),
        a.s()*b.yz() + a.yz()*b.s() + a.xy()*b.xz() - a.xz()*b.xy(),
    ))
}

/// Sandwich product: UnitRotor × Vector → Vector
///
/// Uses the unit rotor's optimized sandwich.
#[inline]
pub fn sandwich_unit_rotor_vector<T: Float>(
    r: UnitRotor<T>,
    v: Vector<T>,
) -> Vector<T> {
    // Same implementation as sandwich_rotor_vector
    sandwich_rotor_vector(r.into_inner(), v)
}
```

## Testing

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn unit_rotor_has_unit_norm(r in any::<UnitRotor<f64>>()) {
            prop_assert!(abs_diff_eq!(r.norm(), 1.0, epsilon = 1e-10));
        }

        #[test]
        fn unit_rotor_composition_is_unit(
            a in any::<UnitRotor<f64>>(),
            b in any::<UnitRotor<f64>>(),
        ) {
            let result = a.compose(b);
            prop_assert!(abs_diff_eq!(result.norm(), 1.0, epsilon = 1e-10));
        }

        #[test]
        fn unit_rotor_inverse_is_unit(r in any::<UnitRotor<f64>>()) {
            let inv = r.inverse();
            prop_assert!(abs_diff_eq!(inv.norm(), 1.0, epsilon = 1e-10));
        }

        #[test]
        fn unit_rotor_inverse_is_correct(
            r in any::<UnitRotor<f64>>(),
            v in any::<Vector<f64>>(),
        ) {
            let rotated = sandwich_unit_rotor_vector(r, v);
            let back = sandwich_unit_rotor_vector(r.inverse(), rotated);
            prop_assert!(abs_diff_eq!(v, back, epsilon = 1e-10));
        }

        #[test]
        fn unit_rotor_slerp_is_unit(
            a in any::<UnitRotor<f64>>(),
            b in any::<UnitRotor<f64>>(),
            t in 0.0f64..1.0,
        ) {
            let result = a.slerp(b, t);
            prop_assert!(abs_diff_eq!(result.norm(), 1.0, epsilon = 1e-10));
        }

        #[test]
        fn nonzero_vector_is_nonzero(v in any::<NonZeroVector<f64>>()) {
            prop_assert!(v.norm_squared() > f64::EPSILON);
        }
    }
}
```

## Deliverables

- [ ] `ConstraintGenerator` struct
- [ ] Unit wrapper generation
- [ ] NonZero wrapper generation
- [ ] Normalized wrapper generation
- [ ] Null wrapper generation
- [ ] Constructor generation
- [ ] Constraint-preserving operation generation
- [ ] `Deref`, `AsRef`, `From` implementations
- [ ] `Mul` operator for composable unit types
- [ ] Arbitrary implementations
- [ ] Approx trait implementations
- [ ] Specialized products for constrained types
- [ ] Tests for constraint preservation

## Success Criteria

1. All constrained constructors produce valid elements
2. Constraint-preserving operations maintain constraints
3. `Deref` allows transparent access to base type methods
4. Arbitrary produces only valid constrained elements
5. Round-trip through `into_inner()` and `try_from_inner()` works
