# PRD-14.3: Type & Struct Generation

**Status**: Draft
**Parent**: [PRD-14: Geometric Algebra Code Generator](prd-14-codegen.md)
**Goal**: Generate Rust struct definitions for all types in an algebra specification

## Overview

This phase generates:
1. Base struct definitions with private fields
2. Public accessor methods
3. Constructors (`new`, `zero`, `identity`, unit basis)
4. Basic methods (`norm_squared`, `norm`, `reverse`)
5. Comprehensive documentation

## Generated Structure

For each type in the specification, generate:

```rust
// types.rs

/// {description from spec}
///
/// # Basis Ordering
///
/// | Index | Blade | Field |
/// |-------|-------|-------|
/// | {idx} | {blade} | `{field}` |
/// ...
///
/// # Example
///
/// ```
/// use {module_path}::{TypeName};
///
/// let v = {TypeName}::new({example_args});
/// ```
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[repr(C)]
pub struct {TypeName}<T: Float> {
    {field1}: T,
    {field2}: T,
    // ...
}

impl<T: Float> {TypeName}<T> {
    // Constructor
    /// Creates a new {TypeName} from components.
    #[inline]
    pub fn new({field1}: T, {field2}: T, ...) -> Self {
        Self { {field1}, {field2}, ... }
    }

    // Accessors
    /// Returns the {field1} component ({blade_description}).
    #[inline]
    pub fn {field1}(&self) -> T {
        self.{field1}
    }
    // ... for each field

    // Zero
    /// Creates the zero element.
    #[inline]
    pub fn zero() -> Self {
        Self::new(T::zero(), T::zero(), ...)
    }

    // Identity (if applicable - types containing grade 0)
    /// Creates the identity element (scalar = 1, rest = 0).
    #[inline]
    pub fn identity() -> Self {
        Self::new(T::one(), T::zero(), ...)
    }

    // Unit basis elements (for single-grade types)
    /// Creates the unit {blade_name} element.
    #[inline]
    pub fn unit_{field1}() -> Self {
        Self::new(T::one(), T::zero(), ...)
    }
}

impl<T: Float> Default for {TypeName}<T> {
    fn default() -> Self {
        Self::zero()  // or Self::identity() for types like Rotor
    }
}
```

## Code Generation Engine

### Type Generator

```rust
use proc_macro2::TokenStream;
use quote::{quote, format_ident};

pub struct TypeGenerator<'a> {
    spec: &'a AlgebraSpec,
    algebra: &'a Algebra,
}

impl<'a> TypeGenerator<'a> {
    pub fn new(spec: &'a AlgebraSpec, algebra: &'a Algebra) -> Self {
        Self { spec, algebra }
    }

    /// Generates the complete types.rs file.
    pub fn generate_types_file(&self) -> TokenStream {
        let imports = self.generate_imports();
        let types: Vec<TokenStream> = self.spec.types.iter()
            .map(|ty| self.generate_type(ty))
            .collect();

        quote! {
            //! Type definitions for {algebra_name}.
            //!
            //! This file is auto-generated by clifford-codegen.
            //! Do not edit manually.

            #imports

            #(#types)*
        }
    }

    fn generate_imports(&self) -> TokenStream {
        quote! {
            use crate::scalar::Float;

            #[cfg(feature = "serde")]
            use serde::{Serialize, Deserialize};
        }
    }

    /// Generates a single type definition.
    fn generate_type(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let doc = self.generate_type_doc(ty);
        let derives = self.generate_derives(ty);
        let fields = self.generate_fields(ty);
        let impl_block = self.generate_impl(ty);
        let default_impl = self.generate_default(ty);

        quote! {
            #doc
            #derives
            #[repr(C)]
            pub struct #name<T: Float> {
                #fields
            }

            #impl_block
            #default_impl
        }
    }

    fn generate_type_doc(&self, ty: &TypeSpec) -> TokenStream {
        let description = ty.description.as_deref().unwrap_or(&ty.name);
        let basis_table = self.generate_basis_table(ty);
        let example = self.generate_example(ty);

        let doc_string = format!(
            "{}\n\n# Basis Ordering\n\n{}\n\n# Example\n\n```\n{}\n```",
            description, basis_table, example
        );

        quote! {
            #[doc = #doc_string]
        }
    }

    fn generate_basis_table(&self, ty: &TypeSpec) -> String {
        let mut table = String::from("| Index | Blade | Field |\n|-------|-------|-------|\n");

        for field in &ty.fields {
            let blade_name = self.algebra.blade_name(Blade::from_index(field.blade_index));
            table.push_str(&format!(
                "| {} | {} | `{}` |\n",
                field.blade_index, blade_name, field.name
            ));
        }

        table
    }

    fn generate_example(&self, ty: &TypeSpec) -> String {
        let args: Vec<String> = ty.fields.iter()
            .enumerate()
            .map(|(i, _)| format!("{}.0", i + 1))
            .collect();

        format!(
            "use clifford::{}::{};\n\nlet v = {}::new({});",
            self.spec.module_path.as_deref().unwrap_or("generated"),
            ty.name,
            ty.name,
            args.join(", ")
        )
    }

    fn generate_derives(&self, _ty: &TypeSpec) -> TokenStream {
        let serde_derive = if self.spec.options.generate_serde {
            quote! { #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))] }
        } else {
            quote! {}
        };

        quote! {
            #[derive(Clone, Copy, Debug, PartialEq)]
            #serde_derive
        }
    }

    fn generate_fields(&self, ty: &TypeSpec) -> TokenStream {
        let fields: Vec<TokenStream> = ty.fields.iter().map(|field| {
            let name = format_ident!("{}", field.name);
            let blade_name = self.algebra.blade_name(Blade::from_index(field.blade_index));
            let doc = format!("Coefficient of `{}`.", blade_name);

            quote! {
                #[doc = #doc]
                #name: T,
            }
        }).collect();

        quote! { #(#fields)* }
    }

    fn generate_impl(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let constructor = self.generate_constructor(ty);
        let accessors = self.generate_accessors(ty);
        let zero = self.generate_zero(ty);
        let identity = self.generate_identity(ty);
        let unit_elements = self.generate_unit_elements(ty);
        let norm_methods = self.generate_norm_methods(ty);
        let reverse = self.generate_reverse(ty);

        quote! {
            impl<T: Float> #name<T> {
                #constructor
                #accessors
                #zero
                #identity
                #unit_elements
                #norm_methods
                #reverse
            }
        }
    }

    fn generate_constructor(&self, ty: &TypeSpec) -> TokenStream {
        let params: Vec<TokenStream> = ty.fields.iter().map(|field| {
            let name = format_ident!("{}", field.name);
            quote! { #name: T }
        }).collect();

        let field_inits: Vec<TokenStream> = ty.fields.iter().map(|field| {
            let name = format_ident!("{}", field.name);
            quote! { #name }
        }).collect();

        quote! {
            /// Creates a new element from components.
            #[inline]
            pub fn new(#(#params),*) -> Self {
                Self { #(#field_inits),* }
            }
        }
    }

    fn generate_accessors(&self, ty: &TypeSpec) -> TokenStream {
        let accessors: Vec<TokenStream> = ty.fields.iter().map(|field| {
            let name = format_ident!("{}", field.name);
            let blade_name = self.algebra.blade_name(Blade::from_index(field.blade_index));
            let doc = format!("Returns the {} component (coefficient of `{}`).", field.name, blade_name);

            quote! {
                #[doc = #doc]
                #[inline]
                pub fn #name(&self) -> T {
                    self.#name
                }
            }
        }).collect();

        quote! { #(#accessors)* }
    }

    fn generate_zero(&self, ty: &TypeSpec) -> TokenStream {
        let zeros: Vec<TokenStream> = ty.fields.iter()
            .map(|_| quote! { T::zero() })
            .collect();

        quote! {
            /// Creates the zero element.
            #[inline]
            pub fn zero() -> Self {
                Self::new(#(#zeros),*)
            }
        }
    }

    fn generate_identity(&self, ty: &TypeSpec) -> TokenStream {
        // Only generate identity for types containing grade 0
        if !ty.grades.contains(&0) {
            return quote! {};
        }

        let values: Vec<TokenStream> = ty.fields.iter().map(|field| {
            if field.grade == 0 {
                quote! { T::one() }
            } else {
                quote! { T::zero() }
            }
        }).collect();

        quote! {
            /// Creates the identity element (scalar = 1, rest = 0).
            #[inline]
            pub fn identity() -> Self {
                Self::new(#(#values),*)
            }
        }
    }

    fn generate_unit_elements(&self, ty: &TypeSpec) -> TokenStream {
        // Only for single-grade types
        if ty.grades.len() != 1 {
            return quote! {};
        }

        let units: Vec<TokenStream> = ty.fields.iter().enumerate().map(|(i, field)| {
            let method_name = format_ident!("unit_{}", field.name);
            let blade_name = self.algebra.blade_name(Blade::from_index(field.blade_index));
            let doc = format!("Creates the unit {} element.", blade_name);

            let values: Vec<TokenStream> = ty.fields.iter().enumerate().map(|(j, _)| {
                if i == j {
                    quote! { T::one() }
                } else {
                    quote! { T::zero() }
                }
            }).collect();

            quote! {
                #[doc = #doc]
                #[inline]
                pub fn #method_name() -> Self {
                    Self::new(#(#values),*)
                }
            }
        }).collect();

        quote! { #(#units)* }
    }

    fn generate_norm_methods(&self, ty: &TypeSpec) -> TokenStream {
        let field_names: Vec<_> = ty.fields.iter()
            .map(|f| format_ident!("{}", f.name))
            .collect();

        // Compute norm squared based on metric signature
        // For now, assume Euclidean (all positive)
        // TODO: Handle different metrics properly
        let squared_terms: Vec<TokenStream> = field_names.iter()
            .map(|name| quote! { self.#name * self.#name })
            .collect();

        quote! {
            /// Returns the squared norm.
            #[inline]
            pub fn norm_squared(&self) -> T {
                #(#squared_terms)+*
            }

            /// Returns the norm.
            #[inline]
            pub fn norm(&self) -> T {
                self.norm_squared().sqrt()
            }

            /// Attempts to normalize this element.
            /// Returns `None` if the norm is too small.
            #[inline]
            pub fn try_normalize(&self) -> Option<Self> {
                let n = self.norm();
                if n < T::epsilon() {
                    None
                } else {
                    Some(self.scale(T::one() / n))
                }
            }

            /// Normalizes this element, panicking if zero.
            #[inline]
            pub fn normalize(&self) -> Self {
                self.try_normalize().expect("cannot normalize zero element")
            }

            /// Scales all components by a scalar.
            #[inline]
            pub fn scale(&self, s: T) -> Self {
                Self::new(#(self.#field_names * s),*)
            }
        }
    }

    fn generate_reverse(&self, ty: &TypeSpec) -> TokenStream {
        // Reverse: (-1)^(k(k-1)/2) for grade k
        let reversed_values: Vec<TokenStream> = ty.fields.iter().map(|field| {
            let name = format_ident!("{}", field.name);
            let grade = field.grade;
            let sign = if (grade * (grade.saturating_sub(1)) / 2) % 2 == 0 {
                quote! { self.#name }
            } else {
                quote! { -self.#name }
            };
            sign
        }).collect();

        quote! {
            /// Returns the reverse (reversion).
            ///
            /// For a k-blade, reverse has sign (-1)^(k(k-1)/2).
            #[inline]
            pub fn reverse(&self) -> Self {
                Self::new(#(#reversed_values),*)
            }
        }
    }

    fn generate_default(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        // Default is identity for types with grade 0, otherwise zero
        let default_fn = if ty.grades.contains(&0) {
            quote! { Self::identity() }
        } else {
            quote! { Self::zero() }
        };

        quote! {
            impl<T: Float> Default for #name<T> {
                fn default() -> Self {
                    #default_fn
                }
            }
        }
    }
}
```

## Field Ordering

Fields are ordered according to canonical blade ordering:

1. **By grade** (ascending): All grade-0 fields, then grade-1, then grade-2, etc.
2. **Within grade by blade index** (ascending): e12 (index 3) before e13 (index 5)

```rust
fn order_fields(ty: &TypeSpec, algebra: &Algebra) -> Vec<FieldSpec> {
    let mut fields = ty.fields.clone();

    // Compute blade indices for each field
    for field in &mut fields {
        field.blade_index = blade_index_from_name(&field.name, algebra);
        field.grade = Blade::from_index(field.blade_index).grade();
    }

    // Sort by grade, then by blade index
    fields.sort_by_key(|f| (f.grade, f.blade_index));

    fields
}
```

## Output Format

### File Organization

```
generated/{algebra_name}/
├── mod.rs
└── types.rs
```

### mod.rs

```rust
//! {algebra_description}
//!
//! This module is auto-generated by clifford-codegen.
//! Do not edit manually.

mod types;

pub use types::*;
```

### Formatting

Generated code is formatted with `rustfmt`:

```rust
use std::process::Command;

pub fn format_file(path: &Path) -> std::io::Result<()> {
    Command::new("rustfmt")
        .arg(path)
        .status()?;
    Ok(())
}
```

## Testing

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generates_vector_type() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::new(3, 0, 0);
        let gen = TypeGenerator::new(&spec, &algebra);

        let tokens = gen.generate_types_file();
        let code = tokens.to_string();

        assert!(code.contains("pub struct Vector<T: Float>"));
        assert!(code.contains("x: T"));
        assert!(code.contains("y: T"));
        assert!(code.contains("z: T"));
        assert!(code.contains("pub fn new(x: T, y: T, z: T)"));
        assert!(code.contains("pub fn x(&self) -> T"));
    }

    #[test]
    fn field_order_is_canonical() {
        // Verify fields are ordered by grade, then by blade index
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let full_type = spec.types.iter().find(|t| t.name == "Full").unwrap();

        let field_order: Vec<&str> = full_type.fields.iter()
            .map(|f| f.name.as_str())
            .collect();

        // Expected: s (grade 0), x, y, z (grade 1), xy, xz, yz (grade 2), xyz (grade 3)
        assert_eq!(field_order, vec!["s", "x", "y", "z", "xy", "xz", "yz", "xyz"]);
    }

    #[test]
    fn reverse_signs_correct() {
        // Grade 0: sign = +1
        // Grade 1: sign = +1 (0*-1/2 = 0, even)
        // Grade 2: sign = -1 (2*1/2 = 1, odd)
        // Grade 3: sign = -1 (3*2/2 = 3, odd)

        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::new(3, 0, 0);
        let gen = TypeGenerator::new(&spec, &algebra);

        // Check Bivector reverse
        let bivector = spec.types.iter().find(|t| t.name == "Bivector").unwrap();
        let tokens = gen.generate_reverse(bivector);
        let code = tokens.to_string();

        // All bivector components should be negated
        assert!(code.contains("-self.xy"));
        assert!(code.contains("-self.xz"));
        assert!(code.contains("-self.yz"));
    }
}
```

## Deliverables

- [ ] `TypeGenerator` struct
- [ ] Struct generation with docs
- [ ] Accessor generation
- [ ] Constructor generation
- [ ] `zero()`, `identity()`, `unit_*()` generation
- [ ] Norm methods generation
- [ ] Reverse generation
- [ ] Default impl generation
- [ ] Field ordering by canonical blade index
- [ ] rustfmt integration
- [ ] Tests

## Dependencies

- `proc-macro2` - Token manipulation
- `quote` - Quasi-quoting
- `syn` - Rust syntax (for parsing, if needed)

## Success Criteria

1. Generated types compile without errors
2. Field ordering matches canonical blade ordering
3. Reverse signs are correct for all grades
4. Generated code passes rustfmt
5. Documentation is complete and accurate
