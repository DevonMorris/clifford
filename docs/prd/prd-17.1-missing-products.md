# PRD-17.1: Missing Product Generation

**Status**: Complete
**Parent**: [PRD-17: Codegen Product Completeness and Documentation](prd-17-codegen-products.md)
**Goal**: Add generation for all standard GA products: interior, left/right contraction, scalar

## Problem Statement

The code generator currently only generates geometric and outer (exterior) products. Extension files must manually implement:

- Left contraction (`A ⌋ B`)
- Right contraction (`A ⌊ B`)
- Interior product (symmetric inner)
- Scalar product (grade-0 of geometric)

This leads to error-prone manual formulas like the `Plane::meet` bug (parameter ordering issue) that was caught by Greptile review.

## Product Definitions

### Left Contraction (A ⌋ B)

The left contraction projects A onto B, returning the part of B that "contains" A.

**Grade rule**: `grade(A ⌋ B) = grade(B) - grade(A)` when `grade(A) ≤ grade(B)`, else 0.

```
A ⌋ B = ⟨AB⟩_{s-r}  where r = grade(A), s = grade(B), r ≤ s
```

**Examples**:
- `Point ⌋ Line → Point` (grade 1 ⌋ grade 2 = grade 1)
- `Point ⌋ Plane → Line` (grade 1 ⌋ grade 3 = grade 2)
- `Line ⌋ Plane → Point` (grade 2 ⌋ grade 3 = grade 1)

### Right Contraction (A ⌊ B)

The right contraction is the "reverse" of left contraction.

**Grade rule**: `grade(A ⌊ B) = grade(A) - grade(B)` when `grade(B) ≤ grade(A)`, else 0.

```
A ⌊ B = ⟨AB⟩_{r-s}  where r = grade(A), s = grade(B), s ≤ r
```

**Examples**:
- `Line ⌊ Point → Point` (grade 2 ⌊ grade 1 = grade 1)
- `Plane ⌊ Point → Line` (grade 3 ⌊ grade 1 = grade 2)

### Interior Product (Symmetric)

The interior product is the symmetric version: `A · B = A ⌋ B + A ⌊ B`.

**Grade rule**: `grade(A · B) = |grade(A) - grade(B)|`

For equal-grade elements, this equals the scalar product.

### Scalar Product

Returns only the grade-0 (scalar) part of the geometric product.

**Grade rule**: Always returns scalar (grade 0).

```
A * B = ⟨AB⟩_0
```

Useful for computing norms and inner products between same-grade elements.

## Implementation

### ProductKind Enum Extension

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ProductKind {
    Geometric,
    Exterior,         // renamed from Outer (PRD-17.2)
    Interior,         // NEW
    LeftContraction,  // exists, needs full generation
    RightContraction, // NEW
    Scalar,           // exists, needs full generation
}
```

### Grade Filter Implementation

```rust
impl ProductGenerator<'_> {
    fn grade_contributes(
        &self,
        grade_a: usize,
        grade_b: usize,
        result_grade: usize,
        kind: ProductKind,
    ) -> bool {
        match kind {
            ProductKind::Geometric => true,
            ProductKind::Exterior => result_grade == grade_a + grade_b,
            ProductKind::Interior => result_grade == grade_a.abs_diff(grade_b),
            ProductKind::LeftContraction => {
                grade_a <= grade_b && result_grade == grade_b - grade_a
            }
            ProductKind::RightContraction => {
                grade_b <= grade_a && result_grade == grade_a - grade_b
            }
            ProductKind::Scalar => result_grade == 0,
        }
    }
}
```

### Generation Entry Point

```rust
impl ProductGenerator<'_> {
    pub fn generate_products_file(&self) -> TokenStream {
        let geometric = self.generate_all_products(ProductKind::Geometric);
        let exterior = self.generate_all_products(ProductKind::Exterior);
        let interior = self.generate_all_products(ProductKind::Interior);
        let left_contract = self.generate_all_products(ProductKind::LeftContraction);
        let right_contract = self.generate_all_products(ProductKind::RightContraction);
        let scalar = self.generate_all_products(ProductKind::Scalar);

        quote! {
            //! Product operations for {algebra_name}.
            //!
            //! Auto-generated by clifford-codegen.

            #geometric

            // ============================================================
            // Exterior Products (Wedge)
            // ============================================================
            #exterior

            // ============================================================
            // Interior Products (Symmetric Inner)
            // ============================================================
            #interior

            // ============================================================
            // Left Contractions
            // ============================================================
            #left_contract

            // ============================================================
            // Right Contractions
            // ============================================================
            #right_contract

            // ============================================================
            // Scalar Products
            // ============================================================
            #scalar
        }
    }
}
```

### Function Naming Convention

```rust
fn product_function_name(kind: ProductKind, type_a: &str, type_b: &str) -> String {
    let prefix = match kind {
        ProductKind::Geometric => "geometric",
        ProductKind::Exterior => "exterior",
        ProductKind::Interior => "interior",
        ProductKind::LeftContraction => "left_contract",
        ProductKind::RightContraction => "right_contract",
        ProductKind::Scalar => "scalar",
    };
    format!("{}_{}_{}",
        prefix,
        type_a.to_lowercase(),
        type_b.to_lowercase()
    )
}
```

**Generated function examples**:
- `left_contract_point_plane(&Point, &Plane) -> Line`
- `right_contract_plane_point(&Plane, &Point) -> Line`
- `interior_line_line(&Line, &Line) -> Scalar`
- `scalar_motor_motor(&Motor, &Motor) -> T`

## TOML Specification

### Product Configuration

```toml
[products]
geometric = true
exterior = true
interior = true
left_contraction = true
right_contraction = true
scalar = true

# Optional: explicit product type mappings (inferred if omitted)
[products.left_contraction]
Point_Line = "Point"
Point_Plane = "Line"
Line_Plane = "Point"

[products.scalar]
Motor_Motor = "T"  # Returns scalar type T directly
Point_Point = "T"
```

### Inference Rules

When product mappings aren't explicit, infer from grade rules:

```rust
fn infer_product_output(
    type_a: &TypeSpec,
    type_b: &TypeSpec,
    kind: ProductKind,
    all_types: &[TypeSpec],
) -> Option<String> {
    let output_grades = compute_output_grades(&type_a.grades, &type_b.grades, kind);

    if output_grades.is_empty() {
        return None; // Product is always zero
    }

    // Find type with matching grades
    all_types.iter()
        .find(|t| t.grades == output_grades)
        .map(|t| t.name.clone())
}
```

## Generated Code Examples

### Left Contraction: Point ⌋ Plane → Line

```rust
/// Left contraction: Point ⌋ Plane → Line
///
/// Projects the point onto the plane, returning a line.
#[doc = "Left contraction: Point ⌋ Plane -> Line"]
#[inline]
pub fn left_contract_point_plane<T: Float>(a: &Point<T>, b: &Plane<T>) -> Line<T> {
    Line::new_unchecked(
        a.e1() * b.e012() + a.e2() * b.e023() + ...,
        // ... remaining components
    )
}
```

### Scalar Product: Motor * Motor → T

```rust
/// Scalar product: Motor * Motor → T
///
/// Returns the scalar (grade-0) part of the geometric product.
#[doc = "Scalar product: Motor * Motor -> T"]
#[inline]
pub fn scalar_motor_motor<T: Float>(a: &Motor<T>, b: &Motor<T>) -> T {
    a.s() * b.s()
        - a.e12() * b.e12()
        - a.e23() * b.e23()
        - a.e31() * b.e31()
        + a.e0123() * b.e0123()
}
```

### Interior Product: Line · Line → Scalar

```rust
/// Interior product: Line · Line → Scalar
///
/// Symmetric inner product of two lines.
#[doc = "Interior product: Line · Line -> Scalar"]
#[inline]
pub fn interior_line_line<T: Float>(a: &Line<T>, b: &Line<T>) -> Scalar<T> {
    Scalar::new(
        a.e01() * b.e01() + a.e02() * b.e02() + a.e03() * b.e03()
            + a.e23() * b.e23() + a.e31() * b.e31() + a.e12() * b.e12()
    )
}
```

## Testing Strategy

### Verification Against Multivector

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use proptest::prelude::*;
    use crate::test_utils::ABS_DIFF_EQ_EPS;

    proptest! {
        #[test]
        fn left_contract_point_plane_matches_mv(
            a in any::<Point<f64>>(),
            b in any::<Plane<f64>>()
        ) {
            let specialized = left_contract_point_plane(&a, &b);

            let mv_a = Multivector::from(a);
            let mv_b = Multivector::from(b);
            let mv_result = mv_a.left_contract(&mv_b);

            let expected = Line::try_from(mv_result).unwrap();
            prop_assert!(abs_diff_eq!(specialized, expected, epsilon = ABS_DIFF_EQ_EPS));
        }

        #[test]
        fn scalar_motor_motor_matches_mv(
            a in any::<Motor<f64>>(),
            b in any::<Motor<f64>>()
        ) {
            let specialized = scalar_motor_motor(&a, &b);

            let mv_a = Multivector::from(a);
            let mv_b = Multivector::from(b);
            let mv_result = (mv_a * mv_b).grade(0);

            prop_assert!(abs_diff_eq!(specialized, mv_result, epsilon = ABS_DIFF_EQ_EPS));
        }
    }
}
```

### Algebraic Property Tests

```rust
proptest! {
    // Left contraction identity: A ⌋ 1 = A (for scalars)
    #[test]
    fn left_contract_with_scalar_identity(a in any::<Point<f64>>()) {
        let one = Scalar::new(1.0);
        // Point ⌋ Scalar doesn't change grade, so this is a special case
    }

    // Contraction vs geometric: A ⌋ B = ⟨AB⟩_{s-r}
    #[test]
    fn left_contract_is_grade_selection(
        a in any::<Point<f64>>(),
        b in any::<Plane<f64>>()
    ) {
        let contract = left_contract_point_plane(&a, &b);
        let geo = geometric_point_plane(&a, &b);

        // Extract grade-2 (line) part from geometric product
        let geo_grade2 = geo.grade_2(); // Flector → extract Line part
        prop_assert!(abs_diff_eq!(contract, geo_grade2, epsilon = ABS_DIFF_EQ_EPS));
    }

    // Scalar product symmetry: A * B = B * A (for scalar part)
    #[test]
    fn scalar_product_symmetric(
        a in any::<Motor<f64>>(),
        b in any::<Motor<f64>>()
    ) {
        let ab = scalar_motor_motor(&a, &b);
        let ba = scalar_motor_motor(&b, &a);
        prop_assert!(abs_diff_eq!(ab, ba, epsilon = ABS_DIFF_EQ_EPS));
    }
}
```

## Deliverables

- [ ] Add `Interior` variant to `ProductKind`
- [ ] Add `RightContraction` variant to `ProductKind`
- [ ] Implement `grade_contributes()` for all product kinds
- [ ] Update `generate_all_products()` to handle new kinds
- [ ] Add TOML spec support for new product sections
- [ ] Generate left contraction for all valid type pairs
- [ ] Generate right contraction for all valid type pairs
- [ ] Generate interior product for all valid type pairs
- [ ] Generate scalar product for all valid type pairs
- [ ] Add verification tests comparing to Multivector
- [ ] Add algebraic property tests
- [ ] Regenerate all existing algebras

## Success Criteria

1. **All products generated**: Every valid type pair has products generated
2. **Correct results**: All products match Multivector implementation
3. **Properties hold**: Algebraic properties verified by proptest
4. **Extensions simplified**: Manual formulas in extensions can be replaced

## Files Changed

| File | Action |
|------|--------|
| `crates/clifford-codegen/src/codegen/products.rs` | Update - Add new ProductKind variants and generation |
| `crates/clifford-codegen/src/spec/raw.rs` | Update - New TOML product fields |
| `crates/clifford-codegen/src/spec/ir.rs` | Update - ProductConfig for new kinds |
| `algebras/projective3.toml` | Update - Enable new products |
| `algebras/euclidean3.toml` | Update - Enable new products |
| `src/generated/*/products.rs` | Regenerate - New product functions |

## Dependencies

- None (builds on existing codegen infrastructure)

## Estimated Scope

- ProductKind extension: ~50 lines
- Grade filter logic: ~30 lines
- Generation loop updates: ~100 lines
- TOML parsing: ~50 lines
- Tests: ~200 lines
- Total: ~400-500 lines of code
