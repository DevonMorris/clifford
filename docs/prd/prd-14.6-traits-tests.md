# PRD-14.6: Trait Implementations & Test Generation

**Status**: Draft
**Parent**: [PRD-14: Geometric Algebra Code Generator](prd-14-codegen.md)
**Goal**: Generate all trait implementations and comprehensive test suites

## Overview

This phase generates:
1. Standard trait implementations (operators, Debug, etc.)
2. `approx` crate traits for floating-point comparison
3. `Arbitrary` implementations for proptest
4. Conversion traits (From, TryFrom for Multivector)
5. Comprehensive property-based tests
6. Consistency tests against `Multivector`

## Operator Trait Implementations

### Arithmetic Operators

```rust
// ops.rs

/// Addition: A + A → A
impl<T: Float> Add for Vector<T> {
    type Output = Self;

    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new(
            self.x() + rhs.x(),
            self.y() + rhs.y(),
            self.z() + rhs.z(),
        )
    }
}

/// Subtraction: A - A → A
impl<T: Float> Sub for Vector<T> {
    type Output = Self;

    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new(
            self.x() - rhs.x(),
            self.y() - rhs.y(),
            self.z() - rhs.z(),
        )
    }
}

/// Negation: -A → A
impl<T: Float> Neg for Vector<T> {
    type Output = Self;

    #[inline]
    fn neg(self) -> Self {
        Self::new(-self.x(), -self.y(), -self.z())
    }
}

/// Scalar multiplication: A * T → A
impl<T: Float> Mul<T> for Vector<T> {
    type Output = Self;

    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}

/// Scalar multiplication: T * A → A (for f32)
impl Mul<Vector<f32>> for f32 {
    type Output = Vector<f32>;

    #[inline]
    fn mul(self, v: Vector<f32>) -> Vector<f32> {
        v.scale(self)
    }
}

/// Scalar multiplication: T * A → A (for f64)
impl Mul<Vector<f64>> for f64 {
    type Output = Vector<f64>;

    #[inline]
    fn mul(self, v: Vector<f64>) -> Vector<f64> {
        v.scale(self)
    }
}

/// Geometric product: A * B → C
impl<T: Float> Mul<Vector<T>> for Vector<T> {
    type Output = Even<T>;

    #[inline]
    fn mul(self, rhs: Vector<T>) -> Even<T> {
        geometric_vector_vector(self, rhs)
    }
}

/// Outer product: A ^ B → C
impl<T: Float> BitXor<Vector<T>> for Vector<T> {
    type Output = Bivector<T>;

    #[inline]
    fn bitxor(self, rhs: Vector<T>) -> Bivector<T> {
        outer_vector_vector(self, rhs)
    }
}
```

### Generator

```rust
pub struct OpsGenerator<'a> {
    spec: &'a AlgebraSpec,
}

impl<'a> OpsGenerator<'a> {
    pub fn generate_ops_file(&self) -> TokenStream {
        let imports = self.generate_imports();

        let impls: Vec<TokenStream> = self.spec.types.iter()
            .flat_map(|ty| self.generate_ops_for_type(ty))
            .collect();

        quote! {
            //! Operator implementations.
            //!
            //! Auto-generated by clifford-codegen.

            #imports

            #(#impls)*
        }
    }

    fn generate_ops_for_type(&self, ty: &TypeSpec) -> Vec<TokenStream> {
        let mut impls = Vec::new();

        // Always generate Add, Sub, Neg for same type
        impls.push(self.generate_add(ty));
        impls.push(self.generate_sub(ty));
        impls.push(self.generate_neg(ty));

        // Scalar multiplication
        impls.push(self.generate_scalar_mul(ty));
        impls.push(self.generate_scalar_mul_reverse_f32(ty));
        impls.push(self.generate_scalar_mul_reverse_f64(ty));

        // Geometric product with other types
        for other in &self.spec.types {
            if let Some(output_type) = self.find_geometric_output(ty, other) {
                impls.push(self.generate_geometric_mul(ty, other, &output_type));
            }
        }

        // Outer product (where applicable)
        for other in &self.spec.types {
            if let Some(output_type) = self.find_outer_output(ty, other) {
                impls.push(self.generate_outer(ty, other, &output_type));
            }
        }

        impls
    }

    fn generate_add(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let field_adds: Vec<TokenStream> = ty.fields.iter().map(|f| {
            let fname = format_ident!("{}", f.name);
            quote! { self.#fname() + rhs.#fname() }
        }).collect();

        quote! {
            impl<T: Float> std::ops::Add for #name<T> {
                type Output = Self;

                #[inline]
                fn add(self, rhs: Self) -> Self {
                    Self::new(#(#field_adds),*)
                }
            }
        }
    }

    // ... similar for Sub, Neg, Mul, BitXor
}
```

## Approx Trait Implementations

```rust
pub struct ApproxGenerator<'a> {
    spec: &'a AlgebraSpec,
}

impl<'a> ApproxGenerator<'a> {
    pub fn generate_approx_file(&self) -> TokenStream {
        let imports = quote! {
            use approx::{AbsDiffEq, RelativeEq, UlpsEq};
            use crate::scalar::Float;
            use super::types::*;
        };

        let impls: Vec<TokenStream> = self.spec.types.iter()
            .map(|ty| self.generate_approx_impls(ty))
            .collect();

        quote! {
            //! Approximate comparison trait implementations.
            //!
            //! Auto-generated by clifford-codegen.

            #imports

            #(#impls)*
        }
    }

    fn generate_approx_impls(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        let abs_diff_checks: Vec<TokenStream> = ty.fields.iter().map(|f| {
            let fname = format_ident!("{}", f.name);
            quote! { T::abs_diff_eq(&self.#fname(), &other.#fname(), epsilon) }
        }).collect();

        let relative_checks: Vec<TokenStream> = ty.fields.iter().map(|f| {
            let fname = format_ident!("{}", f.name);
            quote! { T::relative_eq(&self.#fname(), &other.#fname(), epsilon, max_relative) }
        }).collect();

        let ulps_checks: Vec<TokenStream> = ty.fields.iter().map(|f| {
            let fname = format_ident!("{}", f.name);
            quote! { T::ulps_eq(&self.#fname(), &other.#fname(), epsilon, max_ulps) }
        }).collect();

        quote! {
            impl<T: Float> AbsDiffEq for #name<T> {
                type Epsilon = T;

                fn default_epsilon() -> Self::Epsilon {
                    T::default_epsilon()
                }

                fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
                    #(#abs_diff_checks)&&*
                }
            }

            impl<T: Float> RelativeEq for #name<T> {
                fn default_max_relative() -> Self::Epsilon {
                    T::default_max_relative()
                }

                fn relative_eq(
                    &self,
                    other: &Self,
                    epsilon: Self::Epsilon,
                    max_relative: Self::Epsilon,
                ) -> bool {
                    #(#relative_checks)&&*
                }
            }

            impl<T: Float> UlpsEq for #name<T> {
                fn default_max_ulps() -> u32 {
                    T::default_max_ulps()
                }

                fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
                    #(#ulps_checks)&&*
                }
            }
        }
    }
}
```

## Arbitrary Implementations

```rust
pub struct ArbitraryGenerator<'a> {
    spec: &'a AlgebraSpec,
}

impl<'a> ArbitraryGenerator<'a> {
    pub fn generate_arbitrary_file(&self) -> TokenStream {
        let imports = quote! {
            use proptest::prelude::*;
            use proptest::strategy::BoxedStrategy;
            use crate::scalar::Float;
            use super::types::*;
            use super::constrained::*;
            use std::fmt::Debug;
        };

        let base_impls: Vec<TokenStream> = self.spec.types.iter()
            .map(|ty| self.generate_arbitrary_impl(ty))
            .collect();

        let constrained_impls: Vec<TokenStream> = self.spec.types.iter()
            .flat_map(|ty| {
                ty.constraints.iter()
                    .map(|c| self.generate_constrained_arbitrary(ty, c))
            })
            .collect();

        quote! {
            //! Proptest Arbitrary implementations.
            //!
            //! Auto-generated by clifford-codegen.

            #![cfg(any(test, feature = "proptest-support"))]

            #imports

            #(#base_impls)*

            #(#constrained_impls)*
        }
    }

    fn generate_arbitrary_impl(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let num_fields = ty.fields.len();

        // Generate tuple of ranges
        let range_tuple: Vec<TokenStream> = (0..num_fields)
            .map(|_| quote! { -100.0f64..100.0 })
            .collect();

        let prop_map_args: Vec<TokenStream> = (0..num_fields)
            .map(|i| {
                let var = format_ident!("x{}", i);
                quote! { #var }
            })
            .collect();

        let field_inits: Vec<TokenStream> = (0..num_fields)
            .map(|i| {
                let var = format_ident!("x{}", i);
                quote! { T::from_f64(#var) }
            })
            .collect();

        quote! {
            impl<T: Float + Debug + 'static> Arbitrary for #name<T> {
                type Parameters = ();
                type Strategy = BoxedStrategy<Self>;

                fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
                    (#(#range_tuple),*)
                        .prop_map(|(#(#prop_map_args),*)| {
                            #name::new(#(#field_inits),*)
                        })
                        .boxed()
                }
            }
        }
    }
}
```

## Conversion Implementations

```rust
pub struct ConversionGenerator<'a> {
    spec: &'a AlgebraSpec,
    algebra: &'a Algebra,
}

impl<'a> ConversionGenerator<'a> {
    pub fn generate_conversions_file(&self) -> TokenStream {
        let signature_type = self.get_signature_type();

        let from_impls: Vec<TokenStream> = self.spec.types.iter()
            .map(|ty| self.generate_from_impl(ty, &signature_type))
            .collect();

        let try_from_impls: Vec<TokenStream> = self.spec.types.iter()
            .map(|ty| self.generate_try_from_impl(ty, &signature_type))
            .collect();

        quote! {
            //! Conversions to/from Multivector.
            //!
            //! Auto-generated by clifford-codegen.

            use crate::algebra::Multivector;
            use crate::signature::#signature_type;
            use crate::scalar::Float;
            use super::types::*;

            #(#from_impls)*

            #(#try_from_impls)*
        }
    }

    fn generate_from_impl(&self, ty: &TypeSpec, sig: &Ident) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        let blade_sets: Vec<TokenStream> = ty.fields.iter().map(|f| {
            let fname = format_ident!("{}", f.name);
            let index = f.blade_index;
            quote! { mv.set_blade(#index, value.#fname()); }
        }).collect();

        quote! {
            impl<T: Float> From<#name<T>> for Multivector<T, #sig> {
                fn from(value: #name<T>) -> Self {
                    let mut mv = Self::zero();
                    #(#blade_sets)*
                    mv
                }
            }
        }
    }

    fn generate_try_from_impl(&self, ty: &TypeSpec, sig: &Ident) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        // Collect all blades that should be zero
        let all_blades: std::collections::HashSet<usize> = (0..(1 << self.algebra.dim())).collect();
        let type_blades: std::collections::HashSet<usize> = ty.fields.iter()
            .map(|f| f.blade_index)
            .collect();
        let zero_blades: Vec<usize> = all_blades.difference(&type_blades).copied().collect();

        let zero_checks: Vec<TokenStream> = zero_blades.iter().map(|&idx| {
            quote! {
                if mv.blade(#idx).abs() > T::epsilon() {
                    return Err(ConversionError::NonZeroBlade(#idx));
                }
            }
        }).collect();

        let field_extracts: Vec<TokenStream> = ty.fields.iter().map(|f| {
            let index = f.blade_index;
            quote! { mv.blade(#index) }
        }).collect();

        quote! {
            impl<T: Float> TryFrom<Multivector<T, #sig>> for #name<T> {
                type Error = ConversionError;

                fn try_from(mv: Multivector<T, #sig>) -> Result<Self, Self::Error> {
                    #(#zero_checks)*
                    Ok(#name::new(#(#field_extracts),*))
                }
            }
        }
    }
}
```

## Test Generation

### Test Categories

1. **Round-trip conversions**: Specialized → Multivector → Specialized
2. **Operation consistency**: Specialized ops match Multivector ops
3. **Algebraic properties**: Associativity, anticommutativity, etc.
4. **Constraint preservation**: Unit × Unit = Unit, etc.

### Test Generator

```rust
pub struct TestGenerator<'a> {
    spec: &'a AlgebraSpec,
}

impl<'a> TestGenerator<'a> {
    pub fn generate_tests_file(&self) -> TokenStream {
        let imports = self.generate_imports();
        let roundtrip_tests = self.generate_roundtrip_tests();
        let consistency_tests = self.generate_consistency_tests();
        let property_tests = self.generate_property_tests();
        let constraint_tests = self.generate_constraint_tests();

        quote! {
            //! Generated tests.
            //!
            //! Auto-generated by clifford-codegen.

            #![cfg(test)]

            #imports

            mod roundtrip {
                use super::*;
                #roundtrip_tests
            }

            mod consistency {
                use super::*;
                #consistency_tests
            }

            mod properties {
                use super::*;
                #property_tests
            }

            mod constraints {
                use super::*;
                #constraint_tests
            }
        }
    }

    fn generate_roundtrip_tests(&self) -> TokenStream {
        let tests: Vec<TokenStream> = self.spec.types.iter()
            .map(|ty| self.generate_roundtrip_test(ty))
            .collect();

        quote! {
            proptest! {
                #(#tests)*
            }
        }
    }

    fn generate_roundtrip_test(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let test_name = format_ident!("{}_roundtrip", ty.name.to_lowercase());

        quote! {
            #[test]
            fn #test_name(value in any::<#name<f64>>()) {
                let mv = Multivector::from(value);
                let back = #name::try_from(mv).unwrap();
                prop_assert!(abs_diff_eq!(value, back, epsilon = ABS_DIFF_EQ_EPS));
            }
        }
    }

    fn generate_consistency_tests(&self) -> TokenStream {
        let mut tests = Vec::new();

        // Generate geometric product consistency tests
        for a in &self.spec.types {
            for b in &self.spec.types {
                if let Some(output) = self.find_geometric_output(a, b) {
                    tests.push(self.generate_geometric_consistency_test(a, b, &output));
                }
            }
        }

        // Generate outer product consistency tests
        for a in &self.spec.types {
            for b in &self.spec.types {
                if let Some(output) = self.find_outer_output(a, b) {
                    tests.push(self.generate_outer_consistency_test(a, b, &output));
                }
            }
        }

        quote! {
            proptest! {
                #(#tests)*
            }
        }
    }

    fn generate_geometric_consistency_test(
        &self,
        a: &TypeSpec,
        b: &TypeSpec,
        output: &TypeSpec,
    ) -> TokenStream {
        let a_name = format_ident!("{}", a.name);
        let b_name = format_ident!("{}", b.name);
        let out_name = format_ident!("{}", output.name);
        let fn_name = format_ident!(
            "geometric_{}_{}",
            a.name.to_lowercase(),
            b.name.to_lowercase()
        );
        let test_name = format_ident!(
            "geometric_{}_{}_{}_matches_mv",
            a.name.to_lowercase(),
            b.name.to_lowercase(),
            output.name.to_lowercase()
        );

        quote! {
            #[test]
            fn #test_name(
                a in any::<#a_name<f64>>(),
                b in any::<#b_name<f64>>(),
            ) {
                let gen_result = #fn_name(a, b);

                let mv_a = Multivector::from(a);
                let mv_b = Multivector::from(b);
                let mv_result = mv_a * mv_b;

                let mv_as_out = #out_name::try_from(mv_result).unwrap();

                prop_assert!(abs_diff_eq!(gen_result, mv_as_out, epsilon = ABS_DIFF_EQ_EPS));
            }
        }
    }

    fn generate_property_tests(&self) -> TokenStream {
        let mut tests = Vec::new();

        // Add+Sub properties
        for ty in &self.spec.types {
            tests.push(self.generate_add_commutative_test(ty));
            tests.push(self.generate_add_associative_test(ty));
            tests.push(self.generate_sub_inverse_test(ty));
        }

        // Geometric product properties (for closed subalgebras)
        for ty in &self.spec.types {
            if self.is_closed_under_geometric(ty) {
                tests.push(self.generate_geometric_associative_test(ty));
            }
        }

        // Outer product anticommutativity (for vectors)
        if let Some(vec_ty) = self.spec.types.iter().find(|t| t.grades == vec![1]) {
            tests.push(self.generate_outer_anticommutative_test(vec_ty));
        }

        quote! {
            proptest! {
                #(#tests)*
            }
        }
    }

    fn generate_add_commutative_test(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let test_name = format_ident!("{}_add_commutative", ty.name.to_lowercase());

        quote! {
            #[test]
            fn #test_name(a in any::<#name<f64>>(), b in any::<#name<f64>>()) {
                prop_assert!(abs_diff_eq!(a + b, b + a, epsilon = ABS_DIFF_EQ_EPS));
            }
        }
    }

    fn generate_geometric_associative_test(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let test_name = format_ident!("{}_geometric_associative", ty.name.to_lowercase());

        quote! {
            #[test]
            fn #test_name(
                a in any::<#name<f64>>(),
                b in any::<#name<f64>>(),
                c in any::<#name<f64>>(),
            ) {
                let ab_c = (a * b) * c;
                let a_bc = a * (b * c);
                prop_assert!(abs_diff_eq!(ab_c, a_bc, epsilon = ABS_DIFF_EQ_EPS));
            }
        }
    }

    fn generate_constraint_tests(&self) -> TokenStream {
        let mut tests = Vec::new();

        for ty in &self.spec.types {
            for constraint in &ty.constraints {
                if constraint.kind == ConstraintKind::Unit {
                    tests.extend(self.generate_unit_constraint_tests(ty, constraint));
                }
            }
        }

        quote! {
            proptest! {
                #(#tests)*
            }
        }
    }

    fn generate_unit_constraint_tests(
        &self,
        ty: &TypeSpec,
        constraint: &ConstraintSpec,
    ) -> Vec<TokenStream> {
        let wrapper_name = format_ident!("{}", constraint.wrapper_name);
        let mut tests = Vec::new();

        // Test: has unit norm
        let test_name = format_ident!("{}_has_unit_norm", constraint.wrapper_name.to_lowercase());
        tests.push(quote! {
            #[test]
            fn #test_name(x in any::<#wrapper_name<f64>>()) {
                prop_assert!(abs_diff_eq!(x.norm(), 1.0, epsilon = ABS_DIFF_EQ_EPS));
            }
        });

        // Test: compose preserves unit
        if constraint.preserving_ops.contains(&"compose".to_string()) {
            let test_name = format_ident!(
                "{}_compose_preserves_unit",
                constraint.wrapper_name.to_lowercase()
            );
            tests.push(quote! {
                #[test]
                fn #test_name(
                    a in any::<#wrapper_name<f64>>(),
                    b in any::<#wrapper_name<f64>>(),
                ) {
                    let result = a.compose(b);
                    prop_assert!(abs_diff_eq!(result.norm(), 1.0, epsilon = ABS_DIFF_EQ_EPS));
                }
            });
        }

        // Test: inverse preserves unit
        if constraint.preserving_ops.contains(&"inverse".to_string()) {
            let test_name = format_ident!(
                "{}_inverse_preserves_unit",
                constraint.wrapper_name.to_lowercase()
            );
            tests.push(quote! {
                #[test]
                fn #test_name(x in any::<#wrapper_name<f64>>()) {
                    let inv = x.inverse();
                    prop_assert!(abs_diff_eq!(inv.norm(), 1.0, epsilon = ABS_DIFF_EQ_EPS));
                }
            });
        }

        tests
    }
}
```

## Output Structure

```
generated/{algebra}/
├── mod.rs
├── types.rs
├── constrained.rs
├── products.rs
├── ops.rs
├── approx.rs
├── arbitrary.rs
├── conversions.rs
└── tests.rs
```

## Deliverables

- [ ] `OpsGenerator` for arithmetic operators
- [ ] `ApproxGenerator` for approx traits
- [ ] `ArbitraryGenerator` for proptest
- [ ] `ConversionGenerator` for Multivector interop
- [ ] `TestGenerator` for comprehensive tests
- [ ] Round-trip conversion tests
- [ ] Operation consistency tests
- [ ] Algebraic property tests
- [ ] Constraint preservation tests

## Success Criteria

1. All operator overloads compile and work correctly
2. Approx comparisons work for all types
3. Arbitrary produces valid test values
4. All round-trip conversions pass
5. Generated operations match Multivector
6. Algebraic properties verified
7. Constraints preserved under operations
