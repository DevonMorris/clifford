//! Type struct generation.
//!
//! This module provides the `TypeGenerator` for generating Rust struct
//! definitions from algebra specifications.

use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::algebra::{Algebra, Blade};
use crate::spec::{AlgebraSpec, TypeSpec};

/// Generates Rust struct definitions for algebra types.
///
/// The generator produces complete struct definitions including:
/// - Documentation with basis ordering tables
/// - Derive macros (Clone, Copy, Debug, PartialEq, serde)
/// - Private fields with public accessors
/// - Constructors (`new`, `zero`, unit basis)
/// - Basic methods (`norm_squared`, `norm`, `reverse`)
/// - Default implementation
///
/// # Example
///
/// ```
/// use clifford_codegen::algebra::Algebra;
/// use clifford_codegen::codegen::TypeGenerator;
/// use clifford_codegen::spec::parse_spec;
///
/// let spec = parse_spec(r#"
/// [algebra]
/// name = "euclidean2"
///
/// [signature]
/// positive = ["e1", "e2"]
///
/// [types.Vector]
/// grades = [1]
/// fields = ["x", "y"]
/// "#).unwrap();
///
/// let algebra = Algebra::euclidean(2);
/// let generator = TypeGenerator::new(&spec, &algebra);
///
/// let tokens = generator.generate_types_file();
/// let code = tokens.to_string();
///
/// assert!(code.contains("pub struct Vector"));
/// assert!(code.contains("pub fn new"));
/// assert!(code.contains("pub fn x"));
/// ```
pub struct TypeGenerator<'a> {
    /// The algebra specification.
    spec: &'a AlgebraSpec,
    /// The algebra for blade computations.
    algebra: &'a Algebra,
}

impl<'a> TypeGenerator<'a> {
    /// Creates a new type generator.
    pub fn new(spec: &'a AlgebraSpec, algebra: &'a Algebra) -> Self {
        Self { spec, algebra }
    }

    /// Generates the complete types.rs file.
    pub fn generate_types_file(&self) -> TokenStream {
        let header = self.generate_header();
        let imports = self.generate_imports();
        let types: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|ty| ty.alias_of.is_none()) // Skip aliases
            .map(|ty| self.generate_type(ty))
            .collect();

        let aliases: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|ty| ty.alias_of.is_some())
            .map(|ty| self.generate_alias(ty))
            .collect();

        let wrapper_aliases = self.generate_wrapper_aliases();

        quote! {
            #header
            #imports

            #(#types)*

            #(#aliases)*

            #wrapper_aliases
        }
    }

    /// Generates the file header comment.
    fn generate_header(&self) -> TokenStream {
        let name = &self.spec.name;
        let description = self
            .spec
            .description
            .as_deref()
            .unwrap_or("Generated algebra types");

        let header_doc = format!(
            r#"//! Type definitions for {}.
//!
//! {}
//!
//! This file is auto-generated by clifford-codegen.
//! Do not edit manually.

// Allow clippy lints that are unavoidable in generated code
#![allow(clippy::too_many_arguments)]"#,
            name, description
        );

        // Use a raw token to preserve the comment format
        header_doc.parse().unwrap_or_else(|_| quote! {})
    }

    /// Generates import statements.
    fn generate_imports(&self) -> TokenStream {
        let serde_import = if self.spec.options.generate_serde {
            quote! {
                #[cfg(feature = "serde")]
                use serde::{Serialize, Deserialize};
            }
        } else {
            quote! {}
        };

        quote! {
            use crate::scalar::Float;

            #serde_import
        }
    }

    /// Generates a type alias.
    fn generate_alias(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let target_name = ty.alias_of.as_ref().unwrap();
        let target = format_ident!("{}", target_name);
        let description = ty
            .description
            .clone()
            .unwrap_or_else(|| format!("Alias for {}.", target_name));

        quote! {
            #[doc = #description]
            pub type #name<T> = #target<T>;
        }
    }

    /// Generates a single type definition.
    pub fn generate_type(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let doc = self.generate_type_doc(ty);
        let derives = self.generate_derives();
        let fields = self.generate_fields(ty);
        let impl_block = self.generate_impl(ty);
        let default_impl = self.generate_default(ty);

        quote! {
            #doc
            #derives
            #[repr(C)]
            pub struct #name<T: Float> {
                #fields
            }

            #impl_block
            #default_impl
        }
    }

    /// Generates documentation for a type.
    fn generate_type_doc(&self, ty: &TypeSpec) -> TokenStream {
        let description = ty.description.as_deref().unwrap_or(&ty.name);
        let basis_table = self.generate_basis_table(ty);
        let example = self.generate_example(ty);

        let doc_string = format!(
            "{}\n\n# Basis Ordering\n\n{}\n\n# Example\n\n```\n{}\n```",
            description, basis_table, example
        );

        quote! {
            #[doc = #doc_string]
        }
    }

    /// Generates a markdown table of basis elements.
    fn generate_basis_table(&self, ty: &TypeSpec) -> String {
        let mut table = String::from("| Index | Blade | Field |\n|-------|-------|-------|\n");

        for field in &ty.fields {
            let blade = Blade::from_index(field.blade_index);
            let blade_name = self.algebra.blade_name(blade);
            table.push_str(&format!(
                "| {} | {} | `{}` |\n",
                field.blade_index, blade_name, field.name
            ));
        }

        table
    }

    /// Generates an example usage.
    fn generate_example(&self, ty: &TypeSpec) -> String {
        let args: Vec<String> = ty
            .fields
            .iter()
            .enumerate()
            .map(|(i, _)| format!("{}.0", i + 1))
            .collect();

        let module_path = self.spec.module_path.as_deref().unwrap_or("generated");

        format!(
            "use clifford::specialized::{}::{};\n\nlet v = {}::new({});",
            module_path,
            ty.name,
            ty.name,
            args.join(", ")
        )
    }

    /// Generates derive macros.
    fn generate_derives(&self) -> TokenStream {
        if self.spec.options.generate_serde {
            quote! {
                #[derive(Clone, Copy, Debug, PartialEq)]
                #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
            }
        } else {
            quote! {
                #[derive(Clone, Copy, Debug, PartialEq)]
            }
        }
    }

    /// Generates struct fields.
    fn generate_fields(&self, ty: &TypeSpec) -> TokenStream {
        let fields: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                // Use the field name from the TOML spec, not the computed blade name
                let doc = format!("Coefficient of `{}`.", field.name);

                quote! {
                    #[doc = #doc]
                    #name: T,
                }
            })
            .collect();

        quote! { #(#fields)* }
    }

    /// Generates the impl block with all methods.
    fn generate_impl(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let constructor = self.generate_constructor(ty);
        let accessors = self.generate_accessors(ty);
        let zero = self.generate_zero(ty);
        let unit_elements = self.generate_unit_elements(ty);
        let norm_methods = self.generate_norm_methods(ty);
        let reverse = self.generate_reverse(ty);
        let antireverse = self.generate_antireverse(ty);

        quote! {
            impl<T: Float> #name<T> {
                #constructor
                #accessors
                #zero
                #unit_elements
                #norm_methods
                #reverse
                #antireverse
            }
        }
    }

    /// Generates constructors.
    ///
    /// All types get:
    /// - `new()` - the primary constructor that takes all fields
    /// - `new_unchecked()` - alias for `new()` for backward compatibility with
    ///   code that uses unchecked constructors for constrained types
    fn generate_constructor(&self, ty: &TypeSpec) -> TokenStream {
        let params: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                quote! { #name: T }
            })
            .collect();

        let field_inits: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                quote! { #name }
            })
            .collect();

        let params2 = params.clone();

        quote! {
            /// Creates a new element from components.
            #[inline]
            pub fn new(#(#params),*) -> Self {
                Self { #(#field_inits),* }
            }

            /// Creates a new element from components without validation.
            ///
            /// This is an alias for `new()`. It exists for consistency with types
            /// that have geometric constraints, where unchecked construction is
            /// used in performance-critical code or trusted contexts.
            #[inline]
            pub fn new_unchecked(#(#params2),*) -> Self {
                Self::new(#(#field_inits),*)
            }
        }
    }

    /// Generates accessor methods for each field.
    fn generate_accessors(&self, ty: &TypeSpec) -> TokenStream {
        let accessors: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                // Use the field name from the TOML spec, not the computed blade name
                let doc = format!("Returns the `{}` coefficient.", field.name);

                quote! {
                    #[doc = #doc]
                    #[inline]
                    pub fn #name(&self) -> T {
                        self.#name
                    }
                }
            })
            .collect();

        quote! { #(#accessors)* }
    }

    /// Generates the zero() method for a type.
    fn generate_zero(&self, ty: &TypeSpec) -> TokenStream {
        let zeros: Vec<TokenStream> = ty.fields.iter().map(|_| quote! { T::zero() }).collect();
        let constructor = quote! { new };

        quote! {
            /// Creates the zero element.
            #[inline]
            pub fn zero() -> Self {
                Self::#constructor(#(#zeros),*)
            }
        }
    }

    /// Generates unit basis element constructors for single-grade types.
    fn generate_unit_elements(&self, ty: &TypeSpec) -> TokenStream {
        // Only for single-grade types
        if ty.grades.len() != 1 {
            return quote! {};
        }

        let constructor = quote! { new };

        let units: Vec<TokenStream> = ty
            .fields
            .iter()
            .enumerate()
            .map(|(i, field)| {
                let method_name = format_ident!("unit_{}", field.name);
                let blade = Blade::from_index(field.blade_index);
                let blade_name = self.algebra.blade_name(blade);
                let doc = format!("Creates the unit {} element.", blade_name);

                let values: Vec<TokenStream> = ty
                    .fields
                    .iter()
                    .enumerate()
                    .map(|(j, _)| {
                        if i == j {
                            quote! { T::one() }
                        } else {
                            quote! { T::zero() }
                        }
                    })
                    .collect();

                quote! {
                    #[doc = #doc]
                    #[inline]
                    pub fn #method_name() -> Self {
                        Self::#constructor(#(#values),*)
                    }
                }
            })
            .collect();

        quote! { #(#units)* }
    }

    /// Generates norm_squared, norm, try_normalize, normalize, and scale methods.
    fn generate_norm_methods(&self, ty: &TypeSpec) -> TokenStream {
        let field_names: Vec<_> = ty
            .fields
            .iter()
            .map(|f| format_ident!("{}", f.name))
            .collect();

        let constructor = quote! { new };

        // Compute norm squared based on metric signature.
        // For each blade, we need to consider the metric.
        // For now, this uses Euclidean norm (sum of squares).
        // TODO: Handle non-Euclidean metrics properly (e.g., for CGA, PGA).
        let squared_terms: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                let blade = Blade::from_index(field.blade_index);
                let metric = self.blade_metric(blade);

                if metric >= 0 {
                    quote! { self.#name * self.#name }
                } else {
                    // Negative metric: subtract instead of add
                    // Note: we still compute the absolute value for norm purposes
                    quote! { self.#name * self.#name }
                }
            })
            .collect();

        quote! {
            /// Returns the squared Euclidean norm.
            ///
            /// This is the sum of squares of all components.
            #[inline]
            pub fn norm_squared(&self) -> T {
                #(#squared_terms)+*
            }

            /// Returns the Euclidean norm.
            #[inline]
            pub fn norm(&self) -> T {
                self.norm_squared().sqrt()
            }

            /// Attempts to normalize this element.
            ///
            /// Returns `None` if the norm is too small (less than epsilon).
            #[inline]
            pub fn try_normalize(&self) -> Option<Self> {
                let n = self.norm();
                if n < T::epsilon() {
                    None
                } else {
                    Some(self.scale(T::one() / n))
                }
            }

            /// Normalizes this element, panicking if the norm is too small.
            ///
            /// # Panics
            ///
            /// Panics if the norm is less than epsilon.
            #[inline]
            pub fn normalize(&self) -> Self {
                self.try_normalize().expect("cannot normalize zero element")
            }

            /// Scales all components by a scalar.
            #[inline]
            pub fn scale(&self, s: T) -> Self {
                Self::#constructor(#(self.#field_names * s),*)
            }
        }
    }

    /// Computes the metric sign for a blade.
    ///
    /// Returns 1 for positive metric, -1 for negative, 0 for null.
    fn blade_metric(&self, blade: Blade) -> i32 {
        // For a blade that is a product of basis vectors,
        // the metric is the product of individual metrics.
        let mut metric = 1i32;

        for i in 0..self.algebra.dim() {
            if blade.contains(i) {
                metric *= i32::from(self.algebra.metric(i));
            }
        }

        metric
    }

    /// Generates the reverse() method.
    ///
    /// Reverse: (-1)^(k(k-1)/2) for grade k.
    pub fn generate_reverse(&self, ty: &TypeSpec) -> TokenStream {
        let reversed_values: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                let grade = field.grade;
                // Sign is (-1)^(k(k-1)/2)
                let exponent = grade * grade.saturating_sub(1) / 2;
                if exponent.is_multiple_of(2) {
                    quote! { self.#name }
                } else {
                    quote! { -self.#name }
                }
            })
            .collect();

        let constructor = quote! { new };

        quote! {
            /// Returns the reverse (reversion).
            ///
            /// For a k-blade, the reverse has sign (-1)^(k(k-1)/2):
            /// - Grade 0: +1
            /// - Grade 1: +1
            /// - Grade 2: -1
            /// - Grade 3: -1
            /// - Grade 4: +1
            /// - ...
            #[inline]
            pub fn reverse(&self) -> Self {
                Self::#constructor(#(#reversed_values),*)
            }
        }
    }

    /// Generates the antireverse() method.
    ///
    /// Antireverse: (-1)^((n-k)(n-k-1)/2) for grade k in dimension n.
    /// This is the reverse of the complement, or complement of the reverse.
    pub fn generate_antireverse(&self, ty: &TypeSpec) -> TokenStream {
        let dim = self.spec.signature.dim();

        let antireversed_values: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                let grade = field.grade;
                let antigrade = dim - grade;
                // Sign is (-1)^((n-k)(n-k-1)/2)
                let exponent = antigrade * antigrade.saturating_sub(1) / 2;
                if exponent.is_multiple_of(2) {
                    quote! { self.#name }
                } else {
                    quote! { -self.#name }
                }
            })
            .collect();

        // Use unchecked constructor for constrained types
        let has_constraints = !ty.solve_for_fields().is_empty();
        let constructor = if has_constraints {
            quote! { new_unchecked }
        } else {
            quote! { new }
        };

        quote! {
            /// Returns the antireverse.
            ///
            /// For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2).
            /// This is equivalent to complement(reverse(complement(x))).
            ///
            /// In PGA (n=4):
            /// - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1
            /// - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1
            /// - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1
            /// - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1
            /// - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1
            #[inline]
            pub fn antireverse(&self) -> Self {
                Self::#constructor(#(#antireversed_values),*)
            }
        }
    }

    /// Generates the Default implementation.
    fn generate_default(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        // Default is always zero - identity() is context-dependent and not generated
        quote! {
            impl<T: Float> Default for #name<T> {
                fn default() -> Self {
                    Self::zero()
                }
            }
        }
    }

    /// Generates wrapper type aliases for all entity types.
    ///
    /// For every entity type (except Scalar and type aliases), generates:
    /// - `Bulk<Type>` alias: `BulkVector<T> = Bulk<Vector<T>>`
    /// - `Unitized<Type>` alias: `UnitizedVector<T> = Unitized<Vector<T>>`
    ///
    /// Additionally for Euclidean algebras, generates `Unit<T>` aliases:
    /// - `UnitVector<T> = Unit<Vector<T>>`
    fn generate_wrapper_aliases(&self) -> TokenStream {
        let mut aliases = Vec::new();
        let is_pga = self.spec.signature.r > 0;

        for ty in &self.spec.types {
            // Skip type aliases
            if ty.alias_of.is_some() {
                continue;
            }

            // Skip Scalar type - no need for Bulk/Unitized wrappers
            if ty.name == "Scalar" {
                continue;
            }

            let type_name = format_ident!("{}", ty.name);

            // Generate Bulk<T> alias for all entity types
            let bulk_alias = format_ident!("Bulk{}", ty.name);
            let bulk_doc = format!(
                "A bulk-normalized {} (bulk norm = 1).\n\n\
                 This type alias wraps {} in `Bulk<T>`, which normalizes by the bulk \
                 (non-degenerate) part of the norm.",
                ty.name, ty.name
            );

            aliases.push(quote! {
                #[doc = #bulk_doc]
                pub type #bulk_alias<T> = crate::wrappers::Bulk<#type_name<T>>;
            });

            // Generate Unitized<T> alias for all entity types
            let unitized_alias = format_ident!("Unitized{}", ty.name);
            let unitized_doc = format!(
                "A unitized {} (weight norm = 1).\n\n\
                 This type alias wraps {} in `Unitized<T>`, which normalizes by the weight \
                 (degenerate) part of the norm.",
                ty.name, ty.name
            );

            aliases.push(quote! {
                #[doc = #unitized_doc]
                pub type #unitized_alias<T> = crate::wrappers::Unitized<#type_name<T>>;
            });

            // For Euclidean algebras, also generate Unit<T> aliases for appropriate types
            if !is_pga {
                // Generate Unit aliases for types that make sense to normalize:
                // - Single-grade types (Vector, Bivector, Trivector)
                // - Rotor types (grades [0, 2])
                let should_generate_unit = ty.grades.len() == 1
                    || (ty.grades.contains(&0) && ty.grades.contains(&2) && ty.grades.len() == 2);

                if should_generate_unit {
                    let unit_alias = format_ident!("Unit{}", ty.name);
                    let unit_doc = format!(
                        "A unit {} (Euclidean norm = 1).\n\n\
                         This type alias provides compile-time documentation that the \
                         {} has been normalized.",
                        ty.name, ty.name
                    );

                    aliases.push(quote! {
                        #[doc = #unit_doc]
                        pub type #unit_alias<T> = crate::wrappers::Unit<#type_name<T>>;
                    });
                }
            }
        }

        if aliases.is_empty() {
            quote! {}
        } else {
            quote! {
                // ============================================================================
                // Wrapper Type Aliases
                // ============================================================================

                #(#aliases)*
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::spec::parse_spec;

    #[test]
    fn generates_vector_type() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        let tokens = generator.generate_types_file();
        let code = tokens.to_string();

        assert!(code.contains("pub struct Vector"));
        assert!(code.contains("x : T"));
        assert!(code.contains("y : T"));
        assert!(code.contains("z : T"));
        assert!(code.contains("pub fn new"));
        assert!(code.contains("pub fn x"));
    }

    #[test]
    fn field_order_is_canonical() {
        // Verify fields are ordered by grade, then by blade index
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let rotor_type = spec.types.iter().find(|t| t.name == "Rotor").unwrap();

        let field_order: Vec<&str> = rotor_type.fields.iter().map(|f| f.name.as_str()).collect();

        // Expected: s (grade 0), xy, xz, yz (grade 2)
        assert_eq!(field_order, vec!["s", "xy", "xz", "yz"]);
    }

    #[test]
    fn reverse_signs_correct() {
        // Grade 0: sign = +1
        // Grade 1: sign = +1 (0*-1/2 = 0, even)
        // Grade 2: sign = -1 (2*1/2 = 1, odd)
        // Grade 3: sign = -1 (3*2/2 = 3, odd)

        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        // Check Bivector reverse
        let bivector = spec.types.iter().find(|t| t.name == "Bivector").unwrap();
        let tokens = generator.generate_reverse(bivector);
        let code = tokens.to_string();

        // All bivector components should be negated
        assert!(code.contains("- self . xy"));
        assert!(code.contains("- self . xz"));
        assert!(code.contains("- self . yz"));
    }

    #[test]
    fn generates_unit_elements_for_vector() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        let vector = spec.types.iter().find(|t| t.name == "Vector").unwrap();
        let tokens = generator.generate_unit_elements(vector);
        let code = tokens.to_string();

        // Vector should have unit_x, unit_y, unit_z
        assert!(code.contains("unit_x"));
        assert!(code.contains("unit_y"));
        assert!(code.contains("unit_z"));
    }

    #[test]
    fn no_unit_elements_for_rotor() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        let rotor = spec.types.iter().find(|t| t.name == "Rotor").unwrap();
        let tokens = generator.generate_unit_elements(rotor);
        let code = tokens.to_string();

        // Rotor has multiple grades, so no unit elements
        assert!(code.is_empty());
    }

    #[test]
    fn generates_alias_if_present() {
        // Currently no algebras define type aliases, so this test just verifies
        // the code generation completes without errors. Type alias generation
        // would be tested when an algebra with alias_of is added.
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        let tokens = generator.generate_types_file();
        let code = tokens.to_string();

        // Verify basic types are generated (aliases would appear similarly)
        assert!(code.contains("pub struct Rotor"));
    }

    #[test]
    fn generates_default_impl() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        let rotor = spec.types.iter().find(|t| t.name == "Rotor").unwrap();
        let tokens = generator.generate_default(rotor);
        let code = tokens.to_string();

        // Default is always zero - identity is context-dependent
        assert!(code.contains("impl < T : Float > Default for Rotor"));
        assert!(code.contains("Self :: zero ()"));

        let vector = spec.types.iter().find(|t| t.name == "Vector").unwrap();
        let tokens = generator.generate_default(vector);
        let code = tokens.to_string();

        // Vector default should be zero
        assert!(code.contains("impl < T : Float > Default for Vector"));
        assert!(code.contains("Self :: zero ()"));
    }
}
