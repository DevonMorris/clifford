//! Type struct generation.
//!
//! This module provides the `TypeGenerator` for generating Rust struct
//! definitions from algebra specifications.

use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::algebra::{Algebra, Blade};
use crate::spec::{AlgebraSpec, TypeSpec};

/// Generates Rust struct definitions for algebra types.
///
/// The generator produces complete struct definitions including:
/// - Documentation with basis ordering tables
/// - Derive macros (Clone, Copy, Debug, PartialEq, serde)
/// - Private fields with public accessors
/// - Constructors (`new`, `zero`, `identity`, unit basis)
/// - Basic methods (`norm_squared`, `norm`, `reverse`)
/// - Default implementation
///
/// # Example
///
/// ```
/// use clifford_codegen::algebra::Algebra;
/// use clifford_codegen::codegen::TypeGenerator;
/// use clifford_codegen::spec::parse_spec;
///
/// let spec = parse_spec(r#"
/// [algebra]
/// name = "euclidean2"
///
/// [signature]
/// positive = ["e1", "e2"]
///
/// [types.Vector]
/// grades = [1]
/// fields = ["x", "y"]
/// "#).unwrap();
///
/// let algebra = Algebra::euclidean(2);
/// let generator = TypeGenerator::new(&spec, &algebra);
///
/// let tokens = generator.generate_types_file();
/// let code = tokens.to_string();
///
/// assert!(code.contains("pub struct Vector"));
/// assert!(code.contains("pub fn new"));
/// assert!(code.contains("pub fn x"));
/// ```
pub struct TypeGenerator<'a> {
    /// The algebra specification.
    spec: &'a AlgebraSpec,
    /// The algebra for blade computations.
    algebra: &'a Algebra,
}

impl<'a> TypeGenerator<'a> {
    /// Creates a new type generator.
    pub fn new(spec: &'a AlgebraSpec, algebra: &'a Algebra) -> Self {
        Self { spec, algebra }
    }

    /// Generates the complete types.rs file.
    pub fn generate_types_file(&self) -> TokenStream {
        let header = self.generate_header();
        let imports = self.generate_imports();
        let types: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|ty| ty.alias_of.is_none()) // Skip aliases
            .map(|ty| self.generate_type(ty))
            .collect();

        let aliases: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|ty| ty.alias_of.is_some())
            .map(|ty| self.generate_alias(ty))
            .collect();

        let wrapper_aliases = self.generate_wrapper_aliases();

        quote! {
            #header
            #imports

            #(#types)*

            #(#aliases)*

            #wrapper_aliases
        }
    }

    /// Generates the file header comment.
    fn generate_header(&self) -> TokenStream {
        let name = &self.spec.name;
        let description = self
            .spec
            .description
            .as_deref()
            .unwrap_or("Generated algebra types");

        let header_doc = format!(
            r#"//! Type definitions for {}.
//!
//! {}
//!
//! This file is auto-generated by clifford-codegen.
//! Do not edit manually.

// Allow clippy lints that are unavoidable in generated code
#![allow(clippy::too_many_arguments)]"#,
            name, description
        );

        // Use a raw token to preserve the comment format
        header_doc.parse().unwrap_or_else(|_| quote! {})
    }

    /// Generates import statements.
    fn generate_imports(&self) -> TokenStream {
        let serde_import = if self.spec.options.generate_serde {
            quote! {
                #[cfg(feature = "serde")]
                use serde::{Serialize, Deserialize};
            }
        } else {
            quote! {}
        };

        quote! {
            use crate::scalar::Float;

            #serde_import
        }
    }

    /// Generates a type alias.
    fn generate_alias(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let target_name = ty.alias_of.as_ref().unwrap();
        let target = format_ident!("{}", target_name);
        let description = ty
            .description
            .clone()
            .unwrap_or_else(|| format!("Alias for {}.", target_name));

        quote! {
            #[doc = #description]
            pub type #name<T> = #target<T>;
        }
    }

    /// Generates a single type definition.
    pub fn generate_type(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let doc = self.generate_type_doc(ty);
        let derives = self.generate_derives();
        let fields = self.generate_fields(ty);
        let impl_block = self.generate_impl(ty);
        let default_impl = self.generate_default(ty);

        quote! {
            #doc
            #derives
            #[repr(C)]
            pub struct #name<T: Float> {
                #fields
            }

            #impl_block
            #default_impl
        }
    }

    /// Generates documentation for a type.
    fn generate_type_doc(&self, ty: &TypeSpec) -> TokenStream {
        let description = ty.description.as_deref().unwrap_or(&ty.name);
        let basis_table = self.generate_basis_table(ty);
        let example = self.generate_example(ty);

        let doc_string = format!(
            "{}\n\n# Basis Ordering\n\n{}\n\n# Example\n\n```\n{}\n```",
            description, basis_table, example
        );

        quote! {
            #[doc = #doc_string]
        }
    }

    /// Generates a markdown table of basis elements.
    fn generate_basis_table(&self, ty: &TypeSpec) -> String {
        let mut table = String::from("| Index | Blade | Field |\n|-------|-------|-------|\n");

        for field in &ty.fields {
            let blade = Blade::from_index(field.blade_index);
            let blade_name = self.algebra.blade_name(blade);
            table.push_str(&format!(
                "| {} | {} | `{}` |\n",
                field.blade_index, blade_name, field.name
            ));
        }

        table
    }

    /// Generates an example usage.
    fn generate_example(&self, ty: &TypeSpec) -> String {
        let args: Vec<String> = ty
            .fields
            .iter()
            .enumerate()
            .map(|(i, _)| format!("{}.0", i + 1))
            .collect();

        let module_path = self.spec.module_path.as_deref().unwrap_or("generated");

        format!(
            "use clifford::specialized::{}::{};\n\nlet v = {}::new({});",
            module_path,
            ty.name,
            ty.name,
            args.join(", ")
        )
    }

    /// Generates derive macros.
    fn generate_derives(&self) -> TokenStream {
        if self.spec.options.generate_serde {
            quote! {
                #[derive(Clone, Copy, Debug, PartialEq)]
                #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
            }
        } else {
            quote! {
                #[derive(Clone, Copy, Debug, PartialEq)]
            }
        }
    }

    /// Generates struct fields.
    fn generate_fields(&self, ty: &TypeSpec) -> TokenStream {
        let fields: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                // Use the field name from the TOML spec, not the computed blade name
                let doc = format!("Coefficient of `{}`.", field.name);

                quote! {
                    #[doc = #doc]
                    #name: T,
                }
            })
            .collect();

        quote! { #(#fields)* }
    }

    /// Generates the impl block with all methods.
    fn generate_impl(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let constructor = self.generate_constructor(ty);
        let accessors = self.generate_accessors(ty);
        let zero = self.generate_zero(ty);
        let identity = self.generate_identity(ty);
        let unit_elements = self.generate_unit_elements(ty);
        let norm_methods = self.generate_norm_methods(ty);
        let reverse = self.generate_reverse(ty);
        let transform_methods = self.generate_transform_methods(ty);

        quote! {
            impl<T: Float> #name<T> {
                #constructor
                #accessors
                #zero
                #identity
                #unit_elements
                #norm_methods
                #reverse
                #transform_methods
            }
        }
    }

    /// Generates constructors.
    ///
    /// All types get:
    /// - `new()` - the primary constructor that takes all fields
    /// - `new_unchecked()` - alias for `new()` for backward compatibility with
    ///   code that uses unchecked constructors for constrained types
    fn generate_constructor(&self, ty: &TypeSpec) -> TokenStream {
        let params: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                quote! { #name: T }
            })
            .collect();

        let field_inits: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                quote! { #name }
            })
            .collect();

        let params2 = params.clone();

        quote! {
            /// Creates a new element from components.
            #[inline]
            pub fn new(#(#params),*) -> Self {
                Self { #(#field_inits),* }
            }

            /// Creates a new element from components without validation.
            ///
            /// This is an alias for `new()`. It exists for consistency with types
            /// that have geometric constraints, where unchecked construction is
            /// used in performance-critical code or trusted contexts.
            #[inline]
            pub fn new_unchecked(#(#params2),*) -> Self {
                Self::new(#(#field_inits),*)
            }
        }
    }

    /// Generates accessor methods for each field.
    fn generate_accessors(&self, ty: &TypeSpec) -> TokenStream {
        let accessors: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                // Use the field name from the TOML spec, not the computed blade name
                let doc = format!("Returns the `{}` coefficient.", field.name);

                quote! {
                    #[doc = #doc]
                    #[inline]
                    pub fn #name(&self) -> T {
                        self.#name
                    }
                }
            })
            .collect();

        quote! { #(#accessors)* }
    }

    /// Generates the zero() method for a type.
    fn generate_zero(&self, ty: &TypeSpec) -> TokenStream {
        let zeros: Vec<TokenStream> = ty.fields.iter().map(|_| quote! { T::zero() }).collect();
        let constructor = quote! { new };

        quote! {
            /// Creates the zero element.
            #[inline]
            pub fn zero() -> Self {
                Self::#constructor(#(#zeros),*)
            }
        }
    }

    /// Generates the identity() method if the type contains grade 0.
    fn generate_identity(&self, ty: &TypeSpec) -> TokenStream {
        // Only generate identity for types containing grade 0
        if !ty.grades.contains(&0) {
            return quote! {};
        }

        let values: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                if field.grade == 0 {
                    quote! { T::one() }
                } else {
                    quote! { T::zero() }
                }
            })
            .collect();

        let constructor = quote! { new };

        quote! {
            /// Creates the identity element (scalar = 1, rest = 0).
            #[inline]
            pub fn identity() -> Self {
                Self::#constructor(#(#values),*)
            }
        }
    }

    /// Generates unit basis element constructors for single-grade types.
    fn generate_unit_elements(&self, ty: &TypeSpec) -> TokenStream {
        // Only for single-grade types
        if ty.grades.len() != 1 {
            return quote! {};
        }

        let constructor = quote! { new };

        let units: Vec<TokenStream> = ty
            .fields
            .iter()
            .enumerate()
            .map(|(i, field)| {
                let method_name = format_ident!("unit_{}", field.name);
                let blade = Blade::from_index(field.blade_index);
                let blade_name = self.algebra.blade_name(blade);
                let doc = format!("Creates the unit {} element.", blade_name);

                let values: Vec<TokenStream> = ty
                    .fields
                    .iter()
                    .enumerate()
                    .map(|(j, _)| {
                        if i == j {
                            quote! { T::one() }
                        } else {
                            quote! { T::zero() }
                        }
                    })
                    .collect();

                quote! {
                    #[doc = #doc]
                    #[inline]
                    pub fn #method_name() -> Self {
                        Self::#constructor(#(#values),*)
                    }
                }
            })
            .collect();

        quote! { #(#units)* }
    }

    /// Generates norm_squared, norm, try_normalize, normalize, and scale methods.
    fn generate_norm_methods(&self, ty: &TypeSpec) -> TokenStream {
        let field_names: Vec<_> = ty
            .fields
            .iter()
            .map(|f| format_ident!("{}", f.name))
            .collect();

        let constructor = quote! { new };

        // Compute norm squared based on metric signature.
        // For each blade, we need to consider the metric.
        // For now, this uses Euclidean norm (sum of squares).
        // TODO: Handle non-Euclidean metrics properly (e.g., for CGA, PGA).
        let squared_terms: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                let blade = Blade::from_index(field.blade_index);
                let metric = self.blade_metric(blade);

                if metric >= 0 {
                    quote! { self.#name * self.#name }
                } else {
                    // Negative metric: subtract instead of add
                    // Note: we still compute the absolute value for norm purposes
                    quote! { self.#name * self.#name }
                }
            })
            .collect();

        quote! {
            /// Returns the squared Euclidean norm.
            ///
            /// This is the sum of squares of all components.
            #[inline]
            pub fn norm_squared(&self) -> T {
                #(#squared_terms)+*
            }

            /// Returns the Euclidean norm.
            #[inline]
            pub fn norm(&self) -> T {
                self.norm_squared().sqrt()
            }

            /// Attempts to normalize this element.
            ///
            /// Returns `None` if the norm is too small (less than epsilon).
            #[inline]
            pub fn try_normalize(&self) -> Option<Self> {
                let n = self.norm();
                if n < T::epsilon() {
                    None
                } else {
                    Some(self.scale(T::one() / n))
                }
            }

            /// Normalizes this element, panicking if the norm is too small.
            ///
            /// # Panics
            ///
            /// Panics if the norm is less than epsilon.
            #[inline]
            pub fn normalize(&self) -> Self {
                self.try_normalize().expect("cannot normalize zero element")
            }

            /// Scales all components by a scalar.
            #[inline]
            pub fn scale(&self, s: T) -> Self {
                Self::#constructor(#(self.#field_names * s),*)
            }
        }
    }

    /// Computes the metric sign for a blade.
    ///
    /// Returns 1 for positive metric, -1 for negative, 0 for null.
    fn blade_metric(&self, blade: Blade) -> i32 {
        // For a blade that is a product of basis vectors,
        // the metric is the product of individual metrics.
        let mut metric = 1i32;

        for i in 0..self.algebra.dim() {
            if blade.contains(i) {
                metric *= i32::from(self.algebra.metric(i));
            }
        }

        metric
    }

    /// Generates the reverse() method.
    ///
    /// Reverse: (-1)^(k(k-1)/2) for grade k.
    pub fn generate_reverse(&self, ty: &TypeSpec) -> TokenStream {
        let reversed_values: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                let grade = field.grade;
                // Sign is (-1)^(k(k-1)/2)
                let exponent = grade * grade.saturating_sub(1) / 2;
                if exponent % 2 == 0 {
                    quote! { self.#name }
                } else {
                    quote! { -self.#name }
                }
            })
            .collect();

        let constructor = quote! { new };

        quote! {
            /// Returns the reverse (reversion).
            ///
            /// For a k-blade, the reverse has sign (-1)^(k(k-1)/2):
            /// - Grade 0: +1
            /// - Grade 1: +1
            /// - Grade 2: -1
            /// - Grade 3: -1
            /// - Grade 4: +1
            /// - ...
            #[inline]
            pub fn reverse(&self) -> Self {
                Self::#constructor(#(#reversed_values),*)
            }
        }
    }

    /// Generates transform methods for versor types.
    ///
    /// Note: Transform methods are now generated in extensions.rs, not here.
    /// This function returns empty so that domain-specific transform methods
    /// can be defined in extensions with appropriate documentation and behavior.
    fn generate_transform_methods(&self, _ty: &TypeSpec) -> TokenStream {
        // Transform methods should be defined in extensions.rs, not generated here.
        // This allows for domain-specific documentation and behavior.
        quote! {}
    }

    /// Generates the Default implementation.
    fn generate_default(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        // Default is identity for types with grade 0, otherwise zero
        let default_fn = if ty.grades.contains(&0) {
            quote! { Self::identity() }
        } else {
            quote! { Self::zero() }
        };

        quote! {
            impl<T: Float> Default for #name<T> {
                fn default() -> Self {
                    #default_fn
                }
            }
        }
    }

    /// Generates wrapper type aliases based on algebra type.
    ///
    /// For Euclidean algebras (no degenerate basis), generates `Unit<T>` aliases:
    /// - `UnitVector<T> = Unit<Vector<T>>`
    /// - `UnitBivector<T> = Unit<Bivector<T>>`
    /// - `UnitRotor<T> = Unit<Rotor<T>>`
    ///
    /// For PGA algebras (has degenerate basis), generates:
    /// - `Bulk<T>` aliases for versors (Motor, Flector): `BulkMotor<T> = Bulk<Motor<T>>`
    /// - `Ideal<T>` aliases for geometric entities (Point, Plane, Line): `IdealPoint<T> = Ideal<Point<T>>`
    fn generate_wrapper_aliases(&self) -> TokenStream {
        let is_pga = self.spec.signature.r > 0;

        if is_pga {
            self.generate_pga_wrapper_aliases()
        } else {
            self.generate_euclidean_wrapper_aliases()
        }
    }

    /// Generates Unit<T> wrapper aliases for Euclidean algebras.
    fn generate_euclidean_wrapper_aliases(&self) -> TokenStream {
        let mut aliases = Vec::new();

        for ty in &self.spec.types {
            // Skip aliases
            if ty.alias_of.is_some() {
                continue;
            }

            // Generate Unit aliases for types that make sense to normalize:
            // - Single-grade types (Vector, Bivector, Trivector)
            // - Rotor types (grades [0, 2])
            let should_generate = ty.grades.len() == 1
                || (ty.grades.contains(&0) && ty.grades.contains(&2) && ty.grades.len() == 2);

            if should_generate {
                let type_name = format_ident!("{}", ty.name);
                let alias_name = format_ident!("Unit{}", ty.name);
                let doc = format!(
                    "A unit {} (Euclidean norm = 1).\n\n\
                     This type alias provides compile-time documentation that the \
                     {} has been normalized.",
                    ty.name, ty.name
                );

                aliases.push(quote! {
                    #[doc = #doc]
                    pub type #alias_name<T> = crate::wrappers::Unit<#type_name<T>>;
                });
            }
        }

        if aliases.is_empty() {
            quote! {}
        } else {
            quote! {
                // ============================================================================
                // Wrapper Type Aliases
                // ============================================================================

                #(#aliases)*
            }
        }
    }

    /// Generates Bulk<T> and Ideal<T> wrapper aliases for PGA algebras.
    fn generate_pga_wrapper_aliases(&self) -> TokenStream {
        let mut aliases = Vec::new();

        // Versor type names that get Bulk<T> wrappers
        let versor_names = ["Motor", "Flector"];

        // Homogeneous geometric entity names that get Ideal<T> wrappers
        let homogeneous_names = ["Point", "Plane", "Line"];

        for ty in &self.spec.types {
            // Skip aliases
            if ty.alias_of.is_some() {
                continue;
            }

            let type_name = format_ident!("{}", ty.name);

            // Check if it's a versor type
            if versor_names.contains(&ty.name.as_str()) {
                let alias_name = format_ident!("Bulk{}", ty.name);
                let doc = format!(
                    "A bulk-normalized {} (bulk norm = 1).\n\n\
                     For a {} to represent a proper rigid transformation, the bulk norm \
                     (non-degenerate part) should be 1. This type alias provides compile-time \
                     documentation that the {} has been bulk-normalized.",
                    ty.name, ty.name, ty.name
                );

                aliases.push(quote! {
                    #[doc = #doc]
                    pub type #alias_name<T> = crate::wrappers::Bulk<#type_name<T>>;
                });
            }

            // Check if it's a homogeneous geometric entity
            if homogeneous_names.contains(&ty.name.as_str()) {
                let alias_name = format_ident!("Ideal{}", ty.name);
                let doc = format!(
                    "An {} in standard homogeneous form (weight norm = 1).\n\n\
                     In PGA, geometric entities like {}s are represented in homogeneous \
                     coordinates. This type alias provides compile-time documentation that \
                     the {} has been weight-normalized to standard form.",
                    ty.name.to_lowercase(),
                    ty.name.to_lowercase(),
                    ty.name.to_lowercase()
                );

                aliases.push(quote! {
                    #[doc = #doc]
                    pub type #alias_name<T> = crate::wrappers::Ideal<#type_name<T>>;
                });
            }
        }

        if aliases.is_empty() {
            quote! {}
        } else {
            quote! {
                // ============================================================================
                // Wrapper Type Aliases
                // ============================================================================

                #(#aliases)*
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::spec::parse_spec;

    #[test]
    fn generates_vector_type() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        let tokens = generator.generate_types_file();
        let code = tokens.to_string();

        assert!(code.contains("pub struct Vector"));
        assert!(code.contains("x : T"));
        assert!(code.contains("y : T"));
        assert!(code.contains("z : T"));
        assert!(code.contains("pub fn new"));
        assert!(code.contains("pub fn x"));
    }

    #[test]
    fn field_order_is_canonical() {
        // Verify fields are ordered by grade, then by blade index
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let full_type = spec.types.iter().find(|t| t.name == "Full").unwrap();

        let field_order: Vec<&str> = full_type.fields.iter().map(|f| f.name.as_str()).collect();

        // Expected: s (grade 0), x, y, z (grade 1), xy, xz, yz (grade 2), xyz (grade 3)
        assert_eq!(
            field_order,
            vec!["s", "x", "y", "z", "xy", "xz", "yz", "xyz"]
        );
    }

    #[test]
    fn reverse_signs_correct() {
        // Grade 0: sign = +1
        // Grade 1: sign = +1 (0*-1/2 = 0, even)
        // Grade 2: sign = -1 (2*1/2 = 1, odd)
        // Grade 3: sign = -1 (3*2/2 = 3, odd)

        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        // Check Bivector reverse
        let bivector = spec.types.iter().find(|t| t.name == "Bivector").unwrap();
        let tokens = generator.generate_reverse(bivector);
        let code = tokens.to_string();

        // All bivector components should be negated
        assert!(code.contains("- self . xy"));
        assert!(code.contains("- self . xz"));
        assert!(code.contains("- self . yz"));
    }

    #[test]
    fn generates_identity_for_rotor() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        let rotor = spec.types.iter().find(|t| t.name == "Rotor").unwrap();
        let tokens = generator.generate_identity(rotor);
        let code = tokens.to_string();

        // Identity should have scalar = 1
        assert!(code.contains("identity"));
        assert!(code.contains("T :: one ()"));
    }

    #[test]
    fn no_identity_for_vector() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        let vector = spec.types.iter().find(|t| t.name == "Vector").unwrap();
        let tokens = generator.generate_identity(vector);
        let code = tokens.to_string();

        // Vector has no grade 0, so no identity
        assert!(code.is_empty());
    }

    #[test]
    fn generates_unit_elements_for_vector() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        let vector = spec.types.iter().find(|t| t.name == "Vector").unwrap();
        let tokens = generator.generate_unit_elements(vector);
        let code = tokens.to_string();

        // Vector should have unit_x, unit_y, unit_z
        assert!(code.contains("unit_x"));
        assert!(code.contains("unit_y"));
        assert!(code.contains("unit_z"));
    }

    #[test]
    fn no_unit_elements_for_rotor() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        let rotor = spec.types.iter().find(|t| t.name == "Rotor").unwrap();
        let tokens = generator.generate_unit_elements(rotor);
        let code = tokens.to_string();

        // Rotor has multiple grades, so no unit elements
        assert!(code.is_empty());
    }

    #[test]
    fn generates_alias() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        let tokens = generator.generate_types_file();
        let code = tokens.to_string();

        // Even is an alias of Rotor
        assert!(code.contains("pub type Even"));
        assert!(code.contains("Rotor"));
    }

    #[test]
    fn generates_default_impl() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        let rotor = spec.types.iter().find(|t| t.name == "Rotor").unwrap();
        let tokens = generator.generate_default(rotor);
        let code = tokens.to_string();

        // Rotor default should be identity
        assert!(code.contains("impl < T : Float > Default for Rotor"));
        assert!(code.contains("Self :: identity ()"));

        let vector = spec.types.iter().find(|t| t.name == "Vector").unwrap();
        let tokens = generator.generate_default(vector);
        let code = tokens.to_string();

        // Vector default should be zero
        assert!(code.contains("impl < T : Float > Default for Vector"));
        assert!(code.contains("Self :: zero ()"));
    }
}
