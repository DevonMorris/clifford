//! Type struct generation.
//!
//! This module provides the `TypeGenerator` for generating Rust struct
//! definitions from algebra specifications.

use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::algebra::{Algebra, Blade};
use crate::spec::{AlgebraSpec, SignConvention, TypeSpec};
use crate::symbolic::{ConstraintSolver, SolutionType, SolveResult};

/// Generates Rust struct definitions for algebra types.
///
/// The generator produces complete struct definitions including:
/// - Documentation with basis ordering tables
/// - Derive macros (Clone, Copy, Debug, PartialEq, serde)
/// - Private fields with public accessors
/// - Constructors (`new`, `zero`, `identity`, unit basis)
/// - Basic methods (`norm_squared`, `norm`, `reverse`)
/// - Default implementation
///
/// # Example
///
/// ```
/// use clifford_codegen::algebra::Algebra;
/// use clifford_codegen::codegen::TypeGenerator;
/// use clifford_codegen::spec::parse_spec;
///
/// let spec = parse_spec(r#"
/// [algebra]
/// name = "euclidean2"
///
/// [signature]
/// positive = ["e1", "e2"]
///
/// [types.Vector]
/// grades = [1]
/// fields = ["x", "y"]
/// "#).unwrap();
///
/// let algebra = Algebra::euclidean(2);
/// let generator = TypeGenerator::new(&spec, &algebra);
///
/// let tokens = generator.generate_types_file();
/// let code = tokens.to_string();
///
/// assert!(code.contains("pub struct Vector"));
/// assert!(code.contains("pub fn new"));
/// assert!(code.contains("pub fn x"));
/// ```
pub struct TypeGenerator<'a> {
    /// The algebra specification.
    spec: &'a AlgebraSpec,
    /// The algebra for blade computations.
    algebra: &'a Algebra,
}

impl<'a> TypeGenerator<'a> {
    /// Creates a new type generator.
    pub fn new(spec: &'a AlgebraSpec, algebra: &'a Algebra) -> Self {
        Self { spec, algebra }
    }

    /// Generates the complete types.rs file.
    pub fn generate_types_file(&self) -> TokenStream {
        let header = self.generate_header();
        let imports = self.generate_imports();
        let types: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|ty| ty.alias_of.is_none()) // Skip aliases
            .map(|ty| self.generate_type(ty))
            .collect();

        let aliases: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|ty| ty.alias_of.is_some())
            .map(|ty| self.generate_alias(ty))
            .collect();

        quote! {
            #header
            #imports

            #(#types)*

            #(#aliases)*
        }
    }

    /// Generates the file header comment.
    fn generate_header(&self) -> TokenStream {
        let name = &self.spec.name;
        let description = self
            .spec
            .description
            .as_deref()
            .unwrap_or("Generated algebra types");

        let header_doc = format!(
            r#"//! Type definitions for {}.
//!
//! {}
//!
//! This file is auto-generated by clifford-codegen.
//! Do not edit manually.

// Allow clippy lints that are unavoidable in generated code
#![allow(clippy::too_many_arguments)]"#,
            name, description
        );

        // Use a raw token to preserve the comment format
        header_doc.parse().unwrap_or_else(|_| quote! {})
    }

    /// Generates import statements.
    fn generate_imports(&self) -> TokenStream {
        let serde_import = if self.spec.options.generate_serde {
            quote! {
                #[cfg(feature = "serde")]
                use serde::{Serialize, Deserialize};
            }
        } else {
            quote! {}
        };

        quote! {
            use crate::scalar::Float;

            #serde_import
        }
    }

    /// Generates a type alias.
    fn generate_alias(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let target_name = ty.alias_of.as_ref().unwrap();
        let target = format_ident!("{}", target_name);
        let description = ty
            .description
            .clone()
            .unwrap_or_else(|| format!("Alias for {}.", target_name));

        quote! {
            #[doc = #description]
            pub type #name<T> = #target<T>;
        }
    }

    /// Generates a single type definition.
    pub fn generate_type(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let doc = self.generate_type_doc(ty);
        let derives = self.generate_derives();
        let fields = self.generate_fields(ty);
        let impl_block = self.generate_impl(ty);
        let default_impl = self.generate_default(ty);

        quote! {
            #doc
            #derives
            #[repr(C)]
            pub struct #name<T: Float> {
                #fields
            }

            #impl_block
            #default_impl
        }
    }

    /// Generates documentation for a type.
    fn generate_type_doc(&self, ty: &TypeSpec) -> TokenStream {
        let description = ty.description.as_deref().unwrap_or(&ty.name);
        let basis_table = self.generate_basis_table(ty);
        let example = self.generate_example(ty);

        let doc_string = format!(
            "{}\n\n# Basis Ordering\n\n{}\n\n# Example\n\n```ignore\n{}\n```",
            description, basis_table, example
        );

        quote! {
            #[doc = #doc_string]
        }
    }

    /// Generates a markdown table of basis elements.
    fn generate_basis_table(&self, ty: &TypeSpec) -> String {
        let mut table = String::from("| Index | Blade | Field |\n|-------|-------|-------|\n");

        for field in &ty.fields {
            let blade = Blade::from_index(field.blade_index);
            let blade_name = self.algebra.blade_name(blade);
            table.push_str(&format!(
                "| {} | {} | `{}` |\n",
                field.blade_index, blade_name, field.name
            ));
        }

        table
    }

    /// Generates an example usage.
    fn generate_example(&self, ty: &TypeSpec) -> String {
        let args: Vec<String> = ty
            .fields
            .iter()
            .enumerate()
            .map(|(i, _)| format!("{}.0", i + 1))
            .collect();

        let module_path = self
            .spec
            .module_path
            .as_deref()
            .unwrap_or("generated")
            .replace("::", "/");

        format!(
            "use clifford::{}::{};\n\nlet v = {}::new({});",
            module_path,
            ty.name,
            ty.name,
            args.join(", ")
        )
    }

    /// Generates derive macros.
    fn generate_derives(&self) -> TokenStream {
        if self.spec.options.generate_serde {
            quote! {
                #[derive(Clone, Copy, Debug, PartialEq)]
                #[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
            }
        } else {
            quote! {
                #[derive(Clone, Copy, Debug, PartialEq)]
            }
        }
    }

    /// Generates struct fields.
    fn generate_fields(&self, ty: &TypeSpec) -> TokenStream {
        let fields: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                let blade = Blade::from_index(field.blade_index);
                let blade_name = self.algebra.blade_name(blade);
                let doc = format!("Coefficient of `{}`.", blade_name);

                quote! {
                    #[doc = #doc]
                    #name: T,
                }
            })
            .collect();

        quote! { #(#fields)* }
    }

    /// Generates the impl block with all methods.
    fn generate_impl(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let constructor = self.generate_constructor(ty);
        let accessors = self.generate_accessors(ty);
        let zero = self.generate_zero(ty);
        let identity = self.generate_identity(ty);
        let unit_elements = self.generate_unit_elements(ty);
        let norm_methods = self.generate_norm_methods(ty);
        let reverse = self.generate_reverse(ty);

        quote! {
            impl<T: Float> #name<T> {
                #constructor
                #accessors
                #zero
                #identity
                #unit_elements
                #norm_methods
                #reverse
            }
        }
    }

    /// Generates constructors.
    ///
    /// For types with `solve_for` fields:
    /// - `new()` takes all fields except the solved-for ones and computes them
    /// - `new_checked()` takes all fields and validates constraints
    /// - `new_unchecked()` takes all fields without validation
    ///
    /// For types without `solve_for`:
    /// - `new()` takes all fields (same as current behavior)
    fn generate_constructor(&self, ty: &TypeSpec) -> TokenStream {
        let solve_for_fields = ty.solve_for_fields();

        if solve_for_fields.is_empty() {
            // No solve_for - generate simple constructor
            return self.generate_simple_constructor(ty);
        }

        // Collect solutions for all solve_for fields
        let solver = ConstraintSolver::new();
        let mut solutions = Vec::new();

        // Solve geometric constraint if geometric_solve_for is specified
        if let (Some(solve_for), Some(constraint)) =
            (&ty.geometric_solve_for, &ty.geometric_constraint)
        {
            match solver.solve(constraint, solve_for) {
                Ok(solution) => solutions.push((solve_for.clone(), solution)),
                Err(e) => {
                    let error_msg = format!("/* geometric_solve_for failed: {} */", e);
                    let unchecked = self.generate_new_unchecked(ty);
                    return quote! {
                        #[doc = #error_msg]
                        #unchecked
                    };
                }
            }
        }

        // Solve antiproduct constraint only if independent (different constraint)
        if ty.has_independent_constraints() {
            if let (Some(solve_for), Some(constraint)) =
                (&ty.antiproduct_solve_for, &ty.antiproduct_constraint)
            {
                match solver.solve(constraint, solve_for) {
                    Ok(solution) => solutions.push((solve_for.clone(), solution)),
                    Err(e) => {
                        let error_msg = format!("/* antiproduct_solve_for failed: {} */", e);
                        let unchecked = self.generate_new_unchecked(ty);
                        return quote! {
                            #[doc = #error_msg]
                            #unchecked
                        };
                    }
                }
            }
        }

        // Solve user-defined constraints with solve_for
        for user_constraint in &ty.constraints {
            if let Some(ref solve_for) = user_constraint.solve_for {
                let positive_root = user_constraint.sign == SignConvention::Positive;
                match solver.solve_with_sign(&user_constraint.expression, solve_for, positive_root)
                {
                    Ok(solution) => solutions.push((solve_for.clone(), solution)),
                    Err(e) => {
                        let error_msg = format!(
                            "/* user constraint '{}' solve_for failed: {} */",
                            user_constraint.name, e
                        );
                        let unchecked = self.generate_new_unchecked(ty);
                        return quote! {
                            #[doc = #error_msg]
                            #unchecked
                        };
                    }
                }
            }
        }

        if solutions.is_empty() {
            // No solutions - generate simple constructor
            return self.generate_simple_constructor(ty);
        }

        self.generate_constrained_constructors_multi(ty, &solutions)
    }

    /// Generates a simple constructor (for types without solve_for).
    fn generate_simple_constructor(&self, ty: &TypeSpec) -> TokenStream {
        let params: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                quote! { #name: T }
            })
            .collect();

        let field_inits: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                quote! { #name }
            })
            .collect();

        quote! {
            /// Creates a new element from components.
            #[inline]
            pub fn new(#(#params),*) -> Self {
                Self { #(#field_inits),* }
            }
        }
    }

    /// Generates all three constructors for constrained types with multiple solve_for fields.
    fn generate_constrained_constructors_multi(
        &self,
        ty: &TypeSpec,
        solutions: &[(String, SolveResult)],
    ) -> TokenStream {
        let new_fn = self.generate_new_with_solve_multi(ty, solutions);
        let new_checked = self.generate_new_checked(ty);
        let new_unchecked = self.generate_new_unchecked(ty);

        quote! {
            #new_fn
            #new_checked
            #new_unchecked
        }
    }

    /// Generates `new()` that computes all solved-for fields.
    ///
    /// For quadratic constraints (involving sqrt), returns `Option<Self>` since
    /// the sqrt argument may be negative for some inputs.
    fn generate_new_with_solve_multi(
        &self,
        ty: &TypeSpec,
        solutions: &[(String, SolveResult)],
    ) -> TokenStream {
        let solve_for_names: Vec<&str> = solutions.iter().map(|(name, _)| name.as_str()).collect();

        // Check if any solution requires sqrt (quadratic)
        let has_quadratic = solutions
            .iter()
            .any(|(_, sol)| sol.solution_type == SolutionType::Quadratic);

        // Parameters: all fields except solve_for fields
        let params: Vec<TokenStream> = ty
            .fields
            .iter()
            .filter(|f| !solve_for_names.contains(&f.name.as_str()))
            .map(|field| {
                let name = format_ident!("{}", field.name);
                quote! { #name: T }
            })
            .collect();

        // Field initializers
        let field_inits: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                quote! { #name }
            })
            .collect();

        // Generate computation expressions for each solve_for field
        let compute_exprs: Vec<TokenStream> = solutions
            .iter()
            .map(|(solve_for, solution)| {
                let solve_for_ident = format_ident!("{}", solve_for);

                let numerator_expr: TokenStream = solution
                    .numerator
                    .parse()
                    .unwrap_or_else(|_| quote! { T::zero() });

                match solution.solution_type {
                    SolutionType::Quadratic => {
                        // Quadratic: var = sqrt(expr)
                        if has_quadratic {
                            let sign_expr = if solution.positive_root {
                                quote! { sqrt_arg.sqrt() }
                            } else {
                                quote! { -sqrt_arg.sqrt() }
                            };
                            quote! {
                                let sqrt_arg = #numerator_expr;
                                if sqrt_arg < T::zero() {
                                    return None; // No real solution
                                }
                                let #solve_for_ident = #sign_expr;
                            }
                        } else {
                            // Shouldn't happen, but handle gracefully
                            let sign_expr = if solution.positive_root {
                                quote! { (#numerator_expr).sqrt() }
                            } else {
                                quote! { -(#numerator_expr).sqrt() }
                            };
                            quote! {
                                let #solve_for_ident = #sign_expr;
                            }
                        }
                    }
                    SolutionType::Linear => {
                        // Linear: var = expr / divisor
                        if let Some(ref divisor) = solution.divisor {
                            let divisor_ident: TokenStream =
                                divisor.parse().unwrap_or_else(|_| quote! { T::one() });

                            quote! {
                                let #solve_for_ident = if (#divisor_ident).abs() > T::epsilon() {
                                    (#numerator_expr) / (#divisor_ident)
                                } else {
                                    T::zero() // Canonical value for degenerate case
                                };
                            }
                        } else {
                            quote! {
                                let #solve_for_ident = #numerator_expr;
                            }
                        }
                    }
                }
            })
            .collect();

        // Generate doc comment
        let solve_for_list = solve_for_names.join("`, `");

        if has_quadratic {
            let doc = format!(
                "Creates a new element from {} independent coefficients.\n\n\
                 The `{}` coefficient(s) are computed from geometric constraints.\n\n\
                 Returns `None` if the constraint cannot be satisfied (e.g., when the\n\
                 sqrt argument would be negative).",
                ty.fields.len() - solutions.len(),
                solve_for_list
            );

            quote! {
                #[doc = #doc]
                #[inline]
                pub fn new(#(#params),*) -> Option<Self> {
                    #(#compute_exprs)*
                    Some(Self { #(#field_inits),* })
                }
            }
        } else {
            let doc = format!(
                "Creates a new element from {} independent coefficients.\n\n\
                 The `{}` coefficient(s) are computed from geometric constraints.\n\
                 When divisors are zero (degenerate case), computed values default to zero.",
                ty.fields.len() - solutions.len(),
                solve_for_list
            );

            quote! {
                #[doc = #doc]
                #[inline]
                pub fn new(#(#params),*) -> Self {
                    #(#compute_exprs)*
                    Self { #(#field_inits),* }
                }
            }
        }
    }

    /// Generates `new_checked()` that validates the constraint.
    fn generate_new_checked(&self, ty: &TypeSpec) -> TokenStream {
        let type_name = &ty.name;

        // All parameters
        let params: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                quote! { #name: T }
            })
            .collect();

        let field_inits: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                quote! { #name }
            })
            .collect();

        // Get the constraint expression for validation
        let constraint = ty
            .geometric_constraint
            .as_ref()
            .or(ty.antiproduct_constraint.as_ref())
            .cloned()
            .unwrap_or_default();

        // Parse the constraint LHS to generate residual computation
        let residual_expr = self.generate_residual_expr(&constraint, ty);

        let constraint_doc = constraint.clone();

        let doc = format!(
            "Creates a new element from all coefficients with constraint validation.\n\n\
             Returns an error if the geometric constraint is not satisfied within\n\
             the given tolerance.\n\n\
             # Errors\n\n\
             Returns `ConstraintError` if `|{}| > tolerance`.",
            constraint_doc.replace(" = 0", "")
        );

        quote! {
            #[doc = #doc]
            #[inline]
            pub fn new_checked(
                #(#params,)*
                tolerance: T,
            ) -> Result<Self, crate::ConstraintError> {
                let residual = #residual_expr;

                if residual.abs() > tolerance {
                    return Err(crate::ConstraintError::new(
                        #type_name,
                        #constraint_doc,
                        residual.to_f64().unwrap_or(0.0),
                    ));
                }

                Ok(Self { #(#field_inits),* })
            }
        }
    }

    /// Generates `new_unchecked()` for raw construction.
    fn generate_new_unchecked(&self, ty: &TypeSpec) -> TokenStream {
        let params: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                quote! { #name: T }
            })
            .collect();

        let field_inits: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                quote! { #name }
            })
            .collect();

        quote! {
            /// Creates a new element from all coefficients without validation.
            ///
            /// # Safety (Logical)
            ///
            /// Caller must ensure the geometric constraint is satisfied.
            /// Use this for performance-critical code, automatic differentiation,
            /// or when coefficients come from trusted sources (e.g., product operations).
            #[inline]
            pub fn new_unchecked(#(#params),*) -> Self {
                Self { #(#field_inits),* }
            }
        }
    }

    /// Generates the residual expression for constraint validation.
    fn generate_residual_expr(&self, constraint: &str, ty: &TypeSpec) -> TokenStream {
        // Parse constraint like "2*s*e0123 - 2*e12*e03 + 2*e13*e02 - 2*e23*e01 = 0"
        // and generate Rust expression for the LHS

        // Split on '='
        let lhs = constraint.split('=').next().unwrap_or("T::zero()").trim();

        // Parse the expression, converting to Rust
        // This is a simplified conversion - we just use the expression as-is
        // since our constraints use simple multiplication syntax
        let rust_expr = self.constraint_to_rust_expr(lhs, ty);

        rust_expr.parse().unwrap_or_else(|_| quote! { T::zero() })
    }

    /// Converts a constraint expression to Rust syntax.
    fn constraint_to_rust_expr(&self, expr: &str, _ty: &TypeSpec) -> String {
        // Convert "2*s*e0123" to "T::TWO * s * e0123"
        // and "-2*e12*e03" to "-T::TWO * e12 * e03"

        // First normalize: add spaces around operators
        let mut result = expr.to_string();
        result = result.replace("*", " * ");
        result = result.replace("+", " + ");
        result = result.replace("-", " - ");

        // Clean up double spaces
        while result.contains("  ") {
            result = result.replace("  ", " ");
        }

        // Now replace standalone numeric coefficients (at word boundaries)
        // " 2 " -> " T::TWO "  and " - 2 " -> " - T::TWO "
        result = result.replace(" 2 ", " T::TWO ");
        result = result.replace(" - 2 ", " - T::TWO ");

        // Handle start of expression: "2 * " -> "T::TWO * " and "- 2 * " -> "- T::TWO * "
        if result.starts_with("2 ") {
            result = format!("T::TWO {}", &result[2..]);
        } else if result.starts_with("- 2 ") {
            result = format!("- T::TWO {}", &result[4..]);
        }

        result.trim().to_string()
    }

    /// Generates accessor methods for each field.
    fn generate_accessors(&self, ty: &TypeSpec) -> TokenStream {
        let accessors: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                let blade = Blade::from_index(field.blade_index);
                let blade_name = self.algebra.blade_name(blade);
                let doc = format!(
                    "Returns the {} component (coefficient of `{}`).",
                    field.name, blade_name
                );

                quote! {
                    #[doc = #doc]
                    #[inline]
                    pub fn #name(&self) -> T {
                        self.#name
                    }
                }
            })
            .collect();

        quote! { #(#accessors)* }
    }

    /// Generates the zero() method.
    /// Returns the constructor name to use for the given type.
    /// Uses `new_unchecked` for constrained types, `new` otherwise.
    fn constructor_name(ty: &TypeSpec) -> TokenStream {
        let has_constraints = !ty.solve_for_fields().is_empty();
        if has_constraints {
            quote! { new_unchecked }
        } else {
            quote! { new }
        }
    }

    /// Generates the zero() method for a type.
    fn generate_zero(&self, ty: &TypeSpec) -> TokenStream {
        let zeros: Vec<TokenStream> = ty.fields.iter().map(|_| quote! { T::zero() }).collect();
        let constructor = Self::constructor_name(ty);

        quote! {
            /// Creates the zero element.
            #[inline]
            pub fn zero() -> Self {
                Self::#constructor(#(#zeros),*)
            }
        }
    }

    /// Generates the identity() method if the type contains grade 0.
    fn generate_identity(&self, ty: &TypeSpec) -> TokenStream {
        // Only generate identity for types containing grade 0
        if !ty.grades.contains(&0) {
            return quote! {};
        }

        let values: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                if field.grade == 0 {
                    quote! { T::one() }
                } else {
                    quote! { T::zero() }
                }
            })
            .collect();

        let constructor = Self::constructor_name(ty);

        quote! {
            /// Creates the identity element (scalar = 1, rest = 0).
            #[inline]
            pub fn identity() -> Self {
                Self::#constructor(#(#values),*)
            }
        }
    }

    /// Generates unit basis element constructors for single-grade types.
    fn generate_unit_elements(&self, ty: &TypeSpec) -> TokenStream {
        // Only for single-grade types
        if ty.grades.len() != 1 {
            return quote! {};
        }

        let constructor = Self::constructor_name(ty);

        let units: Vec<TokenStream> = ty
            .fields
            .iter()
            .enumerate()
            .map(|(i, field)| {
                let method_name = format_ident!("unit_{}", field.name);
                let blade = Blade::from_index(field.blade_index);
                let blade_name = self.algebra.blade_name(blade);
                let doc = format!("Creates the unit {} element.", blade_name);

                let values: Vec<TokenStream> = ty
                    .fields
                    .iter()
                    .enumerate()
                    .map(|(j, _)| {
                        if i == j {
                            quote! { T::one() }
                        } else {
                            quote! { T::zero() }
                        }
                    })
                    .collect();

                quote! {
                    #[doc = #doc]
                    #[inline]
                    pub fn #method_name() -> Self {
                        Self::#constructor(#(#values),*)
                    }
                }
            })
            .collect();

        quote! { #(#units)* }
    }

    /// Generates norm_squared, norm, try_normalize, normalize, and scale methods.
    fn generate_norm_methods(&self, ty: &TypeSpec) -> TokenStream {
        let field_names: Vec<_> = ty
            .fields
            .iter()
            .map(|f| format_ident!("{}", f.name))
            .collect();

        let constructor = Self::constructor_name(ty);

        // Compute norm squared based on metric signature.
        // For each blade, we need to consider the metric.
        // For now, this uses Euclidean norm (sum of squares).
        // TODO: Handle non-Euclidean metrics properly (e.g., for CGA, PGA).
        let squared_terms: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                let blade = Blade::from_index(field.blade_index);
                let metric = self.blade_metric(blade);

                if metric >= 0 {
                    quote! { self.#name * self.#name }
                } else {
                    // Negative metric: subtract instead of add
                    // Note: we still compute the absolute value for norm purposes
                    quote! { self.#name * self.#name }
                }
            })
            .collect();

        quote! {
            /// Returns the squared Euclidean norm.
            ///
            /// This is the sum of squares of all components.
            #[inline]
            pub fn norm_squared(&self) -> T {
                #(#squared_terms)+*
            }

            /// Returns the Euclidean norm.
            #[inline]
            pub fn norm(&self) -> T {
                self.norm_squared().sqrt()
            }

            /// Attempts to normalize this element.
            ///
            /// Returns `None` if the norm is too small (less than epsilon).
            #[inline]
            pub fn try_normalize(&self) -> Option<Self> {
                let n = self.norm();
                if n < T::epsilon() {
                    None
                } else {
                    Some(self.scale(T::one() / n))
                }
            }

            /// Normalizes this element, panicking if the norm is too small.
            ///
            /// # Panics
            ///
            /// Panics if the norm is less than epsilon.
            #[inline]
            pub fn normalize(&self) -> Self {
                self.try_normalize().expect("cannot normalize zero element")
            }

            /// Scales all components by a scalar.
            #[inline]
            pub fn scale(&self, s: T) -> Self {
                Self::#constructor(#(self.#field_names * s),*)
            }
        }
    }

    /// Computes the metric sign for a blade.
    ///
    /// Returns 1 for positive metric, -1 for negative, 0 for null.
    fn blade_metric(&self, blade: Blade) -> i32 {
        // For a blade that is a product of basis vectors,
        // the metric is the product of individual metrics.
        let mut metric = 1i32;

        for i in 0..self.algebra.dim() {
            if blade.contains(i) {
                metric *= i32::from(self.algebra.metric(i));
            }
        }

        metric
    }

    /// Generates the reverse() method.
    ///
    /// Reverse: (-1)^(k(k-1)/2) for grade k.
    pub fn generate_reverse(&self, ty: &TypeSpec) -> TokenStream {
        let reversed_values: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let name = format_ident!("{}", field.name);
                let grade = field.grade;
                // Sign is (-1)^(k(k-1)/2)
                let exponent = grade * grade.saturating_sub(1) / 2;
                if exponent % 2 == 0 {
                    quote! { self.#name }
                } else {
                    quote! { -self.#name }
                }
            })
            .collect();

        let constructor = Self::constructor_name(ty);

        quote! {
            /// Returns the reverse (reversion).
            ///
            /// For a k-blade, the reverse has sign (-1)^(k(k-1)/2):
            /// - Grade 0: +1
            /// - Grade 1: +1
            /// - Grade 2: -1
            /// - Grade 3: -1
            /// - Grade 4: +1
            /// - ...
            #[inline]
            pub fn reverse(&self) -> Self {
                Self::#constructor(#(#reversed_values),*)
            }
        }
    }

    /// Generates the Default implementation.
    fn generate_default(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        // Default is identity for types with grade 0, otherwise zero
        let default_fn = if ty.grades.contains(&0) {
            quote! { Self::identity() }
        } else {
            quote! { Self::zero() }
        };

        quote! {
            impl<T: Float> Default for #name<T> {
                fn default() -> Self {
                    #default_fn
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::spec::parse_spec;

    #[test]
    fn generates_vector_type() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        let tokens = generator.generate_types_file();
        let code = tokens.to_string();

        assert!(code.contains("pub struct Vector"));
        assert!(code.contains("x : T"));
        assert!(code.contains("y : T"));
        assert!(code.contains("z : T"));
        assert!(code.contains("pub fn new"));
        assert!(code.contains("pub fn x"));
    }

    #[test]
    fn field_order_is_canonical() {
        // Verify fields are ordered by grade, then by blade index
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let full_type = spec.types.iter().find(|t| t.name == "Full").unwrap();

        let field_order: Vec<&str> = full_type.fields.iter().map(|f| f.name.as_str()).collect();

        // Expected: s (grade 0), x, y, z (grade 1), xy, xz, yz (grade 2), xyz (grade 3)
        assert_eq!(
            field_order,
            vec!["s", "x", "y", "z", "xy", "xz", "yz", "xyz"]
        );
    }

    #[test]
    fn reverse_signs_correct() {
        // Grade 0: sign = +1
        // Grade 1: sign = +1 (0*-1/2 = 0, even)
        // Grade 2: sign = -1 (2*1/2 = 1, odd)
        // Grade 3: sign = -1 (3*2/2 = 3, odd)

        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        // Check Bivector reverse
        let bivector = spec.types.iter().find(|t| t.name == "Bivector").unwrap();
        let tokens = generator.generate_reverse(bivector);
        let code = tokens.to_string();

        // All bivector components should be negated
        assert!(code.contains("- self . xy"));
        assert!(code.contains("- self . xz"));
        assert!(code.contains("- self . yz"));
    }

    #[test]
    fn generates_identity_for_rotor() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        let rotor = spec.types.iter().find(|t| t.name == "Rotor").unwrap();
        let tokens = generator.generate_identity(rotor);
        let code = tokens.to_string();

        // Identity should have scalar = 1
        assert!(code.contains("identity"));
        assert!(code.contains("T :: one ()"));
    }

    #[test]
    fn no_identity_for_vector() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        let vector = spec.types.iter().find(|t| t.name == "Vector").unwrap();
        let tokens = generator.generate_identity(vector);
        let code = tokens.to_string();

        // Vector has no grade 0, so no identity
        assert!(code.is_empty());
    }

    #[test]
    fn generates_unit_elements_for_vector() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        let vector = spec.types.iter().find(|t| t.name == "Vector").unwrap();
        let tokens = generator.generate_unit_elements(vector);
        let code = tokens.to_string();

        // Vector should have unit_x, unit_y, unit_z
        assert!(code.contains("unit_x"));
        assert!(code.contains("unit_y"));
        assert!(code.contains("unit_z"));
    }

    #[test]
    fn no_unit_elements_for_rotor() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        let rotor = spec.types.iter().find(|t| t.name == "Rotor").unwrap();
        let tokens = generator.generate_unit_elements(rotor);
        let code = tokens.to_string();

        // Rotor has multiple grades, so no unit elements
        assert!(code.is_empty());
    }

    #[test]
    fn generates_alias() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        let tokens = generator.generate_types_file();
        let code = tokens.to_string();

        // Even is an alias of Rotor
        assert!(code.contains("pub type Even"));
        assert!(code.contains("Rotor"));
    }

    #[test]
    fn generates_default_impl() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let generator = TypeGenerator::new(&spec, &algebra);

        let rotor = spec.types.iter().find(|t| t.name == "Rotor").unwrap();
        let tokens = generator.generate_default(rotor);
        let code = tokens.to_string();

        // Rotor default should be identity
        assert!(code.contains("impl < T : Float > Default for Rotor"));
        assert!(code.contains("Self :: identity ()"));

        let vector = spec.types.iter().find(|t| t.name == "Vector").unwrap();
        let tokens = generator.generate_default(vector);
        let code = tokens.to_string();

        // Vector default should be zero
        assert!(code.contains("impl < T : Float > Default for Vector"));
        assert!(code.contains("Self :: zero ()"));
    }
}
