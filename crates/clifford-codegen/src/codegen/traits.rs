//! Trait implementation generation.
//!
//! This module provides the `TraitsGenerator` for generating Rust trait
//! implementations including operators, approx traits, and Arbitrary.

use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::algebra::{Algebra, ProductTable};
use crate::spec::{AlgebraSpec, TypeSpec};
use crate::symbolic::{ConstraintDeriver, ConstraintSolver, SolutionType};

/// Generates trait implementations for algebra types.
///
/// The generator produces:
/// - Arithmetic operators (Add, Sub, Neg, Mul)
/// - Scalar multiplication
/// - Geometric and outer product operators
/// - Approx traits (AbsDiffEq, RelativeEq, UlpsEq)
/// - Arbitrary implementations for proptest
///
/// # Example
///
/// ```
/// use clifford_codegen::algebra::{Algebra, ProductTable};
/// use clifford_codegen::codegen::TraitsGenerator;
/// use clifford_codegen::spec::parse_spec;
///
/// let spec = parse_spec(r#"
/// [algebra]
/// name = "euclidean2"
///
/// [signature]
/// positive = ["e1", "e2"]
///
/// [types.Vector]
/// grades = [1]
/// fields = ["x", "y"]
///
/// [types.Bivector]
/// grades = [2]
/// fields = ["xy"]
/// "#).unwrap();
///
/// let algebra = Algebra::euclidean(2);
/// let table = ProductTable::new(&algebra);
/// let generator = TraitsGenerator::new(&spec, &algebra, table);
///
/// let (tokens, _tests) = generator.generate_traits_file();
/// let code = tokens.to_string();
///
/// assert!(code.contains("Add for Vector"));
/// ```
pub struct TraitsGenerator<'a> {
    /// The algebra specification.
    spec: &'a AlgebraSpec,
    /// The algebra for computations.
    algebra: &'a Algebra,
}

impl<'a> TraitsGenerator<'a> {
    /// Creates a new traits generator.
    pub fn new(spec: &'a AlgebraSpec, algebra: &'a Algebra, _table: ProductTable) -> Self {
        Self { spec, algebra }
    }

    /// Generates the complete traits file.
    ///
    /// Returns a tuple of (TokenStream, String) where:
    /// - The TokenStream contains the main code (operators, traits, arbitrary)
    /// - The String contains pre-formatted verification tests that should be
    ///   appended after formatting the main code (rustfmt can't format inside
    ///   proptest! macros)
    pub fn generate_traits_file(&self) -> (TokenStream, String) {
        let header = self.generate_header();
        let imports = self.generate_imports();
        let ops = self.generate_all_ops();
        let normed = self.generate_all_normed();
        let approx = self.generate_all_approx();
        let arbitrary = self.generate_all_arbitrary();
        let verification_tests = self.generate_verification_tests_raw();

        let main_tokens = quote! {
            #header
            #imports

            // ============================================================
            // Operator Implementations
            // ============================================================
            #ops

            // ============================================================
            // Normed Trait Implementations
            // ============================================================
            #normed

            // ============================================================
            // Approx Trait Implementations
            // ============================================================
            #approx

            // ============================================================
            // Arbitrary Implementations (for proptest)
            // ============================================================
            #arbitrary
        };

        (main_tokens, verification_tests)
    }

    /// Generates the file header.
    fn generate_header(&self) -> TokenStream {
        let name = &self.spec.name;
        let header_doc = format!(
            r#"//! Trait implementations for {}.
//!
//! This file is auto-generated by clifford-codegen.
//! Do not edit manually."#,
            name
        );

        header_doc.parse().unwrap_or_else(|_| quote! {})
    }

    /// Generates import statements.
    fn generate_imports(&self) -> TokenStream {
        let type_names: Vec<_> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|t| format_ident!("{}", t.name))
            .collect();

        quote! {
            use crate::scalar::Float;
            use super::types::{#(#type_names),*};
            use super::products::*;

            use std::ops::{Add, Sub, Neg, Mul, BitXor};

            use approx::{AbsDiffEq, RelativeEq, UlpsEq};
        }
    }

    // ========================================================================
    // Operator Implementations
    // ========================================================================

    /// Generates all operator implementations.
    fn generate_all_ops(&self) -> TokenStream {
        let ops: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .flat_map(|ty| self.generate_ops_for_type(ty))
            .collect();

        quote! { #(#ops)* }
    }

    /// Generates operators for a single type.
    #[allow(clippy::vec_init_then_push)]
    fn generate_ops_for_type(&self, ty: &TypeSpec) -> Vec<TokenStream> {
        let mut impls = Vec::new();

        // Same-type operations
        impls.push(self.generate_add(ty));
        impls.push(self.generate_sub(ty));
        impls.push(self.generate_neg(ty));
        impls.push(self.generate_scalar_mul(ty));
        impls.push(self.generate_scalar_mul_reverse_f32(ty));
        impls.push(self.generate_scalar_mul_reverse_f64(ty));

        // Cross-type operations (geometric product) - only for explicit products
        for entry in &self.spec.products.geometric {
            // Only generate if lhs matches this type
            if entry.lhs == ty.name {
                if let Some(other) = self.find_type(&entry.rhs) {
                    if let Some(output_type) = self.find_type(&entry.output) {
                        impls.push(self.generate_geometric_mul_from_entry(
                            ty,
                            other,
                            output_type,
                            entry,
                        ));
                    }
                }
            }
        }

        // Exterior product (using BitXor) - only for explicit products
        for entry in &self.spec.products.exterior {
            // Only generate if lhs matches this type
            if entry.lhs == ty.name {
                if let Some(other) = self.find_type(&entry.rhs) {
                    if let Some(output_type) = self.find_type(&entry.output) {
                        impls.push(self.generate_exterior_from_entry(
                            ty,
                            other,
                            output_type,
                            entry,
                        ));
                    }
                }
            }
        }

        impls
    }

    /// Finds a TypeSpec by name.
    fn find_type(&self, name: &str) -> Option<&TypeSpec> {
        self.spec.types.iter().find(|t| t.name == name)
    }

    /// Generates a constructor call.
    fn generate_constructor_call(_ty: &TypeSpec, field_exprs: &[TokenStream]) -> TokenStream {
        quote! { Self::new(#(#field_exprs),*) }
    }

    /// Generates Add implementation.
    fn generate_add(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let field_adds: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname() + rhs.#fname() }
            })
            .collect();

        let constructor_call = Self::generate_constructor_call(ty, &field_adds);

        quote! {
            impl<T: Float> Add for #name<T> {
                type Output = Self;

                #[inline]
                fn add(self, rhs: Self) -> Self {
                    #constructor_call
                }
            }
        }
    }

    /// Generates Sub implementation.
    fn generate_sub(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let field_subs: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname() - rhs.#fname() }
            })
            .collect();

        let constructor_call = Self::generate_constructor_call(ty, &field_subs);

        quote! {
            impl<T: Float> Sub for #name<T> {
                type Output = Self;

                #[inline]
                fn sub(self, rhs: Self) -> Self {
                    #constructor_call
                }
            }
        }
    }

    /// Generates Neg implementation.
    fn generate_neg(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let field_negs: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { -self.#fname() }
            })
            .collect();

        let constructor_call = Self::generate_constructor_call(ty, &field_negs);

        quote! {
            impl<T: Float> Neg for #name<T> {
                type Output = Self;

                #[inline]
                fn neg(self) -> Self {
                    #constructor_call
                }
            }
        }
    }

    /// Generates scalar multiplication (Type * T).
    fn generate_scalar_mul(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        quote! {
            impl<T: Float> Mul<T> for #name<T> {
                type Output = Self;

                #[inline]
                fn mul(self, scalar: T) -> Self {
                    self.scale(scalar)
                }
            }
        }
    }

    /// Generates reverse scalar multiplication for f32 (f32 * Type).
    fn generate_scalar_mul_reverse_f32(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        quote! {
            impl Mul<#name<f32>> for f32 {
                type Output = #name<f32>;

                #[inline]
                fn mul(self, v: #name<f32>) -> #name<f32> {
                    v.scale(self)
                }
            }
        }
    }

    /// Generates reverse scalar multiplication for f64 (f64 * Type).
    fn generate_scalar_mul_reverse_f64(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        quote! {
            impl Mul<#name<f64>> for f64 {
                type Output = #name<f64>;

                #[inline]
                fn mul(self, v: #name<f64>) -> #name<f64> {
                    v.scale(self)
                }
            }
        }
    }

    /// Generates geometric product (Type * Other -> Output) from a product entry.
    fn generate_geometric_mul_from_entry(
        &self,
        a: &TypeSpec,
        b: &TypeSpec,
        output: &TypeSpec,
        entry: &crate::spec::ProductEntry,
    ) -> TokenStream {
        let a_name = format_ident!("{}", a.name);
        let b_name = format_ident!("{}", b.name);
        let out_name = format_ident!("{}", output.name);
        let fn_name = format_ident!(
            "geometric_{}_{}",
            entry.lhs.to_lowercase(),
            entry.rhs.to_lowercase()
        );

        quote! {
            impl<T: Float> Mul<#b_name<T>> for #a_name<T> {
                type Output = #out_name<T>;

                #[inline]
                fn mul(self, rhs: #b_name<T>) -> #out_name<T> {
                    #fn_name(&self, &rhs)
                }
            }
        }
    }

    /// Generates exterior product (Type ^ Other -> Output) from a product entry.
    fn generate_exterior_from_entry(
        &self,
        a: &TypeSpec,
        b: &TypeSpec,
        output: &TypeSpec,
        entry: &crate::spec::ProductEntry,
    ) -> TokenStream {
        let a_name = format_ident!("{}", a.name);
        let b_name = format_ident!("{}", b.name);
        let out_name = format_ident!("{}", output.name);
        let fn_name = format_ident!(
            "exterior_{}_{}",
            entry.lhs.to_lowercase(),
            entry.rhs.to_lowercase()
        );

        quote! {
            impl<T: Float> BitXor<#b_name<T>> for #a_name<T> {
                type Output = #out_name<T>;

                #[inline]
                fn bitxor(self, rhs: #b_name<T>) -> #out_name<T> {
                    #fn_name(&self, &rhs)
                }
            }
        }
    }

    // ========================================================================
    // Normed Trait Implementations
    // ========================================================================

    /// Generates all Normed trait implementations.
    fn generate_all_normed(&self) -> TokenStream {
        let impls: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|ty| self.generate_normed_impl(ty))
            .collect();

        // For PGA algebras (with degenerate basis), also generate DegenerateNormed
        let degenerate_impls: Vec<TokenStream> = if self.spec.signature.r > 0 {
            self.spec
                .types
                .iter()
                .filter(|t| t.alias_of.is_none())
                .filter_map(|ty| self.generate_degenerate_normed_impl(ty))
                .collect()
        } else {
            Vec::new()
        };

        quote! {
            #(#impls)*
            #(#degenerate_impls)*
        }
    }

    /// Generates `impl Normed for Type<T>`.
    fn generate_normed_impl(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        // Generate norm_squared: sum of squares of all fields
        let norm_squared_terms: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname() * self.#fname() }
            })
            .collect();

        // Generate scale: multiply each field by factor
        let scale_fields: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname() * factor }
            })
            .collect();

        // Handle edge case where type has no fields
        let norm_squared_expr = if norm_squared_terms.is_empty() {
            quote! { T::zero() }
        } else {
            quote! { #(#norm_squared_terms)+* }
        };

        quote! {
            impl<T: Float> crate::norm::Normed for #name<T> {
                type Scalar = T;

                #[inline]
                fn norm_squared(&self) -> T {
                    #norm_squared_expr
                }

                fn try_normalize(&self) -> Option<Self> {
                    let n = self.norm();
                    if n < T::epsilon() {
                        None
                    } else {
                        Some(self.scale(T::one() / n))
                    }
                }

                #[inline]
                fn scale(&self, factor: T) -> Self {
                    Self::new(#(#scale_fields),*)
                }
            }
        }
    }

    /// Generates `impl DegenerateNormed for Type<T>` for PGA types.
    ///
    /// Returns None if the type has no bulk or weight components.
    fn generate_degenerate_normed_impl(&self, ty: &TypeSpec) -> Option<TokenStream> {
        let name = format_ident!("{}", ty.name);

        // Find indices of degenerate basis vectors (those with metric == 0)
        let degenerate_indices: Vec<usize> = self
            .spec
            .signature
            .basis
            .iter()
            .filter(|b| b.metric == 0)
            .map(|b| b.index)
            .collect();

        // Partition fields into bulk (no degenerate basis) and weight (has degenerate basis)
        let (bulk_fields, weight_fields): (Vec<_>, Vec<_>) = ty.fields.iter().partition(|f| {
            // Check if this field's blade involves any degenerate basis vector
            !degenerate_indices.iter().any(|&deg_idx| {
                // Check if bit `deg_idx` is set in the blade_index
                (f.blade_index >> deg_idx) & 1 == 1
            })
        });

        // Don't generate if there are no fields in either category
        if bulk_fields.is_empty() && weight_fields.is_empty() {
            return None;
        }

        // Generate bulk_norm_squared: sum of squares of bulk fields
        let bulk_norm_terms: Vec<TokenStream> = bulk_fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname() * self.#fname() }
            })
            .collect();

        // Generate weight_norm_squared: sum of squares of weight fields
        let weight_norm_terms: Vec<TokenStream> = weight_fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname() * self.#fname() }
            })
            .collect();

        let bulk_norm_expr = if bulk_norm_terms.is_empty() {
            quote! { T::zero() }
        } else {
            quote! { #(#bulk_norm_terms)+* }
        };

        let weight_norm_expr = if weight_norm_terms.is_empty() {
            quote! { T::zero() }
        } else {
            quote! { #(#weight_norm_terms)+* }
        };

        // Generate scale fields for try_unitize
        let scale_fields: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname() * inv_w }
            })
            .collect();

        Some(quote! {
            impl<T: Float> crate::norm::DegenerateNormed for #name<T> {
                #[inline]
                fn bulk_norm_squared(&self) -> T {
                    #bulk_norm_expr
                }

                #[inline]
                fn weight_norm_squared(&self) -> T {
                    #weight_norm_expr
                }

                fn try_unitize(&self) -> Option<Self> {
                    let w = self.weight_norm();
                    if w < T::epsilon() {
                        None
                    } else {
                        let inv_w = T::one() / w;
                        Some(Self::new(#(#scale_fields),*))
                    }
                }
            }
        })
    }

    // ========================================================================
    // Approx Trait Implementations
    // ========================================================================

    /// Generates all approx trait implementations.
    fn generate_all_approx(&self) -> TokenStream {
        let impls: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|ty| self.generate_approx_impls(ty))
            .collect();

        quote! { #(#impls)* }
    }

    /// Generates approx trait implementations for a type.
    fn generate_approx_impls(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        let abs_diff_checks: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname().abs_diff_eq(&other.#fname(), epsilon) }
            })
            .collect();

        let relative_checks: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname().relative_eq(&other.#fname(), epsilon, max_relative) }
            })
            .collect();

        let ulps_checks: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname().ulps_eq(&other.#fname(), epsilon, max_ulps) }
            })
            .collect();

        quote! {
            impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for #name<T> {
                type Epsilon = T;

                fn default_epsilon() -> Self::Epsilon {
                    T::default_epsilon()
                }

                fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
                    #(#abs_diff_checks)&&*
                }
            }

            impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for #name<T> {
                fn default_max_relative() -> Self::Epsilon {
                    T::default_max_relative()
                }

                fn relative_eq(
                    &self,
                    other: &Self,
                    epsilon: Self::Epsilon,
                    max_relative: Self::Epsilon,
                ) -> bool {
                    #(#relative_checks)&&*
                }
            }

            impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for #name<T> {
                fn default_max_ulps() -> u32 {
                    T::default_max_ulps()
                }

                fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
                    #(#ulps_checks)&&*
                }
            }
        }
    }

    // ========================================================================
    // Arbitrary Implementations
    // ========================================================================

    /// Generates all Arbitrary implementations.
    fn generate_all_arbitrary(&self) -> TokenStream {
        let impls: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|ty| self.generate_arbitrary_impl(ty))
            .collect();

        quote! {
            #[cfg(any(test, feature = "proptest-support"))]
            #[allow(clippy::missing_docs_in_private_items)]
            mod arbitrary_impls {
                use super::*;
                use proptest::prelude::*;
                use proptest::strategy::BoxedStrategy;
                use std::fmt::Debug;

                #(#impls)*
            }
        }
    }

    /// Generates Arbitrary implementation for a type.
    ///
    /// For unconstrained types, generates random values for all fields.
    /// For constrained types (with geometric constraints like Study condition),
    /// solves the constraint to compute dependent variables from independent ones.
    fn generate_arbitrary_impl(&self, ty: &TypeSpec) -> TokenStream {
        // Check if this type has a derived constraint
        if let Some(constraint_impl) = self.try_generate_constrained_arbitrary(ty) {
            return constraint_impl;
        }

        // No constraint - generate simple random values for all fields
        self.generate_unconstrained_arbitrary(ty)
    }

    /// Attempts to generate a constraint-solving Arbitrary implementation.
    ///
    /// Returns `Some(TokenStream)` if the type has a derived constraint that can be solved,
    /// `None` otherwise.
    fn try_generate_constrained_arbitrary(&self, ty: &TypeSpec) -> Option<TokenStream> {
        // Derive constraints from algebra structure
        let deriver = ConstraintDeriver::new(self.algebra);
        let constraint = deriver.derive_geometric_constraint(ty, "x")?;

        // Only handle single-constraint cases for now
        if constraint.zero_expressions.len() != 1 {
            return None;
        }

        let expr = &constraint.zero_expressions[0];

        // Convert Symbolica expression to string for the solver
        let expr_str = format!("{} = 0", expr);

        // Find the highest-grade field to solve for (typically pseudoscalar like e0123)
        let solve_for_field = ty.fields.iter().max_by_key(|f| f.grade)?;

        // Try to solve the constraint for this variable
        let solver = ConstraintSolver::new();
        let symbol_name = format!("x_{}", solve_for_field.name);
        let solution = solver.solve(&expr_str, &symbol_name).ok()?;

        // For quadratic constraints (like Plücker), use filter instead of solving
        if solution.solution_type == SolutionType::Quadratic {
            return self.generate_filtered_arbitrary(ty);
        }

        // Generate constraint-solving Arbitrary
        Some(self.generate_solving_arbitrary(ty, &solve_for_field.name, &solution))
    }

    /// Generates Arbitrary that solves a linear constraint.
    fn generate_solving_arbitrary(
        &self,
        ty: &TypeSpec,
        solve_for: &str,
        solution: &crate::symbolic::SolveResult,
    ) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let num_fields = ty.fields.len();

        // Find indices of free and dependent fields
        let solve_for_idx = ty.fields.iter().position(|f| f.name == solve_for).unwrap();
        let free_indices: Vec<usize> = (0..num_fields).filter(|&i| i != solve_for_idx).collect();

        // Generate ranges for free variables
        let range_tuple: Vec<TokenStream> = free_indices
            .iter()
            .map(|_| quote! { -100.0f64..100.0 })
            .collect();

        // Generate variable names for prop_map
        let prop_map_args: Vec<TokenStream> = free_indices
            .iter()
            .enumerate()
            .map(|(i, _)| {
                let var = format_ident!("x{}", i);
                quote! { #var }
            })
            .collect();

        // Build the solution expression
        let numerator_expr = self.convert_solution_to_tokens(&solution.numerator, ty);
        let solution_expr = if let Some(ref divisor) = solution.divisor {
            let divisor_expr = self.convert_solution_to_tokens(divisor, ty);
            quote! { (#numerator_expr) / (#divisor_expr) }
        } else {
            numerator_expr
        };

        // Build field initialization expressions
        let mut field_var_map: Vec<Option<usize>> = vec![None; num_fields];
        for (var_idx, &field_idx) in free_indices.iter().enumerate() {
            field_var_map[field_idx] = Some(var_idx);
        }

        let field_inits: Vec<TokenStream> = ty
            .fields
            .iter()
            .enumerate()
            .map(|(i, _f)| {
                if i == solve_for_idx {
                    quote! { T::from_f64(#solution_expr) }
                } else {
                    let var_idx = field_var_map[i].unwrap();
                    let var = format_ident!("x{}", var_idx);
                    quote! { T::from_f64(#var) }
                }
            })
            .collect();

        // Generate filter for divisor non-zero condition
        let filter_expr = if let Some(ref divisor) = solution.divisor {
            let divisor_var = self.find_divisor_variable(divisor, ty);
            if let Some(var_idx) = divisor_var {
                let var = format_ident!("x{}", var_idx);
                // Generate filter args with underscores for unused variables
                let filter_args: Vec<TokenStream> = free_indices
                    .iter()
                    .enumerate()
                    .map(|(i, _)| {
                        if i == var_idx {
                            let v = format_ident!("x{}", i);
                            quote! { #v }
                        } else {
                            let v = format_ident!("_x{}", i);
                            quote! { #v }
                        }
                    })
                    .collect();
                Some(quote! {
                    .prop_filter("non-zero divisor", |(#(#filter_args),*)| (#var).abs() > 0.1)
                })
            } else {
                None
            }
        } else {
            None
        };

        let filter_chain = filter_expr.unwrap_or_else(|| quote! {});

        if free_indices.len() == 1 {
            let var = format_ident!("x0");
            quote! {
                impl<T: Float + Debug + 'static> Arbitrary for #name<T> {
                    type Parameters = ();
                    type Strategy = BoxedStrategy<Self>;

                    fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
                        (-100.0f64..100.0)
                            #filter_chain
                            .prop_map(|#var| {
                                #name::new(#(#field_inits),*)
                            })
                            .boxed()
                    }
                }
            }
        } else {
            quote! {
                impl<T: Float + Debug + 'static> Arbitrary for #name<T> {
                    type Parameters = ();
                    type Strategy = BoxedStrategy<Self>;

                    fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
                        (#(#range_tuple),*)
                            #filter_chain
                            .prop_map(|(#(#prop_map_args),*)| {
                                #name::new(#(#field_inits),*)
                            })
                            .boxed()
                    }
                }
            }
        }
    }

    /// Converts a solution expression string to TokenStream.
    ///
    /// The solution from `ConstraintSolver` uses variable names like "x_s", "x_e23", etc.
    /// (field names with the `x_` prefix from ConstraintDeriver).
    /// We need to convert these to the corresponding `x{i}` variables.
    fn convert_solution_to_tokens(&self, expr: &str, ty: &TypeSpec) -> TokenStream {
        let mut result = expr.to_string();

        // Find field indices for free variables (all except the solved-for one)
        let solve_for_field = ty.fields.iter().max_by_key(|f| f.grade).unwrap();

        let free_fields: Vec<_> = ty
            .fields
            .iter()
            .filter(|f| f.name != solve_for_field.name)
            .collect();

        // Replace "x_fieldname" with "x{i}" variables
        // Do longer names first to avoid partial replacements
        let mut sorted_fields: Vec<_> = free_fields.iter().enumerate().collect();
        sorted_fields.sort_by(|a, b| b.1.name.len().cmp(&a.1.name.len()));

        for (i, field) in sorted_fields {
            let field_pattern = format!("x_{}", field.name);
            let var_name = format!("x{}", i);
            result = result.replace(&field_pattern, &var_name);
        }

        // Parse and convert to TokenStream
        result.parse().unwrap_or_else(|_| quote! { T::zero() })
    }

    /// Finds which free variable corresponds to the divisor.
    ///
    /// The divisor uses the `x_fieldname` format from ConstraintDeriver.
    fn find_divisor_variable(&self, divisor: &str, ty: &TypeSpec) -> Option<usize> {
        let solve_for_field = ty.fields.iter().max_by_key(|f| f.grade)?;

        let free_fields: Vec<_> = ty
            .fields
            .iter()
            .filter(|f| f.name != solve_for_field.name)
            .collect();

        for (i, field) in free_fields.iter().enumerate() {
            // Check for "x_fieldname" pattern
            let pattern = format!("x_{}", field.name);
            if divisor.contains(&pattern) {
                return Some(i);
            }
        }
        None
    }

    /// Generates Arbitrary with a filter for quadratic constraints.
    ///
    /// For constraints like the Plücker condition that are quadratic and can't
    /// be easily solved, we generate random values and filter.
    fn generate_filtered_arbitrary(&self, ty: &TypeSpec) -> Option<TokenStream> {
        let name = format_ident!("{}", ty.name);
        let num_fields = ty.fields.len();

        // Generate tuple of ranges
        let range_tuple: Vec<TokenStream> =
            (0..num_fields).map(|_| quote! { -10.0f64..10.0 }).collect();

        let prop_map_args: Vec<TokenStream> = (0..num_fields)
            .map(|i| {
                let var = format_ident!("x{}", i);
                quote! { #var }
            })
            .collect();

        let field_inits: Vec<TokenStream> = (0..num_fields)
            .map(|i| {
                let var = format_ident!("x{}", i);
                quote! { T::from_f64(#var) }
            })
            .collect();

        Some(quote! {
            impl<T: Float + Debug + 'static> Arbitrary for #name<T> {
                type Parameters = ();
                type Strategy = BoxedStrategy<Self>;

                fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
                    (#(#range_tuple),*)
                        .prop_map(|(#(#prop_map_args),*)| {
                            #name::new(#(#field_inits),*)
                        })
                        .boxed()
                }
            }
        })
    }

    /// Generates simple Arbitrary for unconstrained types.
    fn generate_unconstrained_arbitrary(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let num_fields = ty.fields.len();

        // Generate tuple of ranges
        let range_tuple: Vec<TokenStream> = (0..num_fields)
            .map(|_| quote! { -100.0f64..100.0 })
            .collect();

        let field_inits: Vec<TokenStream> = (0..num_fields)
            .map(|i| {
                let var = format_ident!("x{}", i);
                quote! { T::from_f64(#var) }
            })
            .collect();

        if num_fields == 1 {
            quote! {
                impl<T: Float + Debug + 'static> Arbitrary for #name<T> {
                    type Parameters = ();
                    type Strategy = BoxedStrategy<Self>;

                    fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
                        (-100.0f64..100.0)
                            .prop_map(|x0| {
                                #name::new(#(#field_inits),*)
                            })
                            .boxed()
                    }
                }
            }
        } else {
            let prop_map_args: Vec<TokenStream> = (0..num_fields)
                .map(|i| {
                    let var = format_ident!("x{}", i);
                    quote! { #var }
                })
                .collect();

            quote! {
                impl<T: Float + Debug + 'static> Arbitrary for #name<T> {
                    type Parameters = ();
                    type Strategy = BoxedStrategy<Self>;

                    fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
                        (#(#range_tuple),*)
                            .prop_map(|(#(#prop_map_args),*)| {
                                #name::new(#(#field_inits),*)
                            })
                            .boxed()
                    }
                }
            }
        }
    }

    // ========================================================================
    // Verification Tests
    // ========================================================================

    /// Generates verification tests as a pre-formatted string.
    ///
    /// This returns a raw string instead of TokenStream because rustfmt
    /// cannot format code inside proptest! macros. By generating the tests
    /// as pre-formatted strings, we preserve the formatting.
    fn generate_verification_tests_raw(&self) -> String {
        let signature_name = self.generate_signature_name();
        let add_sub_tests = self.generate_add_sub_verification_tests_raw();
        let geometric_tests = self.generate_geometric_verification_tests_raw();
        let exterior_tests = self.generate_exterior_verification_tests_raw();

        format!(
            r#"
// ============================================================
// Verification Tests (compare against Multivector)
// ============================================================

#[cfg(test)]
#[allow(clippy::missing_docs_in_private_items)]
mod verification_tests {{
    use super::*;
    use crate::algebra::Multivector;
    use crate::signature::{sig};
    use approx::relative_eq;
    use proptest::prelude::*;

    /// Relative epsilon for floating-point comparisons in verification tests.
    /// Using relative comparison handles varying magnitudes better than absolute.
    const REL_EPSILON: f64 = 1e-10;
{add_sub}{geometric}{exterior}}}
"#,
            sig = signature_name,
            add_sub = add_sub_tests,
            geometric = geometric_tests,
            exterior = exterior_tests,
        )
    }

    /// Generates the signature type name for this algebra.
    ///
    /// Uses the signature tuple (p, q, r) to determine the signature type,
    /// not the algebra name. This ensures generic handling of all algebras.
    fn generate_signature_name(&self) -> proc_macro2::Ident {
        let sig = &self.spec.signature;
        let (p, q, r) = (sig.p, sig.q, sig.r);

        // Derive signature type from (p, q, r)
        let sig_name = match (p, q, r) {
            // Euclidean: Cl(n, 0, 0)
            (2, 0, 0) => "Euclidean2",
            (3, 0, 0) => "Euclidean3",

            // Projective (PGA): Cl(n, 0, 1)
            (2, 0, 1) => "Projective2",
            (3, 0, 1) => "Projective3",

            // Conformal (CGA): Cl(n+1, 1, 0) - note: uses p+q=4/5 convention
            // CGA 2D: Cl(3, 1, 0) - 2D + 2 extra dimensions
            // CGA 3D: Cl(4, 1, 0) - 3D + 2 extra dimensions
            (4, 1, 0) => "Conformal3",

            // Minkowski spacetime: Cl(1, 3, 0)
            (1, 3, 0) => "Minkowski4",

            // Generic: use Cl{p}_{q}_{r} format
            _ => {
                return format_ident!("Cl{}_{}_{}", p, q, r);
            }
        };
        format_ident!("{}", sig_name)
    }

    /// Generates add/sub verification tests for each type as a formatted string.
    fn generate_add_sub_verification_tests_raw(&self) -> String {
        let signature_name = self.generate_signature_name();
        self.spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|ty| {
                let name = &ty.name;
                let name_lower = ty.name.to_lowercase();

                format!(
                    r#"
    proptest! {{
        #[test]
        fn {name_lower}_add_matches_multivector(a in any::<{name}<f64>>(), b in any::<{name}<f64>>()) {{
            let mv_a: Multivector<f64, {sig}> = a.into();
            let mv_b: Multivector<f64, {sig}> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, {sig}> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={{:?}}, generic={{:?}}",
                specialized_mv, generic_result
            );
        }}

        #[test]
        fn {name_lower}_sub_matches_multivector(a in any::<{name}<f64>>(), b in any::<{name}<f64>>()) {{
            let mv_a: Multivector<f64, {sig}> = a.into();
            let mv_b: Multivector<f64, {sig}> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, {sig}> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={{:?}}, generic={{:?}}",
                specialized_mv, generic_result
            );
        }}

        #[test]
        fn {name_lower}_neg_matches_multivector(a in any::<{name}<f64>>()) {{
            let mv_a: Multivector<f64, {sig}> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, {sig}> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={{:?}}, generic={{:?}}",
                specialized_mv, generic_result
            );
        }}
    }}
"#,
                    name_lower = name_lower,
                    name = name,
                    sig = signature_name,
                )
            })
            .collect()
    }

    /// Generates geometric product verification tests as a formatted string.
    fn generate_geometric_verification_tests_raw(&self) -> String {
        // Only generate tests for products explicitly listed in the TOML
        if self.spec.products.geometric.is_empty() {
            return String::new();
        }

        let signature_name = self.generate_signature_name();
        self.spec
            .products
            .geometric
            .iter()
            .map(|entry| {
                let lhs_lower = entry.lhs.to_lowercase();
                let rhs_lower = entry.rhs.to_lowercase();
                let out_lower = entry.output.to_lowercase();

                format!(
                    r#"
    proptest! {{
        #[test]
        fn geometric_{lhs_lower}_{rhs_lower}_{out_lower}_matches_multivector(a in any::<{lhs}<f64>>(), b in any::<{rhs}<f64>>()) {{
            let mv_a: Multivector<f64, {sig}> = a.into();
            let mv_b: Multivector<f64, {sig}> = b.into();

            let specialized_result: {out}<f64> = geometric_{lhs_lower}_{rhs_lower}(&a, &b);
            let generic_result = mv_a * mv_b;

            let specialized_mv: Multivector<f64, {sig}> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Geometric product mismatch: specialized={{:?}}, generic={{:?}}",
                specialized_mv, generic_result
            );
        }}
    }}
"#,
                    lhs_lower = lhs_lower,
                    rhs_lower = rhs_lower,
                    out_lower = out_lower,
                    lhs = entry.lhs,
                    rhs = entry.rhs,
                    out = entry.output,
                    sig = signature_name,
                )
            })
            .collect()
    }

    /// Generates exterior product verification tests as a formatted string.
    fn generate_exterior_verification_tests_raw(&self) -> String {
        // Only generate tests for products explicitly listed in the TOML
        if self.spec.products.exterior.is_empty() {
            return String::new();
        }

        let signature_name = self.generate_signature_name();
        self.spec
            .products
            .exterior
            .iter()
            .map(|entry| {
                let lhs_lower = entry.lhs.to_lowercase();
                let rhs_lower = entry.rhs.to_lowercase();
                let out_lower = entry.output.to_lowercase();

                format!(
                    r#"
    proptest! {{
        #[test]
        fn exterior_{lhs_lower}_{rhs_lower}_{out_lower}_matches_multivector(a in any::<{lhs}<f64>>(), b in any::<{rhs}<f64>>()) {{
            let mv_a: Multivector<f64, {sig}> = a.into();
            let mv_b: Multivector<f64, {sig}> = b.into();

            let specialized_result: {out}<f64> = exterior_{lhs_lower}_{rhs_lower}(&a, &b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, {sig}> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Exterior product mismatch: specialized={{:?}}, generic={{:?}}",
                specialized_mv, generic_result
            );
        }}
    }}
"#,
                    lhs_lower = lhs_lower,
                    rhs_lower = rhs_lower,
                    out_lower = out_lower,
                    lhs = entry.lhs,
                    rhs = entry.rhs,
                    out = entry.output,
                    sig = signature_name,
                )
            })
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::spec::parse_spec;

    #[test]
    fn generates_add_impl() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let (tokens, _tests) = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("impl < T : Float > Add for Vector"));
    }

    #[test]
    fn generates_sub_impl() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let (tokens, _tests) = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("impl < T : Float > Sub for Vector"));
    }

    #[test]
    fn generates_neg_impl() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let (tokens, _tests) = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("impl < T : Float > Neg for Vector"));
    }

    #[test]
    fn generates_scalar_mul() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let (tokens, _tests) = generator.generate_traits_file();
        let code = tokens.to_string();

        // Check that scalar mul is generated for Vector
        assert!(code.contains("Mul"));
        assert!(code.contains("for Vector"));
        assert!(code.contains("scale"));
    }

    #[test]
    fn generates_geometric_mul() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let (tokens, _tests) = generator.generate_traits_file();
        let code = tokens.to_string();

        // Vector * Vector should produce a product type
        assert!(code.contains("geometric_vector_vector"));
    }

    #[test]
    fn generates_exterior() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let (tokens, _tests) = generator.generate_traits_file();
        let code = tokens.to_string();

        // Vector ^ Vector should produce Bivector
        assert!(code.contains("BitXor"));
        assert!(code.contains("exterior_vector_vector"));
    }

    #[test]
    fn generates_approx_impls() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let (tokens, _tests) = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("AbsDiffEq for Vector"));
        assert!(code.contains("RelativeEq for Vector"));
        assert!(code.contains("UlpsEq for Vector"));
    }

    #[test]
    fn generates_arbitrary_impls() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let (tokens, _tests) = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("impl < T : Float + Debug + 'static > Arbitrary for Vector"));
    }
}
