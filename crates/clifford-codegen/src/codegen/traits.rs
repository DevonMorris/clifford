//! Trait implementation generation.
//!
//! This module provides the `TraitsGenerator` for generating Rust trait
//! implementations including operators, approx traits, and Arbitrary.

use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::algebra::{Algebra, ProductTable};
use crate::spec::{AlgebraSpec, TypeSpec};

/// Generates trait implementations for algebra types.
///
/// The generator produces:
/// - Arithmetic operators (Add, Sub, Neg, Mul)
/// - Scalar multiplication
/// - Geometric and outer product operators
/// - Approx traits (AbsDiffEq, RelativeEq, UlpsEq)
/// - Arbitrary implementations for proptest
///
/// # Example
///
/// ```
/// use clifford_codegen::algebra::{Algebra, ProductTable};
/// use clifford_codegen::codegen::TraitsGenerator;
/// use clifford_codegen::spec::parse_spec;
///
/// let spec = parse_spec(r#"
/// [algebra]
/// name = "euclidean2"
///
/// [signature]
/// positive = ["e1", "e2"]
///
/// [types.Vector]
/// grades = [1]
/// fields = ["x", "y"]
///
/// [types.Bivector]
/// grades = [2]
/// fields = ["xy"]
/// "#).unwrap();
///
/// let algebra = Algebra::euclidean(2);
/// let table = ProductTable::new(&algebra);
/// let generator = TraitsGenerator::new(&spec, &algebra, table);
///
/// let tokens = generator.generate_traits_file();
/// let code = tokens.to_string();
///
/// assert!(code.contains("Add for Vector"));
/// ```
pub struct TraitsGenerator<'a> {
    /// The algebra specification.
    spec: &'a AlgebraSpec,
    /// The algebra for computations.
    algebra: &'a Algebra,
    /// The product table.
    #[allow(dead_code)]
    table: ProductTable,
}

impl<'a> TraitsGenerator<'a> {
    /// Creates a new traits generator.
    pub fn new(spec: &'a AlgebraSpec, algebra: &'a Algebra, table: ProductTable) -> Self {
        Self {
            spec,
            algebra,
            table,
        }
    }

    /// Generates the complete traits file.
    pub fn generate_traits_file(&self) -> TokenStream {
        let header = self.generate_header();
        let imports = self.generate_imports();
        let ops = self.generate_all_ops();
        let approx = self.generate_all_approx();
        let arbitrary = self.generate_all_arbitrary();
        let verification = self.generate_verification_tests();

        quote! {
            #header
            #imports

            // ============================================================
            // Operator Implementations
            // ============================================================
            #ops

            // ============================================================
            // Approx Trait Implementations
            // ============================================================
            #approx

            // ============================================================
            // Arbitrary Implementations (for proptest)
            // ============================================================
            #arbitrary

            // ============================================================
            // Verification Tests (compare against Multivector)
            // ============================================================
            #verification
        }
    }

    /// Generates the file header.
    fn generate_header(&self) -> TokenStream {
        let name = &self.spec.name;
        let header_doc = format!(
            r#"//! Trait implementations for {}.
//!
//! This file is auto-generated by clifford-codegen.
//! Do not edit manually."#,
            name
        );

        header_doc.parse().unwrap_or_else(|_| quote! {})
    }

    /// Generates import statements.
    fn generate_imports(&self) -> TokenStream {
        let type_names: Vec<_> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|t| format_ident!("{}", t.name))
            .collect();

        quote! {
            use crate::scalar::Float;
            use super::types::{#(#type_names),*};
            use super::products::*;

            use std::ops::{Add, Sub, Neg, Mul, BitXor};

            use approx::{AbsDiffEq, RelativeEq, UlpsEq};
        }
    }

    // ========================================================================
    // Operator Implementations
    // ========================================================================

    /// Generates all operator implementations.
    fn generate_all_ops(&self) -> TokenStream {
        let ops: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .flat_map(|ty| self.generate_ops_for_type(ty))
            .collect();

        quote! { #(#ops)* }
    }

    /// Generates operators for a single type.
    #[allow(clippy::vec_init_then_push)]
    fn generate_ops_for_type(&self, ty: &TypeSpec) -> Vec<TokenStream> {
        let mut impls = Vec::new();

        // Same-type operations
        impls.push(self.generate_add(ty));
        impls.push(self.generate_sub(ty));
        impls.push(self.generate_neg(ty));
        impls.push(self.generate_scalar_mul(ty));
        impls.push(self.generate_scalar_mul_reverse_f32(ty));
        impls.push(self.generate_scalar_mul_reverse_f64(ty));

        // Cross-type operations (geometric product) - only for explicit products
        for entry in &self.spec.products.geometric {
            // Only generate if lhs matches this type
            if entry.lhs == ty.name {
                if let Some(other) = self.find_type(&entry.rhs) {
                    if let Some(output_type) = self.find_type(&entry.output) {
                        impls.push(self.generate_geometric_mul_from_entry(
                            ty,
                            other,
                            output_type,
                            entry,
                        ));
                    }
                }
            }
        }

        // Outer product (using BitXor) - only for explicit products
        for entry in &self.spec.products.outer {
            // Only generate if lhs matches this type
            if entry.lhs == ty.name {
                if let Some(other) = self.find_type(&entry.rhs) {
                    if let Some(output_type) = self.find_type(&entry.output) {
                        impls.push(self.generate_outer_from_entry(ty, other, output_type, entry));
                    }
                }
            }
        }

        impls
    }

    /// Finds a TypeSpec by name.
    fn find_type(&self, name: &str) -> Option<&TypeSpec> {
        self.spec.types.iter().find(|t| t.name == name)
    }

    /// Generates Add implementation.
    fn generate_add(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let field_adds: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname() + rhs.#fname() }
            })
            .collect();

        quote! {
            impl<T: Float> Add for #name<T> {
                type Output = Self;

                #[inline]
                fn add(self, rhs: Self) -> Self {
                    Self::new(#(#field_adds),*)
                }
            }
        }
    }

    /// Generates Sub implementation.
    fn generate_sub(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let field_subs: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname() - rhs.#fname() }
            })
            .collect();

        quote! {
            impl<T: Float> Sub for #name<T> {
                type Output = Self;

                #[inline]
                fn sub(self, rhs: Self) -> Self {
                    Self::new(#(#field_subs),*)
                }
            }
        }
    }

    /// Generates Neg implementation.
    fn generate_neg(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let field_negs: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { -self.#fname() }
            })
            .collect();

        quote! {
            impl<T: Float> Neg for #name<T> {
                type Output = Self;

                #[inline]
                fn neg(self) -> Self {
                    Self::new(#(#field_negs),*)
                }
            }
        }
    }

    /// Generates scalar multiplication (Type * T).
    fn generate_scalar_mul(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        quote! {
            impl<T: Float> Mul<T> for #name<T> {
                type Output = Self;

                #[inline]
                fn mul(self, scalar: T) -> Self {
                    self.scale(scalar)
                }
            }
        }
    }

    /// Generates reverse scalar multiplication for f32 (f32 * Type).
    fn generate_scalar_mul_reverse_f32(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        quote! {
            impl Mul<#name<f32>> for f32 {
                type Output = #name<f32>;

                #[inline]
                fn mul(self, v: #name<f32>) -> #name<f32> {
                    v.scale(self)
                }
            }
        }
    }

    /// Generates reverse scalar multiplication for f64 (f64 * Type).
    fn generate_scalar_mul_reverse_f64(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        quote! {
            impl Mul<#name<f64>> for f64 {
                type Output = #name<f64>;

                #[inline]
                fn mul(self, v: #name<f64>) -> #name<f64> {
                    v.scale(self)
                }
            }
        }
    }

    /// Generates geometric product (Type * Other -> Output) from a product entry.
    fn generate_geometric_mul_from_entry(
        &self,
        a: &TypeSpec,
        b: &TypeSpec,
        output: &TypeSpec,
        entry: &crate::spec::ProductEntry,
    ) -> TokenStream {
        let a_name = format_ident!("{}", a.name);
        let b_name = format_ident!("{}", b.name);
        let out_name = format_ident!("{}", output.name);
        let fn_name = format_ident!(
            "geometric_{}_{}",
            entry.lhs.to_lowercase(),
            entry.rhs.to_lowercase()
        );

        quote! {
            impl<T: Float> Mul<#b_name<T>> for #a_name<T> {
                type Output = #out_name<T>;

                #[inline]
                fn mul(self, rhs: #b_name<T>) -> #out_name<T> {
                    #fn_name(&self, &rhs)
                }
            }
        }
    }

    /// Generates outer product (Type ^ Other -> Output) from a product entry.
    fn generate_outer_from_entry(
        &self,
        a: &TypeSpec,
        b: &TypeSpec,
        output: &TypeSpec,
        entry: &crate::spec::ProductEntry,
    ) -> TokenStream {
        let a_name = format_ident!("{}", a.name);
        let b_name = format_ident!("{}", b.name);
        let out_name = format_ident!("{}", output.name);
        let fn_name = format_ident!(
            "outer_{}_{}",
            entry.lhs.to_lowercase(),
            entry.rhs.to_lowercase()
        );

        quote! {
            impl<T: Float> BitXor<#b_name<T>> for #a_name<T> {
                type Output = #out_name<T>;

                #[inline]
                fn bitxor(self, rhs: #b_name<T>) -> #out_name<T> {
                    #fn_name(&self, &rhs)
                }
            }
        }
    }

    // ========================================================================
    // Approx Trait Implementations
    // ========================================================================

    /// Generates all approx trait implementations.
    fn generate_all_approx(&self) -> TokenStream {
        let impls: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|ty| self.generate_approx_impls(ty))
            .collect();

        quote! { #(#impls)* }
    }

    /// Generates approx trait implementations for a type.
    fn generate_approx_impls(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        let abs_diff_checks: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname().abs_diff_eq(&other.#fname(), epsilon) }
            })
            .collect();

        let relative_checks: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname().relative_eq(&other.#fname(), epsilon, max_relative) }
            })
            .collect();

        let ulps_checks: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname().ulps_eq(&other.#fname(), epsilon, max_ulps) }
            })
            .collect();

        quote! {
            impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for #name<T> {
                type Epsilon = T;

                fn default_epsilon() -> Self::Epsilon {
                    T::default_epsilon()
                }

                fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
                    #(#abs_diff_checks)&&*
                }
            }

            impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for #name<T> {
                fn default_max_relative() -> Self::Epsilon {
                    T::default_max_relative()
                }

                fn relative_eq(
                    &self,
                    other: &Self,
                    epsilon: Self::Epsilon,
                    max_relative: Self::Epsilon,
                ) -> bool {
                    #(#relative_checks)&&*
                }
            }

            impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for #name<T> {
                fn default_max_ulps() -> u32 {
                    T::default_max_ulps()
                }

                fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
                    #(#ulps_checks)&&*
                }
            }
        }
    }

    // ========================================================================
    // Arbitrary Implementations
    // ========================================================================

    /// Generates all Arbitrary implementations.
    fn generate_all_arbitrary(&self) -> TokenStream {
        let impls: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|ty| self.generate_arbitrary_impl(ty))
            .collect();

        quote! {
            #[cfg(any(test, feature = "proptest-support"))]
            mod arbitrary_impls {
                use super::*;
                use proptest::prelude::*;
                use proptest::strategy::BoxedStrategy;
                use std::fmt::Debug;

                #(#impls)*
            }
        }
    }

    /// Generates Arbitrary implementation for a type.
    fn generate_arbitrary_impl(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let num_fields = ty.fields.len();

        // Generate tuple of ranges
        let range_tuple: Vec<TokenStream> = (0..num_fields)
            .map(|_| quote! { -100.0f64..100.0 })
            .collect();

        let prop_map_args: Vec<TokenStream> = (0..num_fields)
            .map(|i| {
                let var = format_ident!("x{}", i);
                quote! { #var }
            })
            .collect();

        let field_inits: Vec<TokenStream> = (0..num_fields)
            .map(|i| {
                let var = format_ident!("x{}", i);
                quote! { T::from_f64(#var) }
            })
            .collect();

        quote! {
            impl<T: Float + Debug + 'static> Arbitrary for #name<T> {
                type Parameters = ();
                type Strategy = BoxedStrategy<Self>;

                fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
                    (#(#range_tuple),*)
                        .prop_map(|(#(#prop_map_args),*)| {
                            #name::new(#(#field_inits),*)
                        })
                        .boxed()
                }
            }
        }
    }

    // ========================================================================
    // Verification Tests
    // ========================================================================

    /// Generates verification tests that compare specialized operations against Multivector.
    fn generate_verification_tests(&self) -> TokenStream {
        let signature_name = self.generate_signature_name();
        let add_sub_tests = self.generate_add_sub_verification_tests();
        let geometric_tests = self.generate_geometric_verification_tests();
        let outer_tests = self.generate_outer_verification_tests();

        quote! {
            #[cfg(test)]
            mod verification_tests {
                use super::*;
                use super::arbitrary_impls::*;
                use crate::algebra::Multivector;
                use crate::signature::#signature_name;
                use approx::abs_diff_eq;
                use proptest::prelude::*;

                /// Epsilon for floating-point comparisons in verification tests.
                const EPSILON: f64 = 1e-10;

                #add_sub_tests
                #geometric_tests
                #outer_tests
            }
        }
    }

    /// Generates the signature type name for this algebra.
    fn generate_signature_name(&self) -> proc_macro2::Ident {
        // Convert algebra name to PascalCase signature name
        let name = &self.spec.name;
        let sig_name = if name.starts_with("euclidean") {
            match self.algebra.dim() {
                2 => "Euclidean2",
                3 => "Euclidean3",
                _ => "Euclidean3", // fallback
            }
        } else if name.starts_with("pga") || name.starts_with("projective") {
            match self.algebra.dim() {
                3 => "Projective2",
                4 => "Projective3",
                _ => "Projective3",
            }
        } else if name.starts_with("cga") || name.starts_with("conformal") {
            match self.algebra.dim() {
                4 => "Conformal2",
                5 => "Conformal3",
                _ => "Conformal3",
            }
        } else {
            // Default: generate a custom signature name
            "CustomSignature"
        };
        format_ident!("{}", sig_name)
    }

    /// Generates add/sub verification tests for each type.
    fn generate_add_sub_verification_tests(&self) -> TokenStream {
        let signature_name = self.generate_signature_name();
        let tests: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|ty| {
                let name = format_ident!("{}", ty.name);
                let name_lower = format_ident!("{}", ty.name.to_lowercase());
                let add_test_name = format_ident!("{}_add_matches_multivector", name_lower);
                let sub_test_name = format_ident!("{}_sub_matches_multivector", name_lower);
                let neg_test_name = format_ident!("{}_neg_matches_multivector", name_lower);

                quote! {
                    proptest! {
                        #[test]
                        fn #add_test_name(a in any::<#name<f64>>(), b in any::<#name<f64>>()) {
                            let mv_a: Multivector<f64, #signature_name> = a.into();
                            let mv_b: Multivector<f64, #signature_name> = b.into();

                            let specialized_result = a + b;
                            let generic_result = mv_a + mv_b;

                            let specialized_mv: Multivector<f64, #signature_name> = specialized_result.into();
                            prop_assert!(
                                abs_diff_eq!(specialized_mv, generic_result, epsilon = EPSILON),
                                "Add mismatch: specialized={:?}, generic={:?}",
                                specialized_mv, generic_result
                            );
                        }

                        #[test]
                        fn #sub_test_name(a in any::<#name<f64>>(), b in any::<#name<f64>>()) {
                            let mv_a: Multivector<f64, #signature_name> = a.into();
                            let mv_b: Multivector<f64, #signature_name> = b.into();

                            let specialized_result = a - b;
                            let generic_result = mv_a - mv_b;

                            let specialized_mv: Multivector<f64, #signature_name> = specialized_result.into();
                            prop_assert!(
                                abs_diff_eq!(specialized_mv, generic_result, epsilon = EPSILON),
                                "Sub mismatch: specialized={:?}, generic={:?}",
                                specialized_mv, generic_result
                            );
                        }

                        #[test]
                        fn #neg_test_name(a in any::<#name<f64>>()) {
                            let mv_a: Multivector<f64, #signature_name> = a.into();

                            let specialized_result = -a;
                            let generic_result = -mv_a;

                            let specialized_mv: Multivector<f64, #signature_name> = specialized_result.into();
                            prop_assert!(
                                abs_diff_eq!(specialized_mv, generic_result, epsilon = EPSILON),
                                "Neg mismatch: specialized={:?}, generic={:?}",
                                specialized_mv, generic_result
                            );
                        }
                    }
                }
            })
            .collect();

        quote! { #(#tests)* }
    }

    /// Generates geometric product verification tests.
    fn generate_geometric_verification_tests(&self) -> TokenStream {
        // Only generate tests for products explicitly listed in the TOML
        if self.spec.products.geometric.is_empty() {
            return quote! {};
        }

        let signature_name = self.generate_signature_name();
        let tests: Vec<TokenStream> = self
            .spec
            .products
            .geometric
            .iter()
            .map(|entry| {
                let name_a = format_ident!("{}", entry.lhs);
                let name_b = format_ident!("{}", entry.rhs);
                let name_out = format_ident!("{}", entry.output);
                let test_name = format_ident!(
                    "geometric_{}_{}_{}_matches_multivector",
                    entry.lhs.to_lowercase(),
                    entry.rhs.to_lowercase(),
                    entry.output.to_lowercase()
                );
                let fn_name = format_ident!(
                    "geometric_{}_{}",
                    entry.lhs.to_lowercase(),
                    entry.rhs.to_lowercase()
                );

                quote! {
                    proptest! {
                        #[test]
                        fn #test_name(a in any::<#name_a<f64>>(), b in any::<#name_b<f64>>()) {
                            let mv_a: Multivector<f64, #signature_name> = a.into();
                            let mv_b: Multivector<f64, #signature_name> = b.into();

                            let specialized_result: #name_out<f64> = #fn_name(&a, &b);
                            let generic_result = mv_a * mv_b;

                            let specialized_mv: Multivector<f64, #signature_name> = specialized_result.into();
                            prop_assert!(
                                abs_diff_eq!(specialized_mv, generic_result, epsilon = EPSILON),
                                "Geometric product mismatch: specialized={:?}, generic={:?}",
                                specialized_mv, generic_result
                            );
                        }
                    }
                }
            })
            .collect();

        quote! { #(#tests)* }
    }

    /// Generates outer product verification tests.
    fn generate_outer_verification_tests(&self) -> TokenStream {
        // Only generate tests for products explicitly listed in the TOML
        if self.spec.products.outer.is_empty() {
            return quote! {};
        }

        let signature_name = self.generate_signature_name();
        let tests: Vec<TokenStream> = self
            .spec
            .products
            .outer
            .iter()
            .map(|entry| {
                let name_a = format_ident!("{}", entry.lhs);
                let name_b = format_ident!("{}", entry.rhs);
                let name_out = format_ident!("{}", entry.output);
                let test_name = format_ident!(
                    "outer_{}_{}_{}_matches_multivector",
                    entry.lhs.to_lowercase(),
                    entry.rhs.to_lowercase(),
                    entry.output.to_lowercase()
                );
                let fn_name = format_ident!(
                    "outer_{}_{}",
                    entry.lhs.to_lowercase(),
                    entry.rhs.to_lowercase()
                );

                quote! {
                    proptest! {
                        #[test]
                        fn #test_name(a in any::<#name_a<f64>>(), b in any::<#name_b<f64>>()) {
                            let mv_a: Multivector<f64, #signature_name> = a.into();
                            let mv_b: Multivector<f64, #signature_name> = b.into();

                            let specialized_result: #name_out<f64> = #fn_name(&a, &b);
                            let generic_result = mv_a.outer(&mv_b);

                            let specialized_mv: Multivector<f64, #signature_name> = specialized_result.into();
                            prop_assert!(
                                abs_diff_eq!(specialized_mv, generic_result, epsilon = EPSILON),
                                "Outer product mismatch: specialized={:?}, generic={:?}",
                                specialized_mv, generic_result
                            );
                        }
                    }
                }
            })
            .collect();

        quote! { #(#tests)* }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::spec::parse_spec;

    #[test]
    fn generates_add_impl() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let tokens = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("impl < T : Float > Add for Vector"));
    }

    #[test]
    fn generates_sub_impl() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let tokens = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("impl < T : Float > Sub for Vector"));
    }

    #[test]
    fn generates_neg_impl() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let tokens = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("impl < T : Float > Neg for Vector"));
    }

    #[test]
    fn generates_scalar_mul() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let tokens = generator.generate_traits_file();
        let code = tokens.to_string();

        // Check that scalar mul is generated for Vector
        assert!(code.contains("Mul"));
        assert!(code.contains("for Vector"));
        assert!(code.contains("scale"));
    }

    #[test]
    fn generates_geometric_mul() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let tokens = generator.generate_traits_file();
        let code = tokens.to_string();

        // Vector * Vector should produce a product type
        assert!(code.contains("geometric_vector_vector"));
    }

    #[test]
    fn generates_outer() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let tokens = generator.generate_traits_file();
        let code = tokens.to_string();

        // Vector ^ Vector should produce Bivector
        assert!(code.contains("BitXor"));
        assert!(code.contains("outer_vector_vector"));
    }

    #[test]
    fn generates_approx_impls() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let tokens = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("AbsDiffEq for Vector"));
        assert!(code.contains("RelativeEq for Vector"));
        assert!(code.contains("UlpsEq for Vector"));
    }

    #[test]
    fn generates_arbitrary_impls() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let tokens = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("impl < T : Float + Debug + 'static > Arbitrary for Vector"));
    }
}
