//! Trait implementation generation.
//!
//! This module provides the `TraitsGenerator` for generating Rust trait
//! implementations including operators, approx traits, and Arbitrary.

use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::algebra::{Algebra, Blade, ProductTable};
use crate::spec::{AlgebraSpec, TypeSpec};
use crate::symbolic::{
    AtomToRust, ConstraintDeriver, ConstraintSimplifier, ConstraintSolver, ExpressionSimplifier,
    ProductKind as SymbolicProductKind, SolutionType, SymbolicProduct,
};

/// Generates trait implementations for algebra types.
///
/// The generator produces:
/// - Arithmetic operators (Add, Sub, Neg, Mul)
/// - Scalar multiplication
/// - Geometric and outer product operators
/// - Approx traits (AbsDiffEq, RelativeEq, UlpsEq)
/// - Arbitrary implementations for proptest
///
/// # Example
///
/// ```
/// use clifford_codegen::algebra::{Algebra, ProductTable};
/// use clifford_codegen::codegen::TraitsGenerator;
/// use clifford_codegen::spec::parse_spec;
///
/// let spec = parse_spec(r#"
/// [algebra]
/// name = "euclidean2"
///
/// [signature]
/// positive = ["e1", "e2"]
///
/// [types.Vector]
/// grades = [1]
/// fields = ["x", "y"]
///
/// [types.Bivector]
/// grades = [2]
/// fields = ["xy"]
/// "#).unwrap();
///
/// let algebra = Algebra::euclidean(2);
/// let table = ProductTable::new(&algebra);
/// let generator = TraitsGenerator::new(&spec, &algebra, table);
///
/// let (tokens, _tests) = generator.generate_traits_file();
/// let code = tokens.to_string();
///
/// assert!(code.contains("Add for Vector"));
/// ```
pub struct TraitsGenerator<'a> {
    /// The algebra specification.
    spec: &'a AlgebraSpec,
    /// The algebra for computations.
    algebra: &'a Algebra,
    /// The product table for term computation.
    table: ProductTable,
}

impl<'a> TraitsGenerator<'a> {
    /// Creates a new traits generator.
    pub fn new(spec: &'a AlgebraSpec, algebra: &'a Algebra, table: ProductTable) -> Self {
        Self {
            spec,
            algebra,
            table,
        }
    }

    /// Generates the complete traits file.
    ///
    /// Returns a tuple of (TokenStream, String) where:
    /// - The TokenStream contains the main code (operators, traits, arbitrary)
    /// - The String contains pre-formatted verification tests that should be
    ///   appended after formatting the main code (rustfmt can't format inside
    ///   proptest! macros)
    pub fn generate_traits_file(&self) -> (TokenStream, String) {
        let header = self.generate_header();
        let imports = self.generate_imports();
        let ops = self.generate_all_ops();
        let product_traits = self.generate_all_product_traits();
        let normed = self.generate_all_normed();
        let approx = self.generate_all_approx();
        let arbitrary = self.generate_all_arbitrary();
        let verification_tests = self.generate_verification_tests_raw();

        let main_tokens = quote! {
            #header
            #imports

            // ============================================================
            // Operator Implementations
            // ============================================================
            #ops

            // ============================================================
            // Product Trait Implementations (clifford::ops)
            // ============================================================
            #product_traits

            // ============================================================
            // Normed Trait Implementations
            // ============================================================
            #normed

            // ============================================================
            // Approx Trait Implementations
            // ============================================================
            #approx

            // ============================================================
            // Arbitrary Implementations (for proptest)
            // ============================================================
            #arbitrary
        };

        (main_tokens, verification_tests)
    }

    /// Generates the file header.
    fn generate_header(&self) -> TokenStream {
        let name = &self.spec.name;
        let header_doc = format!(
            r#"//! Trait implementations for {}.
//!
//! This file is auto-generated by clifford-codegen.
//! Do not edit manually."#,
            name
        );

        header_doc.parse().unwrap_or_else(|_| quote! {})
    }

    /// Generates import statements.
    fn generate_imports(&self) -> TokenStream {
        let type_names: Vec<_> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|t| format_ident!("{}", t.name))
            .collect();

        quote! {
            use crate::scalar::Float;
            use crate::ops::{
                Wedge, Antiwedge, LeftContract, RightContract,
                Sandwich, Antisandwich, ScalarProduct, BulkContract, WeightContract,
                BulkExpand, WeightExpand, Dot, Antidot,
                Reverse, Antireverse, RightComplement, Versor,
            };
            use super::types::{#(#type_names),*};

            use std::ops::{Add, Sub, Neg, Mul};

            use approx::{AbsDiffEq, RelativeEq, UlpsEq};
        }
    }

    // ========================================================================
    // Operator Implementations
    // ========================================================================

    /// Generates all operator implementations.
    fn generate_all_ops(&self) -> TokenStream {
        let ops: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .flat_map(|ty| self.generate_ops_for_type(ty))
            .collect();

        quote! { #(#ops)* }
    }

    /// Generates operators for a single type.
    #[allow(clippy::vec_init_then_push)]
    fn generate_ops_for_type(&self, ty: &TypeSpec) -> Vec<TokenStream> {
        let mut impls = Vec::new();

        // Same-type operations
        impls.push(self.generate_add(ty));
        impls.push(self.generate_sub(ty));
        impls.push(self.generate_neg(ty));
        impls.push(self.generate_scalar_mul(ty));
        impls.push(self.generate_scalar_mul_reverse_f32(ty));
        impls.push(self.generate_scalar_mul_reverse_f64(ty));

        // Cross-type operations (geometric product) - only for explicit products
        for entry in &self.spec.products.geometric {
            // Only generate if lhs matches this type
            if entry.lhs == ty.name {
                if let Some(other) = self.find_type(&entry.rhs) {
                    if let Some(output_type) = self.find_type(&entry.output) {
                        impls.push(self.generate_geometric_mul_from_entry(
                            ty,
                            other,
                            output_type,
                            entry,
                        ));
                    }
                }
            }
        }

        impls
    }

    /// Finds a TypeSpec by name.
    fn find_type(&self, name: &str) -> Option<&TypeSpec> {
        self.spec.types.iter().find(|t| t.name == name)
    }

    /// Generates a constructor call.
    fn generate_constructor_call(_ty: &TypeSpec, field_exprs: &[TokenStream]) -> TokenStream {
        quote! { Self::new_unchecked(#(#field_exprs),*) }
    }

    /// Generates Add implementation.
    fn generate_add(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let field_adds: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname() + rhs.#fname() }
            })
            .collect();

        let constructor_call = Self::generate_constructor_call(ty, &field_adds);

        quote! {
            impl<T: Float> Add for #name<T> {
                type Output = Self;

                #[inline]
                fn add(self, rhs: Self) -> Self {
                    #constructor_call
                }
            }
        }
    }

    /// Generates Sub implementation.
    fn generate_sub(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let field_subs: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname() - rhs.#fname() }
            })
            .collect();

        let constructor_call = Self::generate_constructor_call(ty, &field_subs);

        quote! {
            impl<T: Float> Sub for #name<T> {
                type Output = Self;

                #[inline]
                fn sub(self, rhs: Self) -> Self {
                    #constructor_call
                }
            }
        }
    }

    /// Generates Neg implementation.
    fn generate_neg(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let field_negs: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { -self.#fname() }
            })
            .collect();

        let constructor_call = Self::generate_constructor_call(ty, &field_negs);

        quote! {
            impl<T: Float> Neg for #name<T> {
                type Output = Self;

                #[inline]
                fn neg(self) -> Self {
                    #constructor_call
                }
            }
        }
    }

    /// Generates scalar multiplication (Type * T).
    fn generate_scalar_mul(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        quote! {
            impl<T: Float> Mul<T> for #name<T> {
                type Output = Self;

                #[inline]
                fn mul(self, scalar: T) -> Self {
                    self.scale(scalar)
                }
            }
        }
    }

    /// Generates reverse scalar multiplication for f32 (f32 * Type).
    fn generate_scalar_mul_reverse_f32(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        quote! {
            impl Mul<#name<f32>> for f32 {
                type Output = #name<f32>;

                #[inline]
                fn mul(self, v: #name<f32>) -> #name<f32> {
                    v.scale(self)
                }
            }
        }
    }

    /// Generates reverse scalar multiplication for f64 (f64 * Type).
    fn generate_scalar_mul_reverse_f64(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        quote! {
            impl Mul<#name<f64>> for f64 {
                type Output = #name<f64>;

                #[inline]
                fn mul(self, v: #name<f64>) -> #name<f64> {
                    v.scale(self)
                }
            }
        }
    }

    /// Generates geometric product (Type * Other -> Output) from a product entry.
    ///
    /// The formula is computed inline using symbolic simplification, rather than
    /// calling a separate function. This avoids generating geometric_* functions
    /// which are not type-safe in general.
    fn generate_geometric_mul_from_entry(
        &self,
        a: &TypeSpec,
        b: &TypeSpec,
        output: &TypeSpec,
        _entry: &crate::spec::ProductEntry,
    ) -> TokenStream {
        let a_name = format_ident!("{}", a.name);
        let b_name = format_ident!("{}", b.name);
        let out_name = format_ident!("{}", output.name);

        // Compute the formula using symbolic machinery
        let field_exprs =
            self.compute_product_expressions(a, b, output, SymbolicProductKind::Geometric);

        // Generate constructor call with the computed expressions
        let constructor_call = if output.versor.is_some() {
            quote! { #out_name::new_unchecked(#(#field_exprs),*) }
        } else {
            quote! { #out_name::new_unchecked(#(#field_exprs),*) }
        };

        quote! {
            impl<T: Float> Mul<#b_name<T>> for #a_name<T> {
                type Output = #out_name<T>;

                #[inline]
                fn mul(self, rhs: #b_name<T>) -> #out_name<T> {
                    #constructor_call
                }
            }
        }
    }

    /// Computes product expressions using symbolic simplification.
    ///
    /// This is used by Mul operators to inline the formula instead of calling
    /// a separate function.
    fn compute_product_expressions(
        &self,
        type_a: &TypeSpec,
        type_b: &TypeSpec,
        output_type: &TypeSpec,
        kind: SymbolicProductKind,
    ) -> Vec<TokenStream> {
        let symbolic_product = SymbolicProduct::new(self.algebra);
        let expr_simplifier = ExpressionSimplifier::new();

        // Create constraint simplifier for input type constraints
        let constraint_simplifier = ConstraintSimplifier::new(&[type_a, type_b], &["self", "rhs"]);

        // Create symbolic field variables
        let a_symbols = symbolic_product.create_field_symbols(type_a, "self");
        let b_symbols = symbolic_product.create_field_symbols(type_b, "rhs");

        // Compute symbolic product
        let symbolic_fields =
            symbolic_product.compute(type_a, type_b, output_type, kind, &a_symbols, &b_symbols);

        // Create converter for Rust code generation
        let converter = AtomToRust::new(&[type_a, type_b], &["self", "rhs"]);

        // Apply constraint substitution, simplify, and convert each field expression
        symbolic_fields
            .iter()
            .map(|field| {
                // First apply constraint substitutions (e.g., s*s + xy*xy + ... = 1)
                let with_constraints = constraint_simplifier.apply(&field.expression);
                // Then simplify (expand and collect like terms)
                let simplified = expr_simplifier.simplify(&with_constraints);
                converter.convert(&simplified)
            })
            .collect()
    }

    /// Computes sandwich product expressions: v × x × rev(v).
    ///
    /// Returns TokenStream expressions for each field of the output type.
    fn compute_sandwich_expressions(
        &self,
        versor: &TypeSpec,
        operand: &TypeSpec,
    ) -> Vec<TokenStream> {
        operand
            .fields
            .iter()
            .map(|field| self.compute_sandwich_field(versor, operand, field.blade_index, false))
            .collect()
    }

    /// Computes antisandwich product expressions: v ⊛ x ⊛ antirev(v).
    ///
    /// Returns TokenStream expressions for each field of the output type.
    fn compute_antisandwich_expressions(
        &self,
        versor: &TypeSpec,
        operand: &TypeSpec,
    ) -> Vec<TokenStream> {
        operand
            .fields
            .iter()
            .map(|field| self.compute_sandwich_field(versor, operand, field.blade_index, true))
            .collect()
    }

    /// Computes a single sandwich field expression.
    ///
    /// If `use_antiproduct` is true, uses the antiproduct and antireverse (for antisandwich).
    fn compute_sandwich_field(
        &self,
        versor: &TypeSpec,
        operand: &TypeSpec,
        result_blade: usize,
        use_antiproduct: bool,
    ) -> TokenStream {
        let dim = self.algebra.dim();

        // Collect terms: for each combination v_i × x_j × rev(v_k) or v_i ⊛ x_j ⊛ antirev(v_k)
        let mut term_map: std::collections::HashMap<(String, String, String), i8> =
            std::collections::HashMap::new();

        for field_v1 in &versor.fields {
            for field_x in &operand.fields {
                for field_v2 in &versor.fields {
                    let v1_blade = field_v1.blade_index;
                    let x_blade = field_x.blade_index;
                    let v2_blade = field_v2.blade_index;

                    // Compute v_i × x_j (or v_i ⊛ x_j)
                    let (sign_vx, vx) = if use_antiproduct {
                        self.table.antiproduct(v1_blade, x_blade)
                    } else {
                        self.table.geometric(v1_blade, x_blade)
                    };
                    if sign_vx == 0 {
                        continue;
                    }

                    // Compute the reverse/antireverse sign
                    let v2_grade = Blade::from_index(v2_blade).grade();
                    let rev_sign: i8 = if use_antiproduct {
                        // Antireverse sign: (-1)^((n-k)(n-k-1)/2)
                        let antigrade = dim - v2_grade;
                        if (antigrade * antigrade.saturating_sub(1) / 2).is_multiple_of(2) {
                            1
                        } else {
                            -1
                        }
                    } else {
                        // Reverse sign: (-1)^(k(k-1)/2)
                        if (v2_grade * v2_grade.saturating_sub(1) / 2).is_multiple_of(2) {
                            1
                        } else {
                            -1
                        }
                    };

                    // Compute (v_i × x_j) × rev(v_k) (or (v_i ⊛ x_j) ⊛ antirev(v_k))
                    let (sign_vxr, result) = if use_antiproduct {
                        self.table.antiproduct(vx, v2_blade)
                    } else {
                        self.table.geometric(vx, v2_blade)
                    };
                    if sign_vxr == 0 {
                        continue;
                    }

                    if result == result_blade {
                        let final_sign = sign_vx * sign_vxr * rev_sign;
                        let key = (
                            field_v1.name.clone(),
                            field_x.name.clone(),
                            field_v2.name.clone(),
                        );
                        *term_map.entry(key).or_insert(0) += final_sign;
                    }
                }
            }
        }

        // Convert to TokenStream
        if term_map.is_empty() {
            return quote! { T::zero() };
        }

        // Filter out zero coefficients and collect non-zero terms
        let terms: Vec<_> = term_map
            .into_iter()
            .filter(|(_, coeff)| *coeff != 0)
            .collect();

        if terms.is_empty() {
            return quote! { T::zero() };
        }

        let mut expr_parts: Vec<TokenStream> = Vec::new();
        for (i, ((v1, x, v2), coeff)) in terms.iter().enumerate() {
            let v1_ident = format_ident!("{}", v1);
            let x_ident = format_ident!("{}", x);
            let v2_ident = format_ident!("{}", v2);

            let abs_coeff = coeff.abs();
            let is_negative = *coeff < 0;

            // Build the base product expression
            let base_expr = quote! { self.#v1_ident() * operand.#x_ident() * self.#v2_ident() };

            // Apply coefficient if not 1
            let coeff_expr = match abs_coeff {
                1 => base_expr,
                2 => quote! { T::TWO * #base_expr },
                n => {
                    quote! { T::from_i8(#n) * #base_expr }
                }
            };

            // Apply sign and position-based formatting
            let term_expr = match (i, is_negative) {
                (0, false) => coeff_expr,
                (0, true) => quote! { -(#coeff_expr) },
                (_, false) => quote! { + #coeff_expr },
                (_, true) => quote! { - #coeff_expr },
            };

            expr_parts.push(term_expr);
        }

        quote! { #(#expr_parts)* }
    }

    /// Computes scalar product expression (grade-0 projection of geometric product).
    ///
    /// Returns TokenStream expression for the scalar result.
    fn compute_scalar_product_expression(&self, a: &TypeSpec, b: &TypeSpec) -> TokenStream {
        let mut terms: Vec<TokenStream> = Vec::new();

        for field_a in &a.fields {
            for field_b in &b.fields {
                let (sign, result) = self
                    .table
                    .geometric(field_a.blade_index, field_b.blade_index);

                // Only include if result is grade 0 (scalar blade index = 0)
                let result_grade = Blade::from_index(result).grade();
                if result_grade != 0 || sign == 0 {
                    continue;
                }

                let a_ident = format_ident!("{}", field_a.name);
                let b_ident = format_ident!("{}", field_b.name);

                let term_expr = if terms.is_empty() {
                    if sign > 0 {
                        quote! { self.#a_ident() * rhs.#b_ident() }
                    } else {
                        quote! { -(self.#a_ident() * rhs.#b_ident()) }
                    }
                } else if sign > 0 {
                    quote! { + self.#a_ident() * rhs.#b_ident() }
                } else {
                    quote! { - self.#a_ident() * rhs.#b_ident() }
                };
                terms.push(term_expr);
            }
        }

        if terms.is_empty() {
            quote! { T::zero() }
        } else {
            quote! { #(#terms)* }
        }
    }

    /// Computes dot product expression (same-grade metric inner product).
    ///
    /// Returns TokenStream expression for the scalar result.
    fn compute_dot_expression(&self, a: &TypeSpec, b: &TypeSpec) -> TokenStream {
        let mut terms: Vec<TokenStream> = Vec::new();

        for field_a in &a.fields {
            for field_b in &b.fields {
                let (sign, _result) = self.table.dot(field_a.blade_index, field_b.blade_index);

                // Only include non-zero results
                if sign == 0 {
                    continue;
                }

                let a_ident = format_ident!("{}", field_a.name);
                let b_ident = format_ident!("{}", field_b.name);

                let term_expr = if terms.is_empty() {
                    if sign > 0 {
                        quote! { self.#a_ident() * rhs.#b_ident() }
                    } else {
                        quote! { -(self.#a_ident() * rhs.#b_ident()) }
                    }
                } else if sign > 0 {
                    quote! { + self.#a_ident() * rhs.#b_ident() }
                } else {
                    quote! { - self.#a_ident() * rhs.#b_ident() }
                };
                terms.push(term_expr);
            }
        }

        if terms.is_empty() {
            quote! { T::zero() }
        } else {
            quote! { #(#terms)* }
        }
    }

    /// Computes antidot product expression (same-antigrade metric anti-inner product).
    ///
    /// Returns TokenStream expression for the scalar result.
    fn compute_antidot_expression(&self, a: &TypeSpec, b: &TypeSpec) -> TokenStream {
        let mut terms: Vec<TokenStream> = Vec::new();

        for field_a in &a.fields {
            for field_b in &b.fields {
                let (sign, _result) = self.table.antidot(field_a.blade_index, field_b.blade_index);

                // Only include non-zero results
                if sign == 0 {
                    continue;
                }

                let a_ident = format_ident!("{}", field_a.name);
                let b_ident = format_ident!("{}", field_b.name);

                let term_expr = if terms.is_empty() {
                    if sign > 0 {
                        quote! { self.#a_ident() * rhs.#b_ident() }
                    } else {
                        quote! { -(self.#a_ident() * rhs.#b_ident()) }
                    }
                } else if sign > 0 {
                    quote! { + self.#a_ident() * rhs.#b_ident() }
                } else {
                    quote! { - self.#a_ident() * rhs.#b_ident() }
                };
                terms.push(term_expr);
            }
        }

        if terms.is_empty() {
            quote! { T::zero() }
        } else {
            quote! { #(#terms)* }
        }
    }

    // ========================================================================
    // Product Trait Implementations (clifford::ops)
    // ========================================================================

    /// Checks if a type represents a single-grade blade (not a versor/multivector).
    ///
    /// Single-grade types have exactly one grade and are not marked as versors.
    /// Examples: Scalar (grade 0), Vector (grade 1), Bivector (grade 2), etc.
    /// Counter-examples: Rotor (grades 0,2), Motor (grades 0,2,0123), Flector (grades 1,3,...)
    fn is_single_grade_blade(&self, ty: &TypeSpec) -> bool {
        ty.grades.len() == 1 && ty.versor.is_none()
    }

    /// Generates all product trait implementations.
    fn generate_all_product_traits(&self) -> TokenStream {
        let mut impls = Vec::new();

        // Note: GeometricProduct trait has been removed (PRD-24)
        // The geometric product cannot be type-safe for single-grade elements.
        // Use Dot for same-grade scalar products, or Mul operator for versors.

        // Product traits are only implemented for single-grade blade types.
        // Versors (Motor, Flector, Rotor) use Sandwich/Antisandwich instead.

        // Wedge trait - single-grade types only
        for entry in &self.spec.products.wedge {
            if let (Some(a), Some(b), Some(out)) = (
                self.find_type(&entry.lhs),
                self.find_type(&entry.rhs),
                self.find_type(&entry.output),
            ) {
                if self.is_single_grade_blade(a) && self.is_single_grade_blade(b) {
                    impls.push(self.generate_wedge_trait(a, b, out, entry));
                }
            }
        }

        // Antiwedge trait - single-grade types only
        for entry in &self.spec.products.antiwedge {
            if let (Some(a), Some(b), Some(out)) = (
                self.find_type(&entry.lhs),
                self.find_type(&entry.rhs),
                self.find_type(&entry.output),
            ) {
                if self.is_single_grade_blade(a) && self.is_single_grade_blade(b) {
                    impls.push(self.generate_antiwedge_trait(a, b, out, entry));
                }
            }
        }

        // LeftContract trait - single-grade types only
        for entry in &self.spec.products.left_contraction {
            if let (Some(a), Some(b), Some(out)) = (
                self.find_type(&entry.lhs),
                self.find_type(&entry.rhs),
                self.find_type(&entry.output),
            ) {
                if self.is_single_grade_blade(a) && self.is_single_grade_blade(b) {
                    impls.push(self.generate_left_contract_trait(a, b, out, entry));
                }
            }
        }

        // RightContract trait - single-grade types only
        for entry in &self.spec.products.right_contraction {
            if let (Some(a), Some(b), Some(out)) = (
                self.find_type(&entry.lhs),
                self.find_type(&entry.rhs),
                self.find_type(&entry.output),
            ) {
                if self.is_single_grade_blade(a) && self.is_single_grade_blade(b) {
                    impls.push(self.generate_right_contract_trait(a, b, out, entry));
                }
            }
        }

        // Sandwich trait - generated from versor types
        for versor_type in &self.spec.types {
            if versor_type.alias_of.is_some() {
                continue;
            }
            if let Some(ref versor_spec) = versor_type.versor {
                let targets = if versor_spec.sandwich_targets.is_empty() {
                    // Infer valid targets: types where sandwich preserves grades
                    self.infer_sandwich_targets(versor_type)
                } else {
                    versor_spec.sandwich_targets.clone()
                };

                for target_name in &targets {
                    if let Some(target_type) = self.find_type(target_name) {
                        impls.push(
                            self.generate_sandwich_trait_from_versor(versor_type, target_type),
                        );
                    }
                }
            }
        }

        // Antisandwich trait - generated from versor types (uses same targets as sandwich)
        for versor_type in &self.spec.types {
            if versor_type.alias_of.is_some() {
                continue;
            }
            if let Some(ref versor_spec) = versor_type.versor {
                let targets = if versor_spec.sandwich_targets.is_empty() {
                    // Infer valid targets: types where sandwich preserves grades
                    self.infer_sandwich_targets(versor_type)
                } else {
                    versor_spec.sandwich_targets.clone()
                };

                for target_name in &targets {
                    if let Some(target_type) = self.find_type(target_name) {
                        impls.push(
                            self.generate_antisandwich_trait_from_versor(versor_type, target_type),
                        );
                    }
                }
            }
        }

        // Versor trait - generated for versor types (Rotor, Motor, Flector)
        // Provides compose() method for versor composition
        impls.extend(self.generate_versor_traits());

        // ScalarProduct trait - single-grade types only
        for entry in &self.spec.products.scalar {
            if let (Some(a), Some(b), Some(out)) = (
                self.find_type(&entry.lhs),
                self.find_type(&entry.rhs),
                self.find_type(&entry.output),
            ) {
                if self.is_single_grade_blade(a) && self.is_single_grade_blade(b) {
                    impls.push(self.generate_scalar_product_trait(a, b, out, entry));
                }
            }
        }

        // BulkContract trait - single-grade types only
        for entry in &self.spec.products.bulk_contraction {
            if let (Some(a), Some(b), Some(out)) = (
                self.find_type(&entry.lhs),
                self.find_type(&entry.rhs),
                self.find_type(&entry.output),
            ) {
                if self.is_single_grade_blade(a) && self.is_single_grade_blade(b) {
                    impls.push(self.generate_bulk_contract_trait(a, b, out, entry));
                }
            }
        }

        // WeightContract trait - single-grade types only
        for entry in &self.spec.products.weight_contraction {
            if let (Some(a), Some(b), Some(out)) = (
                self.find_type(&entry.lhs),
                self.find_type(&entry.rhs),
                self.find_type(&entry.output),
            ) {
                if self.is_single_grade_blade(a) && self.is_single_grade_blade(b) {
                    impls.push(self.generate_weight_contract_trait(a, b, out, entry));
                }
            }
        }

        // BulkExpand trait - single-grade types only
        for entry in &self.spec.products.bulk_expansion {
            if let (Some(a), Some(b), Some(out)) = (
                self.find_type(&entry.lhs),
                self.find_type(&entry.rhs),
                self.find_type(&entry.output),
            ) {
                if self.is_single_grade_blade(a) && self.is_single_grade_blade(b) {
                    impls.push(self.generate_bulk_expand_trait(a, b, out, entry));
                }
            }
        }

        // WeightExpand trait - single-grade types only
        for entry in &self.spec.products.weight_expansion {
            if let (Some(a), Some(b), Some(out)) = (
                self.find_type(&entry.lhs),
                self.find_type(&entry.rhs),
                self.find_type(&entry.output),
            ) {
                if self.is_single_grade_blade(a) && self.is_single_grade_blade(b) {
                    impls.push(self.generate_weight_expand_trait(a, b, out, entry));
                }
            }
        }

        // Note: Antigeometric trait has been removed (PRD-24)
        // The antigeometric product cannot be type-safe for single-grade elements.
        // Use Antidot for same-antigrade scalar products.

        // Dot trait (same-grade metric inner product, returns scalar)
        for entry in &self.spec.products.dot {
            if let (Some(a), Some(b)) = (self.find_type(&entry.lhs), self.find_type(&entry.rhs)) {
                impls.push(self.generate_dot_trait(a, b, entry));
            }
        }

        // Antidot trait (same-antigrade metric inner product, returns scalar)
        for entry in &self.spec.products.antidot {
            if let (Some(a), Some(b)) = (self.find_type(&entry.lhs), self.find_type(&entry.rhs)) {
                impls.push(self.generate_antidot_trait(a, b, entry));
            }
        }

        // ====== Unary Operation Traits ======

        // Reverse trait - for all types
        for ty in &self.spec.types {
            if ty.alias_of.is_none() {
                impls.push(self.generate_reverse_trait(ty));
            }
        }

        // Antireverse trait - for all types
        for ty in &self.spec.types {
            if ty.alias_of.is_none() {
                impls.push(self.generate_antireverse_trait(ty));
            }
        }

        // RightComplement trait - only for types that have a complement function
        // (i.e., where the complement grades map to an existing type)
        for ty in &self.spec.types {
            if ty.alias_of.is_none() {
                if let Some(impl_tokens) = self.generate_right_complement_trait(ty) {
                    impls.push(impl_tokens);
                }
            }
        }

        // Note: LeftComplement, BulkDual, and WeightDual traits are not yet generated
        // because the corresponding free functions don't exist in unary.rs.
        // These can be added in a future PR by extending unary.rs.

        quote! { #(#impls)* }
    }

    // Note: generate_geometric_product_trait has been removed (PRD-24)
    // The GeometricProduct trait cannot be type-safe for single-grade elements.

    /// Generates Dot trait impl (same-grade metric inner product, returns scalar).
    fn generate_dot_trait(
        &self,
        a: &TypeSpec,
        b: &TypeSpec,
        _entry: &crate::spec::ProductEntry,
    ) -> TokenStream {
        let a_name = format_ident!("{}", a.name);
        let b_name = format_ident!("{}", b.name);

        // Compute the dot product expression
        let expr = self.compute_dot_expression(a, b);

        quote! {
            impl<T: Float> Dot<#b_name<T>> for #a_name<T> {
                type Scalar = T;

                #[inline]
                fn dot(&self, rhs: &#b_name<T>) -> T {
                    #expr
                }
            }
        }
    }

    /// Generates Antidot trait impl (same-antigrade metric inner product, returns scalar).
    fn generate_antidot_trait(
        &self,
        a: &TypeSpec,
        b: &TypeSpec,
        _entry: &crate::spec::ProductEntry,
    ) -> TokenStream {
        let a_name = format_ident!("{}", a.name);
        let b_name = format_ident!("{}", b.name);

        // Compute the antidot product expression
        let expr = self.compute_antidot_expression(a, b);

        quote! {
            impl<T: Float> Antidot<#b_name<T>> for #a_name<T> {
                type Scalar = T;

                #[inline]
                fn antidot(&self, rhs: &#b_name<T>) -> T {
                    #expr
                }
            }
        }
    }

    /// Generates Wedge trait impl.
    fn generate_wedge_trait(
        &self,
        a: &TypeSpec,
        b: &TypeSpec,
        output: &TypeSpec,
        _entry: &crate::spec::ProductEntry,
    ) -> TokenStream {
        let a_name = format_ident!("{}", a.name);
        let b_name = format_ident!("{}", b.name);
        let out_name = format_ident!("{}", output.name);

        // Compute the formula using symbolic machinery
        let field_exprs =
            self.compute_product_expressions(a, b, output, SymbolicProductKind::Wedge);

        // Generate constructor call
        let constructor_call = if output.versor.is_some() {
            quote! { #out_name::new_unchecked(#(#field_exprs),*) }
        } else {
            quote! { #out_name::new_unchecked(#(#field_exprs),*) }
        };

        quote! {
            impl<T: Float> Wedge<#b_name<T>> for #a_name<T> {
                type Output = #out_name<T>;

                #[inline]
                fn wedge(&self, rhs: &#b_name<T>) -> #out_name<T> {
                    #constructor_call
                }
            }
        }
    }

    /// Generates Antiwedge trait impl.
    fn generate_antiwedge_trait(
        &self,
        a: &TypeSpec,
        b: &TypeSpec,
        output: &TypeSpec,
        _entry: &crate::spec::ProductEntry,
    ) -> TokenStream {
        let a_name = format_ident!("{}", a.name);
        let b_name = format_ident!("{}", b.name);
        let out_name = format_ident!("{}", output.name);

        // Compute the formula using symbolic machinery
        let field_exprs =
            self.compute_product_expressions(a, b, output, SymbolicProductKind::Antiwedge);

        // Generate constructor call
        let constructor_call = if output.versor.is_some() {
            quote! { #out_name::new_unchecked(#(#field_exprs),*) }
        } else {
            quote! { #out_name::new_unchecked(#(#field_exprs),*) }
        };

        quote! {
            impl<T: Float> Antiwedge<#b_name<T>> for #a_name<T> {
                type Output = #out_name<T>;

                #[inline]
                fn antiwedge(&self, rhs: &#b_name<T>) -> #out_name<T> {
                    #constructor_call
                }
            }
        }
    }

    /// Generates LeftContract trait impl.
    fn generate_left_contract_trait(
        &self,
        a: &TypeSpec,
        b: &TypeSpec,
        output: &TypeSpec,
        _entry: &crate::spec::ProductEntry,
    ) -> TokenStream {
        let a_name = format_ident!("{}", a.name);
        let b_name = format_ident!("{}", b.name);
        let out_name = format_ident!("{}", output.name);

        // Compute the formula using symbolic machinery
        let field_exprs =
            self.compute_product_expressions(a, b, output, SymbolicProductKind::LeftContraction);

        // Generate constructor call
        let constructor_call = if output.versor.is_some() {
            quote! { #out_name::new_unchecked(#(#field_exprs),*) }
        } else {
            quote! { #out_name::new_unchecked(#(#field_exprs),*) }
        };

        quote! {
            impl<T: Float> LeftContract<#b_name<T>> for #a_name<T> {
                type Output = #out_name<T>;

                #[inline]
                fn left_contract(&self, rhs: &#b_name<T>) -> #out_name<T> {
                    #constructor_call
                }
            }
        }
    }

    /// Generates RightContract trait impl.
    fn generate_right_contract_trait(
        &self,
        a: &TypeSpec,
        b: &TypeSpec,
        output: &TypeSpec,
        _entry: &crate::spec::ProductEntry,
    ) -> TokenStream {
        let a_name = format_ident!("{}", a.name);
        let b_name = format_ident!("{}", b.name);
        let out_name = format_ident!("{}", output.name);

        // Compute the formula using symbolic machinery
        let field_exprs =
            self.compute_product_expressions(a, b, output, SymbolicProductKind::RightContraction);

        // Generate constructor call
        let constructor_call = if output.versor.is_some() {
            quote! { #out_name::new_unchecked(#(#field_exprs),*) }
        } else {
            quote! { #out_name::new_unchecked(#(#field_exprs),*) }
        };

        quote! {
            impl<T: Float> RightContract<#b_name<T>> for #a_name<T> {
                type Output = #out_name<T>;

                #[inline]
                fn right_contract(&self, rhs: &#b_name<T>) -> #out_name<T> {
                    #constructor_call
                }
            }
        }
    }

    /// Generates Sandwich trait impl from versor type.
    fn generate_sandwich_trait_from_versor(
        &self,
        versor: &TypeSpec,
        operand: &TypeSpec,
    ) -> TokenStream {
        let versor_name = format_ident!("{}", versor.name);
        let operand_name = format_ident!("{}", operand.name);

        // Compute the sandwich expression for each output field
        let field_exprs = self.compute_sandwich_expressions(versor, operand);

        // Generate constructor call
        let constructor_call = if operand.versor.is_some() {
            quote! { #operand_name::new_unchecked(#(#field_exprs),*) }
        } else {
            quote! { #operand_name::new_unchecked(#(#field_exprs),*) }
        };

        // For sandwich, output is typically same type as operand
        quote! {
            impl<T: Float> Sandwich<#operand_name<T>> for #versor_name<T> {
                type Output = #operand_name<T>;

                #[inline]
                fn sandwich(&self, operand: &#operand_name<T>) -> #operand_name<T> {
                    #constructor_call
                }
            }
        }
    }

    /// Generates Antisandwich trait impl from versor type.
    fn generate_antisandwich_trait_from_versor(
        &self,
        versor: &TypeSpec,
        operand: &TypeSpec,
    ) -> TokenStream {
        let versor_name = format_ident!("{}", versor.name);
        let operand_name = format_ident!("{}", operand.name);

        // Compute the antisandwich expression for each output field
        let field_exprs = self.compute_antisandwich_expressions(versor, operand);

        // Generate constructor call
        let constructor_call = if operand.versor.is_some() {
            quote! { #operand_name::new_unchecked(#(#field_exprs),*) }
        } else {
            quote! { #operand_name::new_unchecked(#(#field_exprs),*) }
        };

        // For antisandwich, output is typically same type as operand
        quote! {
            impl<T: Float> Antisandwich<#operand_name<T>> for #versor_name<T> {
                type Output = #operand_name<T>;

                #[inline]
                fn antisandwich(&self, operand: &#operand_name<T>) -> #operand_name<T> {
                    #constructor_call
                }
            }
        }
    }

    /// Generates Versor trait impls for all versor×versor combinations.
    ///
    /// The Versor trait provides `compose()` for versor composition.
    /// This delegates to the Mul operator which already implements the
    /// correct product formula (geometric for Euclidean, antigeometric for PGA).
    ///
    /// Output types follow the algebraic rules:
    /// - Even × Even → Even (Motor × Motor → Motor)
    /// - Odd × Odd → Even (Flector × Flector → Motor)
    /// - Even × Odd → Odd (Motor × Flector → Flector)
    /// - Odd × Even → Odd (Flector × Motor → Flector)
    fn generate_versor_traits(&self) -> Vec<TokenStream> {
        let mut impls = Vec::new();

        // Find all versor types
        let versor_types: Vec<_> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none() && t.versor.is_some())
            .collect();

        // Generate impl for each pair of versors
        for lhs in &versor_types {
            for rhs in &versor_types {
                // Look up the output type from the geometric products
                // (the Mul operator output type)
                if let Some(output_type) = self.find_mul_output_type(&lhs.name, &rhs.name) {
                    let lhs_name = format_ident!("{}", lhs.name);
                    let rhs_name = format_ident!("{}", rhs.name);
                    let out_name = format_ident!("{}", output_type);

                    // Check if both types are self-complementary (complement returns same type)
                    let lhs_self_complement = self
                        .find_complement_output_type(lhs)
                        .map(|t| t == lhs.name)
                        .unwrap_or(false);
                    let rhs_self_complement = self
                        .find_complement_output_type(rhs)
                        .map(|t| t == rhs.name)
                        .unwrap_or(false);

                    // For self-complementary versors (like Motor in 3D PGA),
                    // use the antiproduct formula: complement(complement(a) × complement(b))
                    // This is required for correct composition with antisandwich-based transformations.
                    let compose_body = if lhs_self_complement && rhs_self_complement {
                        quote! {
                            // Antiproduct: complement(complement(a) × complement(b))
                            (self.right_complement() * other.right_complement()).right_complement()
                        }
                    } else {
                        // Fall back to geometric product for non-self-complementary types
                        // Use dereference (*) to avoid clone() on Copy types
                        quote! {
                            *self * *other
                        }
                    };

                    impls.push(quote! {
                        impl<T: Float> Versor<#rhs_name<T>> for #lhs_name<T> {
                            type Output = #out_name<T>;

                            #[inline]
                            fn compose(&self, other: &#rhs_name<T>) -> #out_name<T> {
                                #compose_body
                            }
                        }
                    });
                }
            }
        }

        impls
    }

    /// Finds the output type for a Mul<Rhs> for Lhs operation.
    fn find_mul_output_type(&self, lhs: &str, rhs: &str) -> Option<String> {
        // Check geometric products for the output type
        for entry in &self.spec.products.geometric {
            if entry.lhs == lhs && entry.rhs == rhs {
                return Some(entry.output.clone());
            }
        }
        None
    }

    /// Generates ScalarProduct trait impl.
    fn generate_scalar_product_trait(
        &self,
        a: &TypeSpec,
        b: &TypeSpec,
        _output: &TypeSpec,
        _entry: &crate::spec::ProductEntry,
    ) -> TokenStream {
        let a_name = format_ident!("{}", a.name);
        let b_name = format_ident!("{}", b.name);

        // Compute the scalar product expression (grade-0 projection)
        let expr = self.compute_scalar_product_expression(a, b);

        quote! {
            impl<T: Float> ScalarProduct<#b_name<T>> for #a_name<T> {
                type Scalar = T;

                #[inline]
                fn scalar_product(&self, rhs: &#b_name<T>) -> T {
                    #expr
                }
            }
        }
    }

    /// Generates BulkContract trait impl.
    fn generate_bulk_contract_trait(
        &self,
        a: &TypeSpec,
        b: &TypeSpec,
        output: &TypeSpec,
        _entry: &crate::spec::ProductEntry,
    ) -> TokenStream {
        let a_name = format_ident!("{}", a.name);
        let b_name = format_ident!("{}", b.name);
        let out_name = format_ident!("{}", output.name);

        // Compute the formula using symbolic machinery
        let field_exprs =
            self.compute_product_expressions(a, b, output, SymbolicProductKind::BulkContraction);

        // Generate constructor call
        let constructor_call = if output.versor.is_some() {
            quote! { #out_name::new_unchecked(#(#field_exprs),*) }
        } else {
            quote! { #out_name::new_unchecked(#(#field_exprs),*) }
        };

        quote! {
            impl<T: Float> BulkContract<#b_name<T>> for #a_name<T> {
                type Output = #out_name<T>;

                #[inline]
                fn bulk_contract(&self, rhs: &#b_name<T>) -> #out_name<T> {
                    #constructor_call
                }
            }
        }
    }

    /// Generates WeightContract trait impl.
    fn generate_weight_contract_trait(
        &self,
        a: &TypeSpec,
        b: &TypeSpec,
        output: &TypeSpec,
        _entry: &crate::spec::ProductEntry,
    ) -> TokenStream {
        let a_name = format_ident!("{}", a.name);
        let b_name = format_ident!("{}", b.name);
        let out_name = format_ident!("{}", output.name);

        // Compute the formula using symbolic machinery
        let field_exprs =
            self.compute_product_expressions(a, b, output, SymbolicProductKind::WeightContraction);

        // Generate constructor call
        let constructor_call = if output.versor.is_some() {
            quote! { #out_name::new_unchecked(#(#field_exprs),*) }
        } else {
            quote! { #out_name::new_unchecked(#(#field_exprs),*) }
        };

        quote! {
            impl<T: Float> WeightContract<#b_name<T>> for #a_name<T> {
                type Output = #out_name<T>;

                #[inline]
                fn weight_contract(&self, rhs: &#b_name<T>) -> #out_name<T> {
                    #constructor_call
                }
            }
        }
    }

    /// Generates BulkExpand trait impl.
    fn generate_bulk_expand_trait(
        &self,
        a: &TypeSpec,
        b: &TypeSpec,
        output: &TypeSpec,
        _entry: &crate::spec::ProductEntry,
    ) -> TokenStream {
        let a_name = format_ident!("{}", a.name);
        let b_name = format_ident!("{}", b.name);
        let out_name = format_ident!("{}", output.name);

        // Compute the formula using symbolic machinery
        let field_exprs =
            self.compute_product_expressions(a, b, output, SymbolicProductKind::BulkExpansion);

        // Generate constructor call
        let constructor_call = if output.versor.is_some() {
            quote! { #out_name::new_unchecked(#(#field_exprs),*) }
        } else {
            quote! { #out_name::new_unchecked(#(#field_exprs),*) }
        };

        quote! {
            impl<T: Float> BulkExpand<#b_name<T>> for #a_name<T> {
                type Output = #out_name<T>;

                #[inline]
                fn bulk_expand(&self, rhs: &#b_name<T>) -> #out_name<T> {
                    #constructor_call
                }
            }
        }
    }

    /// Generates WeightExpand trait impl.
    fn generate_weight_expand_trait(
        &self,
        a: &TypeSpec,
        b: &TypeSpec,
        output: &TypeSpec,
        _entry: &crate::spec::ProductEntry,
    ) -> TokenStream {
        let a_name = format_ident!("{}", a.name);
        let b_name = format_ident!("{}", b.name);
        let out_name = format_ident!("{}", output.name);

        // Compute the formula using symbolic machinery
        let field_exprs =
            self.compute_product_expressions(a, b, output, SymbolicProductKind::WeightExpansion);

        // Generate constructor call
        let constructor_call = if output.versor.is_some() {
            quote! { #out_name::new_unchecked(#(#field_exprs),*) }
        } else {
            quote! { #out_name::new_unchecked(#(#field_exprs),*) }
        };

        quote! {
            impl<T: Float> WeightExpand<#b_name<T>> for #a_name<T> {
                type Output = #out_name<T>;

                #[inline]
                fn weight_expand(&self, rhs: &#b_name<T>) -> #out_name<T> {
                    #constructor_call
                }
            }
        }
    }

    // Note: generate_antigeometric_trait has been removed (PRD-24)
    // The Antigeometric trait cannot be type-safe for single-grade elements.

    // ========================================================================
    // Sandwich Target Inference
    // ========================================================================

    /// Infers valid sandwich targets for a versor type.
    ///
    /// A type is a valid target if the sandwich product V * X * rev(V) produces
    /// the same grades as X (grade-preserving transformation).
    fn infer_sandwich_targets(&self, _versor_type: &TypeSpec) -> Vec<String> {
        // Versors have the grade-preserving property: V * X * rev(V) preserves the grade of X.
        // This means ANY type can be a valid sandwich target for a versor.
        // We include all non-alias types as valid targets.
        //
        // Note: This is a fundamental property of versors in geometric algebra.
        // A versor is a product of unit vectors, and conjugation by a versor
        // preserves grades (it only rotates/reflects within each grade subspace).
        self.spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|t| t.name.clone())
            .collect()
    }

    // ========================================================================
    // Unary Operation Trait Implementations
    // ========================================================================

    /// Generates Reverse trait impl.
    fn generate_reverse_trait(&self, ty: &TypeSpec) -> TokenStream {
        let type_name = format_ident!("{}", ty.name);

        // Compute field expressions with reverse signs
        let field_exprs: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let field_name = format_ident!("{}", field.name);
                let grade = field.grade;
                // Reverse sign: (-1)^(k(k-1)/2)
                if (grade * grade.saturating_sub(1) / 2).is_multiple_of(2) {
                    quote! { self.#field_name() }
                } else {
                    quote! { -self.#field_name() }
                }
            })
            .collect();

        let constructor = quote! { Self::new_unchecked(#(#field_exprs),*) };

        quote! {
            impl<T: Float> Reverse for #type_name<T> {
                #[inline]
                fn reverse(&self) -> Self {
                    #constructor
                }
            }
        }
    }

    /// Generates Antireverse trait impl.
    fn generate_antireverse_trait(&self, ty: &TypeSpec) -> TokenStream {
        let type_name = format_ident!("{}", ty.name);
        let dim = self.algebra.dim();

        // Compute field expressions with antireverse signs
        let field_exprs: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let field_name = format_ident!("{}", field.name);
                let grade = field.grade;
                let antigrade = dim - grade;
                // Antireverse sign: (-1)^((n-k)(n-k-1)/2)
                if (antigrade * antigrade.saturating_sub(1) / 2).is_multiple_of(2) {
                    quote! { self.#field_name() }
                } else {
                    quote! { -self.#field_name() }
                }
            })
            .collect();

        let constructor = quote! { Self::new_unchecked(#(#field_exprs),*) };

        quote! {
            impl<T: Float> Antireverse for #type_name<T> {
                #[inline]
                fn antireverse(&self) -> Self {
                    #constructor
                }
            }
        }
    }

    /// Generates RightComplement trait impl.
    ///
    /// Returns None if the complement grades don't map to an existing type.
    fn generate_right_complement_trait(&self, ty: &TypeSpec) -> Option<TokenStream> {
        // Check if there's a matching output type for the complement
        let output_type_name = self.find_complement_output_type(ty)?;
        let output_type = self
            .spec
            .types
            .iter()
            .find(|t| t.name == output_type_name)?;

        let type_name = format_ident!("{}", ty.name);
        let out_name = format_ident!("{}", output_type_name);

        // Compute field expressions for complement
        let field_exprs: Vec<TokenStream> = output_type
            .fields
            .iter()
            .map(|out_field| {
                // Find the input field that complements to this output blade
                let out_blade = out_field.blade_index;

                for in_field in &ty.fields {
                    let (sign, comp_blade) = self.table.complement(in_field.blade_index);
                    if comp_blade == out_blade && sign != 0 {
                        let in_name = format_ident!("{}", in_field.name);
                        return if sign > 0 {
                            quote! { self.#in_name() }
                        } else {
                            quote! { -self.#in_name() }
                        };
                    }
                }
                // No input blade maps to this output blade
                quote! { T::zero() }
            })
            .collect();

        let constructor = quote! { #out_name::new_unchecked(#(#field_exprs),*) };

        Some(quote! {
            impl<T: Float> RightComplement for #type_name<T> {
                type Output = #out_name<T>;

                #[inline]
                fn right_complement(&self) -> #out_name<T> {
                    #constructor
                }
            }
        })
    }

    // Note: LeftComplement, BulkDual, and WeightDual trait generation removed
    // because the corresponding free functions don't exist in unary.rs yet.
    // These can be added in a future PR by extending unary.rs.

    /// Finds the output type for complement operations.
    ///
    /// The complement of a type with grades [g1, g2, ...] has grades [n-g1, n-g2, ...].
    /// Returns None if no type with matching grades exists.
    fn find_complement_output_type(&self, ty: &TypeSpec) -> Option<String> {
        let dim = self.algebra.dim();
        let complement_grades: Vec<usize> = ty.grades.iter().map(|g| dim - g).collect();

        // Find a type with matching grades
        for candidate in &self.spec.types {
            if candidate.alias_of.is_some() {
                continue;
            }
            let mut candidate_grades = candidate.grades.clone();
            candidate_grades.sort();
            let mut sorted_complement = complement_grades.clone();
            sorted_complement.sort();
            if candidate_grades == sorted_complement {
                return Some(candidate.name.clone());
            }
        }

        // No matching type found
        None
    }

    // ========================================================================
    // Normed Trait Implementations
    // ========================================================================

    /// Generates all Normed trait implementations.
    fn generate_all_normed(&self) -> TokenStream {
        let impls: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|ty| self.generate_normed_impl(ty))
            .collect();

        // For PGA algebras (with degenerate basis), also generate DegenerateNormed
        let degenerate_impls: Vec<TokenStream> = if self.spec.signature.r > 0 {
            self.spec
                .types
                .iter()
                .filter(|t| t.alias_of.is_none())
                .filter_map(|ty| self.generate_degenerate_normed_impl(ty))
                .collect()
        } else {
            Vec::new()
        };

        quote! {
            #(#impls)*
            #(#degenerate_impls)*
        }
    }

    /// Generates `impl Normed for Type<T>`.
    fn generate_normed_impl(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        // Generate norm_squared: sum of squares of all fields
        let norm_squared_terms: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname() * self.#fname() }
            })
            .collect();

        // Generate scale: multiply each field by factor
        let scale_fields: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname() * factor }
            })
            .collect();

        // Handle edge case where type has no fields
        let norm_squared_expr = if norm_squared_terms.is_empty() {
            quote! { T::zero() }
        } else {
            quote! { #(#norm_squared_terms)+* }
        };

        quote! {
            impl<T: Float> crate::norm::Normed for #name<T> {
                type Scalar = T;

                #[inline]
                fn norm_squared(&self) -> T {
                    #norm_squared_expr
                }

                fn try_normalize(&self) -> Option<Self> {
                    let n = self.norm();
                    if n < T::epsilon() {
                        None
                    } else {
                        Some(self.scale(T::one() / n))
                    }
                }

                #[inline]
                fn scale(&self, factor: T) -> Self {
                    Self::new_unchecked(#(#scale_fields),*)
                }
            }
        }
    }

    /// Generates `impl DegenerateNormed for Type<T>` for PGA types.
    ///
    /// Returns None if the type has no bulk or weight components.
    fn generate_degenerate_normed_impl(&self, ty: &TypeSpec) -> Option<TokenStream> {
        let name = format_ident!("{}", ty.name);

        // Find indices of degenerate basis vectors (those with metric == 0)
        let degenerate_indices: Vec<usize> = self
            .spec
            .signature
            .basis
            .iter()
            .filter(|b| b.metric == 0)
            .map(|b| b.index)
            .collect();

        // Partition fields into bulk (no degenerate basis) and weight (has degenerate basis)
        let (bulk_fields, weight_fields): (Vec<_>, Vec<_>) = ty.fields.iter().partition(|f| {
            // Check if this field's blade involves any degenerate basis vector
            !degenerate_indices.iter().any(|&deg_idx| {
                // Check if bit `deg_idx` is set in the blade_index
                (f.blade_index >> deg_idx) & 1 == 1
            })
        });

        // Don't generate if there are no fields in either category
        if bulk_fields.is_empty() && weight_fields.is_empty() {
            return None;
        }

        // Generate bulk_norm_squared: sum of squares of bulk fields
        let bulk_norm_terms: Vec<TokenStream> = bulk_fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname() * self.#fname() }
            })
            .collect();

        // Generate weight_norm_squared: sum of squares of weight fields
        let weight_norm_terms: Vec<TokenStream> = weight_fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname() * self.#fname() }
            })
            .collect();

        let bulk_norm_expr = if bulk_norm_terms.is_empty() {
            quote! { T::zero() }
        } else {
            quote! { #(#bulk_norm_terms)+* }
        };

        let weight_norm_expr = if weight_norm_terms.is_empty() {
            quote! { T::zero() }
        } else {
            quote! { #(#weight_norm_terms)+* }
        };

        // Generate scale fields for try_unitize
        let scale_fields: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname() * inv_w }
            })
            .collect();

        Some(quote! {
            impl<T: Float> crate::norm::DegenerateNormed for #name<T> {
                #[inline]
                fn bulk_norm_squared(&self) -> T {
                    #bulk_norm_expr
                }

                #[inline]
                fn weight_norm_squared(&self) -> T {
                    #weight_norm_expr
                }

                fn try_unitize(&self) -> Option<Self> {
                    let w = self.weight_norm();
                    if w < T::epsilon() {
                        None
                    } else {
                        let inv_w = T::one() / w;
                        Some(Self::new_unchecked(#(#scale_fields),*))
                    }
                }
            }
        })
    }

    // ========================================================================
    // Approx Trait Implementations
    // ========================================================================

    /// Generates all approx trait implementations.
    fn generate_all_approx(&self) -> TokenStream {
        let impls: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|ty| self.generate_approx_impls(ty))
            .collect();

        quote! { #(#impls)* }
    }

    /// Generates approx trait implementations for a type.
    fn generate_approx_impls(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        let abs_diff_checks: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname().abs_diff_eq(&other.#fname(), epsilon) }
            })
            .collect();

        let relative_checks: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname().relative_eq(&other.#fname(), epsilon, max_relative) }
            })
            .collect();

        let ulps_checks: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname().ulps_eq(&other.#fname(), epsilon, max_ulps) }
            })
            .collect();

        quote! {
            impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for #name<T> {
                type Epsilon = T;

                fn default_epsilon() -> Self::Epsilon {
                    T::default_epsilon()
                }

                fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
                    #(#abs_diff_checks)&&*
                }
            }

            impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for #name<T> {
                fn default_max_relative() -> Self::Epsilon {
                    T::default_max_relative()
                }

                fn relative_eq(
                    &self,
                    other: &Self,
                    epsilon: Self::Epsilon,
                    max_relative: Self::Epsilon,
                ) -> bool {
                    #(#relative_checks)&&*
                }
            }

            impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for #name<T> {
                fn default_max_ulps() -> u32 {
                    T::default_max_ulps()
                }

                fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
                    #(#ulps_checks)&&*
                }
            }
        }
    }

    // ========================================================================
    // Arbitrary Implementations
    // ========================================================================

    /// Generates all Arbitrary implementations.
    fn generate_all_arbitrary(&self) -> TokenStream {
        let impls: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|ty| self.generate_arbitrary_impl(ty))
            .collect();

        quote! {
            #[cfg(any(test, feature = "proptest-support"))]
            #[allow(clippy::missing_docs_in_private_items)]
            mod arbitrary_impls {
                use super::*;
                use proptest::prelude::*;
                use proptest::strategy::BoxedStrategy;
                use std::fmt::Debug;

                #(#impls)*
            }
        }
    }

    /// Generates Arbitrary implementation for a type.
    ///
    /// For unconstrained types, generates random values for all fields.
    /// For constrained types (with geometric constraints like Study condition),
    /// solves the constraint to compute dependent variables from independent ones.
    fn generate_arbitrary_impl(&self, ty: &TypeSpec) -> TokenStream {
        // Check if this type has a derived constraint
        if let Some(constraint_impl) = self.try_generate_constrained_arbitrary(ty) {
            return constraint_impl;
        }

        // No constraint - generate simple random values for all fields
        self.generate_unconstrained_arbitrary(ty)
    }

    /// Attempts to generate a constraint-solving Arbitrary implementation.
    ///
    /// Returns `Some(TokenStream)` if the type has a derived constraint that can be solved,
    /// `None` otherwise.
    fn try_generate_constrained_arbitrary(&self, ty: &TypeSpec) -> Option<TokenStream> {
        // Derive constraints from algebra structure
        let deriver = ConstraintDeriver::new(self.algebra);
        let constraint = deriver.derive_geometric_constraint(ty, "x")?;

        // Only handle single-constraint cases for now
        if constraint.zero_expressions.len() != 1 {
            return None;
        }

        let expr = &constraint.zero_expressions[0];

        // Convert Symbolica expression to string for the solver
        let expr_str = format!("{} = 0", expr);

        // Find the highest-grade field to solve for (typically pseudoscalar like e0123)
        let solve_for_field = ty.fields.iter().max_by_key(|f| f.grade)?;

        // Try to solve the constraint for this variable
        let solver = ConstraintSolver::new();
        let symbol_name = format!("x_{}", solve_for_field.name);
        let solution = solver.solve(&expr_str, &symbol_name).ok()?;

        // For quadratic constraints (like Plücker), use filter instead of solving
        if solution.solution_type == SolutionType::Quadratic {
            return self.generate_filtered_arbitrary(ty);
        }

        // Generate constraint-solving Arbitrary
        Some(self.generate_solving_arbitrary(ty, &solve_for_field.name, &solution))
    }

    /// Generates Arbitrary that solves a linear constraint.
    fn generate_solving_arbitrary(
        &self,
        ty: &TypeSpec,
        solve_for: &str,
        solution: &crate::symbolic::SolveResult,
    ) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let num_fields = ty.fields.len();

        // Find indices of free and dependent fields
        let solve_for_idx = ty.fields.iter().position(|f| f.name == solve_for).unwrap();
        let free_indices: Vec<usize> = (0..num_fields).filter(|&i| i != solve_for_idx).collect();

        // Generate ranges for free variables
        let range_tuple: Vec<TokenStream> = free_indices
            .iter()
            .map(|_| quote! { -100.0f64..100.0 })
            .collect();

        // Generate variable names for prop_map
        let prop_map_args: Vec<TokenStream> = free_indices
            .iter()
            .enumerate()
            .map(|(i, _)| {
                let var = format_ident!("x{}", i);
                quote! { #var }
            })
            .collect();

        // Build the solution expression
        let numerator_expr = self.convert_solution_to_tokens(&solution.numerator, ty);
        let solution_expr = if let Some(ref divisor) = solution.divisor {
            let divisor_expr = self.convert_solution_to_tokens(divisor, ty);
            quote! { (#numerator_expr) / (#divisor_expr) }
        } else {
            numerator_expr
        };

        // Build field initialization expressions
        let mut field_var_map: Vec<Option<usize>> = vec![None; num_fields];
        for (var_idx, &field_idx) in free_indices.iter().enumerate() {
            field_var_map[field_idx] = Some(var_idx);
        }

        let field_inits: Vec<TokenStream> = ty
            .fields
            .iter()
            .enumerate()
            .map(|(i, _f)| {
                if i == solve_for_idx {
                    quote! { T::from_f64(#solution_expr) }
                } else {
                    let var_idx = field_var_map[i].unwrap();
                    let var = format_ident!("x{}", var_idx);
                    quote! { T::from_f64(#var) }
                }
            })
            .collect();

        // Generate filter for divisor non-zero condition
        let filter_expr = if let Some(ref divisor) = solution.divisor {
            let divisor_var = self.find_divisor_variable(divisor, ty);
            if let Some(var_idx) = divisor_var {
                let var = format_ident!("x{}", var_idx);
                // Generate filter args with underscores for unused variables
                let filter_args: Vec<TokenStream> = free_indices
                    .iter()
                    .enumerate()
                    .map(|(i, _)| {
                        if i == var_idx {
                            let v = format_ident!("x{}", i);
                            quote! { #v }
                        } else {
                            let v = format_ident!("_x{}", i);
                            quote! { #v }
                        }
                    })
                    .collect();
                Some(quote! {
                    .prop_filter("non-zero divisor", |(#(#filter_args),*)| (#var).abs() > 0.1)
                })
            } else {
                None
            }
        } else {
            None
        };

        let filter_chain = filter_expr.unwrap_or_else(|| quote! {});

        if free_indices.len() == 1 {
            let var = format_ident!("x0");
            quote! {
                impl<T: Float + Debug + 'static> Arbitrary for #name<T> {
                    type Parameters = ();
                    type Strategy = BoxedStrategy<Self>;

                    fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
                        (-100.0f64..100.0)
                            #filter_chain
                            .prop_map(|#var| {
                                #name::new_unchecked(#(#field_inits),*)
                            })
                            .boxed()
                    }
                }
            }
        } else {
            quote! {
                impl<T: Float + Debug + 'static> Arbitrary for #name<T> {
                    type Parameters = ();
                    type Strategy = BoxedStrategy<Self>;

                    fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
                        (#(#range_tuple),*)
                            #filter_chain
                            .prop_map(|(#(#prop_map_args),*)| {
                                #name::new_unchecked(#(#field_inits),*)
                            })
                            .boxed()
                    }
                }
            }
        }
    }

    /// Converts a solution expression string to TokenStream.
    ///
    /// The solution from `ConstraintSolver` uses variable names like "x_s", "x_e23", etc.
    /// (field names with the `x_` prefix from ConstraintDeriver).
    /// We need to convert these to the corresponding `x{i}` variables.
    fn convert_solution_to_tokens(&self, expr: &str, ty: &TypeSpec) -> TokenStream {
        let mut result = expr.to_string();

        // Find field indices for free variables (all except the solved-for one)
        let solve_for_field = ty.fields.iter().max_by_key(|f| f.grade).unwrap();

        let free_fields: Vec<_> = ty
            .fields
            .iter()
            .filter(|f| f.name != solve_for_field.name)
            .collect();

        // Replace "x_fieldname" with "x{i}" variables
        // Do longer names first to avoid partial replacements
        let mut sorted_fields: Vec<_> = free_fields.iter().enumerate().collect();
        sorted_fields.sort_by(|a, b| b.1.name.len().cmp(&a.1.name.len()));

        for (i, field) in sorted_fields {
            let field_pattern = format!("x_{}", field.name);
            let var_name = format!("x{}", i);
            result = result.replace(&field_pattern, &var_name);
        }

        // Parse and convert to TokenStream
        result.parse().unwrap_or_else(|_| quote! { T::zero() })
    }

    /// Finds which free variable corresponds to the divisor.
    ///
    /// The divisor uses the `x_fieldname` format from ConstraintDeriver.
    fn find_divisor_variable(&self, divisor: &str, ty: &TypeSpec) -> Option<usize> {
        let solve_for_field = ty.fields.iter().max_by_key(|f| f.grade)?;

        let free_fields: Vec<_> = ty
            .fields
            .iter()
            .filter(|f| f.name != solve_for_field.name)
            .collect();

        for (i, field) in free_fields.iter().enumerate() {
            // Check for "x_fieldname" pattern
            let pattern = format!("x_{}", field.name);
            if divisor.contains(&pattern) {
                return Some(i);
            }
        }
        None
    }

    /// Generates Arbitrary with a filter for quadratic constraints.
    ///
    /// For constraints like the Plücker condition that are quadratic and can't
    /// be easily solved, we generate random values and filter.
    fn generate_filtered_arbitrary(&self, ty: &TypeSpec) -> Option<TokenStream> {
        let name = format_ident!("{}", ty.name);
        let num_fields = ty.fields.len();

        // Generate tuple of ranges
        let range_tuple: Vec<TokenStream> =
            (0..num_fields).map(|_| quote! { -10.0f64..10.0 }).collect();

        let prop_map_args: Vec<TokenStream> = (0..num_fields)
            .map(|i| {
                let var = format_ident!("x{}", i);
                quote! { #var }
            })
            .collect();

        let field_inits: Vec<TokenStream> = (0..num_fields)
            .map(|i| {
                let var = format_ident!("x{}", i);
                quote! { T::from_f64(#var) }
            })
            .collect();

        Some(quote! {
            impl<T: Float + Debug + 'static> Arbitrary for #name<T> {
                type Parameters = ();
                type Strategy = BoxedStrategy<Self>;

                fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
                    (#(#range_tuple),*)
                        .prop_map(|(#(#prop_map_args),*)| {
                            #name::new_unchecked(#(#field_inits),*)
                        })
                        .boxed()
                }
            }
        })
    }

    /// Generates simple Arbitrary for unconstrained types.
    fn generate_unconstrained_arbitrary(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let num_fields = ty.fields.len();

        // Generate tuple of ranges
        let range_tuple: Vec<TokenStream> = (0..num_fields)
            .map(|_| quote! { -100.0f64..100.0 })
            .collect();

        let field_inits: Vec<TokenStream> = (0..num_fields)
            .map(|i| {
                let var = format_ident!("x{}", i);
                quote! { T::from_f64(#var) }
            })
            .collect();

        if num_fields == 1 {
            quote! {
                impl<T: Float + Debug + 'static> Arbitrary for #name<T> {
                    type Parameters = ();
                    type Strategy = BoxedStrategy<Self>;

                    fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
                        (-100.0f64..100.0)
                            .prop_map(|x0| {
                                #name::new_unchecked(#(#field_inits),*)
                            })
                            .boxed()
                    }
                }
            }
        } else {
            let prop_map_args: Vec<TokenStream> = (0..num_fields)
                .map(|i| {
                    let var = format_ident!("x{}", i);
                    quote! { #var }
                })
                .collect();

            quote! {
                impl<T: Float + Debug + 'static> Arbitrary for #name<T> {
                    type Parameters = ();
                    type Strategy = BoxedStrategy<Self>;

                    fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
                        (#(#range_tuple),*)
                            .prop_map(|(#(#prop_map_args),*)| {
                                #name::new_unchecked(#(#field_inits),*)
                            })
                            .boxed()
                    }
                }
            }
        }
    }

    // ========================================================================
    // Verification Tests
    // ========================================================================

    /// Generates verification tests as a pre-formatted string.
    ///
    /// This returns a raw string instead of TokenStream because rustfmt
    /// cannot format code inside proptest! macros. By generating the tests
    /// as pre-formatted strings, we preserve the formatting.
    fn generate_verification_tests_raw(&self) -> String {
        let signature_name = self.generate_signature_name();
        let add_sub_tests = self.generate_add_sub_verification_tests_raw();
        let exterior_tests = self.generate_exterior_verification_tests_raw();
        let bulk_contraction_tests = self.generate_bulk_contraction_verification_tests_raw();
        let weight_contraction_tests = self.generate_weight_contraction_verification_tests_raw();
        let bulk_expansion_tests = self.generate_bulk_expansion_verification_tests_raw();
        let weight_expansion_tests = self.generate_weight_expansion_verification_tests_raw();
        let de_morgan_tests = self.generate_de_morgan_verification_tests_raw();

        format!(
            r#"
// ============================================================
// Verification Tests (compare against Multivector)
// ============================================================

#[cfg(test)]
#[allow(clippy::missing_docs_in_private_items)]
mod verification_tests {{
    use super::*;
    use crate::algebra::Multivector;
    use crate::signature::{sig};
    use approx::relative_eq;
    use proptest::prelude::*;

    /// Relative epsilon for floating-point comparisons in verification tests.
    /// Using relative comparison handles varying magnitudes better than absolute.
    const REL_EPSILON: f64 = 1e-10;
{add_sub}{exterior}{bulk_contraction}{weight_contraction}{bulk_expansion}{weight_expansion}{de_morgan}}}
"#,
            sig = signature_name,
            add_sub = add_sub_tests,
            exterior = exterior_tests,
            bulk_contraction = bulk_contraction_tests,
            weight_contraction = weight_contraction_tests,
            bulk_expansion = bulk_expansion_tests,
            weight_expansion = weight_expansion_tests,
            de_morgan = de_morgan_tests,
        )
    }

    /// Generates the signature type name for this algebra.
    ///
    /// Uses the signature tuple (p, q, r) to determine the signature type,
    /// not the algebra name. This ensures generic handling of all algebras.
    fn generate_signature_name(&self) -> proc_macro2::Ident {
        let sig = &self.spec.signature;
        let (p, q, r) = (sig.p, sig.q, sig.r);

        // Derive signature type from (p, q, r)
        let sig_name = match (p, q, r) {
            // Euclidean: Cl(n, 0, 0)
            (2, 0, 0) => "Euclidean2",
            (3, 0, 0) => "Euclidean3",

            // Projective (PGA): Cl(n, 0, 1)
            (2, 0, 1) => "Projective2",
            (3, 0, 1) => "Projective3",

            // Conformal (CGA): Cl(n+1, 1, 0) - note: uses p+q=4/5 convention
            // CGA 2D: Cl(3, 1, 0) - 2D + 2 extra dimensions
            // CGA 3D: Cl(4, 1, 0) - 3D + 2 extra dimensions
            (4, 1, 0) => "Conformal3",

            // Minkowski spacetime: Cl(1, 3, 0)
            (1, 3, 0) => "Minkowski4",

            // Generic: use Cl{p}_{q}_{r} format
            _ => {
                return format_ident!("Cl{}_{}_{}", p, q, r);
            }
        };
        format_ident!("{}", sig_name)
    }

    /// Generates add/sub verification tests for each type as a formatted string.
    fn generate_add_sub_verification_tests_raw(&self) -> String {
        let signature_name = self.generate_signature_name();
        self.spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|ty| {
                let name = &ty.name;
                let name_lower = ty.name.to_lowercase();

                format!(
                    r#"
    proptest! {{
        #[test]
        fn {name_lower}_add_matches_multivector(a in any::<{name}<f64>>(), b in any::<{name}<f64>>()) {{
            let mv_a: Multivector<f64, {sig}> = a.into();
            let mv_b: Multivector<f64, {sig}> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, {sig}> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={{:?}}, generic={{:?}}",
                specialized_mv, generic_result
            );
        }}

        #[test]
        fn {name_lower}_sub_matches_multivector(a in any::<{name}<f64>>(), b in any::<{name}<f64>>()) {{
            let mv_a: Multivector<f64, {sig}> = a.into();
            let mv_b: Multivector<f64, {sig}> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, {sig}> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={{:?}}, generic={{:?}}",
                specialized_mv, generic_result
            );
        }}

        #[test]
        fn {name_lower}_neg_matches_multivector(a in any::<{name}<f64>>()) {{
            let mv_a: Multivector<f64, {sig}> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, {sig}> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={{:?}}, generic={{:?}}",
                specialized_mv, generic_result
            );
        }}
    }}
"#,
                    name_lower = name_lower,
                    name = name,
                    sig = signature_name,
                )
            })
            .collect()
    }

    /// Generates exterior product verification tests as a formatted string.
    fn generate_exterior_verification_tests_raw(&self) -> String {
        // Only generate tests for products explicitly listed in the TOML
        if self.spec.products.wedge.is_empty() {
            return String::new();
        }

        let signature_name = self.generate_signature_name();
        self.spec
            .products
            .wedge
            .iter()
            // Only generate tests for single-grade types (where Wedge is implemented)
            .filter(|entry| {
                self.find_type(&entry.lhs)
                    .is_some_and(|t| self.is_single_grade_blade(t))
                    && self
                        .find_type(&entry.rhs)
                        .is_some_and(|t| self.is_single_grade_blade(t))
            })
            .map(|entry| {
                let lhs_lower = entry.lhs.to_lowercase();
                let rhs_lower = entry.rhs.to_lowercase();
                let out_lower = entry.output.to_lowercase();

                format!(
                    r#"
    proptest! {{
        #[test]
        fn wedge_{lhs_lower}_{rhs_lower}_{out_lower}_matches_multivector(a in any::<{lhs}<f64>>(), b in any::<{rhs}<f64>>()) {{
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, {sig}> = a.into();
            let mv_b: Multivector<f64, {sig}> = b.into();

            let specialized_result: {out}<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, {sig}> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={{:?}}, generic={{:?}}",
                specialized_mv, generic_result
            );
        }}
    }}
"#,
                    lhs_lower = lhs_lower,
                    rhs_lower = rhs_lower,
                    out_lower = out_lower,
                    lhs = entry.lhs,
                    rhs = entry.rhs,
                    out = entry.output,
                    sig = signature_name,
                )
            })
            .collect()
    }

    /// Generates bulk contraction verification tests as a formatted string.
    fn generate_bulk_contraction_verification_tests_raw(&self) -> String {
        if self.spec.products.bulk_contraction.is_empty() {
            return String::new();
        }

        let signature_name = self.generate_signature_name();
        self.spec
            .products
            .bulk_contraction
            .iter()
            // Only generate tests for single-grade types (where BulkContract is implemented)
            .filter(|entry| {
                self.find_type(&entry.lhs)
                    .is_some_and(|t| self.is_single_grade_blade(t))
                    && self
                        .find_type(&entry.rhs)
                        .is_some_and(|t| self.is_single_grade_blade(t))
            })
            .map(|entry| {
                let lhs_lower = entry.lhs.to_lowercase();
                let rhs_lower = entry.rhs.to_lowercase();
                let out_lower = entry.output.to_lowercase();

                format!(
                    r#"
    proptest! {{
        #[test]
        fn bulk_contraction_{lhs_lower}_{rhs_lower}_{out_lower}_matches_multivector(a in any::<{lhs}<f64>>(), b in any::<{rhs}<f64>>()) {{
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, {sig}> = a.into();
            let mv_b: Multivector<f64, {sig}> = b.into();

            let specialized_result: {out}<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, {sig}> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={{:?}}, generic={{:?}}",
                specialized_mv, generic_result
            );
        }}
    }}
"#,
                    lhs_lower = lhs_lower,
                    rhs_lower = rhs_lower,
                    out_lower = out_lower,
                    lhs = entry.lhs,
                    rhs = entry.rhs,
                    out = entry.output,
                    sig = signature_name,
                )
            })
            .collect()
    }

    /// Generates weight contraction verification tests as a formatted string.
    fn generate_weight_contraction_verification_tests_raw(&self) -> String {
        if self.spec.products.weight_contraction.is_empty() {
            return String::new();
        }

        let signature_name = self.generate_signature_name();
        self.spec
            .products
            .weight_contraction
            .iter()
            // Only generate tests for single-grade types (where WeightContract is implemented)
            .filter(|entry| {
                self.find_type(&entry.lhs)
                    .is_some_and(|t| self.is_single_grade_blade(t))
                    && self
                        .find_type(&entry.rhs)
                        .is_some_and(|t| self.is_single_grade_blade(t))
            })
            .map(|entry| {
                let lhs_lower = entry.lhs.to_lowercase();
                let rhs_lower = entry.rhs.to_lowercase();
                let out_lower = entry.output.to_lowercase();

                format!(
                    r#"
    proptest! {{
        #[test]
        fn weight_contraction_{lhs_lower}_{rhs_lower}_{out_lower}_matches_multivector(a in any::<{lhs}<f64>>(), b in any::<{rhs}<f64>>()) {{
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, {sig}> = a.into();
            let mv_b: Multivector<f64, {sig}> = b.into();

            let specialized_result: {out}<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, {sig}> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={{:?}}, generic={{:?}}",
                specialized_mv, generic_result
            );
        }}
    }}
"#,
                    lhs_lower = lhs_lower,
                    rhs_lower = rhs_lower,
                    out_lower = out_lower,
                    lhs = entry.lhs,
                    rhs = entry.rhs,
                    out = entry.output,
                    sig = signature_name,
                )
            })
            .collect()
    }

    /// Generates bulk expansion verification tests as a formatted string.
    fn generate_bulk_expansion_verification_tests_raw(&self) -> String {
        if self.spec.products.bulk_expansion.is_empty() {
            return String::new();
        }

        let signature_name = self.generate_signature_name();
        self.spec
            .products
            .bulk_expansion
            .iter()
            // Only generate tests for single-grade types (where BulkExpand is implemented)
            .filter(|entry| {
                self.find_type(&entry.lhs)
                    .is_some_and(|t| self.is_single_grade_blade(t))
                    && self
                        .find_type(&entry.rhs)
                        .is_some_and(|t| self.is_single_grade_blade(t))
            })
            .map(|entry| {
                let lhs_lower = entry.lhs.to_lowercase();
                let rhs_lower = entry.rhs.to_lowercase();
                let out_lower = entry.output.to_lowercase();

                format!(
                    r#"
    proptest! {{
        #[test]
        fn bulk_expansion_{lhs_lower}_{rhs_lower}_{out_lower}_matches_multivector(a in any::<{lhs}<f64>>(), b in any::<{rhs}<f64>>()) {{
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, {sig}> = a.into();
            let mv_b: Multivector<f64, {sig}> = b.into();

            let specialized_result: {out}<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, {sig}> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={{:?}}, generic={{:?}}",
                specialized_mv, generic_result
            );
        }}
    }}
"#,
                    lhs_lower = lhs_lower,
                    rhs_lower = rhs_lower,
                    out_lower = out_lower,
                    lhs = entry.lhs,
                    rhs = entry.rhs,
                    out = entry.output,
                    sig = signature_name,
                )
            })
            .collect()
    }

    /// Generates weight expansion verification tests as a formatted string.
    fn generate_weight_expansion_verification_tests_raw(&self) -> String {
        if self.spec.products.weight_expansion.is_empty() {
            return String::new();
        }

        let signature_name = self.generate_signature_name();
        self.spec
            .products
            .weight_expansion
            .iter()
            // Only generate tests for single-grade types (where WeightExpand is implemented)
            .filter(|entry| {
                self.find_type(&entry.lhs)
                    .is_some_and(|t| self.is_single_grade_blade(t))
                    && self
                        .find_type(&entry.rhs)
                        .is_some_and(|t| self.is_single_grade_blade(t))
            })
            .map(|entry| {
                let lhs_lower = entry.lhs.to_lowercase();
                let rhs_lower = entry.rhs.to_lowercase();
                let out_lower = entry.output.to_lowercase();

                format!(
                    r#"
    proptest! {{
        #[test]
        fn weight_expansion_{lhs_lower}_{rhs_lower}_{out_lower}_matches_multivector(a in any::<{lhs}<f64>>(), b in any::<{rhs}<f64>>()) {{
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, {sig}> = a.into();
            let mv_b: Multivector<f64, {sig}> = b.into();

            let specialized_result: {out}<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, {sig}> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={{:?}}, generic={{:?}}",
                specialized_mv, generic_result
            );
        }}
    }}
"#,
                    lhs_lower = lhs_lower,
                    rhs_lower = rhs_lower,
                    out_lower = out_lower,
                    lhs = entry.lhs,
                    rhs = entry.rhs,
                    out = entry.output,
                    sig = signature_name,
                )
            })
            .collect()
    }

    /// Generates de-Morgan's law verification tests as a formatted string.
    ///
    /// Tests the fundamental identities from RGA:
    /// - complement(a * b) = complement(a) ⋇ complement(b)
    /// - complement(a ⋇ b) = complement(a) * complement(b)
    ///
    /// These tests verify that the complement and antiproduct operations
    /// on Multivector satisfy the de-Morgan duality laws.
    fn generate_de_morgan_verification_tests_raw(&self) -> String {
        let signature_name = self.generate_signature_name();

        // Generate tests for each non-alias type
        self.spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|ty| {
                let name = &ty.name;
                let name_lower = ty.name.to_lowercase();

                format!(
                    r#"
    proptest! {{
        /// De Morgan: complement(a * b) = complement(a) ⋇ complement(b)
        #[test]
        fn de_morgan_geometric_{name_lower}(a in any::<{name}<f64>>(), b in any::<{name}<f64>>()) {{
            let mv_a: Multivector<f64, {sig}> = a.into();
            let mv_b: Multivector<f64, {sig}> = b.into();

            // LHS: complement(a * b)
            let lhs = (&mv_a * &mv_b).complement();

            // RHS: complement(a) ⋇ complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={{:?}}, complement(a)⋇complement(b)={{:?}}",
                lhs, rhs
            );
        }}

        /// De Morgan: complement(a ⋇ b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_{name_lower}(a in any::<{name}<f64>>(), b in any::<{name}<f64>>()) {{
            let mv_a: Multivector<f64, {sig}> = a.into();
            let mv_b: Multivector<f64, {sig}> = b.into();

            // LHS: complement(a ⋇ b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = &mv_a.complement() * &mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(a⋇b)={{:?}}, complement(a)*complement(b)={{:?}}",
                lhs, rhs
            );
        }}
    }}
"#,
                    name_lower = name_lower,
                    name = name,
                    sig = signature_name,
                )
            })
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::spec::parse_spec;

    #[test]
    fn symbolica_generates_add_impl() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let (tokens, _tests) = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("impl < T : Float > Add for Vector"));
    }

    #[test]
    fn symbolica_generates_sub_impl() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let (tokens, _tests) = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("impl < T : Float > Sub for Vector"));
    }

    #[test]
    fn symbolica_generates_neg_impl() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let (tokens, _tests) = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("impl < T : Float > Neg for Vector"));
    }

    #[test]
    fn symbolica_generates_scalar_mul() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let (tokens, _tests) = generator.generate_traits_file();
        let code = tokens.to_string();

        // Check that scalar mul is generated for Vector
        assert!(code.contains("Mul"));
        assert!(code.contains("for Vector"));
        assert!(code.contains("scale"));
    }

    #[test]
    fn symbolica_generates_geometric_mul() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let (tokens, _tests) = generator.generate_traits_file();
        let code = tokens.to_string();

        // Vector * Vector should produce a product type
        assert!(code.contains("geometric_vector_vector"));
    }

    #[test]
    fn symbolica_generates_exterior() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let (tokens, _tests) = generator.generate_traits_file();
        let code = tokens.to_string();

        // Vector ^ Vector should produce Bivector
        assert!(code.contains("BitXor"));
        assert!(code.contains("exterior_vector_vector"));
    }

    #[test]
    fn symbolica_generates_approx_impls() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let (tokens, _tests) = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("AbsDiffEq for Vector"));
        assert!(code.contains("RelativeEq for Vector"));
        assert!(code.contains("UlpsEq for Vector"));
    }

    #[test]
    fn symbolica_generates_arbitrary_impls() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let (tokens, _tests) = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("impl < T : Float + Debug + 'static > Arbitrary for Vector"));
    }
}
