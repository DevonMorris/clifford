//! Trait implementation generation.
//!
//! This module provides the `TraitsGenerator` for generating Rust trait
//! implementations including operators, approx traits, and Arbitrary.

use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::algebra::{Algebra, ProductTable, geometric_grades};
use crate::spec::{AlgebraSpec, TypeSpec};

/// Generates trait implementations for algebra types.
///
/// The generator produces:
/// - Arithmetic operators (Add, Sub, Neg, Mul)
/// - Scalar multiplication
/// - Geometric and outer product operators
/// - Approx traits (AbsDiffEq, RelativeEq, UlpsEq)
/// - Arbitrary implementations for proptest
///
/// # Example
///
/// ```
/// use clifford_codegen::algebra::{Algebra, ProductTable};
/// use clifford_codegen::codegen::TraitsGenerator;
/// use clifford_codegen::spec::parse_spec;
///
/// let spec = parse_spec(r#"
/// [algebra]
/// name = "euclidean2"
///
/// [signature]
/// positive = ["e1", "e2"]
///
/// [types.Vector]
/// grades = [1]
/// fields = ["x", "y"]
///
/// [types.Bivector]
/// grades = [2]
/// fields = ["xy"]
/// "#).unwrap();
///
/// let algebra = Algebra::euclidean(2);
/// let table = ProductTable::new(&algebra);
/// let generator = TraitsGenerator::new(&spec, &algebra, table);
///
/// let tokens = generator.generate_traits_file();
/// let code = tokens.to_string();
///
/// assert!(code.contains("Add for Vector"));
/// ```
pub struct TraitsGenerator<'a> {
    /// The algebra specification.
    spec: &'a AlgebraSpec,
    /// The algebra for computations.
    algebra: &'a Algebra,
    /// The product table.
    #[allow(dead_code)]
    table: ProductTable,
}

impl<'a> TraitsGenerator<'a> {
    /// Creates a new traits generator.
    pub fn new(spec: &'a AlgebraSpec, algebra: &'a Algebra, table: ProductTable) -> Self {
        Self {
            spec,
            algebra,
            table,
        }
    }

    /// Generates the complete traits file.
    pub fn generate_traits_file(&self) -> TokenStream {
        let header = self.generate_header();
        let imports = self.generate_imports();
        let ops = self.generate_all_ops();
        let approx = self.generate_all_approx();
        let arbitrary = self.generate_all_arbitrary();

        quote! {
            #header
            #imports

            // ============================================================
            // Operator Implementations
            // ============================================================
            #ops

            // ============================================================
            // Approx Trait Implementations
            // ============================================================
            #approx

            // ============================================================
            // Arbitrary Implementations (for proptest)
            // ============================================================
            #arbitrary
        }
    }

    /// Generates the file header.
    fn generate_header(&self) -> TokenStream {
        let name = &self.spec.name;
        let header_doc = format!(
            r#"//! Trait implementations for {}.
//!
//! This file is auto-generated by clifford-codegen.
//! Do not edit manually."#,
            name
        );

        header_doc.parse().unwrap_or_else(|_| quote! {})
    }

    /// Generates import statements.
    fn generate_imports(&self) -> TokenStream {
        let type_names: Vec<_> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|t| format_ident!("{}", t.name))
            .collect();

        quote! {
            use crate::scalar::Float;
            use super::types::{#(#type_names),*};
            use super::products::*;

            use std::ops::{Add, Sub, Neg, Mul, BitXor};

            use approx::{AbsDiffEq, RelativeEq, UlpsEq};
        }
    }

    // ========================================================================
    // Operator Implementations
    // ========================================================================

    /// Generates all operator implementations.
    fn generate_all_ops(&self) -> TokenStream {
        let ops: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .flat_map(|ty| self.generate_ops_for_type(ty))
            .collect();

        quote! { #(#ops)* }
    }

    /// Generates operators for a single type.
    fn generate_ops_for_type(&self, ty: &TypeSpec) -> Vec<TokenStream> {
        let mut impls = Vec::new();

        // Same-type operations
        impls.push(self.generate_add(ty));
        impls.push(self.generate_sub(ty));
        impls.push(self.generate_neg(ty));
        impls.push(self.generate_scalar_mul(ty));
        impls.push(self.generate_scalar_mul_reverse_f32(ty));
        impls.push(self.generate_scalar_mul_reverse_f64(ty));

        // Cross-type operations (geometric product)
        for other in &self.spec.types {
            if other.alias_of.is_some() {
                continue;
            }
            if let Some(output_type) = self.find_geometric_output(ty, other) {
                impls.push(self.generate_geometric_mul(ty, other, output_type));
            }
        }

        // Outer product (using BitXor)
        for other in &self.spec.types {
            if other.alias_of.is_some() {
                continue;
            }
            if let Some(output_type) = self.find_outer_output(ty, other) {
                impls.push(self.generate_outer(ty, other, output_type));
            }
        }

        impls
    }

    /// Generates Add implementation.
    fn generate_add(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let field_adds: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname() + rhs.#fname() }
            })
            .collect();

        quote! {
            impl<T: Float> Add for #name<T> {
                type Output = Self;

                #[inline]
                fn add(self, rhs: Self) -> Self {
                    Self::new(#(#field_adds),*)
                }
            }
        }
    }

    /// Generates Sub implementation.
    fn generate_sub(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let field_subs: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname() - rhs.#fname() }
            })
            .collect();

        quote! {
            impl<T: Float> Sub for #name<T> {
                type Output = Self;

                #[inline]
                fn sub(self, rhs: Self) -> Self {
                    Self::new(#(#field_subs),*)
                }
            }
        }
    }

    /// Generates Neg implementation.
    fn generate_neg(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let field_negs: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { -self.#fname() }
            })
            .collect();

        quote! {
            impl<T: Float> Neg for #name<T> {
                type Output = Self;

                #[inline]
                fn neg(self) -> Self {
                    Self::new(#(#field_negs),*)
                }
            }
        }
    }

    /// Generates scalar multiplication (Type * T).
    fn generate_scalar_mul(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        quote! {
            impl<T: Float> Mul<T> for #name<T> {
                type Output = Self;

                #[inline]
                fn mul(self, scalar: T) -> Self {
                    self.scale(scalar)
                }
            }
        }
    }

    /// Generates reverse scalar multiplication for f32 (f32 * Type).
    fn generate_scalar_mul_reverse_f32(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        quote! {
            impl Mul<#name<f32>> for f32 {
                type Output = #name<f32>;

                #[inline]
                fn mul(self, v: #name<f32>) -> #name<f32> {
                    v.scale(self)
                }
            }
        }
    }

    /// Generates reverse scalar multiplication for f64 (f64 * Type).
    fn generate_scalar_mul_reverse_f64(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        quote! {
            impl Mul<#name<f64>> for f64 {
                type Output = #name<f64>;

                #[inline]
                fn mul(self, v: #name<f64>) -> #name<f64> {
                    v.scale(self)
                }
            }
        }
    }

    /// Generates geometric product (Type * Other -> Output).
    fn generate_geometric_mul(&self, a: &TypeSpec, b: &TypeSpec, output: &TypeSpec) -> TokenStream {
        let a_name = format_ident!("{}", a.name);
        let b_name = format_ident!("{}", b.name);
        let out_name = format_ident!("{}", output.name);
        let fn_name = format_ident!(
            "geometric_{}_{}",
            a.name.to_lowercase(),
            b.name.to_lowercase()
        );

        quote! {
            impl<T: Float> Mul<#b_name<T>> for #a_name<T> {
                type Output = #out_name<T>;

                #[inline]
                fn mul(self, rhs: #b_name<T>) -> #out_name<T> {
                    #fn_name(&self, &rhs)
                }
            }
        }
    }

    /// Generates outer product (Type ^ Other -> Output).
    fn generate_outer(&self, a: &TypeSpec, b: &TypeSpec, output: &TypeSpec) -> TokenStream {
        let a_name = format_ident!("{}", a.name);
        let b_name = format_ident!("{}", b.name);
        let out_name = format_ident!("{}", output.name);
        let fn_name = format_ident!("outer_{}_{}", a.name.to_lowercase(), b.name.to_lowercase());

        quote! {
            impl<T: Float> BitXor<#b_name<T>> for #a_name<T> {
                type Output = #out_name<T>;

                #[inline]
                fn bitxor(self, rhs: #b_name<T>) -> #out_name<T> {
                    #fn_name(&self, &rhs)
                }
            }
        }
    }

    /// Finds the output type for geometric product.
    fn find_geometric_output(&self, a: &TypeSpec, b: &TypeSpec) -> Option<&TypeSpec> {
        let dim = self.algebra.dim();
        let output_grades = self.compute_geometric_output_grades(a, b, dim);
        self.find_type_for_grades(&output_grades)
    }

    /// Finds the output type for outer product.
    fn find_outer_output(&self, a: &TypeSpec, b: &TypeSpec) -> Option<&TypeSpec> {
        let dim = self.algebra.dim();
        let output_grades = self.compute_outer_output_grades(a, b, dim);
        if output_grades.is_empty() {
            return None;
        }
        self.find_type_for_grades(&output_grades)
    }

    /// Computes output grades for geometric product.
    fn compute_geometric_output_grades(
        &self,
        a: &TypeSpec,
        b: &TypeSpec,
        dim: usize,
    ) -> Vec<usize> {
        let mut grades = Vec::new();
        for &ga in &a.grades {
            for &gb in &b.grades {
                for g in geometric_grades(ga, gb, dim) {
                    if !grades.contains(&g) {
                        grades.push(g);
                    }
                }
            }
        }
        grades.sort();
        grades
    }

    /// Computes output grades for outer product.
    fn compute_outer_output_grades(&self, a: &TypeSpec, b: &TypeSpec, dim: usize) -> Vec<usize> {
        let mut grades = Vec::new();
        for &ga in &a.grades {
            for &gb in &b.grades {
                let sum = ga + gb;
                if sum <= dim && !grades.contains(&sum) {
                    grades.push(sum);
                }
            }
        }
        grades.sort();
        grades
    }

    /// Finds a type that contains exactly the given grades.
    fn find_type_for_grades(&self, grades: &[usize]) -> Option<&TypeSpec> {
        self.spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .find(|t| t.grades == grades)
    }

    // ========================================================================
    // Approx Trait Implementations
    // ========================================================================

    /// Generates all approx trait implementations.
    fn generate_all_approx(&self) -> TokenStream {
        let impls: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|ty| self.generate_approx_impls(ty))
            .collect();

        quote! { #(#impls)* }
    }

    /// Generates approx trait implementations for a type.
    fn generate_approx_impls(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);

        let abs_diff_checks: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname().abs_diff_eq(&other.#fname(), epsilon) }
            })
            .collect();

        let relative_checks: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname().relative_eq(&other.#fname(), epsilon, max_relative) }
            })
            .collect();

        let ulps_checks: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|f| {
                let fname = format_ident!("{}", f.name);
                quote! { self.#fname().ulps_eq(&other.#fname(), epsilon, max_ulps) }
            })
            .collect();

        quote! {
            impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for #name<T> {
                type Epsilon = T;

                fn default_epsilon() -> Self::Epsilon {
                    T::default_epsilon()
                }

                fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
                    #(#abs_diff_checks)&&*
                }
            }

            impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for #name<T> {
                fn default_max_relative() -> Self::Epsilon {
                    T::default_max_relative()
                }

                fn relative_eq(
                    &self,
                    other: &Self,
                    epsilon: Self::Epsilon,
                    max_relative: Self::Epsilon,
                ) -> bool {
                    #(#relative_checks)&&*
                }
            }

            impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for #name<T> {
                fn default_max_ulps() -> u32 {
                    T::default_max_ulps()
                }

                fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
                    #(#ulps_checks)&&*
                }
            }
        }
    }

    // ========================================================================
    // Arbitrary Implementations
    // ========================================================================

    /// Generates all Arbitrary implementations.
    fn generate_all_arbitrary(&self) -> TokenStream {
        let impls: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|ty| self.generate_arbitrary_impl(ty))
            .collect();

        quote! {
            #[cfg(any(test, feature = "proptest-support"))]
            mod arbitrary_impls {
                use super::*;
                use proptest::prelude::*;
                use proptest::strategy::BoxedStrategy;
                use std::fmt::Debug;

                #(#impls)*
            }
        }
    }

    /// Generates Arbitrary implementation for a type.
    fn generate_arbitrary_impl(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let num_fields = ty.fields.len();

        // Generate tuple of ranges
        let range_tuple: Vec<TokenStream> = (0..num_fields)
            .map(|_| quote! { -100.0f64..100.0 })
            .collect();

        let prop_map_args: Vec<TokenStream> = (0..num_fields)
            .map(|i| {
                let var = format_ident!("x{}", i);
                quote! { #var }
            })
            .collect();

        let field_inits: Vec<TokenStream> = (0..num_fields)
            .map(|i| {
                let var = format_ident!("x{}", i);
                quote! { T::from_f64(#var) }
            })
            .collect();

        quote! {
            impl<T: Float + Debug + 'static> Arbitrary for #name<T> {
                type Parameters = ();
                type Strategy = BoxedStrategy<Self>;

                fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
                    (#(#range_tuple),*)
                        .prop_map(|(#(#prop_map_args),*)| {
                            #name::new(#(#field_inits),*)
                        })
                        .boxed()
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::spec::parse_spec;

    #[test]
    fn generates_add_impl() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let tokens = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("impl < T : Float > Add for Vector"));
    }

    #[test]
    fn generates_sub_impl() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let tokens = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("impl < T : Float > Sub for Vector"));
    }

    #[test]
    fn generates_neg_impl() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let tokens = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("impl < T : Float > Neg for Vector"));
    }

    #[test]
    fn generates_scalar_mul() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let tokens = generator.generate_traits_file();
        let code = tokens.to_string();

        // Check that scalar mul is generated for Vector
        assert!(code.contains("Mul"));
        assert!(code.contains("for Vector"));
        assert!(code.contains("scale"));
    }

    #[test]
    fn generates_geometric_mul() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let tokens = generator.generate_traits_file();
        let code = tokens.to_string();

        // Vector * Vector should produce a product type
        assert!(code.contains("geometric_vector_vector"));
    }

    #[test]
    fn generates_outer() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let tokens = generator.generate_traits_file();
        let code = tokens.to_string();

        // Vector ^ Vector should produce Bivector
        assert!(code.contains("BitXor"));
        assert!(code.contains("outer_vector_vector"));
    }

    #[test]
    fn generates_approx_impls() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let tokens = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("AbsDiffEq for Vector"));
        assert!(code.contains("RelativeEq for Vector"));
        assert!(code.contains("UlpsEq for Vector"));
    }

    #[test]
    fn generates_arbitrary_impls() {
        let spec = parse_spec(include_str!("../../algebras/euclidean3.toml")).unwrap();
        let algebra = Algebra::euclidean(3);
        let table = ProductTable::new(&algebra);
        let generator = TraitsGenerator::new(&spec, &algebra, table);

        let tokens = generator.generate_traits_file();
        let code = tokens.to_string();

        assert!(code.contains("impl < T : Float + Debug + 'static > Arbitrary for Vector"));
    }
}
