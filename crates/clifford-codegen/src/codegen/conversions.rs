//! Multivector conversion generation.
//!
//! This module generates `From` implementations for converting specialized
//! types to and from generic `Multivector`.

use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::algebra::Algebra;
use crate::spec::{AlgebraSpec, TypeSpec};

/// Generates Multivector conversion implementations.
///
/// # Example
///
/// ```
/// use clifford_codegen::algebra::Algebra;
/// use clifford_codegen::codegen::ConversionsGenerator;
/// use clifford_codegen::spec::parse_spec;
///
/// let spec = parse_spec(r#"
/// [algebra]
/// name = "euclidean2"
///
/// [signature]
/// positive = ["e1", "e2"]
///
/// [types.Vector]
/// grades = [1]
/// fields = ["x", "y"]
/// "#).unwrap();
///
/// let algebra = Algebra::euclidean(2);
/// let generator = ConversionsGenerator::new(&spec, &algebra);
///
/// let tokens = generator.generate_conversions_file();
/// let code = tokens.to_string();
///
/// assert!(code.contains("From < Vector"));
/// assert!(code.contains("for Multivector"));
/// ```
pub struct ConversionsGenerator<'a> {
    /// The algebra specification.
    spec: &'a AlgebraSpec,
    /// The algebra for computations.
    algebra: &'a Algebra,
}

impl<'a> ConversionsGenerator<'a> {
    /// Creates a new conversions generator.
    pub fn new(spec: &'a AlgebraSpec, algebra: &'a Algebra) -> Self {
        Self { spec, algebra }
    }

    /// Generates the complete conversions file.
    pub fn generate_conversions_file(&self) -> TokenStream {
        let header = self.generate_header();
        let imports = self.generate_imports();
        let to_mv = self.generate_all_to_multivector();
        let from_mv = self.generate_all_from_multivector();

        quote! {
            #header
            #imports

            // ============================================================
            // From<Type> for Multivector
            // ============================================================
            #to_mv

            // ============================================================
            // From<Multivector> for Type (lossy projection)
            // ============================================================
            #from_mv
        }
    }

    /// Generates the file header.
    fn generate_header(&self) -> TokenStream {
        let name = &self.spec.name;
        let header_doc = format!(
            r#"//! Multivector conversions for {}.
//!
//! This file is auto-generated by clifford-codegen.
//! Do not edit manually."#,
            name
        );

        header_doc.parse().unwrap_or_else(|_| quote! {})
    }

    /// Generates import statements.
    fn generate_imports(&self) -> TokenStream {
        let signature_name = self.generate_signature_name();
        let type_names: Vec<_> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|t| format_ident!("{}", t.name))
            .collect();

        quote! {
            use crate::algebra::Multivector;
            use crate::basis::Blade;
            use crate::scalar::Float;
            use crate::signature::#signature_name;
            use super::types::{#(#type_names),*};
        }
    }

    /// Generates the signature type name.
    ///
    /// Uses the signature tuple (p, q, r) to determine the signature type,
    /// not the algebra name. This ensures generic handling of all algebras.
    fn generate_signature_name(&self) -> proc_macro2::Ident {
        let sig = &self.spec.signature;
        let (p, q, r) = (sig.p, sig.q, sig.r);

        // Derive signature type from (p, q, r)
        let sig_name = match (p, q, r) {
            // Euclidean: Cl(n, 0, 0)
            (2, 0, 0) => "Euclidean2",
            (3, 0, 0) => "Euclidean3",

            // Projective (PGA): Cl(n, 0, 1)
            (2, 0, 1) => "Projective2",
            (3, 0, 1) => "Projective3",

            // Conformal (CGA): Cl(n+1, 1, 0)
            (4, 1, 0) => "Conformal3",

            // Minkowski spacetime: Cl(1, 3, 0)
            (1, 3, 0) => "Minkowski4",

            // Generic: use Cl{p}_{q}_{r} format
            _ => {
                return format_ident!("Cl{}_{}_{}", p, q, r);
            }
        };
        format_ident!("{}", sig_name)
    }

    /// Generates all `From<Type> for Multivector` implementations.
    fn generate_all_to_multivector(&self) -> TokenStream {
        let impls: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|ty| self.generate_to_multivector(ty))
            .collect();

        quote! { #(#impls)* }
    }

    /// Generates `From<Type> for Multivector` for a single type.
    fn generate_to_multivector(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let signature_name = self.generate_signature_name();

        // Build array of coefficient assignments
        let num_blades = 1usize << self.algebra.dim();
        let mut coeffs: Vec<TokenStream> = vec![quote! { T::zero() }; num_blades];

        for field in &ty.fields {
            let field_name = format_ident!("{}", field.name);
            let idx = field.blade_index;
            // Apply field sign: if field stores e31 (sign=-1), we need to negate
            // to get the canonical e13 coefficient for the multivector.
            if field.sign < 0 {
                coeffs[idx] = quote! { -value.#field_name() };
            } else {
                coeffs[idx] = quote! { value.#field_name() };
            }
        }

        quote! {
            impl<T: Float> From<#name<T>> for Multivector<T, #signature_name> {
                fn from(value: #name<T>) -> Self {
                    Self::from_coeffs(&[#(#coeffs),*])
                }
            }
        }
    }

    /// Generates all `From<Multivector> for Type` implementations.
    fn generate_all_from_multivector(&self) -> TokenStream {
        let impls: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|ty| self.generate_from_multivector(ty))
            .collect();

        quote! { #(#impls)* }
    }

    /// Generates `From<Multivector> for Type` for a single type.
    ///
    /// Note: This is a lossy projection that only extracts the relevant grades.
    /// For constrained types, uses `new_unchecked()` since the multivector may not
    /// satisfy the geometric constraint.
    fn generate_from_multivector(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let signature_name = self.generate_signature_name();

        // Build constructor arguments from multivector coefficients
        let field_extracts: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let idx = field.blade_index;
                // Apply field sign: if field stores e31 (sign=-1), we need to negate
                // the canonical e13 coefficient from the multivector.
                if field.sign < 0 {
                    quote! { -mv.get(Blade::from_index(#idx)) }
                } else {
                    quote! { mv.get(Blade::from_index(#idx)) }
                }
            })
            .collect();

        let constructor = quote! { Self::new_unchecked(#(#field_extracts),*) };

        let doc = quote! {
            /// Extracts this type from a multivector.
            ///
            /// Note: This is a lossy projection that only extracts the relevant
            /// grades. Other components of the multivector are discarded.
        };

        quote! {
            impl<T: Float> From<Multivector<T, #signature_name>> for #name<T> {
                #doc
                fn from(mv: Multivector<T, #signature_name>) -> Self {
                    #constructor
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::spec::parse_spec;

    #[test]
    fn generates_to_multivector() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean2.toml")).unwrap();
        let algebra = Algebra::euclidean(2);
        let generator = ConversionsGenerator::new(&spec, &algebra);

        let tokens = generator.generate_conversions_file();
        let code = tokens.to_string();

        assert!(code.contains("From < Vector"));
        assert!(code.contains("for Multivector"));
    }

    #[test]
    fn generates_from_multivector() {
        let spec = parse_spec(include_str!("../../../../algebras/euclidean2.toml")).unwrap();
        let algebra = Algebra::euclidean(2);
        let generator = ConversionsGenerator::new(&spec, &algebra);

        let tokens = generator.generate_conversions_file();
        let code = tokens.to_string();

        assert!(code.contains("From < Multivector"));
        assert!(code.contains("for Vector"));
    }
}
