//! Multivector conversion generation.
//!
//! This module generates `From` implementations for converting specialized
//! types to and from generic `Multivector`.

use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::algebra::Algebra;
use crate::spec::{AlgebraSpec, TypeSpec};

/// Generates Multivector conversion implementations.
///
/// # Example
///
/// ```
/// use clifford_codegen::algebra::Algebra;
/// use clifford_codegen::codegen::ConversionsGenerator;
/// use clifford_codegen::spec::parse_spec;
///
/// let spec = parse_spec(r#"
/// [algebra]
/// name = "euclidean2"
///
/// [signature]
/// positive = ["e1", "e2"]
///
/// [types.Vector]
/// grades = [1]
/// fields = ["x", "y"]
/// "#).unwrap();
///
/// let algebra = Algebra::euclidean(2);
/// let generator = ConversionsGenerator::new(&spec, &algebra);
///
/// let tokens = generator.generate_conversions_file();
/// let code = tokens.to_string();
///
/// assert!(code.contains("From < Vector"));
/// assert!(code.contains("for Multivector"));
/// ```
pub struct ConversionsGenerator<'a> {
    /// The algebra specification.
    spec: &'a AlgebraSpec,
    /// The algebra for computations.
    algebra: &'a Algebra,
}

impl<'a> ConversionsGenerator<'a> {
    /// Creates a new conversions generator.
    pub fn new(spec: &'a AlgebraSpec, algebra: &'a Algebra) -> Self {
        Self { spec, algebra }
    }

    /// Generates the complete conversions file.
    pub fn generate_conversions_file(&self) -> TokenStream {
        let header = self.generate_header();
        let imports = self.generate_imports();
        let to_mv = self.generate_all_to_multivector();
        let from_mv = self.generate_all_from_multivector();

        quote! {
            #header
            #imports

            // ============================================================
            // From<Type> for Multivector
            // ============================================================
            #to_mv

            // ============================================================
            // From<Multivector> for Type (lossy projection)
            // ============================================================
            #from_mv
        }
    }

    /// Generates the file header.
    fn generate_header(&self) -> TokenStream {
        let name = &self.spec.name;
        let header_doc = format!(
            r#"//! Multivector conversions for {}.
//!
//! This file is auto-generated by clifford-codegen.
//! Do not edit manually."#,
            name
        );

        header_doc.parse().unwrap_or_else(|_| quote! {})
    }

    /// Generates import statements.
    fn generate_imports(&self) -> TokenStream {
        let signature_name = self.generate_signature_name();
        let type_names: Vec<_> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|t| format_ident!("{}", t.name))
            .collect();

        quote! {
            use crate::algebra::Multivector;
            use crate::basis::Blade;
            use crate::scalar::Float;
            use crate::signature::#signature_name;
            use super::types::{#(#type_names),*};
        }
    }

    /// Generates the signature type name.
    fn generate_signature_name(&self) -> proc_macro2::Ident {
        let name = &self.spec.name;
        let sig_name = if name.starts_with("euclidean") {
            match self.algebra.dim() {
                2 => "Euclidean2",
                3 => "Euclidean3",
                _ => "Euclidean3",
            }
        } else if name.starts_with("pga") || name.starts_with("projective") {
            match self.algebra.dim() {
                3 => "Projective2",
                4 => "Projective3",
                _ => "Projective3",
            }
        } else if name.starts_with("cga") || name.starts_with("conformal") {
            match self.algebra.dim() {
                4 => "Conformal2",
                5 => "Conformal3",
                _ => "Conformal3",
            }
        } else {
            "CustomSignature"
        };
        format_ident!("{}", sig_name)
    }

    /// Generates all `From<Type> for Multivector` implementations.
    fn generate_all_to_multivector(&self) -> TokenStream {
        let impls: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|ty| self.generate_to_multivector(ty))
            .collect();

        quote! { #(#impls)* }
    }

    /// Generates `From<Type> for Multivector` for a single type.
    fn generate_to_multivector(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let signature_name = self.generate_signature_name();

        // Build array of coefficient assignments
        let num_blades = 1usize << self.algebra.dim();
        let mut coeffs: Vec<TokenStream> = vec![quote! { T::zero() }; num_blades];

        for field in &ty.fields {
            let field_name = format_ident!("{}", field.name);
            let idx = field.blade_index;
            coeffs[idx] = quote! { value.#field_name() };
        }

        quote! {
            impl<T: Float> From<#name<T>> for Multivector<T, #signature_name> {
                fn from(value: #name<T>) -> Self {
                    Self::from_coeffs(&[#(#coeffs),*])
                }
            }
        }
    }

    /// Generates all `From<Multivector> for Type` implementations.
    fn generate_all_from_multivector(&self) -> TokenStream {
        let impls: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|ty| self.generate_from_multivector(ty))
            .collect();

        quote! { #(#impls)* }
    }

    /// Generates `From<Multivector> for Type` for a single type.
    ///
    /// Note: This is a lossy projection that only extracts the relevant grades.
    /// For constrained types, uses `new_unchecked()` since the multivector may not
    /// satisfy the geometric constraint.
    fn generate_from_multivector(&self, ty: &TypeSpec) -> TokenStream {
        let name = format_ident!("{}", ty.name);
        let signature_name = self.generate_signature_name();

        // Build constructor arguments from multivector coefficients
        let field_extracts: Vec<TokenStream> = ty
            .fields
            .iter()
            .map(|field| {
                let idx = field.blade_index;
                quote! { mv.get(Blade::from_index(#idx)) }
            })
            .collect();

        // Use new_unchecked for constrained types since the multivector
        // may not satisfy the geometric constraint
        let has_solve_for = !ty.solve_for_fields().is_empty();
        let constructor = if has_solve_for {
            quote! { Self::new_unchecked(#(#field_extracts),*) }
        } else {
            quote! { Self::new(#(#field_extracts),*) }
        };

        let doc = if has_solve_for {
            quote! {
                /// Extracts this type from a multivector.
                ///
                /// Note: This is a lossy projection that only extracts the relevant
                /// grades. Other components of the multivector are discarded.
                ///
                /// **Warning:** Uses `new_unchecked()` since the source multivector
                /// may not satisfy the geometric constraint. Verify the constraint
                /// manually if needed.
            }
        } else {
            quote! {
                /// Extracts this type from a multivector.
                ///
                /// Note: This is a lossy projection that only extracts the relevant
                /// grades. Other components of the multivector are discarded.
            }
        };

        quote! {
            impl<T: Float> From<Multivector<T, #signature_name>> for #name<T> {
                #doc
                fn from(mv: Multivector<T, #signature_name>) -> Self {
                    #constructor
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::spec::parse_spec;

    #[test]
    fn generates_to_multivector() {
        let spec = parse_spec(include_str!("../../algebras/euclidean2.toml")).unwrap();
        let algebra = Algebra::euclidean(2);
        let generator = ConversionsGenerator::new(&spec, &algebra);

        let tokens = generator.generate_conversions_file();
        let code = tokens.to_string();

        assert!(code.contains("From < Vector"));
        assert!(code.contains("for Multivector"));
    }

    #[test]
    fn generates_from_multivector() {
        let spec = parse_spec(include_str!("../../algebras/euclidean2.toml")).unwrap();
        let algebra = Algebra::euclidean(2);
        let generator = ConversionsGenerator::new(&spec, &algebra);

        let tokens = generator.generate_conversions_file();
        let code = tokens.to_string();

        assert!(code.contains("From < Multivector"));
        assert!(code.contains("for Vector"));
    }
}
