//! Constrained type generation.
//!
//! This module provides the `ConstraintGenerator` for generating type-safe
//! wrapper types that enforce algebraic constraints (unit, nonzero, etc.).
//!
//! Constraints only depend on methods generated by codegen:
//! - `Unit` uses `norm()` (generated for all types)
//! - `NonZero` uses `norm_squared()` (generated for all types)
//!
//! For constraints like `Null`, `Normalized`, or `Ideal`, only `new_unchecked()`
//! is generated since the check expression depends on domain-specific knowledge.
//! Users must implement their own validation for these types.

use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::algebra::Algebra;
use crate::spec::{AlgebraSpec, ConstraintKind, ConstraintSpec, TypeSpec};

/// Generates constrained wrapper types.
///
/// The generator produces wrapper types that enforce constraints using
/// only methods generated by codegen:
/// - Unit types use `norm()` to check `|norm - 1| < tolerance`
/// - NonZero types use `norm_squared()` to check `norm_squared > tolerance`
///
/// For Null, Normalized, and Ideal constraints, only `new_unchecked()` is
/// generated since the validation depends on user-specific logic.
///
/// # Example
///
/// ```
/// use clifford_codegen::algebra::Algebra;
/// use clifford_codegen::codegen::ConstraintGenerator;
/// use clifford_codegen::spec::parse_spec;
///
/// let spec = parse_spec(r#"
/// [algebra]
/// name = "euclidean2"
///
/// [signature]
/// positive = ["e1", "e2"]
///
/// [types.Vector]
/// grades = [1]
/// fields = ["x", "y"]
///
/// [types.Vector.constraints.unit]
/// norm = "euclidean"
/// "#).unwrap();
///
/// let algebra = Algebra::euclidean(2);
/// let generator = ConstraintGenerator::new(&spec, &algebra);
///
/// let tokens = generator.generate_constraints_file();
/// let code = tokens.to_string();
///
/// assert!(code.contains("UnitVector"));
/// assert!(code.contains("fn new"));
/// ```
pub struct ConstraintGenerator<'a> {
    /// The algebra specification.
    spec: &'a AlgebraSpec,
    /// The algebra for computations.
    #[allow(dead_code)]
    algebra: &'a Algebra,
}

impl<'a> ConstraintGenerator<'a> {
    /// Creates a new constraint generator.
    pub fn new(spec: &'a AlgebraSpec, algebra: &'a Algebra) -> Self {
        Self { spec, algebra }
    }

    /// Generates the complete constrained types file.
    pub fn generate_constraints_file(&self) -> TokenStream {
        let header = self.generate_header();
        let imports = self.generate_imports();

        let wrappers: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .flat_map(|ty| self.generate_constraints_for_type(ty))
            .collect();

        quote! {
            #header
            #imports

            #(#wrappers)*
        }
    }

    /// Generates the file header.
    fn generate_header(&self) -> TokenStream {
        let name = &self.spec.name;
        let header_doc = format!(
            r#"//! Constrained wrapper types for {}.
//!
//! This file is auto-generated by clifford-codegen.
//! Do not edit manually."#,
            name
        );

        header_doc.parse().unwrap_or_else(|_| quote! {})
    }

    /// Generates import statements.
    fn generate_imports(&self) -> TokenStream {
        let type_names: Vec<_> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|t| format_ident!("{}", t.name))
            .collect();

        quote! {
            use crate::scalar::Float;
            use super::types::{#(#type_names),*};
        }
    }

    /// Generates all constraints for a type.
    fn generate_constraints_for_type(&self, ty: &TypeSpec) -> Vec<TokenStream> {
        ty.constraints
            .iter()
            .map(|c| self.generate_constraint(ty, c))
            .collect()
    }

    /// Generates a single constraint wrapper.
    fn generate_constraint(
        &self,
        base_type: &TypeSpec,
        constraint: &ConstraintSpec,
    ) -> TokenStream {
        match constraint.kind {
            ConstraintKind::Unit => self.generate_unit_wrapper(base_type, constraint),
            ConstraintKind::NonZero => self.generate_nonzero_wrapper(base_type, constraint),
            // These constraints require user-specified validation logic
            ConstraintKind::Normalized | ConstraintKind::Null | ConstraintKind::Ideal => {
                self.generate_unchecked_only_wrapper(base_type, constraint)
            }
        }
    }

    /// Generates a unit constraint wrapper.
    ///
    /// Uses the generated `norm()` method to check `|norm - 1| < tolerance`.
    fn generate_unit_wrapper(
        &self,
        base_type: &TypeSpec,
        constraint: &ConstraintSpec,
    ) -> TokenStream {
        let base_name = format_ident!("{}", base_type.name);
        let wrapper_name = format_ident!("{}", constraint.wrapper_name);

        let doc = format!(
            "Unit {} with guaranteed norm = 1.\n\n\
            This wrapper type ensures the {} always has unit norm.\n\n\
            # Panics\n\n\
            The `new()` constructor panics if `|norm - 1| >= tolerance`.",
            base_type.name,
            base_type.name.to_lowercase()
        );

        let common_impls = self.generate_common_impls(base_type, constraint);

        quote! {
            #[doc = #doc]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(transparent)]
            pub struct #wrapper_name<T: Float>(#base_name<T>);

            impl<T: Float> #wrapper_name<T> {
                /// Creates a unit wrapper, validating the constraint.
                ///
                /// Uses the generated `norm()` method to validate.
                ///
                /// # Arguments
                ///
                /// * `inner` - The element to wrap
                /// * `tolerance` - Maximum allowed deviation from unit norm
                ///
                /// # Panics
                ///
                /// Panics if `|inner.norm() - 1| >= tolerance`.
                #[inline]
                pub fn new(inner: #base_name<T>, tolerance: T) -> Self {
                    let norm = inner.norm();
                    let deviation = if norm > T::one() {
                        norm - T::one()
                    } else {
                        T::one() - norm
                    };
                    assert!(
                        deviation < tolerance,
                        "unit constraint violated: |norm - 1| = {:?} >= tolerance",
                        deviation
                    );
                    Self(inner)
                }

                /// Creates from components without validation.
                ///
                /// # Safety (Logical)
                ///
                /// Caller must ensure the element has unit norm.
                #[inline]
                pub fn new_unchecked(inner: #base_name<T>) -> Self {
                    Self(inner)
                }

                /// Returns the underlying element.
                #[inline]
                pub fn into_inner(self) -> #base_name<T> {
                    self.0
                }
            }

            #common_impls
        }
    }

    /// Generates a nonzero constraint wrapper.
    ///
    /// Uses the generated `norm_squared()` method to check `norm_squared > tolerance`.
    fn generate_nonzero_wrapper(
        &self,
        base_type: &TypeSpec,
        constraint: &ConstraintSpec,
    ) -> TokenStream {
        let base_name = format_ident!("{}", base_type.name);
        let wrapper_name = format_ident!("{}", constraint.wrapper_name);

        let doc = format!(
            "Non-zero {} with guaranteed norm > 0.\n\n\
            This wrapper type ensures the {} is never zero.\n\n\
            # Panics\n\n\
            The `new()` constructor panics if `norm_squared <= tolerance`.",
            base_type.name,
            base_type.name.to_lowercase()
        );

        let common_impls = self.generate_common_impls(base_type, constraint);

        quote! {
            #[doc = #doc]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(transparent)]
            pub struct #wrapper_name<T: Float>(#base_name<T>);

            impl<T: Float> #wrapper_name<T> {
                /// Creates a non-zero wrapper, validating the constraint.
                ///
                /// Uses the generated `norm_squared()` method to validate.
                ///
                /// # Arguments
                ///
                /// * `inner` - The element to wrap
                /// * `tolerance` - Minimum required norm squared
                ///
                /// # Panics
                ///
                /// Panics if `inner.norm_squared() <= tolerance`.
                #[inline]
                pub fn new(inner: #base_name<T>, tolerance: T) -> Self {
                    let norm_sq = inner.norm_squared();
                    assert!(
                        norm_sq > tolerance,
                        "nonzero constraint violated: norm_squared = {:?} <= tolerance",
                        norm_sq
                    );
                    Self(inner)
                }

                /// Creates from components without validation.
                ///
                /// # Safety (Logical)
                ///
                /// Caller must ensure the element is non-zero.
                #[inline]
                pub fn new_unchecked(inner: #base_name<T>) -> Self {
                    Self(inner)
                }

                /// Returns the underlying element.
                #[inline]
                pub fn into_inner(self) -> #base_name<T> {
                    self.0
                }

                /// Normalizes this non-zero element to unit norm.
                #[inline]
                pub fn normalize(self) -> #base_name<T> {
                    self.0.normalize()
                }
            }

            #common_impls
        }
    }

    /// Generates a wrapper with only `new_unchecked()`.
    ///
    /// Used for constraints (Null, Normalized, Ideal) where the validation
    /// logic depends on user-specific knowledge not available to codegen.
    fn generate_unchecked_only_wrapper(
        &self,
        base_type: &TypeSpec,
        constraint: &ConstraintSpec,
    ) -> TokenStream {
        let base_name = format_ident!("{}", base_type.name);
        let wrapper_name = format_ident!("{}", constraint.wrapper_name);

        let constraint_desc = match constraint.kind {
            ConstraintKind::Null => "null (zero self-inner-product)",
            ConstraintKind::Normalized => "normalized (canonical form)",
            ConstraintKind::Ideal => "ideal (point at infinity)",
            _ => "constrained",
        };

        let doc = format!(
            "{} {} wrapper type.\n\n\
            This constraint requires user-specific validation logic.\n\
            Only `new_unchecked()` is provided; implement your own\n\
            validated constructor based on your domain requirements.",
            constraint.wrapper_name, base_type.name
        );

        let note = format!(
            "This is a {} element. The codegen cannot generate\n\
            automatic validation for this constraint type.\n\
            Users should implement a validated `new()` method.",
            constraint_desc
        );

        let common_impls = self.generate_common_impls(base_type, constraint);

        quote! {
            #[doc = #doc]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(transparent)]
            pub struct #wrapper_name<T: Float>(#base_name<T>);

            impl<T: Float> #wrapper_name<T> {
                /// Creates from components without validation.
                ///
                #[doc = #note]
                ///
                /// # Safety (Logical)
                ///
                /// Caller must ensure the element satisfies the constraint.
                #[inline]
                pub fn new_unchecked(inner: #base_name<T>) -> Self {
                    Self(inner)
                }

                /// Returns the underlying element.
                #[inline]
                pub fn into_inner(self) -> #base_name<T> {
                    self.0
                }
            }

            #common_impls
        }
    }

    /// Generates common implementations (Deref, AsRef, From).
    fn generate_common_impls(
        &self,
        base_type: &TypeSpec,
        constraint: &ConstraintSpec,
    ) -> TokenStream {
        let base_name = format_ident!("{}", base_type.name);
        let wrapper_name = format_ident!("{}", constraint.wrapper_name);

        quote! {
            impl<T: Float> std::ops::Deref for #wrapper_name<T> {
                type Target = #base_name<T>;

                #[inline]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }

            impl<T: Float> AsRef<#base_name<T>> for #wrapper_name<T> {
                #[inline]
                fn as_ref(&self) -> &#base_name<T> {
                    &self.0
                }
            }

            impl<T: Float> From<#wrapper_name<T>> for #base_name<T> {
                #[inline]
                fn from(wrapper: #wrapper_name<T>) -> Self {
                    wrapper.0
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::spec::parse_spec;

    #[test]
    fn generates_unit_wrapper_with_validation() {
        let spec = parse_spec(
            r#"
[algebra]
name = "euclidean2"

[signature]
positive = ["e1", "e2"]

[types.Vector]
grades = [1]
fields = ["x", "y"]

[types.Vector.constraints.unit]
norm = "euclidean"
"#,
        )
        .unwrap();

        let algebra = Algebra::euclidean(2);
        let generator = ConstraintGenerator::new(&spec, &algebra);

        let tokens = generator.generate_constraints_file();
        let code = tokens.to_string();

        assert!(code.contains("UnitVector"));
        assert!(code.contains("fn new"));
        assert!(code.contains("fn new_unchecked"));
        assert!(code.contains("inner.norm()"));
        assert!(code.contains("tolerance"));
    }

    #[test]
    fn generates_nonzero_wrapper_with_validation() {
        let spec = parse_spec(
            r#"
[algebra]
name = "euclidean2"

[signature]
positive = ["e1", "e2"]

[types.Vector]
grades = [1]
fields = ["x", "y"]

[types.Vector.constraints.nonzero]
condition = "norm_squared > epsilon"
"#,
        )
        .unwrap();

        let algebra = Algebra::euclidean(2);
        let generator = ConstraintGenerator::new(&spec, &algebra);

        let tokens = generator.generate_constraints_file();
        let code = tokens.to_string();

        assert!(code.contains("NonZeroVector"));
        assert!(code.contains("fn new"));
        assert!(code.contains("inner.norm_squared()"));
    }

    #[test]
    fn generates_null_wrapper_unchecked_only() {
        let spec = parse_spec(
            r#"
[algebra]
name = "cga3"

[signature]
positive = ["e1", "e2", "e3", "e_plus"]
negative = ["e_minus"]

[types.Point]
grades = [1]
fields = ["x", "y", "z", "e_plus", "e_minus"]

[types.Point.constraints.null]
"#,
        )
        .unwrap();

        let algebra = Algebra::cga(3);
        let generator = ConstraintGenerator::new(&spec, &algebra);

        let tokens = generator.generate_constraints_file();
        let code = tokens.to_string();

        assert!(code.contains("NullPoint"));
        assert!(code.contains("fn new_unchecked"));
        // Should NOT have a `fn new(` with validation
        assert!(!code.contains("fn new(inner: Point<T>, tolerance"));
    }
}
