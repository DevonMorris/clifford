//! Constrained type generation.
//!
//! This module provides the `ConstraintGenerator` for generating type-safe
//! wrapper types that enforce algebraic constraints (unit, nonzero, etc.).
//!
//! Constraints can use:
//! - Built-in methods: `norm()`, `norm_squared()` (generated for all types)
//! - User-specified expressions over fields, e.g., `x * x + y * y = 0`
//!
//! Expression syntax:
//! - Field references become method calls: `x` → `inner.x()`
//! - Equality checks use tolerance: `expr = value` → `|expr - value| < tolerance`
//! - Inequality checks: `expr > value`, `expr < value`

use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::algebra::Algebra;
use crate::spec::{AlgebraSpec, ConstraintKind, ConstraintSpec, TypeSpec};

/// Generates constrained wrapper types.
///
/// # Example
///
/// ```
/// use clifford_codegen::algebra::Algebra;
/// use clifford_codegen::codegen::ConstraintGenerator;
/// use clifford_codegen::spec::parse_spec;
///
/// let spec = parse_spec(r#"
/// [algebra]
/// name = "euclidean2"
///
/// [signature]
/// positive = ["e1", "e2"]
///
/// [types.Vector]
/// grades = [1]
/// fields = ["x", "y"]
///
/// [types.Vector.constraints.unit]
/// norm = "euclidean"
/// "#).unwrap();
///
/// let algebra = Algebra::euclidean(2);
/// let generator = ConstraintGenerator::new(&spec, &algebra);
///
/// let tokens = generator.generate_constraints_file();
/// let code = tokens.to_string();
///
/// assert!(code.contains("UnitVector"));
/// assert!(code.contains("fn new_checked"));
/// ```
pub struct ConstraintGenerator<'a> {
    /// The algebra specification.
    spec: &'a AlgebraSpec,
    /// The algebra for computations.
    #[allow(dead_code)]
    algebra: &'a Algebra,
}

impl<'a> ConstraintGenerator<'a> {
    /// Creates a new constraint generator.
    pub fn new(spec: &'a AlgebraSpec, algebra: &'a Algebra) -> Self {
        Self { spec, algebra }
    }

    /// Generates the complete constrained types file.
    pub fn generate_constraints_file(&self) -> TokenStream {
        let header = self.generate_header();
        let imports = self.generate_imports();

        let wrappers: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .flat_map(|ty| self.generate_constraints_for_type(ty))
            .collect();

        quote! {
            #header
            #imports

            #(#wrappers)*
        }
    }

    /// Generates the file header.
    fn generate_header(&self) -> TokenStream {
        let name = &self.spec.name;
        let header_doc = format!(
            r#"//! Constrained wrapper types for {}.
//!
//! This file is auto-generated by clifford-codegen.
//! Do not edit manually."#,
            name
        );

        header_doc.parse().unwrap_or_else(|_| quote! {})
    }

    /// Generates import statements.
    fn generate_imports(&self) -> TokenStream {
        let type_names: Vec<_> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|t| format_ident!("{}", t.name))
            .collect();

        quote! {
            use crate::scalar::Float;
            use super::types::{#(#type_names),*};
        }
    }

    /// Generates all constraints for a type.
    fn generate_constraints_for_type(&self, ty: &TypeSpec) -> Vec<TokenStream> {
        ty.constraints
            .iter()
            .map(|c| self.generate_constraint(ty, c))
            .collect()
    }

    /// Generates a single constraint wrapper.
    fn generate_constraint(
        &self,
        base_type: &TypeSpec,
        constraint: &ConstraintSpec,
    ) -> TokenStream {
        // Check if user provided a custom expression
        if let Some(ref expr) = constraint.condition {
            return self.generate_expression_wrapper(base_type, constraint, expr);
        }

        // Otherwise use built-in constraint handling
        match constraint.kind {
            ConstraintKind::Unit => self.generate_unit_wrapper(base_type, constraint),
            ConstraintKind::NonZero => self.generate_nonzero_wrapper(base_type, constraint),
            // These constraints require user-specified expression
            ConstraintKind::Normalized | ConstraintKind::Null | ConstraintKind::Ideal => {
                self.generate_unchecked_only_wrapper(base_type, constraint)
            }
        }
    }

    /// Generates a wrapper with user-specified expression validation.
    ///
    /// Parses expressions like:
    /// - `x * x + y * y = 0` → checks `|x*x + y*y - 0| < tolerance`
    /// - `s * s + xy * xy = 1` → checks `|s*s + xy*xy - 1| < tolerance`
    fn generate_expression_wrapper(
        &self,
        base_type: &TypeSpec,
        constraint: &ConstraintSpec,
        expr: &str,
    ) -> TokenStream {
        let base_name = format_ident!("{}", base_type.name);
        let wrapper_name = format_ident!("{}", constraint.wrapper_name);

        // Collect field names for this type
        let field_names: Vec<&str> = base_type.fields.iter().map(|f| f.name.as_str()).collect();

        // Parse the expression
        let parsed = parse_constraint_expression(expr, &field_names);

        let check_code = match parsed {
            ParsedExpression::Equality { lhs, rhs } => {
                let lhs_code: TokenStream = lhs.parse().unwrap_or_else(|_| quote! { T::zero() });
                let rhs_code: TokenStream = rhs.parse().unwrap_or_else(|_| quote! { T::zero() });
                quote! {
                    let lhs = #lhs_code;
                    let rhs = #rhs_code;
                    let diff = if lhs > rhs { lhs - rhs } else { rhs - lhs };
                    assert!(
                        diff < tolerance,
                        "constraint violated: |({}) - ({})| = {:?} >= tolerance",
                        stringify!(#lhs_code), stringify!(#rhs_code), diff
                    );
                }
            }
            ParsedExpression::GreaterThan { lhs, rhs } => {
                let lhs_code: TokenStream = lhs.parse().unwrap_or_else(|_| quote! { T::zero() });
                let rhs_code: TokenStream = rhs.parse().unwrap_or_else(|_| quote! { T::zero() });
                quote! {
                    let lhs = #lhs_code;
                    let rhs = #rhs_code;
                    assert!(
                        lhs > rhs,
                        "constraint violated: ({}) = {:?} not > ({}) = {:?}",
                        stringify!(#lhs_code), lhs, stringify!(#rhs_code), rhs
                    );
                }
            }
            ParsedExpression::LessThan { lhs, rhs } => {
                let lhs_code: TokenStream = lhs.parse().unwrap_or_else(|_| quote! { T::zero() });
                let rhs_code: TokenStream = rhs.parse().unwrap_or_else(|_| quote! { T::zero() });
                quote! {
                    let lhs = #lhs_code;
                    let rhs = #rhs_code;
                    assert!(
                        lhs < rhs,
                        "constraint violated: ({}) = {:?} not < ({}) = {:?}",
                        stringify!(#lhs_code), lhs, stringify!(#rhs_code), rhs
                    );
                }
            }
            ParsedExpression::Invalid(msg) => {
                let error_msg = format!("Invalid constraint expression: {}", msg);
                quote! {
                    compile_error!(#error_msg);
                }
            }
        };

        let doc = format!(
            "{} with constraint: `{}`.\n\n\
            # Panics\n\n\
            The `new_checked()` constructor panics if the constraint is violated.",
            constraint.wrapper_name, expr
        );

        let common_impls = self.generate_common_impls(base_type, constraint);

        quote! {
            #[doc = #doc]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(transparent)]
            pub struct #wrapper_name<T: Float>(#base_name<T>);

            impl<T: Float> #wrapper_name<T> {
                /// Creates a wrapper, validating the constraint expression.
                ///
                /// # Arguments
                ///
                /// * `inner` - The element to wrap
                /// * `tolerance` - Maximum allowed deviation for equality checks
                ///
                /// # Panics
                ///
                /// Panics if the constraint is violated.
                #[inline]
                pub fn new_checked(inner: #base_name<T>, tolerance: T) -> Self {
                    #check_code
                    Self(inner)
                }

                /// Creates from components without validation.
                ///
                /// # Safety (Logical)
                ///
                /// Caller must ensure the element satisfies the constraint.
                #[inline]
                pub fn new_unchecked(inner: #base_name<T>) -> Self {
                    Self(inner)
                }

                /// Returns the underlying element.
                #[inline]
                pub fn into_inner(self) -> #base_name<T> {
                    self.0
                }
            }

            #common_impls
        }
    }

    /// Generates a unit constraint wrapper.
    fn generate_unit_wrapper(
        &self,
        base_type: &TypeSpec,
        constraint: &ConstraintSpec,
    ) -> TokenStream {
        let base_name = format_ident!("{}", base_type.name);
        let wrapper_name = format_ident!("{}", constraint.wrapper_name);

        let doc = format!(
            "Unit {} with guaranteed norm = 1.\n\n\
            # Panics\n\n\
            The `new_checked()` constructor panics if `|norm - 1| >= tolerance`.",
            base_type.name
        );

        let common_impls = self.generate_common_impls(base_type, constraint);

        quote! {
            #[doc = #doc]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(transparent)]
            pub struct #wrapper_name<T: Float>(#base_name<T>);

            impl<T: Float> #wrapper_name<T> {
                /// Creates a unit wrapper, validating the constraint.
                ///
                /// # Panics
                ///
                /// Panics if `|inner.norm() - 1| >= tolerance`.
                #[inline]
                pub fn new_checked(inner: #base_name<T>, tolerance: T) -> Self {
                    let norm = inner.norm();
                    let deviation = if norm > T::one() {
                        norm - T::one()
                    } else {
                        T::one() - norm
                    };
                    assert!(
                        deviation < tolerance,
                        "unit constraint violated: |norm - 1| = {:?} >= tolerance",
                        deviation
                    );
                    Self(inner)
                }

                /// Creates from components without validation.
                #[inline]
                pub fn new_unchecked(inner: #base_name<T>) -> Self {
                    Self(inner)
                }

                /// Returns the underlying element.
                #[inline]
                pub fn into_inner(self) -> #base_name<T> {
                    self.0
                }
            }

            #common_impls
        }
    }

    /// Generates a nonzero constraint wrapper.
    fn generate_nonzero_wrapper(
        &self,
        base_type: &TypeSpec,
        constraint: &ConstraintSpec,
    ) -> TokenStream {
        let base_name = format_ident!("{}", base_type.name);
        let wrapper_name = format_ident!("{}", constraint.wrapper_name);

        let doc = format!(
            "Non-zero {} with guaranteed norm > 0.\n\n\
            # Panics\n\n\
            The `new_checked()` constructor panics if `norm_squared <= tolerance`.",
            base_type.name
        );

        let common_impls = self.generate_common_impls(base_type, constraint);

        quote! {
            #[doc = #doc]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(transparent)]
            pub struct #wrapper_name<T: Float>(#base_name<T>);

            impl<T: Float> #wrapper_name<T> {
                /// Creates a non-zero wrapper, validating the constraint.
                ///
                /// # Panics
                ///
                /// Panics if `inner.norm_squared() <= tolerance`.
                #[inline]
                pub fn new_checked(inner: #base_name<T>, tolerance: T) -> Self {
                    let norm_sq = inner.norm_squared();
                    assert!(
                        norm_sq > tolerance,
                        "nonzero constraint violated: norm_squared = {:?} <= tolerance",
                        norm_sq
                    );
                    Self(inner)
                }

                /// Creates from components without validation.
                #[inline]
                pub fn new_unchecked(inner: #base_name<T>) -> Self {
                    Self(inner)
                }

                /// Returns the underlying element.
                #[inline]
                pub fn into_inner(self) -> #base_name<T> {
                    self.0
                }

                /// Normalizes this non-zero element to unit norm.
                #[inline]
                pub fn normalize(self) -> #base_name<T> {
                    self.0.normalize()
                }
            }

            #common_impls
        }
    }

    /// Generates a wrapper with only `new_unchecked()`.
    fn generate_unchecked_only_wrapper(
        &self,
        base_type: &TypeSpec,
        constraint: &ConstraintSpec,
    ) -> TokenStream {
        let base_name = format_ident!("{}", base_type.name);
        let wrapper_name = format_ident!("{}", constraint.wrapper_name);

        let doc = format!(
            "{} {} wrapper type.\n\n\
            Provide a `condition` expression in the spec to enable validation.",
            constraint.wrapper_name, base_type.name
        );

        let common_impls = self.generate_common_impls(base_type, constraint);

        quote! {
            #[doc = #doc]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(transparent)]
            pub struct #wrapper_name<T: Float>(#base_name<T>);

            impl<T: Float> #wrapper_name<T> {
                /// Creates from components without validation.
                ///
                /// Add a `condition` to your spec to enable validated construction.
                #[inline]
                pub fn new_unchecked(inner: #base_name<T>) -> Self {
                    Self(inner)
                }

                /// Returns the underlying element.
                #[inline]
                pub fn into_inner(self) -> #base_name<T> {
                    self.0
                }
            }

            #common_impls
        }
    }

    /// Generates common implementations (Deref, AsRef, From).
    fn generate_common_impls(
        &self,
        base_type: &TypeSpec,
        constraint: &ConstraintSpec,
    ) -> TokenStream {
        let base_name = format_ident!("{}", base_type.name);
        let wrapper_name = format_ident!("{}", constraint.wrapper_name);

        quote! {
            impl<T: Float> std::ops::Deref for #wrapper_name<T> {
                type Target = #base_name<T>;

                #[inline]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }

            impl<T: Float> AsRef<#base_name<T>> for #wrapper_name<T> {
                #[inline]
                fn as_ref(&self) -> &#base_name<T> {
                    &self.0
                }
            }

            impl<T: Float> From<#wrapper_name<T>> for #base_name<T> {
                #[inline]
                fn from(wrapper: #wrapper_name<T>) -> Self {
                    wrapper.0
                }
            }
        }
    }
}

/// Parsed constraint expression.
enum ParsedExpression {
    /// `lhs = rhs` (equality within tolerance)
    Equality {
        /// Left-hand side of the expression.
        lhs: String,
        /// Right-hand side of the expression.
        rhs: String,
    },
    /// `lhs > rhs`
    GreaterThan {
        /// Left-hand side of the expression.
        lhs: String,
        /// Right-hand side of the expression.
        rhs: String,
    },
    /// `lhs < rhs`
    LessThan {
        /// Left-hand side of the expression.
        lhs: String,
        /// Right-hand side of the expression.
        rhs: String,
    },
    /// Parse error
    Invalid(String),
}

/// Parses a constraint expression and transforms field references.
///
/// Examples:
/// - `x * x + y * y = 0` → transforms `x` to `inner.x()`, `y` to `inner.y()`
/// - `s * s + xy * xy = 1` → transforms `s` to `inner.s()`, `xy` to `inner.xy()`
fn parse_constraint_expression(expr: &str, field_names: &[&str]) -> ParsedExpression {
    // Find the comparison operator
    let (lhs, op, rhs) = if let Some(idx) = expr.find(" = ") {
        (&expr[..idx], "=", &expr[idx + 3..])
    } else if let Some(idx) = expr.find(" > ") {
        (&expr[..idx], ">", &expr[idx + 3..])
    } else if let Some(idx) = expr.find(" < ") {
        (&expr[..idx], "<", &expr[idx + 3..])
    } else if let Some(idx) = expr.find('=') {
        (&expr[..idx], "=", &expr[idx + 1..])
    } else if let Some(idx) = expr.find('>') {
        (&expr[..idx], ">", &expr[idx + 1..])
    } else if let Some(idx) = expr.find('<') {
        (&expr[..idx], "<", &expr[idx + 1..])
    } else {
        return ParsedExpression::Invalid(format!(
            "No comparison operator (=, >, <) found in: {}",
            expr
        ));
    };

    // Transform field references in both sides
    let lhs_transformed = transform_field_references(lhs.trim(), field_names);
    let rhs_transformed = transform_field_references(rhs.trim(), field_names);

    match op {
        "=" => ParsedExpression::Equality {
            lhs: lhs_transformed,
            rhs: rhs_transformed,
        },
        ">" => ParsedExpression::GreaterThan {
            lhs: lhs_transformed,
            rhs: rhs_transformed,
        },
        "<" => ParsedExpression::LessThan {
            lhs: lhs_transformed,
            rhs: rhs_transformed,
        },
        _ => ParsedExpression::Invalid(format!("Unknown operator: {}", op)),
    }
}

/// Transforms field references in an expression to method calls.
///
/// `x * x + y * y` → `inner.x() * inner.x() + inner.y() * inner.y()`
fn transform_field_references(expr: &str, field_names: &[&str]) -> String {
    let mut result = expr.to_string();

    // Sort field names by length (longest first) to avoid partial replacements
    let mut sorted_fields: Vec<&str> = field_names.to_vec();
    sorted_fields.sort_by_key(|f| std::cmp::Reverse(f.len()));

    for field in sorted_fields {
        let replacement = format!("inner.{}()", field);
        // Simple word-boundary replacement without regex dependency
        result = replace_word(&result, field, &replacement);
    }

    result
}

/// Replaces whole words only (simple implementation).
fn replace_word(text: &str, word: &str, replacement: &str) -> String {
    let mut result = String::new();
    let mut i = 0;
    let bytes = text.as_bytes();

    while i < bytes.len() {
        // Check if we're at a word boundary and the word matches
        let at_start = i == 0 || !is_ident_char(bytes[i - 1] as char);

        if at_start && text[i..].starts_with(word) {
            let end = i + word.len();
            let at_end = end >= bytes.len() || !is_ident_char(bytes[end] as char);

            if at_end {
                result.push_str(replacement);
                i = end;
                continue;
            }
        }

        result.push(bytes[i] as char);
        i += 1;
    }

    result
}

/// Checks if a character can be part of an identifier.
fn is_ident_char(c: char) -> bool {
    c.is_alphanumeric() || c == '_'
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::spec::parse_spec;

    #[test]
    fn transforms_field_references() {
        let fields = vec!["x", "y", "xy"];
        let result = transform_field_references("x * x + y * y", &fields);
        assert_eq!(result, "inner.x() * inner.x() + inner.y() * inner.y()");
    }

    #[test]
    fn transforms_longer_field_names_first() {
        let fields = vec!["x", "y", "xy"];
        let result = transform_field_references("xy * xy", &fields);
        assert_eq!(result, "inner.xy() * inner.xy()");
    }

    #[test]
    fn parses_equality_expression() {
        let fields = vec!["x", "y"];
        let parsed = parse_constraint_expression("x * x + y * y = 0", &fields);
        match parsed {
            ParsedExpression::Equality { lhs, rhs } => {
                assert_eq!(lhs, "inner.x() * inner.x() + inner.y() * inner.y()");
                assert_eq!(rhs, "0");
            }
            _ => panic!("Expected Equality"),
        }
    }

    #[test]
    fn parses_greater_than_expression() {
        let fields = vec!["x", "y"];
        let parsed = parse_constraint_expression("x * x + y * y > 0", &fields);
        match parsed {
            ParsedExpression::GreaterThan { lhs, rhs } => {
                assert_eq!(lhs, "inner.x() * inner.x() + inner.y() * inner.y()");
                assert_eq!(rhs, "0");
            }
            _ => panic!("Expected GreaterThan"),
        }
    }

    #[test]
    fn generates_unit_wrapper() {
        let spec = parse_spec(
            r#"
[algebra]
name = "euclidean2"

[signature]
positive = ["e1", "e2"]

[types.Scalar]
grades = [0]

[types.Vector]
grades = [1]
fields = ["x", "y"]

[types.Bivector]
grades = [2]

[types.Rotor]
grades = [0, 2]

[types.Vector.constraints.unit]
norm = "euclidean"
"#,
        )
        .unwrap();

        let algebra = Algebra::euclidean(2);
        let generator = ConstraintGenerator::new(&spec, &algebra);

        let tokens = generator.generate_constraints_file();
        let code = tokens.to_string();

        assert!(code.contains("UnitVector"));
        assert!(code.contains("fn new_checked"));
        assert!(code.contains("inner.norm()"));
    }

    #[test]
    fn generates_expression_based_wrapper() {
        let spec = parse_spec(
            r#"
[algebra]
name = "cga2"

[signature]
positive = ["e1", "e2", "ep"]
negative = ["em"]

[types.Scalar]
grades = [0]

[types.Point]
grades = [1]
fields = ["x", "y", "ep", "em"]

[types.Bivector]
grades = [2]

[types.Trivector]
grades = [3]

[types.Quadvector]
grades = [4]

[types.Even]
grades = [0, 2, 4]

[types.Odd]
grades = [1, 3]

[types.Point.constraints.null]
condition = "x * x + y * y - ep * em = 0"
"#,
        )
        .unwrap();

        let algebra = Algebra::cga(2);
        let generator = ConstraintGenerator::new(&spec, &algebra);

        let tokens = generator.generate_constraints_file();
        let code = tokens.to_string();

        assert!(code.contains("NullPoint"));
        assert!(code.contains("fn new_checked"));
        // TokenStream::to_string() adds spaces between tokens
        assert!(code.contains("inner . x ()"));
        assert!(code.contains("inner . ep ()"));
    }
}
