//! Constrained type generation.
//!
//! This module provides the `ConstraintGenerator` for generating type-safe
//! wrapper types that enforce algebraic constraints (unit, nonzero, etc.).
//!
//! The generated wrappers include:
//! - A `new()` constructor that validates the constraint within tolerance and panics if not met
//! - A `new_unchecked()` constructor for advanced users who guarantee the constraint
//! - Accessor methods (`into_inner()`, `Deref`, `AsRef`, `From`)
//!
//! Proper domain-specific constructors (like `identity()`, `from_angle()`) must be added
//! by the user after generation, as the codegen cannot know how to properly construct
//! these types for all use cases.

use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::algebra::Algebra;
use crate::spec::{AlgebraSpec, ConstraintKind, ConstraintSpec, TypeSpec};

/// Generates constrained wrapper types.
///
/// The generator produces wrapper types that enforce constraints:
/// - Unit types (norm = 1 within tolerance)
/// - NonZero types (norm > tolerance)
/// - Normalized types (context-dependent canonical form)
/// - Null types (self-inner-product = 0 within tolerance)
/// - Ideal types (in ideal subspace)
///
/// # Example
///
/// ```
/// use clifford_codegen::algebra::Algebra;
/// use clifford_codegen::codegen::ConstraintGenerator;
/// use clifford_codegen::spec::parse_spec;
///
/// let spec = parse_spec(r#"
/// [algebra]
/// name = "euclidean2"
///
/// [signature]
/// positive = ["e1", "e2"]
///
/// [types.Vector]
/// grades = [1]
/// fields = ["x", "y"]
///
/// [types.Vector.constraints.unit]
/// norm = "euclidean"
/// "#).unwrap();
///
/// let algebra = Algebra::euclidean(2);
/// let generator = ConstraintGenerator::new(&spec, &algebra);
///
/// let tokens = generator.generate_constraints_file();
/// let code = tokens.to_string();
///
/// assert!(code.contains("UnitVector"));
/// assert!(code.contains("fn new"));
/// ```
pub struct ConstraintGenerator<'a> {
    /// The algebra specification.
    spec: &'a AlgebraSpec,
    /// The algebra for computations.
    #[allow(dead_code)]
    algebra: &'a Algebra,
}

impl<'a> ConstraintGenerator<'a> {
    /// Creates a new constraint generator.
    pub fn new(spec: &'a AlgebraSpec, algebra: &'a Algebra) -> Self {
        Self { spec, algebra }
    }

    /// Generates the complete constrained types file.
    pub fn generate_constraints_file(&self) -> TokenStream {
        let header = self.generate_header();
        let imports = self.generate_imports();

        let wrappers: Vec<TokenStream> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .flat_map(|ty| self.generate_constraints_for_type(ty))
            .collect();

        quote! {
            #header
            #imports

            #(#wrappers)*
        }
    }

    /// Generates the file header.
    fn generate_header(&self) -> TokenStream {
        let name = &self.spec.name;
        let header_doc = format!(
            r#"//! Constrained wrapper types for {}.
//!
//! This file is auto-generated by clifford-codegen.
//! Do not edit manually."#,
            name
        );

        header_doc.parse().unwrap_or_else(|_| quote! {})
    }

    /// Generates import statements.
    fn generate_imports(&self) -> TokenStream {
        let type_names: Vec<_> = self
            .spec
            .types
            .iter()
            .filter(|t| t.alias_of.is_none())
            .map(|t| format_ident!("{}", t.name))
            .collect();

        quote! {
            use crate::scalar::Float;
            use super::types::{#(#type_names),*};
        }
    }

    /// Generates all constraints for a type.
    fn generate_constraints_for_type(&self, ty: &TypeSpec) -> Vec<TokenStream> {
        ty.constraints
            .iter()
            .map(|c| self.generate_constraint(ty, c))
            .collect()
    }

    /// Generates a single constraint wrapper.
    fn generate_constraint(
        &self,
        base_type: &TypeSpec,
        constraint: &ConstraintSpec,
    ) -> TokenStream {
        match constraint.kind {
            ConstraintKind::Unit => self.generate_unit_wrapper(base_type, constraint),
            ConstraintKind::NonZero => self.generate_nonzero_wrapper(base_type, constraint),
            ConstraintKind::Normalized => self.generate_normalized_wrapper(base_type, constraint),
            ConstraintKind::Null => self.generate_null_wrapper(base_type, constraint),
            ConstraintKind::Ideal => self.generate_ideal_wrapper(base_type, constraint),
        }
    }

    /// Generates a unit constraint wrapper (norm = 1 within tolerance).
    fn generate_unit_wrapper(
        &self,
        base_type: &TypeSpec,
        constraint: &ConstraintSpec,
    ) -> TokenStream {
        let base_name = format_ident!("{}", base_type.name);
        let wrapper_name = format_ident!("{}", constraint.wrapper_name);

        let doc = format!(
            "Unit {} with guaranteed norm = 1.\n\n\
            This wrapper type ensures the {} always has unit norm.\n\n\
            # Panics\n\n\
            The `new()` constructor panics if `|norm - 1| >= tolerance`.",
            base_type.name,
            base_type.name.to_lowercase()
        );

        let common_impls = self.generate_common_impls(base_type, constraint);

        quote! {
            #[doc = #doc]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(transparent)]
            pub struct #wrapper_name<T: Float>(#base_name<T>);

            impl<T: Float> #wrapper_name<T> {
                /// Creates a unit wrapper, validating the constraint.
                ///
                /// # Arguments
                ///
                /// * `inner` - The element to wrap
                /// * `tolerance` - Maximum allowed deviation from unit norm
                ///
                /// # Panics
                ///
                /// Panics if `|inner.norm() - 1| >= tolerance`.
                #[inline]
                pub fn new(inner: #base_name<T>, tolerance: T) -> Self {
                    let norm = inner.norm();
                    let deviation = if norm > T::one() {
                        norm - T::one()
                    } else {
                        T::one() - norm
                    };
                    assert!(
                        deviation < tolerance,
                        "unit constraint violated: |norm - 1| = {:?} >= tolerance",
                        deviation
                    );
                    Self(inner)
                }

                /// Creates from components without validation.
                ///
                /// # Safety (Logical)
                ///
                /// Caller must ensure the element has unit norm.
                #[inline]
                pub fn new_unchecked(inner: #base_name<T>) -> Self {
                    Self(inner)
                }

                /// Returns the underlying element.
                #[inline]
                pub fn into_inner(self) -> #base_name<T> {
                    self.0
                }
            }

            #common_impls
        }
    }

    /// Generates a nonzero constraint wrapper (norm > tolerance).
    fn generate_nonzero_wrapper(
        &self,
        base_type: &TypeSpec,
        constraint: &ConstraintSpec,
    ) -> TokenStream {
        let base_name = format_ident!("{}", base_type.name);
        let wrapper_name = format_ident!("{}", constraint.wrapper_name);

        let doc = format!(
            "Non-zero {} with guaranteed norm > 0.\n\n\
            This wrapper type ensures the {} is never zero.\n\n\
            # Panics\n\n\
            The `new()` constructor panics if `norm_squared <= tolerance`.",
            base_type.name,
            base_type.name.to_lowercase()
        );

        let common_impls = self.generate_common_impls(base_type, constraint);

        quote! {
            #[doc = #doc]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(transparent)]
            pub struct #wrapper_name<T: Float>(#base_name<T>);

            impl<T: Float> #wrapper_name<T> {
                /// Creates a non-zero wrapper, validating the constraint.
                ///
                /// # Arguments
                ///
                /// * `inner` - The element to wrap
                /// * `tolerance` - Minimum required norm squared
                ///
                /// # Panics
                ///
                /// Panics if `inner.norm_squared() <= tolerance`.
                #[inline]
                pub fn new(inner: #base_name<T>, tolerance: T) -> Self {
                    let norm_sq = inner.norm_squared();
                    assert!(
                        norm_sq > tolerance,
                        "nonzero constraint violated: norm_squared = {:?} <= tolerance",
                        norm_sq
                    );
                    Self(inner)
                }

                /// Creates from components without validation.
                ///
                /// # Safety (Logical)
                ///
                /// Caller must ensure the element is non-zero.
                #[inline]
                pub fn new_unchecked(inner: #base_name<T>) -> Self {
                    Self(inner)
                }

                /// Returns the underlying element.
                #[inline]
                pub fn into_inner(self) -> #base_name<T> {
                    self.0
                }

                /// Normalizes this non-zero element to unit norm.
                #[inline]
                pub fn normalize(self) -> #base_name<T> {
                    self.0.normalize()
                }
            }

            #common_impls
        }
    }

    /// Generates a normalized constraint wrapper.
    fn generate_normalized_wrapper(
        &self,
        base_type: &TypeSpec,
        constraint: &ConstraintSpec,
    ) -> TokenStream {
        let base_name = format_ident!("{}", base_type.name);
        let wrapper_name = format_ident!("{}", constraint.wrapper_name);

        let doc = format!(
            "Normalized {} in canonical form.\n\n\
            The exact normalization condition depends on the geometric interpretation.\n\
            Users must implement appropriate constructors for their use case.",
            base_type.name
        );

        let common_impls = self.generate_common_impls(base_type, constraint);

        quote! {
            #[doc = #doc]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(transparent)]
            pub struct #wrapper_name<T: Float>(#base_name<T>);

            impl<T: Float> #wrapper_name<T> {
                /// Creates from components without validation.
                ///
                /// Users must implement their own validated constructors
                /// appropriate for their normalization condition.
                #[inline]
                pub fn new_unchecked(inner: #base_name<T>) -> Self {
                    Self(inner)
                }

                /// Returns the underlying element.
                #[inline]
                pub fn into_inner(self) -> #base_name<T> {
                    self.0
                }
            }

            #common_impls
        }
    }

    /// Generates a null constraint wrapper (self-inner-product = 0 within tolerance).
    fn generate_null_wrapper(
        &self,
        base_type: &TypeSpec,
        constraint: &ConstraintSpec,
    ) -> TokenStream {
        let base_name = format_ident!("{}", base_type.name);
        let wrapper_name = format_ident!("{}", constraint.wrapper_name);

        let doc = format!(
            "Null {} with zero self-inner-product.\n\n\
            Used in conformal geometric algebra for representing points.\n\n\
            # Panics\n\n\
            The `new()` constructor panics if `|self_inner_product| >= tolerance`.",
            base_type.name
        );

        let common_impls = self.generate_common_impls(base_type, constraint);

        quote! {
            #[doc = #doc]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(transparent)]
            pub struct #wrapper_name<T: Float>(#base_name<T>);

            impl<T: Float> #wrapper_name<T> {
                /// Creates a null wrapper, validating the constraint.
                ///
                /// # Arguments
                ///
                /// * `inner` - The element to wrap
                /// * `tolerance` - Maximum allowed self-inner-product magnitude
                ///
                /// # Panics
                ///
                /// Panics if `|inner.self_inner_product()| >= tolerance`.
                ///
                /// Note: Requires the base type to implement `self_inner_product()`.
                #[inline]
                pub fn new(inner: #base_name<T>, tolerance: T) -> Self {
                    let sip = inner.self_inner_product();
                    let abs_sip = if sip < T::zero() { T::zero() - sip } else { sip };
                    assert!(
                        abs_sip < tolerance,
                        "null constraint violated: |self_inner_product| = {:?} >= tolerance",
                        abs_sip
                    );
                    Self(inner)
                }

                /// Creates from components without validation.
                ///
                /// # Safety (Logical)
                ///
                /// Caller must ensure the element is null.
                #[inline]
                pub fn new_unchecked(inner: #base_name<T>) -> Self {
                    Self(inner)
                }

                /// Returns the underlying element.
                #[inline]
                pub fn into_inner(self) -> #base_name<T> {
                    self.0
                }
            }

            #common_impls
        }
    }

    /// Generates an ideal constraint wrapper.
    fn generate_ideal_wrapper(
        &self,
        base_type: &TypeSpec,
        constraint: &ConstraintSpec,
    ) -> TokenStream {
        let base_name = format_ident!("{}", base_type.name);
        let wrapper_name = format_ident!("{}", constraint.wrapper_name);

        let doc = format!(
            "Ideal {} representing a point at infinity.\n\n\
            Used in projective geometric algebra.\n\
            Users must implement appropriate constructors for their use case.",
            base_type.name
        );

        let common_impls = self.generate_common_impls(base_type, constraint);

        quote! {
            #[doc = #doc]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(transparent)]
            pub struct #wrapper_name<T: Float>(#base_name<T>);

            impl<T: Float> #wrapper_name<T> {
                /// Creates from components without validation.
                ///
                /// Users must implement their own validated constructors
                /// appropriate for the ideal constraint.
                #[inline]
                pub fn new_unchecked(inner: #base_name<T>) -> Self {
                    Self(inner)
                }

                /// Returns the underlying element.
                #[inline]
                pub fn into_inner(self) -> #base_name<T> {
                    self.0
                }
            }

            #common_impls
        }
    }

    /// Generates common implementations (Deref, AsRef, From).
    fn generate_common_impls(
        &self,
        base_type: &TypeSpec,
        constraint: &ConstraintSpec,
    ) -> TokenStream {
        let base_name = format_ident!("{}", base_type.name);
        let wrapper_name = format_ident!("{}", constraint.wrapper_name);

        quote! {
            impl<T: Float> std::ops::Deref for #wrapper_name<T> {
                type Target = #base_name<T>;

                #[inline]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }

            impl<T: Float> AsRef<#base_name<T>> for #wrapper_name<T> {
                #[inline]
                fn as_ref(&self) -> &#base_name<T> {
                    &self.0
                }
            }

            impl<T: Float> From<#wrapper_name<T>> for #base_name<T> {
                #[inline]
                fn from(wrapper: #wrapper_name<T>) -> Self {
                    wrapper.0
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::spec::parse_spec;

    #[test]
    fn generates_unit_wrapper() {
        let spec = parse_spec(
            r#"
[algebra]
name = "euclidean2"

[signature]
positive = ["e1", "e2"]

[types.Vector]
grades = [1]
fields = ["x", "y"]

[types.Vector.constraints.unit]
norm = "euclidean"
"#,
        )
        .unwrap();

        let algebra = Algebra::euclidean(2);
        let generator = ConstraintGenerator::new(&spec, &algebra);

        let tokens = generator.generate_constraints_file();
        let code = tokens.to_string();

        assert!(code.contains("UnitVector"));
        assert!(code.contains("fn new"));
        assert!(code.contains("fn new_unchecked"));
        assert!(code.contains("tolerance"));
    }

    #[test]
    fn generates_nonzero_wrapper() {
        let spec = parse_spec(
            r#"
[algebra]
name = "euclidean2"

[signature]
positive = ["e1", "e2"]

[types.Vector]
grades = [1]
fields = ["x", "y"]

[types.Vector.constraints.nonzero]
condition = "norm_squared > epsilon"
"#,
        )
        .unwrap();

        let algebra = Algebra::euclidean(2);
        let generator = ConstraintGenerator::new(&spec, &algebra);

        let tokens = generator.generate_constraints_file();
        let code = tokens.to_string();

        assert!(code.contains("NonZeroVector"));
        assert!(code.contains("fn new"));
        assert!(code.contains("norm_squared"));
    }
}
