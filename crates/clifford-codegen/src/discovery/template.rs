//! TOML template generation for discovered entities.

use super::DiscoveredEntity;
use crate::algebra::{Algebra, Blade, blades_of_grade};
use std::io::{self, Write};

/// Generates a TOML template from discovered entities.
///
/// The template includes:
/// - Algebra metadata (name, module path, signature)
/// - Discovered types with names and descriptions
/// - Suggested constraints based on norm analysis
///
/// Products are NOT included in the template because they are
/// automatically inferred from the types during code generation.
///
/// # Example
///
/// ```no_run
/// use clifford_codegen::discovery::{discover_entities, generate_toml_template};
/// use clifford_codegen::algebra::Algebra;
///
/// let algebra = Algebra::euclidean(3);
/// let entities = discover_entities(&algebra);
///
/// let mut output = Vec::new();
/// generate_toml_template(&algebra, &entities, &mut output).unwrap();
///
/// let toml = String::from_utf8(output).unwrap();
/// println!("{}", toml);
/// ```
pub fn generate_toml_template(
    algebra: &Algebra,
    entities: &[DiscoveredEntity],
    output: &mut dyn Write,
) -> io::Result<()> {
    // Header
    writeln!(
        output,
        "# Auto-discovered entities for {}",
        algebra_name(algebra)
    )?;
    writeln!(output, "# Generated by clifford-codegen discover")?;
    writeln!(output, "#")?;
    writeln!(output, "# Review and customize:")?;
    writeln!(output, "# - Rename placeholder entities (Entity_*)")?;
    writeln!(output, "# - Add/remove types as needed")?;
    writeln!(output, "# - Customize descriptions")?;
    writeln!(output, "# - Configure constraints")?;
    writeln!(output)?;

    // Algebra section - user should fill in these values
    writeln!(output, "[algebra]")?;
    writeln!(output, "name = \"\"  # TODO: Fill in algebra name")?;
    writeln!(output, "module_path = \"\"  # TODO: Fill in module path")?;
    writeln!(output, "description = \"{}\"", algebra_name(algebra))?;
    writeln!(output)?;

    // Signature section
    write_signature_section(algebra, output)?;

    // Blades section - map index names to field names
    write_blades_section(algebra, output)?;

    // Types section
    writeln!(
        output,
        "# ============================================================"
    )?;
    writeln!(
        output,
        "# Discovered Types ({} entities satisfy geometric constraints)",
        entities.len()
    )?;
    writeln!(
        output,
        "# ============================================================"
    )?;
    writeln!(output)?;

    for entity in entities {
        write_entity_section(entity, output)?;
    }

    // Options section
    writeln!(output, "[options]")?;
    writeln!(output, "generate_serde = true")?;
    writeln!(output, "generate_arbitrary = true")?;
    writeln!(output, "generate_nalgebra = true")?;

    Ok(())
}

/// Writes the signature section of the TOML.
fn write_signature_section(algebra: &Algebra, output: &mut dyn Write) -> io::Result<()> {
    writeln!(output, "[signature]")?;

    // Get signature (p, q, r)
    let (p, q, r) = algebra.signature();

    // Generate basis names
    let positive: Vec<String> = (0..p).map(|i| format!("e{}", i + 1)).collect();
    let negative: Vec<String> = (0..q).map(|i| format!("e{}", p + i + 1)).collect();
    let zero: Vec<String> = (0..r).map(|i| format!("e{}", p + q + i + 1)).collect();

    writeln!(output, "positive = {:?}", positive)?;
    writeln!(output, "negative = {:?}", negative)?;
    writeln!(output, "zero = {:?}", zero)?;
    writeln!(output)?;

    Ok(())
}

/// Writes the blades section of the TOML.
///
/// Maps index-based blade names (e1, e12, e123) to field names.
/// This provides sensible defaults that users can customize.
fn write_blades_section(algebra: &Algebra, output: &mut dyn Write) -> io::Result<()> {
    writeln!(output, "[blades]")?;
    writeln!(output, "# Map blade indices to field names")?;
    writeln!(output, "# Format: e<indices> = \"<field_name>\"")?;
    writeln!(output)?;

    let dim = algebra.dim();

    // Generate blade mappings for each grade (skip grade 0 - scalar handled separately)
    for grade in 1..=dim {
        let grade_name = match grade {
            1 => "Vectors (grade 1)",
            2 => "Bivectors (grade 2)",
            3 => "Trivectors (grade 3)",
            4 => "Quadvectors (grade 4)",
            5 => "5-vectors (grade 5)",
            6 => "6-vectors (grade 6)",
            _ => "Higher grade",
        };
        writeln!(output, "# {}", grade_name)?;

        for blade_index in blades_of_grade(dim, grade) {
            let blade = Blade::from_index(blade_index);
            let index_name = algebra.blade_index_name(blade);
            let field_name = algebra.blade_name(blade);
            writeln!(output, "{} = \"{}\"", index_name, field_name)?;
        }
        writeln!(output)?;
    }

    Ok(())
}

/// Writes a single entity section.
fn write_entity_section(entity: &DiscoveredEntity, output: &mut dyn Write) -> io::Result<()> {
    writeln!(output, "[types.{}]", entity.name)?;
    writeln!(output, "grades = {:?}", entity.grades)?;

    // Output constraints if present
    if let Some(ref constraint) = entity.geometric_constraint {
        writeln!(output, "geometric_constraint = \"{}\"", constraint)?;
    }
    if let Some(ref constraint) = entity.antiproduct_constraint {
        writeln!(output, "antiproduct_constraint = \"{}\"", constraint)?;
    }

    writeln!(output)?;
    Ok(())
}

/// Generates a descriptive name for the algebra based on signature.
fn algebra_name(algebra: &Algebra) -> String {
    let (p, q, r) = algebra.signature();
    format!("Cl({},{},{})", p, q, r)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::discovery::discover_entities;

    #[test]
    fn generate_euclidean3_template() {
        let algebra = Algebra::euclidean(3);
        let entities = discover_entities(&algebra);

        let mut output = Vec::new();
        generate_toml_template(&algebra, &entities, &mut output).unwrap();

        let toml = String::from_utf8(output).unwrap();

        // Check header
        assert!(toml.contains("Auto-discovered entities for Cl(3,0,0)"));

        // Check algebra section has placeholders for user to fill in
        assert!(toml.contains("[algebra]"));
        assert!(toml.contains("name = \"\""));
        assert!(toml.contains("module_path = \"\""));
        assert!(toml.contains("description = \"Cl(3,0,0)\""));

        // Check signature section
        assert!(toml.contains("[signature]"));
        assert!(toml.contains("positive = [\"e1\", \"e2\", \"e3\"]"));

        // Check types section - entities are named by grades
        assert!(toml.contains("[types.Entity_0]")); // Scalar
        assert!(toml.contains("[types.Entity_1]")); // Vector
        assert!(toml.contains("[types.Entity_2]")); // Bivector
        assert!(toml.contains("[types.Entity_0_2]")); // Even/Rotor
    }

    #[test]
    fn toml_is_valid() {
        let algebra = Algebra::euclidean(3);
        let entities = discover_entities(&algebra);

        let mut output = Vec::new();
        generate_toml_template(&algebra, &entities, &mut output).unwrap();

        let toml_str = String::from_utf8(output).unwrap();

        // The TOML should parse without errors
        // Note: We're not adding toml as a dependency, so we just check structure
        assert!(toml_str.contains("[algebra]"));
        assert!(toml_str.contains("[signature]"));
        assert!(toml_str.contains("[types."));
        assert!(toml_str.contains("[options]"));
    }
}
