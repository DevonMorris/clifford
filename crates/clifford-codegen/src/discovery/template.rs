//! TOML template generation for discovered entities.

use super::DiscoveredEntity;
use crate::algebra::Algebra;
use std::io::{self, Write};

/// Generates a TOML template from discovered entities.
///
/// The template includes:
/// - Algebra metadata (name, module path, signature)
/// - Discovered types with names and descriptions
/// - Suggested constraints based on norm analysis
///
/// Products are NOT included in the template because they are
/// automatically inferred from the types during code generation.
///
/// # Example
///
/// ```no_run
/// use clifford_codegen::discovery::{discover_entities, generate_toml_template};
/// use clifford_codegen::algebra::Algebra;
///
/// let algebra = Algebra::euclidean(3);
/// let entities = discover_entities(&algebra);
///
/// let mut output = Vec::new();
/// generate_toml_template(&algebra, &entities, &mut output).unwrap();
///
/// let toml = String::from_utf8(output).unwrap();
/// println!("{}", toml);
/// ```
pub fn generate_toml_template(
    algebra: &Algebra,
    entities: &[DiscoveredEntity],
    output: &mut dyn Write,
) -> io::Result<()> {
    // Header
    writeln!(
        output,
        "# Auto-discovered entities for {}",
        algebra_name(algebra)
    )?;
    writeln!(output, "# Generated by clifford-codegen discover")?;
    writeln!(output, "#")?;
    writeln!(output, "# Review and customize:")?;
    writeln!(output, "# - Rename placeholder entities (Entity_*)")?;
    writeln!(output, "# - Add/remove types as needed")?;
    writeln!(output, "# - Customize descriptions")?;
    writeln!(output, "# - Configure constraints")?;
    writeln!(output)?;

    // Algebra section
    writeln!(output, "[algebra]")?;
    writeln!(output, "name = \"{}\"", algebra_id(algebra))?;
    writeln!(output, "module_path = \"{}\"", module_path(algebra))?;
    writeln!(output, "description = \"{}\"", algebra_description(algebra))?;
    writeln!(output)?;

    // Signature section
    write_signature_section(algebra, output)?;

    // Types section
    writeln!(
        output,
        "# ============================================================"
    )?;
    writeln!(
        output,
        "# Discovered Types ({} entities satisfy geometric constraints)",
        entities.len()
    )?;
    writeln!(
        output,
        "# ============================================================"
    )?;
    writeln!(output)?;

    for entity in entities {
        write_entity_section(entity, output)?;
    }

    // Options section
    writeln!(output, "[options]")?;
    writeln!(output, "generate_serde = true")?;
    writeln!(output, "generate_arbitrary = true")?;
    writeln!(output, "generate_nalgebra = true")?;

    Ok(())
}

/// Writes the signature section of the TOML.
fn write_signature_section(algebra: &Algebra, output: &mut dyn Write) -> io::Result<()> {
    writeln!(output, "[signature]")?;

    // Get signature (p, q, r)
    let (p, q, r) = algebra.signature();

    // Generate basis names
    let positive: Vec<String> = (0..p).map(|i| format!("e{}", i + 1)).collect();
    let negative: Vec<String> = (0..q).map(|i| format!("e{}", p + i + 1)).collect();
    let zero: Vec<String> = (0..r).map(|i| format!("e{}", p + q + i + 1)).collect();

    writeln!(output, "positive = {:?}", positive)?;
    writeln!(output, "negative = {:?}", negative)?;
    writeln!(output, "zero = {:?}", zero)?;
    writeln!(output)?;

    Ok(())
}

/// Writes a single entity section.
fn write_entity_section(entity: &DiscoveredEntity, output: &mut dyn Write) -> io::Result<()> {
    writeln!(output, "[types.{}]", entity.name)?;
    writeln!(output, "grades = {:?}", entity.grades)?;
    writeln!(output, "description = \"{}\"", entity.description)?;

    // Output constraint if present
    if let Some(ref constraint) = entity.constraint {
        writeln!(output, "constraint = \"{}\"", constraint)?;
    }

    // Suggest unit/nonzero constraints for types that support them
    if entity.can_be_unit || entity.can_be_nonzero {
        writeln!(output, "#")?;
        writeln!(output, "# Suggested wrappers:")?;
        if entity.can_be_unit {
            writeln!(output, "# [types.{}.wrappers.unit]", entity.name)?;
        }
        if entity.can_be_nonzero {
            writeln!(output, "# [types.{}.wrappers.nonzero]", entity.name)?;
        }
    }

    writeln!(output)?;
    Ok(())
}

/// Generates a descriptive name for the algebra.
fn algebra_name(algebra: &Algebra) -> String {
    let (p, q, r) = algebra.signature();
    format!("Cl({},{},{})", p, q, r)
}

/// Generates an identifier for the algebra.
fn algebra_id(algebra: &Algebra) -> String {
    let (p, q, r) = algebra.signature();

    // Common algebra identifiers
    match (p, q, r) {
        (2, 0, 0) => "euclidean2".to_string(),
        (3, 0, 0) => "euclidean3".to_string(),
        (3, 0, 1) => "pga3".to_string(),
        (4, 1, 0) => "cga3".to_string(),
        (4, 0, 0) => "euclidean4".to_string(),
        (n, 0, 0) => format!("euclidean{}", n),
        _ => format!(
            "cl_{}_{}{}",
            p,
            q,
            if r > 0 {
                format!("_{}", r)
            } else {
                String::new()
            }
        ),
    }
}

/// Generates a module path for the algebra.
fn module_path(algebra: &Algebra) -> String {
    let (p, q, r) = algebra.signature();

    match (p, q, r) {
        (2, 0, 0) => "euclidean::dim2".to_string(),
        (3, 0, 0) => "euclidean::dim3".to_string(),
        (3, 0, 1) => "projective::dim3".to_string(),
        (4, 1, 0) => "conformal::dim3".to_string(),
        _ => format!(
            "generated::cl_{}_{}{}",
            p,
            q,
            if r > 0 {
                format!("_{}", r)
            } else {
                String::new()
            }
        ),
    }
}

/// Generates a description for the algebra.
fn algebra_description(algebra: &Algebra) -> String {
    let (p, q, r) = algebra.signature();

    match (p, q, r) {
        (2, 0, 0) => "2D Euclidean Geometric Algebra Cl(2,0,0)".to_string(),
        (3, 0, 0) => "3D Euclidean Geometric Algebra Cl(3,0,0)".to_string(),
        (3, 0, 1) => "3D Projective Geometric Algebra Cl(3,0,1)".to_string(),
        (4, 1, 0) => "3D Conformal Geometric Algebra Cl(4,1,0)".to_string(),
        _ => format!("Geometric Algebra Cl({},{},{})", p, q, r),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::discovery::discover_entities;

    #[test]
    fn generate_euclidean3_template() {
        let algebra = Algebra::euclidean(3);
        let entities = discover_entities(&algebra);

        let mut output = Vec::new();
        generate_toml_template(&algebra, &entities, &mut output).unwrap();

        let toml = String::from_utf8(output).unwrap();

        // Check header
        assert!(toml.contains("Auto-discovered entities for Cl(3,0,0)"));

        // Check algebra section
        assert!(toml.contains("[algebra]"));
        assert!(toml.contains("name = \"euclidean3\""));

        // Check signature section
        assert!(toml.contains("[signature]"));
        assert!(toml.contains("positive = [\"e1\", \"e2\", \"e3\"]"));

        // Check types section - entities are named by grades
        assert!(toml.contains("[types.Entity_0]")); // Scalar
        assert!(toml.contains("[types.Entity_1]")); // Vector
        assert!(toml.contains("[types.Entity_2]")); // Bivector
        assert!(toml.contains("[types.Entity_0_2]")); // Even/Rotor
    }

    #[test]
    fn toml_is_valid() {
        let algebra = Algebra::euclidean(3);
        let entities = discover_entities(&algebra);

        let mut output = Vec::new();
        generate_toml_template(&algebra, &entities, &mut output).unwrap();

        let toml_str = String::from_utf8(output).unwrap();

        // The TOML should parse without errors
        // Note: We're not adding toml as a dependency, so we just check structure
        assert!(toml_str.contains("[algebra]"));
        assert!(toml_str.contains("[signature]"));
        assert!(toml_str.contains("[types."));
        assert!(toml_str.contains("[options]"));
    }
}
