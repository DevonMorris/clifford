#![doc = " Trait implementations for projective3."]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
use super::types::{Flector, Line, Motor, Plane, Point, Quadvector, Scalar};
#[allow(unused_imports)]
use crate::ops::{
    Antidot, Antiproject, Antireverse, Antisandwich, Antiwedge, BulkContract, BulkExpand, Dot,
    InverseAntisandwich, InverseSandwich, Involute, LeftContract, Project, Reverse,
    RightComplement, RightContract, Sandwich, ScalarProduct, Transform, Versor, VersorInverse,
    Wedge, WeightContract, WeightDual, WeightExpand,
};
use crate::scalar::Float;
#[allow(unused_imports)]
use crate::wrappers::Unitized;
use approx::{AbsDiffEq, RelativeEq, UlpsEq};
use std::ops::{Add, Mul, Neg, Sub};
impl<T: Float> Add for Flector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.px() + rhs.px(),
            self.py() + rhs.py(),
            self.pz() + rhs.pz(),
            self.pw() + rhs.pw(),
            self.dist() + rhs.dist(),
            self.nz() + rhs.nz(),
            self.ny() + rhs.ny(),
            self.nx() + rhs.nx(),
        )
    }
}
impl<T: Float> Sub for Flector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.px() - rhs.px(),
            self.py() - rhs.py(),
            self.pz() - rhs.pz(),
            self.pw() - rhs.pw(),
            self.dist() - rhs.dist(),
            self.nz() - rhs.nz(),
            self.ny() - rhs.ny(),
            self.nx() - rhs.nx(),
        )
    }
}
impl<T: Float> Neg for Flector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(
            -self.px(),
            -self.py(),
            -self.pz(),
            -self.pw(),
            -self.dist(),
            -self.nz(),
            -self.ny(),
            -self.nx(),
        )
    }
}
impl<T: Float> Mul<T> for Flector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Flector<f32>> for f32 {
    type Output = Flector<f32>;
    #[inline]
    fn mul(self, v: Flector<f32>) -> Flector<f32> {
        v.scale(self)
    }
}
impl Mul<Flector<f64>> for f64 {
    type Output = Flector<f64>;
    #[inline]
    fn mul(self, v: Flector<f64>) -> Flector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Flector<T>> for Flector<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Motor<T> {
        Motor::new_unchecked(
            -(rhs.dist() * self.pw())
                + -(rhs.ny() * self.py())
                + -(rhs.px() * self.nx())
                + -(rhs.pz() * self.nz())
                + rhs.nx() * self.px()
                + rhs.nz() * self.pz()
                + rhs.pw() * self.dist()
                + rhs.py() * self.ny(),
            -(rhs.dist() * self.nz())
                + -(rhs.pw() * self.pz())
                + rhs.nx() * self.py()
                + rhs.ny() * self.px()
                + rhs.nz() * self.dist()
                + rhs.px() * self.ny()
                + rhs.py() * self.nx()
                + rhs.pz() * self.pw(),
            -(rhs.dist() * self.ny())
                + -(rhs.nz() * self.px())
                + -(rhs.px() * self.nz())
                + -(rhs.py() * self.pw())
                + rhs.nx() * self.pz()
                + rhs.ny() * self.dist()
                + rhs.pw() * self.py()
                + rhs.pz() * self.nx(),
            -(rhs.nz() * self.ny())
                + rhs.nx() * self.pw()
                + rhs.ny() * self.nz()
                + rhs.pw() * self.nx(),
            -(rhs.dist() * self.nx())
                + -(rhs.ny() * self.pz())
                + -(rhs.nz() * self.py())
                + -(rhs.pw() * self.px())
                + -(rhs.py() * self.nz())
                + -(rhs.pz() * self.ny())
                + rhs.nx() * self.dist()
                + rhs.px() * self.pw(),
            -(rhs.ny() * self.pw())
                + -(rhs.nz() * self.nx())
                + -(rhs.pw() * self.ny())
                + rhs.nx() * self.nz(),
            -(rhs.ny() * self.nx())
                + rhs.nx() * self.ny()
                + rhs.nz() * self.pw()
                + rhs.pw() * self.nz(),
            -(rhs.pw() * self.pw())
                + rhs.nx() * self.nx()
                + rhs.ny() * self.ny()
                + rhs.nz() * self.nz(),
        )
    }
}
impl<T: Float> Mul<Line<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Line<T>) -> Flector<T> {
        Flector::new_unchecked(
            -(rhs.dir_x() * self.dist())
                + -(rhs.dir_y() * self.pz())
                + -(rhs.moment_z() * self.ny())
                + rhs.dir_z() * self.py()
                + rhs.moment_x() * self.pw()
                + rhs.moment_y() * self.nz(),
            -(rhs.dir_y() * self.dist())
                + -(rhs.dir_z() * self.px())
                + -(rhs.moment_y() * self.pw())
                + -(rhs.moment_z() * self.nx())
                + rhs.dir_x() * self.pz()
                + rhs.moment_x() * self.nz(),
            -(rhs.dir_x() * self.py())
                + -(rhs.dir_z() * self.dist())
                + -(rhs.moment_y() * self.nx())
                + rhs.dir_y() * self.px()
                + rhs.moment_x() * self.ny()
                + rhs.moment_z() * self.pw(),
            -(rhs.dir_x() * self.nx()) + -(rhs.dir_z() * self.nz()) + rhs.dir_y() * self.ny(),
            rhs.dir_x() * self.px()
                + rhs.dir_y() * self.py()
                + rhs.dir_z() * self.pz()
                + rhs.moment_x() * self.nx()
                + rhs.moment_y() * self.ny()
                + rhs.moment_z() * self.nz(),
            rhs.dir_x() * self.ny() + rhs.dir_y() * self.nx() + rhs.dir_z() * self.pw(),
            -(rhs.dir_x() * self.nz()) + -(rhs.dir_y() * self.pw()) + rhs.dir_z() * self.nx(),
            -(rhs.dir_y() * self.nz()) + -(rhs.dir_z() * self.ny()) + rhs.dir_x() * self.pw(),
        )
    }
}
impl<T: Float> Mul<Motor<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Motor<T>) -> Flector<T> {
        Flector::new_unchecked(
            -(rhs.ps() * self.px())
                + -(rhs.ry() * self.pz())
                + -(rhs.tx() * self.dist())
                + -(rhs.tz() * self.ny())
                + rhs.rx() * self.pw()
                + rhs.rz() * self.py()
                + rhs.s() * self.nx()
                + rhs.ty() * self.nz(),
            -(rhs.ps() * self.py())
                + -(rhs.ry() * self.dist())
                + -(rhs.rz() * self.px())
                + -(rhs.s() * self.ny())
                + -(rhs.ty() * self.pw())
                + -(rhs.tz() * self.nx())
                + rhs.rx() * self.nz()
                + rhs.tx() * self.pz(),
            -(rhs.ps() * self.pz())
                + -(rhs.rz() * self.dist())
                + -(rhs.tx() * self.py())
                + -(rhs.ty() * self.nx())
                + rhs.rx() * self.ny()
                + rhs.ry() * self.px()
                + rhs.s() * self.nz()
                + rhs.tz() * self.pw(),
            -(rhs.ps() * self.pw())
                + -(rhs.rz() * self.nz())
                + -(rhs.tx() * self.nx())
                + rhs.ry() * self.ny(),
            -(rhs.ps() * self.dist())
                + -(rhs.s() * self.pw())
                + rhs.rx() * self.nx()
                + rhs.ry() * self.py()
                + rhs.rz() * self.pz()
                + rhs.tx() * self.px()
                + rhs.ty() * self.ny()
                + rhs.tz() * self.nz(),
            -(rhs.ps() * self.nz())
                + rhs.ry() * self.nx()
                + rhs.rz() * self.pw()
                + rhs.tx() * self.ny(),
            -(rhs.ps() * self.ny())
                + -(rhs.ry() * self.pw())
                + -(rhs.tx() * self.nz())
                + rhs.rz() * self.nx(),
            -(rhs.ps() * self.nx())
                + -(rhs.ry() * self.nz())
                + -(rhs.rz() * self.ny())
                + rhs.tx() * self.pw(),
        )
    }
}
impl<T: Float> Mul<Plane<T>> for Flector<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Plane<T>) -> Motor<T> {
        Motor::new_unchecked(
            -(rhs.dist() * self.dist()),
            rhs.dist() * self.pz(),
            -(rhs.dist() * self.py()),
            -(rhs.nx() * self.dist())
                + -(rhs.ny() * self.pz())
                + -(rhs.nz() * self.py())
                + rhs.dist() * self.nx(),
            rhs.dist() * self.px(),
            -(rhs.dist() * self.ny())
                + -(rhs.nx() * self.pz())
                + rhs.ny() * self.dist()
                + rhs.nz() * self.px(),
            -(rhs.nz() * self.dist())
                + rhs.dist() * self.nz()
                + rhs.nx() * self.py()
                + rhs.ny() * self.px(),
            -(rhs.dist() * self.pw())
                + -(rhs.ny() * self.py())
                + rhs.nx() * self.px()
                + rhs.nz() * self.pz(),
        )
    }
}
impl<T: Float> Mul<Point<T>> for Flector<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Point<T>) -> Motor<T> {
        Motor::new_unchecked(
            rhs.x() * self.px() + rhs.y() * self.py() + rhs.z() * self.pz(),
            -(rhs.x() * self.py()) + rhs.y() * self.px() + rhs.z() * self.dist(),
            -(rhs.x() * self.pz()) + -(rhs.y() * self.dist()) + rhs.z() * self.px(),
            -(rhs.x() * self.pw())
                + -(rhs.y() * self.nz())
                + -(rhs.z() * self.ny())
                + rhs.w() * self.px(),
            -(rhs.y() * self.pz()) + rhs.x() * self.dist() + rhs.z() * self.py(),
            -(rhs.y() * self.pw())
                + -(rhs.z() * self.nx())
                + rhs.w() * self.py()
                + rhs.x() * self.nz(),
            -(rhs.z() * self.pw())
                + rhs.w() * self.pz()
                + rhs.x() * self.ny()
                + rhs.y() * self.nx(),
            -(rhs.x() * self.nx())
                + -(rhs.z() * self.nz())
                + rhs.w() * self.dist()
                + rhs.y() * self.ny(),
        )
    }
}
impl<T: Float> Mul<Quadvector<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Quadvector<T>) -> Flector<T> {
        Flector::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            -(rhs.ps() * self.dist()),
            T::zero(),
            rhs.ps() * self.pz(),
            -(rhs.ps() * self.py()),
            rhs.ps() * self.px(),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Flector<T> {
        Flector::new_unchecked(
            rhs.s() * self.px(),
            rhs.s() * self.py(),
            rhs.s() * self.pz(),
            rhs.s() * self.pw(),
            rhs.s() * self.dist(),
            rhs.s() * self.nz(),
            rhs.s() * self.ny(),
            rhs.s() * self.nx(),
        )
    }
}
impl<T: Float> Add for Line<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.moment_z() + rhs.moment_z(),
            self.moment_y() + rhs.moment_y(),
            self.dir_x() + rhs.dir_x(),
            self.moment_x() + rhs.moment_x(),
            self.dir_y() + rhs.dir_y(),
            self.dir_z() + rhs.dir_z(),
        )
    }
}
impl<T: Float> Sub for Line<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.moment_z() - rhs.moment_z(),
            self.moment_y() - rhs.moment_y(),
            self.dir_x() - rhs.dir_x(),
            self.moment_x() - rhs.moment_x(),
            self.dir_y() - rhs.dir_y(),
            self.dir_z() - rhs.dir_z(),
        )
    }
}
impl<T: Float> Neg for Line<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(
            -self.moment_z(),
            -self.moment_y(),
            -self.dir_x(),
            -self.moment_x(),
            -self.dir_y(),
            -self.dir_z(),
        )
    }
}
impl<T: Float> Mul<T> for Line<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Line<f32>> for f32 {
    type Output = Line<f32>;
    #[inline]
    fn mul(self, v: Line<f32>) -> Line<f32> {
        v.scale(self)
    }
}
impl Mul<Line<f64>> for f64 {
    type Output = Line<f64>;
    #[inline]
    fn mul(self, v: Line<f64>) -> Line<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Flector<T>> for Line<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            -(rhs.dist() * self.dir_x())
                + -(rhs.ny() * self.moment_z())
                + -(rhs.pw() * self.moment_x())
                + -(rhs.py() * self.dir_z())
                + rhs.nz() * self.moment_y()
                + rhs.pz() * self.dir_y(),
            -(rhs.dist() * self.dir_y())
                + -(rhs.nx() * self.moment_z())
                + -(rhs.pz() * self.dir_x())
                + rhs.nz() * self.moment_x()
                + rhs.pw() * self.moment_y()
                + rhs.px() * self.dir_z(),
            -(rhs.dist() * self.dir_z())
                + -(rhs.nx() * self.moment_y())
                + -(rhs.pw() * self.moment_z())
                + -(rhs.px() * self.dir_y())
                + rhs.ny() * self.moment_x()
                + rhs.py() * self.dir_x(),
            -(rhs.nx() * self.dir_x()) + -(rhs.nz() * self.dir_z()) + rhs.ny() * self.dir_y(),
            -(rhs.nx() * self.moment_x())
                + -(rhs.ny() * self.moment_y())
                + -(rhs.nz() * self.moment_z())
                + rhs.px() * self.dir_x()
                + rhs.py() * self.dir_y()
                + rhs.pz() * self.dir_z(),
            -(rhs.nx() * self.dir_y()) + -(rhs.ny() * self.dir_x()) + rhs.pw() * self.dir_z(),
            -(rhs.nx() * self.dir_z()) + -(rhs.pw() * self.dir_y()) + rhs.nz() * self.dir_x(),
            rhs.ny() * self.dir_z() + rhs.nz() * self.dir_y() + rhs.pw() * self.dir_x(),
        )
    }
}
impl<T: Float> Mul<Line<T>> for Line<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Line<T>) -> Motor<T> {
        Motor::new_unchecked(
            -(rhs.dir_y() * self.moment_y())
                + -(rhs.moment_y() * self.dir_y())
                + rhs.dir_x() * self.moment_x()
                + rhs.dir_z() * self.moment_z()
                + rhs.moment_x() * self.dir_x()
                + rhs.moment_z() * self.dir_z(),
            -(rhs.dir_x() * self.moment_y())
                + -(rhs.dir_y() * self.moment_x())
                + rhs.moment_x() * self.dir_y()
                + rhs.moment_y() * self.dir_x(),
            -(rhs.dir_z() * self.moment_x())
                + -(rhs.moment_z() * self.dir_x())
                + rhs.dir_x() * self.moment_z()
                + rhs.moment_x() * self.dir_z(),
            -(rhs.dir_z() * self.dir_y()) + rhs.dir_y() * self.dir_z(),
            -(rhs.moment_y() * self.dir_z())
                + -(rhs.moment_z() * self.dir_y())
                + rhs.dir_y() * self.moment_z()
                + rhs.dir_z() * self.moment_y(),
            -(rhs.dir_x() * self.dir_z()) + rhs.dir_z() * self.dir_x(),
            -(rhs.dir_y() * self.dir_x()) + rhs.dir_x() * self.dir_y(),
            -(rhs.dir_x() * self.dir_x())
                + -(rhs.dir_y() * self.dir_y())
                + -(rhs.dir_z() * self.dir_z()),
        )
    }
}
impl<T: Float> Mul<Motor<T>> for Line<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            -(rhs.ry() * self.moment_y())
                + -(rhs.ty() * self.dir_y())
                + rhs.rx() * self.dir_x()
                + rhs.rz() * self.moment_z()
                + rhs.tx() * self.moment_x()
                + rhs.tz() * self.dir_z(),
            -(rhs.ry() * self.moment_x())
                + -(rhs.s() * self.dir_z())
                + -(rhs.tx() * self.moment_y())
                + rhs.ps() * self.moment_z()
                + rhs.rx() * self.dir_y()
                + rhs.ty() * self.dir_x(),
            -(rhs.rz() * self.moment_x())
                + -(rhs.tz() * self.dir_x())
                + rhs.ps() * self.moment_y()
                + rhs.rx() * self.dir_z()
                + rhs.s() * self.dir_y()
                + rhs.tx() * self.moment_z(),
            -(rhs.rz() * self.dir_y()) + rhs.ps() * self.dir_x() + rhs.ry() * self.dir_z(),
            -(rhs.s() * self.dir_x())
                + -(rhs.ty() * self.dir_z())
                + -(rhs.tz() * self.dir_y())
                + rhs.ps() * self.moment_x()
                + rhs.ry() * self.moment_z()
                + rhs.rz() * self.moment_y(),
            -(rhs.tx() * self.dir_z()) + rhs.ps() * self.dir_y() + rhs.rz() * self.dir_x(),
            -(rhs.ry() * self.dir_x()) + rhs.ps() * self.dir_z() + rhs.tx() * self.dir_y(),
            -(rhs.ry() * self.dir_y()) + -(rhs.rz() * self.dir_z()) + -(rhs.tx() * self.dir_x()),
        )
    }
}
impl<T: Float> Mul<Plane<T>> for Line<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Plane<T>) -> Flector<T> {
        Flector::new_unchecked(
            -(rhs.dist() * self.moment_x()),
            rhs.dist() * self.moment_y(),
            -(rhs.dist() * self.moment_z()),
            -(rhs.nx() * self.moment_x())
                + -(rhs.ny() * self.moment_y())
                + -(rhs.nz() * self.moment_z()),
            T::zero(),
            -(rhs.dist() * self.dir_z())
                + -(rhs.nx() * self.moment_y())
                + rhs.ny() * self.moment_x(),
            -(rhs.nz() * self.moment_x()) + rhs.dist() * self.dir_y() + rhs.nx() * self.moment_z(),
            -(rhs.dist() * self.dir_x())
                + -(rhs.ny() * self.moment_z())
                + rhs.nz() * self.moment_y(),
        )
    }
}
impl<T: Float> Mul<Point<T>> for Line<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Point<T>) -> Flector<T> {
        Flector::new_unchecked(
            rhs.y() * self.moment_z() + rhs.z() * self.moment_y(),
            -(rhs.x() * self.moment_z()) + rhs.z() * self.moment_x(),
            -(rhs.x() * self.moment_y()) + -(rhs.y() * self.moment_x()),
            -(rhs.x() * self.dir_x()) + -(rhs.y() * self.dir_y()) + -(rhs.z() * self.dir_z()),
            -(rhs.y() * self.moment_y()) + rhs.x() * self.moment_x() + rhs.z() * self.moment_z(),
            -(rhs.y() * self.dir_x()) + rhs.w() * self.moment_z() + rhs.x() * self.dir_y(),
            -(rhs.z() * self.dir_x()) + rhs.w() * self.moment_y() + rhs.x() * self.dir_z(),
            -(rhs.z() * self.dir_y()) + rhs.w() * self.moment_x() + rhs.y() * self.dir_z(),
        )
    }
}
impl<T: Float> Mul<Quadvector<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn mul(self, rhs: Quadvector<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            -(rhs.ps() * self.moment_x()),
            T::zero(),
            rhs.ps() * self.moment_y(),
            -(rhs.ps() * self.moment_z()),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.s() * self.moment_z(),
            rhs.s() * self.moment_y(),
            rhs.s() * self.dir_x(),
            rhs.s() * self.moment_x(),
            rhs.s() * self.dir_y(),
            rhs.s() * self.dir_z(),
        )
    }
}
impl<T: Float> Add for Motor<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.s() + rhs.s(),
            self.tz() + rhs.tz(),
            self.ty() + rhs.ty(),
            self.tx() + rhs.tx(),
            self.rx() + rhs.rx(),
            self.ry() + rhs.ry(),
            self.rz() + rhs.rz(),
            self.ps() + rhs.ps(),
        )
    }
}
impl<T: Float> Sub for Motor<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.s() - rhs.s(),
            self.tz() - rhs.tz(),
            self.ty() - rhs.ty(),
            self.tx() - rhs.tx(),
            self.rx() - rhs.rx(),
            self.ry() - rhs.ry(),
            self.rz() - rhs.rz(),
            self.ps() - rhs.ps(),
        )
    }
}
impl<T: Float> Neg for Motor<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(
            -self.s(),
            -self.tz(),
            -self.ty(),
            -self.tx(),
            -self.rx(),
            -self.ry(),
            -self.rz(),
            -self.ps(),
        )
    }
}
impl<T: Float> Mul<T> for Motor<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Motor<f32>> for f32 {
    type Output = Motor<f32>;
    #[inline]
    fn mul(self, v: Motor<f32>) -> Motor<f32> {
        v.scale(self)
    }
}
impl Mul<Motor<f64>> for f64 {
    type Output = Motor<f64>;
    #[inline]
    fn mul(self, v: Motor<f64>) -> Motor<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Flector<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            -(rhs.dist() * self.tx())
                + -(rhs.nx() * self.s())
                + -(rhs.ny() * self.tz())
                + -(rhs.pw() * self.rx())
                + -(rhs.px() * self.ps())
                + -(rhs.py() * self.rz())
                + rhs.nz() * self.ty()
                + rhs.pz() * self.ry(),
            -(rhs.dist() * self.ry())
                + -(rhs.nx() * self.tz())
                + -(rhs.py() * self.ps())
                + -(rhs.pz() * self.tx())
                + rhs.ny() * self.s()
                + rhs.nz() * self.rx()
                + rhs.pw() * self.ty()
                + rhs.px() * self.rz(),
            -(rhs.dist() * self.rz())
                + -(rhs.nx() * self.ty())
                + -(rhs.nz() * self.s())
                + -(rhs.pw() * self.tz())
                + -(rhs.px() * self.ry())
                + -(rhs.pz() * self.ps())
                + rhs.ny() * self.rx()
                + rhs.py() * self.tx(),
            -(rhs.nx() * self.tx())
                + -(rhs.nz() * self.rz())
                + -(rhs.pw() * self.ps())
                + rhs.ny() * self.ry(),
            -(rhs.dist() * self.ps())
                + -(rhs.nx() * self.rx())
                + -(rhs.ny() * self.ty())
                + -(rhs.nz() * self.tz())
                + rhs.pw() * self.s()
                + rhs.px() * self.tx()
                + rhs.py() * self.ry()
                + rhs.pz() * self.rz(),
            -(rhs.nx() * self.ry())
                + -(rhs.ny() * self.tx())
                + -(rhs.nz() * self.ps())
                + rhs.pw() * self.rz(),
            -(rhs.nx() * self.rz())
                + -(rhs.ny() * self.ps())
                + -(rhs.pw() * self.ry())
                + rhs.nz() * self.tx(),
            -(rhs.nx() * self.ps())
                + rhs.ny() * self.rz()
                + rhs.nz() * self.ry()
                + rhs.pw() * self.tx(),
        )
    }
}
impl<T: Float> Mul<Line<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Line<T>) -> Motor<T> {
        Motor::new_unchecked(
            -(rhs.dir_y() * self.ty())
                + -(rhs.moment_y() * self.ry())
                + rhs.dir_x() * self.rx()
                + rhs.dir_z() * self.tz()
                + rhs.moment_x() * self.tx()
                + rhs.moment_z() * self.rz(),
            -(rhs.dir_x() * self.ty())
                + -(rhs.dir_y() * self.rx())
                + -(rhs.dir_z() * self.s())
                + rhs.moment_x() * self.ry()
                + rhs.moment_y() * self.tx()
                + rhs.moment_z() * self.ps(),
            -(rhs.dir_z() * self.rx())
                + -(rhs.moment_z() * self.tx())
                + rhs.dir_x() * self.tz()
                + rhs.dir_y() * self.s()
                + rhs.moment_x() * self.rz()
                + rhs.moment_y() * self.ps(),
            -(rhs.dir_z() * self.ry()) + rhs.dir_x() * self.ps() + rhs.dir_y() * self.rz(),
            -(rhs.dir_x() * self.s())
                + -(rhs.moment_y() * self.rz())
                + -(rhs.moment_z() * self.ry())
                + rhs.dir_y() * self.tz()
                + rhs.dir_z() * self.ty()
                + rhs.moment_x() * self.ps(),
            -(rhs.dir_x() * self.rz()) + rhs.dir_y() * self.ps() + rhs.dir_z() * self.tx(),
            -(rhs.dir_y() * self.tx()) + rhs.dir_x() * self.ry() + rhs.dir_z() * self.ps(),
            -(rhs.dir_x() * self.tx()) + -(rhs.dir_y() * self.ry()) + -(rhs.dir_z() * self.rz()),
        )
    }
}
impl<T: Float> Mul<Motor<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            -(rhs.ry() * self.ty())
                + -(rhs.ty() * self.ry())
                + rhs.ps() * self.s()
                + rhs.rx() * self.tx()
                + rhs.rz() * self.tz()
                + rhs.s() * self.ps()
                + rhs.tx() * self.rx()
                + rhs.tz() * self.rz(),
            -(rhs.ry() * self.rx())
                + -(rhs.rz() * self.s())
                + -(rhs.s() * self.rz())
                + -(rhs.tx() * self.ty())
                + rhs.ps() * self.tz()
                + rhs.rx() * self.ry()
                + rhs.ty() * self.tx()
                + rhs.tz() * self.ps(),
            -(rhs.rz() * self.rx())
                + -(rhs.tz() * self.tx())
                + rhs.ps() * self.ty()
                + rhs.rx() * self.rz()
                + rhs.ry() * self.s()
                + rhs.s() * self.ry()
                + rhs.tx() * self.tz()
                + rhs.ty() * self.ps(),
            -(rhs.rz() * self.ry())
                + rhs.ps() * self.tx()
                + rhs.ry() * self.rz()
                + rhs.tx() * self.ps(),
            -(rhs.s() * self.tx())
                + -(rhs.tx() * self.s())
                + -(rhs.ty() * self.rz())
                + -(rhs.tz() * self.ry())
                + rhs.ps() * self.rx()
                + rhs.rx() * self.ps()
                + rhs.ry() * self.tz()
                + rhs.rz() * self.ty(),
            -(rhs.tx() * self.rz())
                + rhs.ps() * self.ry()
                + rhs.ry() * self.ps()
                + rhs.rz() * self.tx(),
            -(rhs.ry() * self.tx())
                + rhs.ps() * self.rz()
                + rhs.rz() * self.ps()
                + rhs.tx() * self.ry(),
            -(rhs.ry() * self.ry())
                + -(rhs.rz() * self.rz())
                + -(rhs.tx() * self.tx())
                + rhs.ps() * self.ps(),
        )
    }
}
impl<T: Float> Mul<Plane<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Plane<T>) -> Flector<T> {
        Flector::new_unchecked(
            -(rhs.dist() * self.rx()),
            rhs.dist() * self.ty(),
            -(rhs.dist() * self.tz()),
            -(rhs.nx() * self.rx())
                + -(rhs.ny() * self.ty())
                + -(rhs.nz() * self.tz())
                + rhs.dist() * self.ps(),
            rhs.dist() * self.s(),
            -(rhs.dist() * self.rz())
                + -(rhs.nx() * self.ty())
                + rhs.ny() * self.rx()
                + rhs.nz() * self.s(),
            -(rhs.nz() * self.rx())
                + rhs.dist() * self.ry()
                + rhs.nx() * self.tz()
                + rhs.ny() * self.s(),
            -(rhs.dist() * self.tx())
                + -(rhs.ny() * self.tz())
                + rhs.nx() * self.s()
                + rhs.nz() * self.ty(),
        )
    }
}
impl<T: Float> Mul<Point<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Point<T>) -> Flector<T> {
        Flector::new_unchecked(
            rhs.x() * self.s() + rhs.y() * self.tz() + rhs.z() * self.ty(),
            -(rhs.x() * self.tz()) + rhs.y() * self.s() + rhs.z() * self.rx(),
            -(rhs.x() * self.ty()) + -(rhs.y() * self.rx()) + rhs.z() * self.s(),
            -(rhs.x() * self.tx())
                + -(rhs.y() * self.ry())
                + -(rhs.z() * self.rz())
                + rhs.w() * self.s(),
            -(rhs.y() * self.ty()) + rhs.x() * self.rx() + rhs.z() * self.tz(),
            -(rhs.y() * self.tx())
                + -(rhs.z() * self.ps())
                + rhs.w() * self.tz()
                + rhs.x() * self.ry(),
            -(rhs.z() * self.tx())
                + rhs.w() * self.ty()
                + rhs.x() * self.rz()
                + rhs.y() * self.ps(),
            -(rhs.x() * self.ps())
                + -(rhs.z() * self.ry())
                + rhs.w() * self.rx()
                + rhs.y() * self.rz(),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Motor<T> {
        Motor::new_unchecked(
            rhs.s() * self.s(),
            rhs.s() * self.tz(),
            rhs.s() * self.ty(),
            rhs.s() * self.tx(),
            rhs.s() * self.rx(),
            rhs.s() * self.ry(),
            rhs.s() * self.rz(),
            rhs.s() * self.ps(),
        )
    }
}
impl<T: Float> Add for Plane<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.dist() + rhs.dist(),
            self.nz() + rhs.nz(),
            self.ny() + rhs.ny(),
            self.nx() + rhs.nx(),
        )
    }
}
impl<T: Float> Sub for Plane<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.dist() - rhs.dist(),
            self.nz() - rhs.nz(),
            self.ny() - rhs.ny(),
            self.nx() - rhs.nx(),
        )
    }
}
impl<T: Float> Neg for Plane<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.dist(), -self.nz(), -self.ny(), -self.nx())
    }
}
impl<T: Float> Mul<T> for Plane<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Plane<f32>> for f32 {
    type Output = Plane<f32>;
    #[inline]
    fn mul(self, v: Plane<f32>) -> Plane<f32> {
        v.scale(self)
    }
}
impl Mul<Plane<f64>> for f64 {
    type Output = Plane<f64>;
    #[inline]
    fn mul(self, v: Plane<f64>) -> Plane<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Flector<T>> for Plane<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Motor<T> {
        Motor::new_unchecked(
            -(rhs.dist() * self.dist()),
            rhs.pz() * self.dist(),
            -(rhs.py() * self.dist()),
            -(rhs.nx() * self.dist())
                + -(rhs.py() * self.nz())
                + -(rhs.pz() * self.ny())
                + rhs.dist() * self.nx(),
            rhs.px() * self.dist(),
            -(rhs.dist() * self.ny())
                + -(rhs.pz() * self.nx())
                + rhs.ny() * self.dist()
                + rhs.px() * self.nz(),
            -(rhs.nz() * self.dist())
                + rhs.dist() * self.nz()
                + rhs.px() * self.ny()
                + rhs.py() * self.nx(),
            -(rhs.px() * self.nx())
                + -(rhs.pz() * self.nz())
                + rhs.pw() * self.dist()
                + rhs.py() * self.ny(),
        )
    }
}
impl<T: Float> Mul<Line<T>> for Plane<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Line<T>) -> Flector<T> {
        Flector::new_unchecked(
            -(rhs.moment_x() * self.dist()),
            rhs.moment_y() * self.dist(),
            -(rhs.moment_z() * self.dist()),
            -(rhs.moment_x() * self.nx())
                + -(rhs.moment_y() * self.ny())
                + -(rhs.moment_z() * self.nz()),
            T::zero(),
            -(rhs.moment_x() * self.ny()) + rhs.dir_z() * self.dist() + rhs.moment_y() * self.nx(),
            -(rhs.dir_y() * self.dist())
                + -(rhs.moment_z() * self.nx())
                + rhs.moment_x() * self.nz(),
            -(rhs.moment_y() * self.nz()) + rhs.dir_x() * self.dist() + rhs.moment_z() * self.ny(),
        )
    }
}
impl<T: Float> Mul<Motor<T>> for Plane<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Motor<T>) -> Flector<T> {
        Flector::new_unchecked(
            -(rhs.rx() * self.dist()),
            rhs.ty() * self.dist(),
            -(rhs.tz() * self.dist()),
            -(rhs.ps() * self.dist())
                + -(rhs.rx() * self.nx())
                + -(rhs.ty() * self.ny())
                + -(rhs.tz() * self.nz()),
            rhs.s() * self.dist(),
            -(rhs.rx() * self.ny())
                + rhs.rz() * self.dist()
                + rhs.s() * self.nz()
                + rhs.ty() * self.nx(),
            -(rhs.ry() * self.dist())
                + -(rhs.tz() * self.nx())
                + rhs.rx() * self.nz()
                + rhs.s() * self.ny(),
            -(rhs.ty() * self.nz())
                + rhs.s() * self.nx()
                + rhs.tx() * self.dist()
                + rhs.tz() * self.ny(),
        )
    }
}
impl<T: Float> Mul<Quadvector<T>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn mul(self, rhs: Quadvector<T>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), -(rhs.ps() * self.dist()))
    }
}
impl<T: Float> Mul<Scalar<T>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.s() * self.dist(),
            rhs.s() * self.nz(),
            rhs.s() * self.ny(),
            rhs.s() * self.nx(),
        )
    }
}
impl<T: Float> Add for Point<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.x() + rhs.x(),
            self.y() + rhs.y(),
            self.z() + rhs.z(),
            self.w() + rhs.w(),
        )
    }
}
impl<T: Float> Sub for Point<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.x() - rhs.x(),
            self.y() - rhs.y(),
            self.z() - rhs.z(),
            self.w() - rhs.w(),
        )
    }
}
impl<T: Float> Neg for Point<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.x(), -self.y(), -self.z(), -self.w())
    }
}
impl<T: Float> Mul<T> for Point<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Point<f32>> for f32 {
    type Output = Point<f32>;
    #[inline]
    fn mul(self, v: Point<f32>) -> Point<f32> {
        v.scale(self)
    }
}
impl Mul<Point<f64>> for f64 {
    type Output = Point<f64>;
    #[inline]
    fn mul(self, v: Point<f64>) -> Point<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Flector<T>> for Point<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Motor<T> {
        Motor::new_unchecked(
            rhs.px() * self.x() + rhs.py() * self.y() + rhs.pz() * self.z(),
            -(rhs.px() * self.y()) + rhs.dist() * self.z() + rhs.py() * self.x(),
            -(rhs.dist() * self.y()) + -(rhs.px() * self.z()) + rhs.pz() * self.x(),
            -(rhs.ny() * self.z())
                + -(rhs.nz() * self.y())
                + -(rhs.px() * self.w())
                + rhs.pw() * self.x(),
            -(rhs.py() * self.z()) + rhs.dist() * self.x() + rhs.pz() * self.y(),
            -(rhs.nx() * self.z())
                + -(rhs.py() * self.w())
                + rhs.nz() * self.x()
                + rhs.pw() * self.y(),
            -(rhs.pz() * self.w())
                + rhs.nx() * self.y()
                + rhs.ny() * self.x()
                + rhs.pw() * self.z(),
            -(rhs.dist() * self.w())
                + -(rhs.ny() * self.y())
                + rhs.nx() * self.x()
                + rhs.nz() * self.z(),
        )
    }
}
impl<T: Float> Mul<Line<T>> for Point<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Line<T>) -> Flector<T> {
        Flector::new_unchecked(
            -(rhs.moment_y() * self.z()) + -(rhs.moment_z() * self.y()),
            -(rhs.moment_x() * self.z()) + rhs.moment_z() * self.x(),
            rhs.moment_x() * self.y() + rhs.moment_y() * self.x(),
            rhs.dir_x() * self.x() + rhs.dir_y() * self.y() + rhs.dir_z() * self.z(),
            -(rhs.moment_y() * self.y()) + rhs.moment_x() * self.x() + rhs.moment_z() * self.z(),
            -(rhs.dir_x() * self.y()) + rhs.dir_y() * self.x() + rhs.moment_z() * self.w(),
            -(rhs.dir_x() * self.z()) + rhs.dir_z() * self.x() + rhs.moment_y() * self.w(),
            -(rhs.dir_y() * self.z()) + rhs.dir_z() * self.y() + rhs.moment_x() * self.w(),
        )
    }
}
impl<T: Float> Mul<Motor<T>> for Point<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Motor<T>) -> Flector<T> {
        Flector::new_unchecked(
            -(rhs.ty() * self.z()) + -(rhs.tz() * self.y()) + rhs.s() * self.x(),
            -(rhs.rx() * self.z()) + rhs.s() * self.y() + rhs.tz() * self.x(),
            rhs.rx() * self.y() + rhs.s() * self.z() + rhs.ty() * self.x(),
            rhs.ry() * self.y() + rhs.rz() * self.z() + rhs.s() * self.w() + rhs.tx() * self.x(),
            -(rhs.ty() * self.y()) + rhs.rx() * self.x() + rhs.tz() * self.z(),
            -(rhs.tx() * self.y())
                + rhs.ps() * self.z()
                + rhs.ry() * self.x()
                + rhs.tz() * self.w(),
            -(rhs.ps() * self.y())
                + -(rhs.tx() * self.z())
                + rhs.rz() * self.x()
                + rhs.ty() * self.w(),
            -(rhs.ry() * self.z())
                + rhs.ps() * self.x()
                + rhs.rx() * self.w()
                + rhs.rz() * self.y(),
        )
    }
}
impl<T: Float> Mul<Quadvector<T>> for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn mul(self, rhs: Quadvector<T>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            rhs.ps() * self.z(),
            -(rhs.ps() * self.y()),
            rhs.ps() * self.x(),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.s() * self.x(),
            rhs.s() * self.y(),
            rhs.s() * self.z(),
            rhs.s() * self.w(),
        )
    }
}
impl<T: Float> Add for Quadvector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.ps() + rhs.ps())
    }
}
impl<T: Float> Sub for Quadvector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.ps() - rhs.ps())
    }
}
impl<T: Float> Neg for Quadvector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.ps())
    }
}
impl<T: Float> Mul<T> for Quadvector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Quadvector<f32>> for f32 {
    type Output = Quadvector<f32>;
    #[inline]
    fn mul(self, v: Quadvector<f32>) -> Quadvector<f32> {
        v.scale(self)
    }
}
impl Mul<Quadvector<f64>> for f64 {
    type Output = Quadvector<f64>;
    #[inline]
    fn mul(self, v: Quadvector<f64>) -> Quadvector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Flector<T>> for Quadvector<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            rhs.dist() * self.ps(),
            T::zero(),
            -(rhs.pz() * self.ps()),
            rhs.py() * self.ps(),
            -(rhs.px() * self.ps()),
        )
    }
}
impl<T: Float> Mul<Line<T>> for Quadvector<T> {
    type Output = Line<T>;
    #[inline]
    fn mul(self, rhs: Line<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            -(rhs.moment_x() * self.ps()),
            T::zero(),
            rhs.moment_y() * self.ps(),
            -(rhs.moment_z() * self.ps()),
        )
    }
}
impl<T: Float> Mul<Plane<T>> for Quadvector<T> {
    type Output = Point<T>;
    #[inline]
    fn mul(self, rhs: Plane<T>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), rhs.dist() * self.ps())
    }
}
impl<T: Float> Mul<Point<T>> for Quadvector<T> {
    type Output = Plane<T>;
    #[inline]
    fn mul(self, rhs: Point<T>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            -(rhs.z() * self.ps()),
            rhs.y() * self.ps(),
            -(rhs.x() * self.ps()),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.s() * self.ps())
    }
}
impl<T: Float> Add for Scalar<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.s() + rhs.s())
    }
}
impl<T: Float> Sub for Scalar<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.s() - rhs.s())
    }
}
impl<T: Float> Neg for Scalar<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.s())
    }
}
impl<T: Float> Mul<T> for Scalar<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Scalar<f32>> for f32 {
    type Output = Scalar<f32>;
    #[inline]
    fn mul(self, v: Scalar<f32>) -> Scalar<f32> {
        v.scale(self)
    }
}
impl Mul<Scalar<f64>> for f64 {
    type Output = Scalar<f64>;
    #[inline]
    fn mul(self, v: Scalar<f64>) -> Scalar<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Flector<T>> for Scalar<T> {
    type Output = Flector<T>;
    #[inline]
    fn mul(self, rhs: Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            rhs.px() * self.s(),
            rhs.py() * self.s(),
            rhs.pz() * self.s(),
            rhs.pw() * self.s(),
            rhs.dist() * self.s(),
            rhs.nz() * self.s(),
            rhs.ny() * self.s(),
            rhs.nx() * self.s(),
        )
    }
}
impl<T: Float> Mul<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn mul(self, rhs: Line<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.moment_z() * self.s(),
            rhs.moment_y() * self.s(),
            rhs.dir_x() * self.s(),
            rhs.moment_x() * self.s(),
            rhs.dir_y() * self.s(),
            rhs.dir_z() * self.s(),
        )
    }
}
impl<T: Float> Mul<Motor<T>> for Scalar<T> {
    type Output = Motor<T>;
    #[inline]
    fn mul(self, rhs: Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            rhs.s() * self.s(),
            rhs.tz() * self.s(),
            rhs.ty() * self.s(),
            rhs.tx() * self.s(),
            rhs.rx() * self.s(),
            rhs.ry() * self.s(),
            rhs.rz() * self.s(),
            rhs.ps() * self.s(),
        )
    }
}
impl<T: Float> Mul<Plane<T>> for Scalar<T> {
    type Output = Plane<T>;
    #[inline]
    fn mul(self, rhs: Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.dist() * self.s(),
            rhs.nz() * self.s(),
            rhs.ny() * self.s(),
            rhs.nx() * self.s(),
        )
    }
}
impl<T: Float> Mul<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn mul(self, rhs: Point<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.x() * self.s(),
            rhs.y() * self.s(),
            rhs.z() * self.s(),
            rhs.w() * self.s(),
        )
    }
}
impl<T: Float> Mul<Quadvector<T>> for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn mul(self, rhs: Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.ps() * self.s())
    }
}
impl<T: Float> Mul<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
#[doc = "Wedge (exterior/outer) product of [`Line`] and [`Line`].\n\nThe wedge product `a ^ b` computes the outer product, which represents\nthe oriented subspace spanned by both operands. The result grade is the\nsum of the input grades (or zero if they share common factors)."]
impl<T: Float> Wedge<Line<T>> for Line<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Line<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(rhs.dir_y() * self.moment_y())
                + -(rhs.moment_y() * self.dir_y())
                + rhs.dir_x() * self.moment_x()
                + rhs.dir_z() * self.moment_z()
                + rhs.moment_x() * self.dir_x()
                + rhs.moment_z() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Line<T>> for Unitized<Line<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Line<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(rhs.dir_y() * self.as_inner().moment_y())
                + -(rhs.moment_y() * self.as_inner().dir_y())
                + rhs.dir_x() * self.as_inner().moment_x()
                + rhs.dir_z() * self.as_inner().moment_z()
                + rhs.moment_x() * self.as_inner().dir_x()
                + rhs.moment_z() * self.as_inner().dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Line<T>>> for Line<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Line<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(rhs.as_inner().dir_y() * self.moment_y())
                + -(rhs.as_inner().moment_y() * self.dir_y())
                + rhs.as_inner().dir_x() * self.moment_x()
                + rhs.as_inner().dir_z() * self.moment_z()
                + rhs.as_inner().moment_x() * self.dir_x()
                + rhs.as_inner().moment_z() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Line<T>>> for Unitized<Line<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Line<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(rhs.as_inner().dir_y() * self.as_inner().moment_y())
                + -(rhs.as_inner().moment_y() * self.as_inner().dir_y())
                + rhs.as_inner().dir_x() * self.as_inner().moment_x()
                + rhs.as_inner().dir_z() * self.as_inner().moment_z()
                + rhs.as_inner().moment_x() * self.as_inner().dir_x()
                + rhs.as_inner().moment_z() * self.as_inner().dir_z(),
        )
    }
}
#[doc = "Wedge (exterior/outer) product of [`Line`] and [`Point`].\n\nThe wedge product `a ^ b` computes the outer product, which represents\nthe oriented subspace spanned by both operands. The result grade is the\nsum of the input grades (or zero if they share common factors)."]
impl<T: Float> Wedge<Point<T>> for Line<T> {
    type Output = Plane<T>;
    #[inline]
    fn wedge(&self, rhs: &Point<T>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.y() * self.moment_y()) + rhs.x() * self.moment_x() + rhs.z() * self.moment_z(),
            -(rhs.y() * self.dir_x()) + rhs.w() * self.moment_z() + rhs.x() * self.dir_y(),
            -(rhs.z() * self.dir_x()) + rhs.w() * self.moment_y() + rhs.x() * self.dir_z(),
            -(rhs.z() * self.dir_y()) + rhs.w() * self.moment_x() + rhs.y() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Point<T>> for Unitized<Line<T>> {
    type Output = Plane<T>;
    #[inline]
    fn wedge(&self, rhs: &Point<T>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.y() * self.as_inner().moment_y())
                + rhs.x() * self.as_inner().moment_x()
                + rhs.z() * self.as_inner().moment_z(),
            -(rhs.y() * self.as_inner().dir_x())
                + rhs.w() * self.as_inner().moment_z()
                + rhs.x() * self.as_inner().dir_y(),
            -(rhs.z() * self.as_inner().dir_x())
                + rhs.w() * self.as_inner().moment_y()
                + rhs.x() * self.as_inner().dir_z(),
            -(rhs.z() * self.as_inner().dir_y())
                + rhs.w() * self.as_inner().moment_x()
                + rhs.y() * self.as_inner().dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Point<T>>> for Line<T> {
    type Output = Plane<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Point<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.as_inner().y() * self.moment_y())
                + rhs.as_inner().x() * self.moment_x()
                + rhs.as_inner().z() * self.moment_z(),
            -(rhs.as_inner().y() * self.dir_x())
                + rhs.as_inner().w() * self.moment_z()
                + rhs.as_inner().x() * self.dir_y(),
            -(rhs.as_inner().z() * self.dir_x())
                + rhs.as_inner().w() * self.moment_y()
                + rhs.as_inner().x() * self.dir_z(),
            -(rhs.as_inner().z() * self.dir_y())
                + rhs.as_inner().w() * self.moment_x()
                + rhs.as_inner().y() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Point<T>>> for Unitized<Line<T>> {
    type Output = Plane<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Point<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.as_inner().y() * self.as_inner().moment_y())
                + rhs.as_inner().x() * self.as_inner().moment_x()
                + rhs.as_inner().z() * self.as_inner().moment_z(),
            -(rhs.as_inner().y() * self.as_inner().dir_x())
                + rhs.as_inner().w() * self.as_inner().moment_z()
                + rhs.as_inner().x() * self.as_inner().dir_y(),
            -(rhs.as_inner().z() * self.as_inner().dir_x())
                + rhs.as_inner().w() * self.as_inner().moment_y()
                + rhs.as_inner().x() * self.as_inner().dir_z(),
            -(rhs.as_inner().z() * self.as_inner().dir_y())
                + rhs.as_inner().w() * self.as_inner().moment_x()
                + rhs.as_inner().y() * self.as_inner().dir_z(),
        )
    }
}
#[doc = "Wedge (exterior/outer) product of [`Line`] and [`Scalar`].\n\nThe wedge product `a ^ b` computes the outer product, which represents\nthe oriented subspace spanned by both operands. The result grade is the\nsum of the input grades (or zero if they share common factors)."]
impl<T: Float> Wedge<Scalar<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.s() * self.moment_z(),
            rhs.s() * self.moment_y(),
            rhs.s() * self.dir_x(),
            rhs.s() * self.moment_x(),
            rhs.s() * self.dir_y(),
            rhs.s() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.s() * self.as_inner().moment_z(),
            rhs.s() * self.as_inner().moment_y(),
            rhs.s() * self.as_inner().dir_x(),
            rhs.s() * self.as_inner().moment_x(),
            rhs.s() * self.as_inner().dir_y(),
            rhs.s() * self.as_inner().dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[doc = "Wedge (exterior/outer) product of [`Plane`] and [`Point`].\n\nThe wedge product `a ^ b` computes the outer product, which represents\nthe oriented subspace spanned by both operands. The result grade is the\nsum of the input grades (or zero if they share common factors)."]
impl<T: Float> Wedge<Point<T>> for Plane<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Point<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(rhs.x() * self.nx())
                + -(rhs.z() * self.nz())
                + rhs.w() * self.dist()
                + rhs.y() * self.ny(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Point<T>> for Unitized<Plane<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Point<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(rhs.x() * self.as_inner().nx())
                + -(rhs.z() * self.as_inner().nz())
                + rhs.w() * self.as_inner().dist()
                + rhs.y() * self.as_inner().ny(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Point<T>>> for Plane<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Point<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(rhs.as_inner().x() * self.nx())
                + -(rhs.as_inner().z() * self.nz())
                + rhs.as_inner().w() * self.dist()
                + rhs.as_inner().y() * self.ny(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Point<T>>> for Unitized<Plane<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Point<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(rhs.as_inner().x() * self.as_inner().nx())
                + -(rhs.as_inner().z() * self.as_inner().nz())
                + rhs.as_inner().w() * self.as_inner().dist()
                + rhs.as_inner().y() * self.as_inner().ny(),
        )
    }
}
#[doc = "Wedge (exterior/outer) product of [`Plane`] and [`Scalar`].\n\nThe wedge product `a ^ b` computes the outer product, which represents\nthe oriented subspace spanned by both operands. The result grade is the\nsum of the input grades (or zero if they share common factors)."]
impl<T: Float> Wedge<Scalar<T>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.s() * self.dist(),
            rhs.s() * self.nz(),
            rhs.s() * self.ny(),
            rhs.s() * self.nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.s() * self.as_inner().dist(),
            rhs.s() * self.as_inner().nz(),
            rhs.s() * self.as_inner().ny(),
            rhs.s() * self.as_inner().nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Wedge (exterior/outer) product of [`Point`] and [`Line`].\n\nThe wedge product `a ^ b` computes the outer product, which represents\nthe oriented subspace spanned by both operands. The result grade is the\nsum of the input grades (or zero if they share common factors)."]
impl<T: Float> Wedge<Line<T>> for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn wedge(&self, rhs: &Line<T>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.moment_y() * self.y()) + rhs.moment_x() * self.x() + rhs.moment_z() * self.z(),
            -(rhs.dir_x() * self.y()) + rhs.dir_y() * self.x() + rhs.moment_z() * self.w(),
            -(rhs.dir_x() * self.z()) + rhs.dir_z() * self.x() + rhs.moment_y() * self.w(),
            -(rhs.dir_y() * self.z()) + rhs.dir_z() * self.y() + rhs.moment_x() * self.w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Line<T>> for Unitized<Point<T>> {
    type Output = Plane<T>;
    #[inline]
    fn wedge(&self, rhs: &Line<T>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.moment_y() * self.as_inner().y())
                + rhs.moment_x() * self.as_inner().x()
                + rhs.moment_z() * self.as_inner().z(),
            -(rhs.dir_x() * self.as_inner().y())
                + rhs.dir_y() * self.as_inner().x()
                + rhs.moment_z() * self.as_inner().w(),
            -(rhs.dir_x() * self.as_inner().z())
                + rhs.dir_z() * self.as_inner().x()
                + rhs.moment_y() * self.as_inner().w(),
            -(rhs.dir_y() * self.as_inner().z())
                + rhs.dir_z() * self.as_inner().y()
                + rhs.moment_x() * self.as_inner().w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Line<T>>> for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Line<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.as_inner().moment_y() * self.y())
                + rhs.as_inner().moment_x() * self.x()
                + rhs.as_inner().moment_z() * self.z(),
            -(rhs.as_inner().dir_x() * self.y())
                + rhs.as_inner().dir_y() * self.x()
                + rhs.as_inner().moment_z() * self.w(),
            -(rhs.as_inner().dir_x() * self.z())
                + rhs.as_inner().dir_z() * self.x()
                + rhs.as_inner().moment_y() * self.w(),
            -(rhs.as_inner().dir_y() * self.z())
                + rhs.as_inner().dir_z() * self.y()
                + rhs.as_inner().moment_x() * self.w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Line<T>>> for Unitized<Point<T>> {
    type Output = Plane<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Line<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.as_inner().moment_y() * self.as_inner().y())
                + rhs.as_inner().moment_x() * self.as_inner().x()
                + rhs.as_inner().moment_z() * self.as_inner().z(),
            -(rhs.as_inner().dir_x() * self.as_inner().y())
                + rhs.as_inner().dir_y() * self.as_inner().x()
                + rhs.as_inner().moment_z() * self.as_inner().w(),
            -(rhs.as_inner().dir_x() * self.as_inner().z())
                + rhs.as_inner().dir_z() * self.as_inner().x()
                + rhs.as_inner().moment_y() * self.as_inner().w(),
            -(rhs.as_inner().dir_y() * self.as_inner().z())
                + rhs.as_inner().dir_z() * self.as_inner().y()
                + rhs.as_inner().moment_x() * self.as_inner().w(),
        )
    }
}
#[doc = "Wedge (exterior/outer) product of [`Point`] and [`Plane`].\n\nThe wedge product `a ^ b` computes the outer product, which represents\nthe oriented subspace spanned by both operands. The result grade is the\nsum of the input grades (or zero if they share common factors)."]
impl<T: Float> Wedge<Plane<T>> for Point<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Plane<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(rhs.dist() * self.w())
                + -(rhs.ny() * self.y())
                + rhs.nx() * self.x()
                + rhs.nz() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Plane<T>> for Unitized<Point<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Plane<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(rhs.dist() * self.as_inner().w())
                + -(rhs.ny() * self.as_inner().y())
                + rhs.nx() * self.as_inner().x()
                + rhs.nz() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Plane<T>>> for Point<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Plane<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(rhs.as_inner().dist() * self.w())
                + -(rhs.as_inner().ny() * self.y())
                + rhs.as_inner().nx() * self.x()
                + rhs.as_inner().nz() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Plane<T>>> for Unitized<Point<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Plane<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(rhs.as_inner().dist() * self.as_inner().w())
                + -(rhs.as_inner().ny() * self.as_inner().y())
                + rhs.as_inner().nx() * self.as_inner().x()
                + rhs.as_inner().nz() * self.as_inner().z(),
        )
    }
}
#[doc = "Wedge (exterior/outer) product of [`Point`] and [`Point`].\n\nThe wedge product `a ^ b` computes the outer product, which represents\nthe oriented subspace spanned by both operands. The result grade is the\nsum of the input grades (or zero if they share common factors)."]
impl<T: Float> Wedge<Point<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            -(rhs.x() * self.y()) + rhs.y() * self.x(),
            -(rhs.x() * self.z()) + rhs.z() * self.x(),
            -(rhs.x() * self.w()) + rhs.w() * self.x(),
            -(rhs.y() * self.z()) + rhs.z() * self.y(),
            -(rhs.y() * self.w()) + rhs.w() * self.y(),
            -(rhs.z() * self.w()) + rhs.w() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Point<T>> for Unitized<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            -(rhs.x() * self.as_inner().y()) + rhs.y() * self.as_inner().x(),
            -(rhs.x() * self.as_inner().z()) + rhs.z() * self.as_inner().x(),
            -(rhs.x() * self.as_inner().w()) + rhs.w() * self.as_inner().x(),
            -(rhs.y() * self.as_inner().z()) + rhs.z() * self.as_inner().y(),
            -(rhs.y() * self.as_inner().w()) + rhs.w() * self.as_inner().y(),
            -(rhs.z() * self.as_inner().w()) + rhs.w() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Point<T>>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            -(rhs.as_inner().x() * self.y()) + rhs.as_inner().y() * self.x(),
            -(rhs.as_inner().x() * self.z()) + rhs.as_inner().z() * self.x(),
            -(rhs.as_inner().x() * self.w()) + rhs.as_inner().w() * self.x(),
            -(rhs.as_inner().y() * self.z()) + rhs.as_inner().z() * self.y(),
            -(rhs.as_inner().y() * self.w()) + rhs.as_inner().w() * self.y(),
            -(rhs.as_inner().z() * self.w()) + rhs.as_inner().w() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Point<T>>> for Unitized<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            -(rhs.as_inner().x() * self.as_inner().y()) + rhs.as_inner().y() * self.as_inner().x(),
            -(rhs.as_inner().x() * self.as_inner().z()) + rhs.as_inner().z() * self.as_inner().x(),
            -(rhs.as_inner().x() * self.as_inner().w()) + rhs.as_inner().w() * self.as_inner().x(),
            -(rhs.as_inner().y() * self.as_inner().z()) + rhs.as_inner().z() * self.as_inner().y(),
            -(rhs.as_inner().y() * self.as_inner().w()) + rhs.as_inner().w() * self.as_inner().y(),
            -(rhs.as_inner().z() * self.as_inner().w()) + rhs.as_inner().w() * self.as_inner().z(),
        )
    }
}
#[doc = "Wedge (exterior/outer) product of [`Point`] and [`Scalar`].\n\nThe wedge product `a ^ b` computes the outer product, which represents\nthe oriented subspace spanned by both operands. The result grade is the\nsum of the input grades (or zero if they share common factors)."]
impl<T: Float> Wedge<Scalar<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.s() * self.x(),
            rhs.s() * self.y(),
            rhs.s() * self.z(),
            rhs.s() * self.w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.s() * self.as_inner().x(),
            rhs.s() * self.as_inner().y(),
            rhs.s() * self.as_inner().z(),
            rhs.s() * self.as_inner().w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Wedge (exterior/outer) product of [`Quadvector`] and [`Scalar`].\n\nThe wedge product `a ^ b` computes the outer product, which represents\nthe oriented subspace spanned by both operands. The result grade is the\nsum of the input grades (or zero if they share common factors)."]
impl<T: Float> Wedge<Scalar<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.s() * self.ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.s() * self.as_inner().ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[doc = "Wedge (exterior/outer) product of [`Scalar`] and [`Line`].\n\nThe wedge product `a ^ b` computes the outer product, which represents\nthe oriented subspace spanned by both operands. The result grade is the\nsum of the input grades (or zero if they share common factors)."]
impl<T: Float> Wedge<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.moment_z() * self.s(),
            rhs.moment_y() * self.s(),
            rhs.dir_x() * self.s(),
            rhs.moment_x() * self.s(),
            rhs.dir_y() * self.s(),
            rhs.dir_z() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Line<T>> for Unitized<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Line<T>>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().moment_z() * self.s(),
            rhs.as_inner().moment_y() * self.s(),
            rhs.as_inner().dir_x() * self.s(),
            rhs.as_inner().moment_x() * self.s(),
            rhs.as_inner().dir_y() * self.s(),
            rhs.as_inner().dir_z() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Line<T>>> for Unitized<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[doc = "Wedge (exterior/outer) product of [`Scalar`] and [`Plane`].\n\nThe wedge product `a ^ b` computes the outer product, which represents\nthe oriented subspace spanned by both operands. The result grade is the\nsum of the input grades (or zero if they share common factors)."]
impl<T: Float> Wedge<Plane<T>> for Scalar<T> {
    type Output = Plane<T>;
    #[inline]
    fn wedge(&self, rhs: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.dist() * self.s(),
            rhs.nz() * self.s(),
            rhs.ny() * self.s(),
            rhs.nx() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Plane<T>> for Unitized<Scalar<T>> {
    type Output = Plane<T>;
    #[inline]
    fn wedge(&self, rhs: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Plane<T>>> for Scalar<T> {
    type Output = Plane<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.as_inner().dist() * self.s(),
            rhs.as_inner().nz() * self.s(),
            rhs.as_inner().ny() * self.s(),
            rhs.as_inner().nx() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Plane<T>>> for Unitized<Scalar<T>> {
    type Output = Plane<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Wedge (exterior/outer) product of [`Scalar`] and [`Point`].\n\nThe wedge product `a ^ b` computes the outer product, which represents\nthe oriented subspace spanned by both operands. The result grade is the\nsum of the input grades (or zero if they share common factors)."]
impl<T: Float> Wedge<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn wedge(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.x() * self.s(),
            rhs.y() * self.s(),
            rhs.z() * self.s(),
            rhs.w() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Point<T>> for Unitized<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn wedge(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Point<T>>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            rhs.as_inner().x() * self.s(),
            rhs.as_inner().y() * self.s(),
            rhs.as_inner().z() * self.s(),
            rhs.as_inner().w() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Point<T>>> for Unitized<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Wedge (exterior/outer) product of [`Scalar`] and [`Quadvector`].\n\nThe wedge product `a ^ b` computes the outer product, which represents\nthe oriented subspace spanned by both operands. The result grade is the\nsum of the input grades (or zero if they share common factors)."]
impl<T: Float> Wedge<Quadvector<T>> for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.ps() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Quadvector<T>> for Unitized<Scalar<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Quadvector<T>>> for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.as_inner().ps() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Quadvector<T>>> for Unitized<Scalar<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[doc = "Wedge (exterior/outer) product of [`Scalar`] and [`Scalar`].\n\nThe wedge product `a ^ b` computes the outer product, which represents\nthe oriented subspace spanned by both operands. The result grade is the\nsum of the input grades (or zero if they share common factors)."]
impl<T: Float> Wedge<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Antiwedge (regressive/meet) product of [`Line`] and [`Line`].\n\nThe antiwedge product `a v b` computes the meet of two subspaces,\nreturning the largest subspace contained in both. In projective geometry,\nthis finds intersections (e.g., where two planes meet to form a line)."]
impl<T: Float> Antiwedge<Line<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.dir_y() * self.moment_y())
                + -(rhs.moment_y() * self.dir_y())
                + rhs.dir_x() * self.moment_x()
                + rhs.dir_z() * self.moment_z()
                + rhs.moment_x() * self.dir_x()
                + rhs.moment_z() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Line<T>> for Unitized<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.dir_y() * self.as_inner().moment_y())
                + -(rhs.moment_y() * self.as_inner().dir_y())
                + rhs.dir_x() * self.as_inner().moment_x()
                + rhs.dir_z() * self.as_inner().moment_z()
                + rhs.moment_x() * self.as_inner().dir_x()
                + rhs.moment_z() * self.as_inner().dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Line<T>>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().dir_y() * self.moment_y())
                + -(rhs.as_inner().moment_y() * self.dir_y())
                + rhs.as_inner().dir_x() * self.moment_x()
                + rhs.as_inner().dir_z() * self.moment_z()
                + rhs.as_inner().moment_x() * self.dir_x()
                + rhs.as_inner().moment_z() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Line<T>>> for Unitized<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().dir_y() * self.as_inner().moment_y())
                + -(rhs.as_inner().moment_y() * self.as_inner().dir_y())
                + rhs.as_inner().dir_x() * self.as_inner().moment_x()
                + rhs.as_inner().dir_z() * self.as_inner().moment_z()
                + rhs.as_inner().moment_x() * self.as_inner().dir_x()
                + rhs.as_inner().moment_z() * self.as_inner().dir_z(),
        )
    }
}
#[doc = "Antiwedge (regressive/meet) product of [`Line`] and [`Plane`].\n\nThe antiwedge product `a v b` computes the meet of two subspaces,\nreturning the largest subspace contained in both. In projective geometry,\nthis finds intersections (e.g., where two planes meet to form a line)."]
impl<T: Float> Antiwedge<Plane<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Plane<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.dist() * self.dir_x())
                + -(rhs.ny() * self.moment_z())
                + rhs.nz() * self.moment_y(),
            -(rhs.dist() * self.dir_y())
                + -(rhs.nx() * self.moment_z())
                + rhs.nz() * self.moment_x(),
            -(rhs.dist() * self.dir_z())
                + -(rhs.nx() * self.moment_y())
                + rhs.ny() * self.moment_x(),
            -(rhs.nx() * self.dir_x()) + -(rhs.nz() * self.dir_z()) + rhs.ny() * self.dir_y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Plane<T>> for Unitized<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Plane<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.dist() * self.as_inner().dir_x())
                + -(rhs.ny() * self.as_inner().moment_z())
                + rhs.nz() * self.as_inner().moment_y(),
            -(rhs.dist() * self.as_inner().dir_y())
                + -(rhs.nx() * self.as_inner().moment_z())
                + rhs.nz() * self.as_inner().moment_x(),
            -(rhs.dist() * self.as_inner().dir_z())
                + -(rhs.nx() * self.as_inner().moment_y())
                + rhs.ny() * self.as_inner().moment_x(),
            -(rhs.nx() * self.as_inner().dir_x())
                + -(rhs.nz() * self.as_inner().dir_z())
                + rhs.ny() * self.as_inner().dir_y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Plane<T>>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Plane<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().dist() * self.dir_x())
                + -(rhs.as_inner().ny() * self.moment_z())
                + rhs.as_inner().nz() * self.moment_y(),
            -(rhs.as_inner().dist() * self.dir_y())
                + -(rhs.as_inner().nx() * self.moment_z())
                + rhs.as_inner().nz() * self.moment_x(),
            -(rhs.as_inner().dist() * self.dir_z())
                + -(rhs.as_inner().nx() * self.moment_y())
                + rhs.as_inner().ny() * self.moment_x(),
            -(rhs.as_inner().nx() * self.dir_x())
                + -(rhs.as_inner().nz() * self.dir_z())
                + rhs.as_inner().ny() * self.dir_y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Plane<T>>> for Unitized<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Plane<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().dist() * self.as_inner().dir_x())
                + -(rhs.as_inner().ny() * self.as_inner().moment_z())
                + rhs.as_inner().nz() * self.as_inner().moment_y(),
            -(rhs.as_inner().dist() * self.as_inner().dir_y())
                + -(rhs.as_inner().nx() * self.as_inner().moment_z())
                + rhs.as_inner().nz() * self.as_inner().moment_x(),
            -(rhs.as_inner().dist() * self.as_inner().dir_z())
                + -(rhs.as_inner().nx() * self.as_inner().moment_y())
                + rhs.as_inner().ny() * self.as_inner().moment_x(),
            -(rhs.as_inner().nx() * self.as_inner().dir_x())
                + -(rhs.as_inner().nz() * self.as_inner().dir_z())
                + rhs.as_inner().ny() * self.as_inner().dir_y(),
        )
    }
}
#[doc = "Antiwedge (regressive/meet) product of [`Line`] and [`Quadvector`].\n\nThe antiwedge product `a v b` computes the meet of two subspaces,\nreturning the largest subspace contained in both. In projective geometry,\nthis finds intersections (e.g., where two planes meet to form a line)."]
impl<T: Float> Antiwedge<Quadvector<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Quadvector<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.ps() * self.moment_z(),
            rhs.ps() * self.moment_y(),
            rhs.ps() * self.dir_x(),
            rhs.ps() * self.moment_x(),
            rhs.ps() * self.dir_y(),
            rhs.ps() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Quadvector<T>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Quadvector<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.ps() * self.as_inner().moment_z(),
            rhs.ps() * self.as_inner().moment_y(),
            rhs.ps() * self.as_inner().dir_x(),
            rhs.ps() * self.as_inner().moment_x(),
            rhs.ps() * self.as_inner().dir_y(),
            rhs.ps() * self.as_inner().dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Quadvector<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Quadvector<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().ps() * self.moment_z(),
            rhs.as_inner().ps() * self.moment_y(),
            rhs.as_inner().ps() * self.dir_x(),
            rhs.as_inner().ps() * self.moment_x(),
            rhs.as_inner().ps() * self.dir_y(),
            rhs.as_inner().ps() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Quadvector<T>>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Quadvector<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().ps() * self.as_inner().moment_z(),
            rhs.as_inner().ps() * self.as_inner().moment_y(),
            rhs.as_inner().ps() * self.as_inner().dir_x(),
            rhs.as_inner().ps() * self.as_inner().moment_x(),
            rhs.as_inner().ps() * self.as_inner().dir_y(),
            rhs.as_inner().ps() * self.as_inner().dir_z(),
        )
    }
}
#[doc = "Antiwedge (regressive/meet) product of [`Plane`] and [`Line`].\n\nThe antiwedge product `a v b` computes the meet of two subspaces,\nreturning the largest subspace contained in both. In projective geometry,\nthis finds intersections (e.g., where two planes meet to form a line)."]
impl<T: Float> Antiwedge<Line<T>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.dir_x() * self.dist())
                + -(rhs.moment_z() * self.ny())
                + rhs.moment_y() * self.nz(),
            -(rhs.dir_y() * self.dist())
                + -(rhs.moment_z() * self.nx())
                + rhs.moment_x() * self.nz(),
            -(rhs.dir_z() * self.dist())
                + -(rhs.moment_y() * self.nx())
                + rhs.moment_x() * self.ny(),
            -(rhs.dir_x() * self.nx()) + -(rhs.dir_z() * self.nz()) + rhs.dir_y() * self.ny(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Line<T>> for Unitized<Plane<T>> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.dir_x() * self.as_inner().dist())
                + -(rhs.moment_z() * self.as_inner().ny())
                + rhs.moment_y() * self.as_inner().nz(),
            -(rhs.dir_y() * self.as_inner().dist())
                + -(rhs.moment_z() * self.as_inner().nx())
                + rhs.moment_x() * self.as_inner().nz(),
            -(rhs.dir_z() * self.as_inner().dist())
                + -(rhs.moment_y() * self.as_inner().nx())
                + rhs.moment_x() * self.as_inner().ny(),
            -(rhs.dir_x() * self.as_inner().nx())
                + -(rhs.dir_z() * self.as_inner().nz())
                + rhs.dir_y() * self.as_inner().ny(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Line<T>>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().dir_x() * self.dist())
                + -(rhs.as_inner().moment_z() * self.ny())
                + rhs.as_inner().moment_y() * self.nz(),
            -(rhs.as_inner().dir_y() * self.dist())
                + -(rhs.as_inner().moment_z() * self.nx())
                + rhs.as_inner().moment_x() * self.nz(),
            -(rhs.as_inner().dir_z() * self.dist())
                + -(rhs.as_inner().moment_y() * self.nx())
                + rhs.as_inner().moment_x() * self.ny(),
            -(rhs.as_inner().dir_x() * self.nx())
                + -(rhs.as_inner().dir_z() * self.nz())
                + rhs.as_inner().dir_y() * self.ny(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Line<T>>> for Unitized<Plane<T>> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().dir_x() * self.as_inner().dist())
                + -(rhs.as_inner().moment_z() * self.as_inner().ny())
                + rhs.as_inner().moment_y() * self.as_inner().nz(),
            -(rhs.as_inner().dir_y() * self.as_inner().dist())
                + -(rhs.as_inner().moment_z() * self.as_inner().nx())
                + rhs.as_inner().moment_x() * self.as_inner().nz(),
            -(rhs.as_inner().dir_z() * self.as_inner().dist())
                + -(rhs.as_inner().moment_y() * self.as_inner().nx())
                + rhs.as_inner().moment_x() * self.as_inner().ny(),
            -(rhs.as_inner().dir_x() * self.as_inner().nx())
                + -(rhs.as_inner().dir_z() * self.as_inner().nz())
                + rhs.as_inner().dir_y() * self.as_inner().ny(),
        )
    }
}
#[doc = "Antiwedge (regressive/meet) product of [`Plane`] and [`Plane`].\n\nThe antiwedge product `a v b` computes the meet of two subspaces,\nreturning the largest subspace contained in both. In projective geometry,\nthis finds intersections (e.g., where two planes meet to form a line)."]
impl<T: Float> Antiwedge<Plane<T>> for Plane<T> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Plane<T>) -> Line<T> {
        Line::new_unchecked(
            -(rhs.dist() * self.nz()) + rhs.nz() * self.dist(),
            -(rhs.dist() * self.ny()) + rhs.ny() * self.dist(),
            -(rhs.nz() * self.ny()) + rhs.ny() * self.nz(),
            -(rhs.dist() * self.nx()) + rhs.nx() * self.dist(),
            -(rhs.nz() * self.nx()) + rhs.nx() * self.nz(),
            -(rhs.ny() * self.nx()) + rhs.nx() * self.ny(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Plane<T>> for Unitized<Plane<T>> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Plane<T>) -> Line<T> {
        Line::new_unchecked(
            -(rhs.dist() * self.as_inner().nz()) + rhs.nz() * self.as_inner().dist(),
            -(rhs.dist() * self.as_inner().ny()) + rhs.ny() * self.as_inner().dist(),
            -(rhs.nz() * self.as_inner().ny()) + rhs.ny() * self.as_inner().nz(),
            -(rhs.dist() * self.as_inner().nx()) + rhs.nx() * self.as_inner().dist(),
            -(rhs.nz() * self.as_inner().nx()) + rhs.nx() * self.as_inner().nz(),
            -(rhs.ny() * self.as_inner().nx()) + rhs.nx() * self.as_inner().ny(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Plane<T>>> for Plane<T> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Plane<T>>) -> Line<T> {
        Line::new_unchecked(
            -(rhs.as_inner().dist() * self.nz()) + rhs.as_inner().nz() * self.dist(),
            -(rhs.as_inner().dist() * self.ny()) + rhs.as_inner().ny() * self.dist(),
            -(rhs.as_inner().nz() * self.ny()) + rhs.as_inner().ny() * self.nz(),
            -(rhs.as_inner().dist() * self.nx()) + rhs.as_inner().nx() * self.dist(),
            -(rhs.as_inner().nz() * self.nx()) + rhs.as_inner().nx() * self.nz(),
            -(rhs.as_inner().ny() * self.nx()) + rhs.as_inner().nx() * self.ny(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Plane<T>>> for Unitized<Plane<T>> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Plane<T>>) -> Line<T> {
        Line::new_unchecked(
            -(rhs.as_inner().dist() * self.as_inner().nz())
                + rhs.as_inner().nz() * self.as_inner().dist(),
            -(rhs.as_inner().dist() * self.as_inner().ny())
                + rhs.as_inner().ny() * self.as_inner().dist(),
            -(rhs.as_inner().nz() * self.as_inner().ny())
                + rhs.as_inner().ny() * self.as_inner().nz(),
            -(rhs.as_inner().dist() * self.as_inner().nx())
                + rhs.as_inner().nx() * self.as_inner().dist(),
            -(rhs.as_inner().nz() * self.as_inner().nx())
                + rhs.as_inner().nx() * self.as_inner().nz(),
            -(rhs.as_inner().ny() * self.as_inner().nx())
                + rhs.as_inner().nx() * self.as_inner().ny(),
        )
    }
}
#[doc = "Antiwedge (regressive/meet) product of [`Plane`] and [`Point`].\n\nThe antiwedge product `a v b` computes the meet of two subspaces,\nreturning the largest subspace contained in both. In projective geometry,\nthis finds intersections (e.g., where two planes meet to form a line)."]
impl<T: Float> Antiwedge<Point<T>> for Plane<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.x() * self.nx())
                + -(rhs.z() * self.nz())
                + rhs.w() * self.dist()
                + rhs.y() * self.ny(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Point<T>> for Unitized<Plane<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.x() * self.as_inner().nx())
                + -(rhs.z() * self.as_inner().nz())
                + rhs.w() * self.as_inner().dist()
                + rhs.y() * self.as_inner().ny(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Point<T>>> for Plane<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().x() * self.nx())
                + -(rhs.as_inner().z() * self.nz())
                + rhs.as_inner().w() * self.dist()
                + rhs.as_inner().y() * self.ny(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Point<T>>> for Unitized<Plane<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().x() * self.as_inner().nx())
                + -(rhs.as_inner().z() * self.as_inner().nz())
                + rhs.as_inner().w() * self.as_inner().dist()
                + rhs.as_inner().y() * self.as_inner().ny(),
        )
    }
}
#[doc = "Antiwedge (regressive/meet) product of [`Plane`] and [`Quadvector`].\n\nThe antiwedge product `a v b` computes the meet of two subspaces,\nreturning the largest subspace contained in both. In projective geometry,\nthis finds intersections (e.g., where two planes meet to form a line)."]
impl<T: Float> Antiwedge<Quadvector<T>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Quadvector<T>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.ps() * self.dist()),
            -(rhs.ps() * self.nz()),
            -(rhs.ps() * self.ny()),
            -(rhs.ps() * self.nx()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Quadvector<T>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Quadvector<T>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.ps() * self.as_inner().dist()),
            -(rhs.ps() * self.as_inner().nz()),
            -(rhs.ps() * self.as_inner().ny()),
            -(rhs.ps() * self.as_inner().nx()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Quadvector<T>>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Quadvector<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.as_inner().ps() * self.dist()),
            -(rhs.as_inner().ps() * self.nz()),
            -(rhs.as_inner().ps() * self.ny()),
            -(rhs.as_inner().ps() * self.nx()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Quadvector<T>>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Quadvector<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.as_inner().ps() * self.as_inner().dist()),
            -(rhs.as_inner().ps() * self.as_inner().nz()),
            -(rhs.as_inner().ps() * self.as_inner().ny()),
            -(rhs.as_inner().ps() * self.as_inner().nx()),
        )
    }
}
#[doc = "Antiwedge (regressive/meet) product of [`Point`] and [`Plane`].\n\nThe antiwedge product `a v b` computes the meet of two subspaces,\nreturning the largest subspace contained in both. In projective geometry,\nthis finds intersections (e.g., where two planes meet to form a line)."]
impl<T: Float> Antiwedge<Plane<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Plane<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.dist() * self.w())
                + -(rhs.ny() * self.y())
                + rhs.nx() * self.x()
                + rhs.nz() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Plane<T>> for Unitized<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Plane<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.dist() * self.as_inner().w())
                + -(rhs.ny() * self.as_inner().y())
                + rhs.nx() * self.as_inner().x()
                + rhs.nz() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Plane<T>>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Plane<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().dist() * self.w())
                + -(rhs.as_inner().ny() * self.y())
                + rhs.as_inner().nx() * self.x()
                + rhs.as_inner().nz() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Plane<T>>> for Unitized<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Plane<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().dist() * self.as_inner().w())
                + -(rhs.as_inner().ny() * self.as_inner().y())
                + rhs.as_inner().nx() * self.as_inner().x()
                + rhs.as_inner().nz() * self.as_inner().z(),
        )
    }
}
#[doc = "Antiwedge (regressive/meet) product of [`Point`] and [`Quadvector`].\n\nThe antiwedge product `a v b` computes the meet of two subspaces,\nreturning the largest subspace contained in both. In projective geometry,\nthis finds intersections (e.g., where two planes meet to form a line)."]
impl<T: Float> Antiwedge<Quadvector<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Quadvector<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.ps() * self.x()),
            -(rhs.ps() * self.y()),
            -(rhs.ps() * self.z()),
            -(rhs.ps() * self.w()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Quadvector<T>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Quadvector<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.ps() * self.as_inner().x()),
            -(rhs.ps() * self.as_inner().y()),
            -(rhs.ps() * self.as_inner().z()),
            -(rhs.ps() * self.as_inner().w()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Quadvector<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Quadvector<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().ps() * self.x()),
            -(rhs.as_inner().ps() * self.y()),
            -(rhs.as_inner().ps() * self.z()),
            -(rhs.as_inner().ps() * self.w()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Quadvector<T>>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Quadvector<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().ps() * self.as_inner().x()),
            -(rhs.as_inner().ps() * self.as_inner().y()),
            -(rhs.as_inner().ps() * self.as_inner().z()),
            -(rhs.as_inner().ps() * self.as_inner().w()),
        )
    }
}
#[doc = "Antiwedge (regressive/meet) product of [`Quadvector`] and [`Line`].\n\nThe antiwedge product `a v b` computes the meet of two subspaces,\nreturning the largest subspace contained in both. In projective geometry,\nthis finds intersections (e.g., where two planes meet to form a line)."]
impl<T: Float> Antiwedge<Line<T>> for Quadvector<T> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.moment_z() * self.ps(),
            rhs.moment_y() * self.ps(),
            rhs.dir_x() * self.ps(),
            rhs.moment_x() * self.ps(),
            rhs.dir_y() * self.ps(),
            rhs.dir_z() * self.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Line<T>> for Unitized<Quadvector<T>> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.moment_z() * self.as_inner().ps(),
            rhs.moment_y() * self.as_inner().ps(),
            rhs.dir_x() * self.as_inner().ps(),
            rhs.moment_x() * self.as_inner().ps(),
            rhs.dir_y() * self.as_inner().ps(),
            rhs.dir_z() * self.as_inner().ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Line<T>>> for Quadvector<T> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().moment_z() * self.ps(),
            rhs.as_inner().moment_y() * self.ps(),
            rhs.as_inner().dir_x() * self.ps(),
            rhs.as_inner().moment_x() * self.ps(),
            rhs.as_inner().dir_y() * self.ps(),
            rhs.as_inner().dir_z() * self.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Line<T>>> for Unitized<Quadvector<T>> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().moment_z() * self.as_inner().ps(),
            rhs.as_inner().moment_y() * self.as_inner().ps(),
            rhs.as_inner().dir_x() * self.as_inner().ps(),
            rhs.as_inner().moment_x() * self.as_inner().ps(),
            rhs.as_inner().dir_y() * self.as_inner().ps(),
            rhs.as_inner().dir_z() * self.as_inner().ps(),
        )
    }
}
#[doc = "Antiwedge (regressive/meet) product of [`Quadvector`] and [`Plane`].\n\nThe antiwedge product `a v b` computes the meet of two subspaces,\nreturning the largest subspace contained in both. In projective geometry,\nthis finds intersections (e.g., where two planes meet to form a line)."]
impl<T: Float> Antiwedge<Plane<T>> for Quadvector<T> {
    type Output = Plane<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.dist() * self.ps()),
            -(rhs.nz() * self.ps()),
            -(rhs.ny() * self.ps()),
            -(rhs.nx() * self.ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Plane<T>> for Unitized<Quadvector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.dist() * self.as_inner().ps()),
            -(rhs.nz() * self.as_inner().ps()),
            -(rhs.ny() * self.as_inner().ps()),
            -(rhs.nx() * self.as_inner().ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Plane<T>>> for Quadvector<T> {
    type Output = Plane<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.as_inner().dist() * self.ps()),
            -(rhs.as_inner().nz() * self.ps()),
            -(rhs.as_inner().ny() * self.ps()),
            -(rhs.as_inner().nx() * self.ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Plane<T>>> for Unitized<Quadvector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.as_inner().dist() * self.as_inner().ps()),
            -(rhs.as_inner().nz() * self.as_inner().ps()),
            -(rhs.as_inner().ny() * self.as_inner().ps()),
            -(rhs.as_inner().nx() * self.as_inner().ps()),
        )
    }
}
#[doc = "Antiwedge (regressive/meet) product of [`Quadvector`] and [`Point`].\n\nThe antiwedge product `a v b` computes the meet of two subspaces,\nreturning the largest subspace contained in both. In projective geometry,\nthis finds intersections (e.g., where two planes meet to form a line)."]
impl<T: Float> Antiwedge<Point<T>> for Quadvector<T> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.x() * self.ps()),
            -(rhs.y() * self.ps()),
            -(rhs.z() * self.ps()),
            -(rhs.w() * self.ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Point<T>> for Unitized<Quadvector<T>> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.x() * self.as_inner().ps()),
            -(rhs.y() * self.as_inner().ps()),
            -(rhs.z() * self.as_inner().ps()),
            -(rhs.w() * self.as_inner().ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Point<T>>> for Quadvector<T> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().x() * self.ps()),
            -(rhs.as_inner().y() * self.ps()),
            -(rhs.as_inner().z() * self.ps()),
            -(rhs.as_inner().w() * self.ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Point<T>>> for Unitized<Quadvector<T>> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().x() * self.as_inner().ps()),
            -(rhs.as_inner().y() * self.as_inner().ps()),
            -(rhs.as_inner().z() * self.as_inner().ps()),
            -(rhs.as_inner().w() * self.as_inner().ps()),
        )
    }
}
#[doc = "Antiwedge (regressive/meet) product of [`Quadvector`] and [`Quadvector`].\n\nThe antiwedge product `a v b` computes the meet of two subspaces,\nreturning the largest subspace contained in both. In projective geometry,\nthis finds intersections (e.g., where two planes meet to form a line)."]
impl<T: Float> Antiwedge<Quadvector<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.ps() * self.ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Quadvector<T>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.ps() * self.as_inner().ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Quadvector<T>>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.as_inner().ps() * self.ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Quadvector<T>>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.as_inner().ps() * self.as_inner().ps())
    }
}
#[doc = "Antiwedge (regressive/meet) product of [`Quadvector`] and [`Scalar`].\n\nThe antiwedge product `a v b` computes the meet of two subspaces,\nreturning the largest subspace contained in both. In projective geometry,\nthis finds intersections (e.g., where two planes meet to form a line)."]
impl<T: Float> Antiwedge<Scalar<T>> for Quadvector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Scalar<T>> for Unitized<Quadvector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.as_inner().ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Scalar<T>>> for Quadvector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Scalar<T>>> for Unitized<Quadvector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Antiwedge (regressive/meet) product of [`Scalar`] and [`Quadvector`].\n\nThe antiwedge product `a v b` computes the meet of two subspaces,\nreturning the largest subspace contained in both. In projective geometry,\nthis finds intersections (e.g., where two planes meet to form a line)."]
impl<T: Float> Antiwedge<Quadvector<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Quadvector<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.ps() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Quadvector<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Quadvector<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Quadvector<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Quadvector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().ps() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Quadvector<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Quadvector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Left contraction of [`Line`] into [`Line`].\n\nThe left contraction `a _| b` projects `a` onto `b`, returning the\ncomponent of `b` orthogonal to `a`. The result grade is grade(b) - grade(a)\n(or zero if grade(a) > grade(b))."]
impl<T: Float> LeftContract<Line<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.moment_x() * self.moment_x())
                + -(rhs.moment_y() * self.moment_y())
                + -(rhs.moment_z() * self.moment_z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Line<T>> for Unitized<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.moment_x() * self.as_inner().moment_x())
                + -(rhs.moment_y() * self.as_inner().moment_y())
                + -(rhs.moment_z() * self.as_inner().moment_z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Line<T>>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().moment_x() * self.moment_x())
                + -(rhs.as_inner().moment_y() * self.moment_y())
                + -(rhs.as_inner().moment_z() * self.moment_z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Line<T>>> for Unitized<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().moment_x() * self.as_inner().moment_x())
                + -(rhs.as_inner().moment_y() * self.as_inner().moment_y())
                + -(rhs.as_inner().moment_z() * self.as_inner().moment_z()),
        )
    }
}
#[doc = "Left contraction of [`Line`] into [`Plane`].\n\nThe left contraction `a _| b` projects `a` onto `b`, returning the\ncomponent of `b` orthogonal to `a`. The result grade is grade(b) - grade(a)\n(or zero if grade(a) > grade(b))."]
impl<T: Float> LeftContract<Plane<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Plane<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.dist() * self.moment_x()),
            rhs.dist() * self.moment_y(),
            -(rhs.dist() * self.moment_z()),
            -(rhs.nx() * self.moment_x())
                + -(rhs.ny() * self.moment_y())
                + -(rhs.nz() * self.moment_z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Plane<T>> for Unitized<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Plane<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.dist() * self.as_inner().moment_x()),
            rhs.dist() * self.as_inner().moment_y(),
            -(rhs.dist() * self.as_inner().moment_z()),
            -(rhs.nx() * self.as_inner().moment_x())
                + -(rhs.ny() * self.as_inner().moment_y())
                + -(rhs.nz() * self.as_inner().moment_z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Plane<T>>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Plane<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().dist() * self.moment_x()),
            rhs.as_inner().dist() * self.moment_y(),
            -(rhs.as_inner().dist() * self.moment_z()),
            -(rhs.as_inner().nx() * self.moment_x())
                + -(rhs.as_inner().ny() * self.moment_y())
                + -(rhs.as_inner().nz() * self.moment_z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Plane<T>>> for Unitized<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Plane<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().dist() * self.as_inner().moment_x()),
            rhs.as_inner().dist() * self.as_inner().moment_y(),
            -(rhs.as_inner().dist() * self.as_inner().moment_z()),
            -(rhs.as_inner().nx() * self.as_inner().moment_x())
                + -(rhs.as_inner().ny() * self.as_inner().moment_y())
                + -(rhs.as_inner().nz() * self.as_inner().moment_z()),
        )
    }
}
#[doc = "Left contraction of [`Line`] into [`Quadvector`].\n\nThe left contraction `a _| b` projects `a` onto `b`, returning the\ncomponent of `b` orthogonal to `a`. The result grade is grade(b) - grade(a)\n(or zero if grade(a) > grade(b))."]
impl<T: Float> LeftContract<Quadvector<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Quadvector<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            -(rhs.ps() * self.moment_x()),
            T::zero(),
            rhs.ps() * self.moment_y(),
            -(rhs.ps() * self.moment_z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Quadvector<T>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Quadvector<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            -(rhs.ps() * self.as_inner().moment_x()),
            T::zero(),
            rhs.ps() * self.as_inner().moment_y(),
            -(rhs.ps() * self.as_inner().moment_z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Quadvector<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Quadvector<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            -(rhs.as_inner().ps() * self.moment_x()),
            T::zero(),
            rhs.as_inner().ps() * self.moment_y(),
            -(rhs.as_inner().ps() * self.moment_z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Quadvector<T>>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Quadvector<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            -(rhs.as_inner().ps() * self.as_inner().moment_x()),
            T::zero(),
            rhs.as_inner().ps() * self.as_inner().moment_y(),
            -(rhs.as_inner().ps() * self.as_inner().moment_z()),
        )
    }
}
#[doc = "Left contraction of [`Plane`] into [`Plane`].\n\nThe left contraction `a _| b` projects `a` onto `b`, returning the\ncomponent of `b` orthogonal to `a`. The result grade is grade(b) - grade(a)\n(or zero if grade(a) > grade(b))."]
impl<T: Float> LeftContract<Plane<T>> for Plane<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Plane<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.dist() * self.dist()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Plane<T>> for Unitized<Plane<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Plane<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.dist() * self.as_inner().dist()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Plane<T>>> for Plane<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Plane<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().dist() * self.dist()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Plane<T>>> for Unitized<Plane<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Plane<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().dist() * self.as_inner().dist()))
    }
}
#[doc = "Left contraction of [`Plane`] into [`Quadvector`].\n\nThe left contraction `a _| b` projects `a` onto `b`, returning the\ncomponent of `b` orthogonal to `a`. The result grade is grade(b) - grade(a)\n(or zero if grade(a) > grade(b))."]
impl<T: Float> LeftContract<Quadvector<T>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Quadvector<T>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), -(rhs.ps() * self.dist()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Quadvector<T>> for Unitized<Plane<T>> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Quadvector<T>) -> Point<T> {
        Point::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            -(rhs.ps() * self.as_inner().dist()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Quadvector<T>>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Quadvector<T>>) -> Point<T> {
        Point::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            -(rhs.as_inner().ps() * self.dist()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Quadvector<T>>> for Unitized<Plane<T>> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Quadvector<T>>) -> Point<T> {
        Point::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            -(rhs.as_inner().ps() * self.as_inner().dist()),
        )
    }
}
#[doc = "Left contraction of [`Point`] into [`Line`].\n\nThe left contraction `a _| b` projects `a` onto `b`, returning the\ncomponent of `b` orthogonal to `a`. The result grade is grade(b) - grade(a)\n(or zero if grade(a) > grade(b))."]
impl<T: Float> LeftContract<Line<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.moment_y() * self.z()) + -(rhs.moment_z() * self.y()),
            -(rhs.moment_x() * self.z()) + rhs.moment_z() * self.x(),
            rhs.moment_x() * self.y() + rhs.moment_y() * self.x(),
            rhs.dir_x() * self.x() + rhs.dir_y() * self.y() + rhs.dir_z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Line<T>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.moment_y() * self.as_inner().z()) + -(rhs.moment_z() * self.as_inner().y()),
            -(rhs.moment_x() * self.as_inner().z()) + rhs.moment_z() * self.as_inner().x(),
            rhs.moment_x() * self.as_inner().y() + rhs.moment_y() * self.as_inner().x(),
            rhs.dir_x() * self.as_inner().x()
                + rhs.dir_y() * self.as_inner().y()
                + rhs.dir_z() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Line<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().moment_y() * self.z()) + -(rhs.as_inner().moment_z() * self.y()),
            -(rhs.as_inner().moment_x() * self.z()) + rhs.as_inner().moment_z() * self.x(),
            rhs.as_inner().moment_x() * self.y() + rhs.as_inner().moment_y() * self.x(),
            rhs.as_inner().dir_x() * self.x()
                + rhs.as_inner().dir_y() * self.y()
                + rhs.as_inner().dir_z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Line<T>>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().moment_y() * self.as_inner().z())
                + -(rhs.as_inner().moment_z() * self.as_inner().y()),
            -(rhs.as_inner().moment_x() * self.as_inner().z())
                + rhs.as_inner().moment_z() * self.as_inner().x(),
            rhs.as_inner().moment_x() * self.as_inner().y()
                + rhs.as_inner().moment_y() * self.as_inner().x(),
            rhs.as_inner().dir_x() * self.as_inner().x()
                + rhs.as_inner().dir_y() * self.as_inner().y()
                + rhs.as_inner().dir_z() * self.as_inner().z(),
        )
    }
}
#[doc = "Left contraction of [`Point`] into [`Plane`].\n\nThe left contraction `a _| b` projects `a` onto `b`, returning the\ncomponent of `b` orthogonal to `a`. The result grade is grade(b) - grade(a)\n(or zero if grade(a) > grade(b))."]
impl<T: Float> LeftContract<Plane<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Plane<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.dist() * self.z(),
            -(rhs.dist() * self.y()),
            -(rhs.ny() * self.z()) + -(rhs.nz() * self.y()),
            rhs.dist() * self.x(),
            -(rhs.nx() * self.z()) + rhs.nz() * self.x(),
            rhs.nx() * self.y() + rhs.ny() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Plane<T>> for Unitized<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Plane<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.dist() * self.as_inner().z(),
            -(rhs.dist() * self.as_inner().y()),
            -(rhs.ny() * self.as_inner().z()) + -(rhs.nz() * self.as_inner().y()),
            rhs.dist() * self.as_inner().x(),
            -(rhs.nx() * self.as_inner().z()) + rhs.nz() * self.as_inner().x(),
            rhs.nx() * self.as_inner().y() + rhs.ny() * self.as_inner().x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Plane<T>>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Plane<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().dist() * self.z(),
            -(rhs.as_inner().dist() * self.y()),
            -(rhs.as_inner().ny() * self.z()) + -(rhs.as_inner().nz() * self.y()),
            rhs.as_inner().dist() * self.x(),
            -(rhs.as_inner().nx() * self.z()) + rhs.as_inner().nz() * self.x(),
            rhs.as_inner().nx() * self.y() + rhs.as_inner().ny() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Plane<T>>> for Unitized<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Plane<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().dist() * self.as_inner().z(),
            -(rhs.as_inner().dist() * self.as_inner().y()),
            -(rhs.as_inner().ny() * self.as_inner().z())
                + -(rhs.as_inner().nz() * self.as_inner().y()),
            rhs.as_inner().dist() * self.as_inner().x(),
            -(rhs.as_inner().nx() * self.as_inner().z())
                + rhs.as_inner().nz() * self.as_inner().x(),
            rhs.as_inner().nx() * self.as_inner().y() + rhs.as_inner().ny() * self.as_inner().x(),
        )
    }
}
#[doc = "Left contraction of [`Point`] into [`Point`].\n\nThe left contraction `a _| b` projects `a` onto `b`, returning the\ncomponent of `b` orthogonal to `a`. The result grade is grade(b) - grade(a)\n(or zero if grade(a) > grade(b))."]
impl<T: Float> LeftContract<Point<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.x() * self.x() + rhs.y() * self.y() + rhs.z() * self.z())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Point<T>> for Unitized<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.x() * self.as_inner().x()
                + rhs.y() * self.as_inner().y()
                + rhs.z() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Point<T>>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.as_inner().x() * self.x()
                + rhs.as_inner().y() * self.y()
                + rhs.as_inner().z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Point<T>>> for Unitized<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.as_inner().x() * self.as_inner().x()
                + rhs.as_inner().y() * self.as_inner().y()
                + rhs.as_inner().z() * self.as_inner().z(),
        )
    }
}
#[doc = "Left contraction of [`Point`] into [`Quadvector`].\n\nThe left contraction `a _| b` projects `a` onto `b`, returning the\ncomponent of `b` orthogonal to `a`. The result grade is grade(b) - grade(a)\n(or zero if grade(a) > grade(b))."]
impl<T: Float> LeftContract<Quadvector<T>> for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn left_contract(&self, rhs: &Quadvector<T>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            rhs.ps() * self.z(),
            -(rhs.ps() * self.y()),
            rhs.ps() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Quadvector<T>> for Unitized<Point<T>> {
    type Output = Plane<T>;
    #[inline]
    fn left_contract(&self, rhs: &Quadvector<T>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            rhs.ps() * self.as_inner().z(),
            -(rhs.ps() * self.as_inner().y()),
            rhs.ps() * self.as_inner().x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Quadvector<T>>> for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Quadvector<T>>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            rhs.as_inner().ps() * self.z(),
            -(rhs.as_inner().ps() * self.y()),
            rhs.as_inner().ps() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Quadvector<T>>> for Unitized<Point<T>> {
    type Output = Plane<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Quadvector<T>>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            rhs.as_inner().ps() * self.as_inner().z(),
            -(rhs.as_inner().ps() * self.as_inner().y()),
            rhs.as_inner().ps() * self.as_inner().x(),
        )
    }
}
#[doc = "Left contraction of [`Scalar`] into [`Line`].\n\nThe left contraction `a _| b` projects `a` onto `b`, returning the\ncomponent of `b` orthogonal to `a`. The result grade is grade(b) - grade(a)\n(or zero if grade(a) > grade(b))."]
impl<T: Float> LeftContract<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.moment_z() * self.s(),
            rhs.moment_y() * self.s(),
            rhs.dir_x() * self.s(),
            rhs.moment_x() * self.s(),
            rhs.dir_y() * self.s(),
            rhs.dir_z() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Line<T>> for Unitized<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Line<T>>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().moment_z() * self.s(),
            rhs.as_inner().moment_y() * self.s(),
            rhs.as_inner().dir_x() * self.s(),
            rhs.as_inner().moment_x() * self.s(),
            rhs.as_inner().dir_y() * self.s(),
            rhs.as_inner().dir_z() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Line<T>>> for Unitized<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[doc = "Left contraction of [`Scalar`] into [`Plane`].\n\nThe left contraction `a _| b` projects `a` onto `b`, returning the\ncomponent of `b` orthogonal to `a`. The result grade is grade(b) - grade(a)\n(or zero if grade(a) > grade(b))."]
impl<T: Float> LeftContract<Plane<T>> for Scalar<T> {
    type Output = Plane<T>;
    #[inline]
    fn left_contract(&self, rhs: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.dist() * self.s(),
            rhs.nz() * self.s(),
            rhs.ny() * self.s(),
            rhs.nx() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Plane<T>> for Unitized<Scalar<T>> {
    type Output = Plane<T>;
    #[inline]
    fn left_contract(&self, rhs: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Plane<T>>> for Scalar<T> {
    type Output = Plane<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.as_inner().dist() * self.s(),
            rhs.as_inner().nz() * self.s(),
            rhs.as_inner().ny() * self.s(),
            rhs.as_inner().nx() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Plane<T>>> for Unitized<Scalar<T>> {
    type Output = Plane<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Left contraction of [`Scalar`] into [`Point`].\n\nThe left contraction `a _| b` projects `a` onto `b`, returning the\ncomponent of `b` orthogonal to `a`. The result grade is grade(b) - grade(a)\n(or zero if grade(a) > grade(b))."]
impl<T: Float> LeftContract<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.x() * self.s(),
            rhs.y() * self.s(),
            rhs.z() * self.s(),
            rhs.w() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Point<T>> for Unitized<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Point<T>>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            rhs.as_inner().x() * self.s(),
            rhs.as_inner().y() * self.s(),
            rhs.as_inner().z() * self.s(),
            rhs.as_inner().w() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Point<T>>> for Unitized<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Left contraction of [`Scalar`] into [`Quadvector`].\n\nThe left contraction `a _| b` projects `a` onto `b`, returning the\ncomponent of `b` orthogonal to `a`. The result grade is grade(b) - grade(a)\n(or zero if grade(a) > grade(b))."]
impl<T: Float> LeftContract<Quadvector<T>> for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.ps() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Quadvector<T>> for Unitized<Scalar<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Quadvector<T>>> for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.as_inner().ps() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Quadvector<T>>> for Unitized<Scalar<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[doc = "Left contraction of [`Scalar`] into [`Scalar`].\n\nThe left contraction `a _| b` projects `a` onto `b`, returning the\ncomponent of `b` orthogonal to `a`. The result grade is grade(b) - grade(a)\n(or zero if grade(a) > grade(b))."]
impl<T: Float> LeftContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Right contraction of [`Line`] by [`Line`].\n\nThe right contraction `a |_ b` projects `b` onto `a`, returning the\ncomponent of `a` orthogonal to `b`. The result grade is grade(a) - grade(b)\n(or zero if grade(b) > grade(a))."]
impl<T: Float> RightContract<Line<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.moment_x() * self.moment_x())
                + -(rhs.moment_y() * self.moment_y())
                + -(rhs.moment_z() * self.moment_z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Line<T>> for Unitized<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.moment_x() * self.as_inner().moment_x())
                + -(rhs.moment_y() * self.as_inner().moment_y())
                + -(rhs.moment_z() * self.as_inner().moment_z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Line<T>>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().moment_x() * self.moment_x())
                + -(rhs.as_inner().moment_y() * self.moment_y())
                + -(rhs.as_inner().moment_z() * self.moment_z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Line<T>>> for Unitized<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().moment_x() * self.as_inner().moment_x())
                + -(rhs.as_inner().moment_y() * self.as_inner().moment_y())
                + -(rhs.as_inner().moment_z() * self.as_inner().moment_z()),
        )
    }
}
#[doc = "Right contraction of [`Line`] by [`Point`].\n\nThe right contraction `a |_ b` projects `b` onto `a`, returning the\ncomponent of `a` orthogonal to `b`. The result grade is grade(a) - grade(b)\n(or zero if grade(b) > grade(a))."]
impl<T: Float> RightContract<Point<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.y() * self.moment_z() + rhs.z() * self.moment_y(),
            -(rhs.x() * self.moment_z()) + rhs.z() * self.moment_x(),
            -(rhs.x() * self.moment_y()) + -(rhs.y() * self.moment_x()),
            -(rhs.x() * self.dir_x()) + -(rhs.y() * self.dir_y()) + -(rhs.z() * self.dir_z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Point<T>> for Unitized<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.y() * self.as_inner().moment_z() + rhs.z() * self.as_inner().moment_y(),
            -(rhs.x() * self.as_inner().moment_z()) + rhs.z() * self.as_inner().moment_x(),
            -(rhs.x() * self.as_inner().moment_y()) + -(rhs.y() * self.as_inner().moment_x()),
            -(rhs.x() * self.as_inner().dir_x())
                + -(rhs.y() * self.as_inner().dir_y())
                + -(rhs.z() * self.as_inner().dir_z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Point<T>>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            rhs.as_inner().y() * self.moment_z() + rhs.as_inner().z() * self.moment_y(),
            -(rhs.as_inner().x() * self.moment_z()) + rhs.as_inner().z() * self.moment_x(),
            -(rhs.as_inner().x() * self.moment_y()) + -(rhs.as_inner().y() * self.moment_x()),
            -(rhs.as_inner().x() * self.dir_x())
                + -(rhs.as_inner().y() * self.dir_y())
                + -(rhs.as_inner().z() * self.dir_z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Point<T>>> for Unitized<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            rhs.as_inner().y() * self.as_inner().moment_z()
                + rhs.as_inner().z() * self.as_inner().moment_y(),
            -(rhs.as_inner().x() * self.as_inner().moment_z())
                + rhs.as_inner().z() * self.as_inner().moment_x(),
            -(rhs.as_inner().x() * self.as_inner().moment_y())
                + -(rhs.as_inner().y() * self.as_inner().moment_x()),
            -(rhs.as_inner().x() * self.as_inner().dir_x())
                + -(rhs.as_inner().y() * self.as_inner().dir_y())
                + -(rhs.as_inner().z() * self.as_inner().dir_z()),
        )
    }
}
#[doc = "Right contraction of [`Line`] by [`Scalar`].\n\nThe right contraction `a |_ b` projects `b` onto `a`, returning the\ncomponent of `a` orthogonal to `b`. The result grade is grade(a) - grade(b)\n(or zero if grade(b) > grade(a))."]
impl<T: Float> RightContract<Scalar<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.s() * self.moment_z(),
            rhs.s() * self.moment_y(),
            rhs.s() * self.dir_x(),
            rhs.s() * self.moment_x(),
            rhs.s() * self.dir_y(),
            rhs.s() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.s() * self.as_inner().moment_z(),
            rhs.s() * self.as_inner().moment_y(),
            rhs.s() * self.as_inner().dir_x(),
            rhs.s() * self.as_inner().moment_x(),
            rhs.s() * self.as_inner().dir_y(),
            rhs.s() * self.as_inner().dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[doc = "Right contraction of [`Plane`] by [`Line`].\n\nThe right contraction `a |_ b` projects `b` onto `a`, returning the\ncomponent of `a` orthogonal to `b`. The result grade is grade(a) - grade(b)\n(or zero if grade(b) > grade(a))."]
impl<T: Float> RightContract<Line<T>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.moment_x() * self.dist()),
            rhs.moment_y() * self.dist(),
            -(rhs.moment_z() * self.dist()),
            -(rhs.moment_x() * self.nx())
                + -(rhs.moment_y() * self.ny())
                + -(rhs.moment_z() * self.nz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Line<T>> for Unitized<Plane<T>> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.moment_x() * self.as_inner().dist()),
            rhs.moment_y() * self.as_inner().dist(),
            -(rhs.moment_z() * self.as_inner().dist()),
            -(rhs.moment_x() * self.as_inner().nx())
                + -(rhs.moment_y() * self.as_inner().ny())
                + -(rhs.moment_z() * self.as_inner().nz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Line<T>>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().moment_x() * self.dist()),
            rhs.as_inner().moment_y() * self.dist(),
            -(rhs.as_inner().moment_z() * self.dist()),
            -(rhs.as_inner().moment_x() * self.nx())
                + -(rhs.as_inner().moment_y() * self.ny())
                + -(rhs.as_inner().moment_z() * self.nz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Line<T>>> for Unitized<Plane<T>> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().moment_x() * self.as_inner().dist()),
            rhs.as_inner().moment_y() * self.as_inner().dist(),
            -(rhs.as_inner().moment_z() * self.as_inner().dist()),
            -(rhs.as_inner().moment_x() * self.as_inner().nx())
                + -(rhs.as_inner().moment_y() * self.as_inner().ny())
                + -(rhs.as_inner().moment_z() * self.as_inner().nz()),
        )
    }
}
#[doc = "Right contraction of [`Plane`] by [`Plane`].\n\nThe right contraction `a |_ b` projects `b` onto `a`, returning the\ncomponent of `a` orthogonal to `b`. The result grade is grade(a) - grade(b)\n(or zero if grade(b) > grade(a))."]
impl<T: Float> RightContract<Plane<T>> for Plane<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Plane<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.dist() * self.dist()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Plane<T>> for Unitized<Plane<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Plane<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.dist() * self.as_inner().dist()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Plane<T>>> for Plane<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Plane<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().dist() * self.dist()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Plane<T>>> for Unitized<Plane<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Plane<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().dist() * self.as_inner().dist()))
    }
}
#[doc = "Right contraction of [`Plane`] by [`Point`].\n\nThe right contraction `a |_ b` projects `b` onto `a`, returning the\ncomponent of `a` orthogonal to `b`. The result grade is grade(a) - grade(b)\n(or zero if grade(b) > grade(a))."]
impl<T: Float> RightContract<Point<T>> for Plane<T> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.z() * self.dist(),
            -(rhs.y() * self.dist()),
            -(rhs.y() * self.nz()) + -(rhs.z() * self.ny()),
            rhs.x() * self.dist(),
            -(rhs.z() * self.nx()) + rhs.x() * self.nz(),
            rhs.x() * self.ny() + rhs.y() * self.nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Point<T>> for Unitized<Plane<T>> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.z() * self.as_inner().dist(),
            -(rhs.y() * self.as_inner().dist()),
            -(rhs.y() * self.as_inner().nz()) + -(rhs.z() * self.as_inner().ny()),
            rhs.x() * self.as_inner().dist(),
            -(rhs.z() * self.as_inner().nx()) + rhs.x() * self.as_inner().nz(),
            rhs.x() * self.as_inner().ny() + rhs.y() * self.as_inner().nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Point<T>>> for Plane<T> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().z() * self.dist(),
            -(rhs.as_inner().y() * self.dist()),
            -(rhs.as_inner().y() * self.nz()) + -(rhs.as_inner().z() * self.ny()),
            rhs.as_inner().x() * self.dist(),
            -(rhs.as_inner().z() * self.nx()) + rhs.as_inner().x() * self.nz(),
            rhs.as_inner().x() * self.ny() + rhs.as_inner().y() * self.nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Point<T>>> for Unitized<Plane<T>> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().z() * self.as_inner().dist(),
            -(rhs.as_inner().y() * self.as_inner().dist()),
            -(rhs.as_inner().y() * self.as_inner().nz())
                + -(rhs.as_inner().z() * self.as_inner().ny()),
            rhs.as_inner().x() * self.as_inner().dist(),
            -(rhs.as_inner().z() * self.as_inner().nx())
                + rhs.as_inner().x() * self.as_inner().nz(),
            rhs.as_inner().x() * self.as_inner().ny() + rhs.as_inner().y() * self.as_inner().nx(),
        )
    }
}
#[doc = "Right contraction of [`Plane`] by [`Scalar`].\n\nThe right contraction `a |_ b` projects `b` onto `a`, returning the\ncomponent of `a` orthogonal to `b`. The result grade is grade(a) - grade(b)\n(or zero if grade(b) > grade(a))."]
impl<T: Float> RightContract<Scalar<T>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.s() * self.dist(),
            rhs.s() * self.nz(),
            rhs.s() * self.ny(),
            rhs.s() * self.nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.s() * self.as_inner().dist(),
            rhs.s() * self.as_inner().nz(),
            rhs.s() * self.as_inner().ny(),
            rhs.s() * self.as_inner().nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Right contraction of [`Point`] by [`Point`].\n\nThe right contraction `a |_ b` projects `b` onto `a`, returning the\ncomponent of `a` orthogonal to `b`. The result grade is grade(a) - grade(b)\n(or zero if grade(b) > grade(a))."]
impl<T: Float> RightContract<Point<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.x() * self.x() + rhs.y() * self.y() + rhs.z() * self.z())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Point<T>> for Unitized<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.x() * self.as_inner().x()
                + rhs.y() * self.as_inner().y()
                + rhs.z() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Point<T>>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.as_inner().x() * self.x()
                + rhs.as_inner().y() * self.y()
                + rhs.as_inner().z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Point<T>>> for Unitized<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.as_inner().x() * self.as_inner().x()
                + rhs.as_inner().y() * self.as_inner().y()
                + rhs.as_inner().z() * self.as_inner().z(),
        )
    }
}
#[doc = "Right contraction of [`Point`] by [`Scalar`].\n\nThe right contraction `a |_ b` projects `b` onto `a`, returning the\ncomponent of `a` orthogonal to `b`. The result grade is grade(a) - grade(b)\n(or zero if grade(b) > grade(a))."]
impl<T: Float> RightContract<Scalar<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.s() * self.x(),
            rhs.s() * self.y(),
            rhs.s() * self.z(),
            rhs.s() * self.w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.s() * self.as_inner().x(),
            rhs.s() * self.as_inner().y(),
            rhs.s() * self.as_inner().z(),
            rhs.s() * self.as_inner().w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Right contraction of [`Quadvector`] by [`Line`].\n\nThe right contraction `a |_ b` projects `b` onto `a`, returning the\ncomponent of `a` orthogonal to `b`. The result grade is grade(a) - grade(b)\n(or zero if grade(b) > grade(a))."]
impl<T: Float> RightContract<Line<T>> for Quadvector<T> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            -(rhs.moment_x() * self.ps()),
            T::zero(),
            rhs.moment_y() * self.ps(),
            -(rhs.moment_z() * self.ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Line<T>> for Unitized<Quadvector<T>> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            -(rhs.moment_x() * self.as_inner().ps()),
            T::zero(),
            rhs.moment_y() * self.as_inner().ps(),
            -(rhs.moment_z() * self.as_inner().ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Line<T>>> for Quadvector<T> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            -(rhs.as_inner().moment_x() * self.ps()),
            T::zero(),
            rhs.as_inner().moment_y() * self.ps(),
            -(rhs.as_inner().moment_z() * self.ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Line<T>>> for Unitized<Quadvector<T>> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            -(rhs.as_inner().moment_x() * self.as_inner().ps()),
            T::zero(),
            rhs.as_inner().moment_y() * self.as_inner().ps(),
            -(rhs.as_inner().moment_z() * self.as_inner().ps()),
        )
    }
}
#[doc = "Right contraction of [`Quadvector`] by [`Plane`].\n\nThe right contraction `a |_ b` projects `b` onto `a`, returning the\ncomponent of `a` orthogonal to `b`. The result grade is grade(a) - grade(b)\n(or zero if grade(b) > grade(a))."]
impl<T: Float> RightContract<Plane<T>> for Quadvector<T> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Plane<T>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), rhs.dist() * self.ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Plane<T>> for Unitized<Quadvector<T>> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Plane<T>) -> Point<T> {
        Point::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            rhs.dist() * self.as_inner().ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Plane<T>>> for Quadvector<T> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Plane<T>>) -> Point<T> {
        Point::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            rhs.as_inner().dist() * self.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Plane<T>>> for Unitized<Quadvector<T>> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Plane<T>>) -> Point<T> {
        Point::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            rhs.as_inner().dist() * self.as_inner().ps(),
        )
    }
}
#[doc = "Right contraction of [`Quadvector`] by [`Point`].\n\nThe right contraction `a |_ b` projects `b` onto `a`, returning the\ncomponent of `a` orthogonal to `b`. The result grade is grade(a) - grade(b)\n(or zero if grade(b) > grade(a))."]
impl<T: Float> RightContract<Point<T>> for Quadvector<T> {
    type Output = Plane<T>;
    #[inline]
    fn right_contract(&self, rhs: &Point<T>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            -(rhs.z() * self.ps()),
            rhs.y() * self.ps(),
            -(rhs.x() * self.ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Point<T>> for Unitized<Quadvector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn right_contract(&self, rhs: &Point<T>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            -(rhs.z() * self.as_inner().ps()),
            rhs.y() * self.as_inner().ps(),
            -(rhs.x() * self.as_inner().ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Point<T>>> for Quadvector<T> {
    type Output = Plane<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Point<T>>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            -(rhs.as_inner().z() * self.ps()),
            rhs.as_inner().y() * self.ps(),
            -(rhs.as_inner().x() * self.ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Point<T>>> for Unitized<Quadvector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Point<T>>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            -(rhs.as_inner().z() * self.as_inner().ps()),
            rhs.as_inner().y() * self.as_inner().ps(),
            -(rhs.as_inner().x() * self.as_inner().ps()),
        )
    }
}
#[doc = "Right contraction of [`Quadvector`] by [`Scalar`].\n\nThe right contraction `a |_ b` projects `b` onto `a`, returning the\ncomponent of `a` orthogonal to `b`. The result grade is grade(a) - grade(b)\n(or zero if grade(b) > grade(a))."]
impl<T: Float> RightContract<Scalar<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.s() * self.ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.s() * self.as_inner().ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[doc = "Right contraction of [`Scalar`] by [`Scalar`].\n\nThe right contraction `a |_ b` projects `b` onto `a`, returning the\ncomponent of `a` orthogonal to `b`. The result grade is grade(a) - grade(b)\n(or zero if grade(b) > grade(a))."]
impl<T: Float> RightContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Sandwich product: [`Flector`] x [`Flector`] x rev([`Flector`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Flector<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            -(self.dist() * operand.dist() * self.px()) + self.dist() * operand.px() * self.dist()
                - self.dist() * operand.py() * self.pz()
                + self.dist() * operand.pz() * self.py()
                + self.px() * operand.dist() * self.dist()
                + self.px() * operand.px() * self.px()
                + self.px() * operand.py() * self.py()
                + self.px() * operand.pz() * self.pz()
                - self.py() * operand.dist() * self.pz()
                - self.py() * operand.px() * self.py()
                + self.py() * operand.py() * self.px()
                + self.py() * operand.pz() * self.dist()
                + self.pz() * operand.dist() * self.py()
                - self.pz() * operand.px() * self.pz()
                - self.pz() * operand.py() * self.dist()
                + self.pz() * operand.pz() * self.px(),
            -(self.dist() * operand.dist() * self.py())
                + self.dist() * operand.px() * self.pz()
                + self.dist() * operand.py() * self.dist()
                - self.dist() * operand.pz() * self.px()
                + self.px() * operand.dist() * self.pz()
                + self.px() * operand.px() * self.py()
                - self.px() * operand.py() * self.px()
                - self.px() * operand.pz() * self.dist()
                + self.py() * operand.dist() * self.dist()
                + self.py() * operand.px() * self.px()
                + self.py() * operand.py() * self.py()
                + self.py() * operand.pz() * self.pz()
                - self.pz() * operand.dist() * self.px()
                + self.pz() * operand.px() * self.dist()
                - self.pz() * operand.py() * self.pz()
                + self.pz() * operand.pz() * self.py(),
            -(self.dist() * operand.dist() * self.pz()) - self.dist() * operand.px() * self.py()
                + self.dist() * operand.py() * self.px()
                + self.dist() * operand.pz() * self.dist()
                - self.px() * operand.dist() * self.py()
                + self.px() * operand.px() * self.pz()
                + self.px() * operand.py() * self.dist()
                - self.px() * operand.pz() * self.px()
                + self.py() * operand.dist() * self.px()
                - self.py() * operand.px() * self.dist()
                + self.py() * operand.py() * self.pz()
                - self.py() * operand.pz() * self.py()
                + self.pz() * operand.dist() * self.dist()
                + self.pz() * operand.px() * self.px()
                + self.pz() * operand.py() * self.py()
                + self.pz() * operand.pz() * self.pz(),
            -(self.dist() * operand.dist() * self.pw()) + self.dist() * operand.nx() * self.px()
                - self.dist() * operand.ny() * self.py()
                + self.dist() * operand.nz() * self.pz()
                - self.dist() * operand.pw() * self.dist()
                + self.dist() * operand.px() * self.nx()
                - self.dist() * operand.py() * self.ny()
                + self.dist() * operand.pz() * self.nz()
                - self.nx() * operand.dist() * self.px()
                + self.nx() * operand.px() * self.dist()
                - self.nx() * operand.py() * self.pz()
                + self.nx() * operand.pz() * self.py()
                + self.ny() * operand.dist() * self.py()
                - self.ny() * operand.px() * self.pz()
                - self.ny() * operand.py() * self.dist()
                + self.ny() * operand.pz() * self.px()
                - self.nz() * operand.dist() * self.pz()
                - self.nz() * operand.px() * self.py()
                + self.nz() * operand.py() * self.px()
                + self.nz() * operand.pz() * self.dist()
                + self.pw() * operand.dist() * self.dist()
                + self.pw() * operand.px() * self.px()
                + self.pw() * operand.py() * self.py()
                + self.pw() * operand.pz() * self.pz()
                + self.px() * operand.dist() * self.nx()
                - self.px() * operand.nx() * self.dist()
                - self.px() * operand.ny() * self.pz()
                - self.px() * operand.nz() * self.py()
                - self.px() * operand.pw() * self.px()
                + self.px() * operand.px() * self.pw()
                + self.px() * operand.py() * self.nz()
                + self.px() * operand.pz() * self.ny()
                - self.py() * operand.dist() * self.ny()
                - self.py() * operand.nx() * self.pz()
                + self.py() * operand.ny() * self.dist()
                + self.py() * operand.nz() * self.px()
                - self.py() * operand.pw() * self.py()
                - self.py() * operand.px() * self.nz()
                + self.py() * operand.py() * self.pw()
                + self.py() * operand.pz() * self.nx()
                + self.pz() * operand.dist() * self.nz()
                + self.pz() * operand.nx() * self.py()
                + self.pz() * operand.ny() * self.px()
                - self.pz() * operand.nz() * self.dist()
                - self.pz() * operand.pw() * self.pz()
                - self.pz() * operand.px() * self.ny()
                - self.pz() * operand.py() * self.nx()
                + self.pz() * operand.pz() * self.pw(),
            self.dist() * operand.dist() * self.dist()
                + self.dist() * operand.px() * self.px()
                + self.dist() * operand.py() * self.py()
                + self.dist() * operand.pz() * self.pz()
                + self.px() * operand.dist() * self.px()
                - self.px() * operand.px() * self.dist()
                + self.px() * operand.py() * self.pz()
                - self.px() * operand.pz() * self.py()
                + self.py() * operand.dist() * self.py()
                - self.py() * operand.px() * self.pz()
                - self.py() * operand.py() * self.dist()
                + self.py() * operand.pz() * self.px()
                + self.pz() * operand.dist() * self.pz()
                + self.pz() * operand.px() * self.py()
                - self.pz() * operand.py() * self.px()
                - self.pz() * operand.pz() * self.dist(),
            self.dist() * operand.dist() * self.nz()
                + self.dist() * operand.nx() * self.py()
                + self.dist() * operand.ny() * self.px()
                - self.dist() * operand.nz() * self.dist()
                - self.dist() * operand.pw() * self.pz()
                - self.dist() * operand.px() * self.ny()
                - self.dist() * operand.py() * self.nx()
                + self.dist() * operand.pz() * self.pw()
                - self.nx() * operand.dist() * self.py()
                + self.nx() * operand.px() * self.pz()
                + self.nx() * operand.py() * self.dist()
                - self.nx() * operand.pz() * self.px()
                - self.ny() * operand.dist() * self.px()
                + self.ny() * operand.px() * self.dist()
                - self.ny() * operand.py() * self.pz()
                + self.ny() * operand.pz() * self.py()
                + self.nz() * operand.dist() * self.dist()
                + self.nz() * operand.px() * self.px()
                + self.nz() * operand.py() * self.py()
                + self.nz() * operand.pz() * self.pz()
                + self.pw() * operand.dist() * self.pz()
                + self.pw() * operand.px() * self.py()
                - self.pw() * operand.py() * self.px()
                - self.pw() * operand.pz() * self.dist()
                - self.px() * operand.dist() * self.ny()
                - self.px() * operand.nx() * self.pz()
                + self.px() * operand.ny() * self.dist()
                + self.px() * operand.nz() * self.px()
                - self.px() * operand.pw() * self.py()
                - self.px() * operand.px() * self.nz()
                + self.px() * operand.py() * self.pw()
                + self.px() * operand.pz() * self.nx()
                - self.py() * operand.dist() * self.nx()
                + self.py() * operand.nx() * self.dist()
                + self.py() * operand.ny() * self.pz()
                + self.py() * operand.nz() * self.py()
                + self.py() * operand.pw() * self.px()
                - self.py() * operand.px() * self.pw()
                - self.py() * operand.py() * self.nz()
                - self.py() * operand.pz() * self.ny()
                + self.pz() * operand.dist() * self.pw()
                - self.pz() * operand.nx() * self.px()
                + self.pz() * operand.ny() * self.py()
                - self.pz() * operand.nz() * self.pz()
                + self.pz() * operand.pw() * self.dist()
                - self.pz() * operand.px() * self.nx()
                + self.pz() * operand.py() * self.ny()
                - self.pz() * operand.pz() * self.nz(),
            self.dist() * operand.dist() * self.ny() + self.dist() * operand.nx() * self.pz()
                - self.dist() * operand.ny() * self.dist()
                - self.dist() * operand.nz() * self.px()
                + self.dist() * operand.pw() * self.py()
                + self.dist() * operand.px() * self.nz()
                - self.dist() * operand.py() * self.pw()
                - self.dist() * operand.pz() * self.nx()
                - self.nx() * operand.dist() * self.pz()
                - self.nx() * operand.px() * self.py()
                + self.nx() * operand.py() * self.px()
                + self.nx() * operand.pz() * self.dist()
                + self.ny() * operand.dist() * self.dist()
                + self.ny() * operand.px() * self.px()
                + self.ny() * operand.py() * self.py()
                + self.ny() * operand.pz() * self.pz()
                + self.nz() * operand.dist() * self.px()
                - self.nz() * operand.px() * self.dist()
                + self.nz() * operand.py() * self.pz()
                - self.nz() * operand.pz() * self.py()
                - self.pw() * operand.dist() * self.py()
                + self.pw() * operand.px() * self.pz()
                + self.pw() * operand.py() * self.dist()
                - self.pw() * operand.pz() * self.px()
                + self.px() * operand.dist() * self.nz()
                + self.px() * operand.nx() * self.py()
                + self.px() * operand.ny() * self.px()
                - self.px() * operand.nz() * self.dist()
                - self.px() * operand.pw() * self.pz()
                - self.px() * operand.px() * self.ny()
                - self.px() * operand.py() * self.nx()
                + self.px() * operand.pz() * self.pw()
                - self.py() * operand.dist() * self.pw()
                + self.py() * operand.nx() * self.px()
                - self.py() * operand.ny() * self.py()
                + self.py() * operand.nz() * self.pz()
                - self.py() * operand.pw() * self.dist()
                + self.py() * operand.px() * self.nx()
                - self.py() * operand.py() * self.ny()
                + self.py() * operand.pz() * self.nz()
                - self.pz() * operand.dist() * self.nx()
                + self.pz() * operand.nx() * self.dist()
                + self.pz() * operand.ny() * self.pz()
                + self.pz() * operand.nz() * self.py()
                + self.pz() * operand.pw() * self.px()
                - self.pz() * operand.px() * self.pw()
                - self.pz() * operand.py() * self.nz()
                - self.pz() * operand.pz() * self.ny(),
            self.dist() * operand.dist() * self.nx()
                - self.dist() * operand.nx() * self.dist()
                - self.dist() * operand.ny() * self.pz()
                - self.dist() * operand.nz() * self.py()
                - self.dist() * operand.pw() * self.px()
                + self.dist() * operand.px() * self.pw()
                + self.dist() * operand.py() * self.nz()
                + self.dist() * operand.pz() * self.ny()
                + self.nx() * operand.dist() * self.dist()
                + self.nx() * operand.px() * self.px()
                + self.nx() * operand.py() * self.py()
                + self.nx() * operand.pz() * self.pz()
                + self.ny() * operand.dist() * self.pz()
                + self.ny() * operand.px() * self.py()
                - self.ny() * operand.py() * self.px()
                - self.ny() * operand.pz() * self.dist()
                + self.nz() * operand.dist() * self.py()
                - self.nz() * operand.px() * self.pz()
                - self.nz() * operand.py() * self.dist()
                + self.nz() * operand.pz() * self.px()
                + self.pw() * operand.dist() * self.px()
                - self.pw() * operand.px() * self.dist()
                + self.pw() * operand.py() * self.pz()
                - self.pw() * operand.pz() * self.py()
                + self.px() * operand.dist() * self.pw()
                - self.px() * operand.nx() * self.px()
                + self.px() * operand.ny() * self.py()
                - self.px() * operand.nz() * self.pz()
                + self.px() * operand.pw() * self.dist()
                - self.px() * operand.px() * self.nx()
                + self.px() * operand.py() * self.ny()
                - self.px() * operand.pz() * self.nz()
                + self.py() * operand.dist() * self.nz()
                + self.py() * operand.nx() * self.py()
                + self.py() * operand.ny() * self.px()
                - self.py() * operand.nz() * self.dist()
                - self.py() * operand.pw() * self.pz()
                - self.py() * operand.px() * self.ny()
                - self.py() * operand.py() * self.nx()
                + self.py() * operand.pz() * self.pw()
                + self.pz() * operand.dist() * self.ny()
                + self.pz() * operand.nx() * self.pz()
                - self.pz() * operand.ny() * self.dist()
                - self.pz() * operand.nz() * self.px()
                + self.pz() * operand.pw() * self.py()
                + self.pz() * operand.px() * self.nz()
                - self.pz() * operand.py() * self.pw()
                - self.pz() * operand.pz() * self.nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Flector<T>> for Unitized<Flector<T>> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            -(operand.px() * self.as_inner().py() * self.as_inner().py())
                + -(operand.px() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.py() * self.as_inner().dist() * self.as_inner().pz()
                + T::TWO * operand.py() * self.as_inner().px() * self.as_inner().py()
                + T::TWO * operand.pz() * self.as_inner().dist() * self.as_inner().py()
                + T::TWO * operand.pz() * self.as_inner().px() * self.as_inner().pz()
                + operand.px() * self.as_inner().dist() * self.as_inner().dist()
                + operand.px() * self.as_inner().px() * self.as_inner().px(),
            -(operand.py() * self.as_inner().px() * self.as_inner().px())
                + -(operand.py() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.pz() * self.as_inner().dist() * self.as_inner().px()
                + T::TWO * operand.px() * self.as_inner().dist() * self.as_inner().pz()
                + T::TWO * operand.px() * self.as_inner().px() * self.as_inner().py()
                + T::TWO * operand.pz() * self.as_inner().py() * self.as_inner().pz()
                + operand.py() * self.as_inner().dist() * self.as_inner().dist()
                + operand.py() * self.as_inner().py() * self.as_inner().py(),
            -(operand.pz() * self.as_inner().px() * self.as_inner().px())
                + -(operand.pz() * self.as_inner().py() * self.as_inner().py())
                + -T::TWO * operand.px() * self.as_inner().dist() * self.as_inner().py()
                + T::TWO * operand.px() * self.as_inner().px() * self.as_inner().pz()
                + T::TWO * operand.py() * self.as_inner().dist() * self.as_inner().px()
                + T::TWO * operand.py() * self.as_inner().py() * self.as_inner().pz()
                + operand.pz() * self.as_inner().dist() * self.as_inner().dist()
                + operand.pz() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.pw() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.pw() * self.as_inner().px() * self.as_inner().px())
                + -(operand.pw() * self.as_inner().py() * self.as_inner().py())
                + -(operand.pw() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.px() * self.as_inner().ny() * self.as_inner().pz()
                + -T::TWO * operand.px() * self.as_inner().nz() * self.as_inner().py()
                + -T::TWO * operand.py() * self.as_inner().dist() * self.as_inner().ny()
                + -T::TWO * operand.py() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.px() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.px() * self.as_inner().pw() * self.as_inner().px()
                + T::TWO * operand.py() * self.as_inner().nz() * self.as_inner().px()
                + T::TWO * operand.py() * self.as_inner().pw() * self.as_inner().py()
                + T::TWO * operand.pz() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.pz() * self.as_inner().nx() * self.as_inner().py()
                + T::TWO * operand.pz() * self.as_inner().ny() * self.as_inner().px()
                + T::TWO * operand.pz() * self.as_inner().pw() * self.as_inner().pz(),
            operand.dist() * self.as_inner().dist() * self.as_inner().dist()
                + operand.dist() * self.as_inner().px() * self.as_inner().px()
                + operand.dist() * self.as_inner().py() * self.as_inner().py()
                + operand.dist() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.nz() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.nz() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.dist() * self.as_inner().nx() * self.as_inner().py()
                + -T::TWO * operand.dist() * self.as_inner().ny() * self.as_inner().px()
                + -T::TWO * operand.nx() * self.as_inner().px() * self.as_inner().pz()
                + T::TWO * operand.dist() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.dist() * self.as_inner().pw() * self.as_inner().pz()
                + T::TWO * operand.nx() * self.as_inner().dist() * self.as_inner().py()
                + T::TWO * operand.ny() * self.as_inner().dist() * self.as_inner().px()
                + T::TWO * operand.ny() * self.as_inner().py() * self.as_inner().pz()
                + operand.nz() * self.as_inner().px() * self.as_inner().px()
                + operand.nz() * self.as_inner().py() * self.as_inner().py(),
            -(operand.ny() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.ny() * self.as_inner().py() * self.as_inner().py())
                + -T::TWO * operand.dist() * self.as_inner().nx() * self.as_inner().pz()
                + -T::TWO * operand.dist() * self.as_inner().pw() * self.as_inner().py()
                + -T::TWO * operand.nz() * self.as_inner().dist() * self.as_inner().px()
                + T::TWO * operand.dist() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.dist() * self.as_inner().nz() * self.as_inner().px()
                + T::TWO * operand.nx() * self.as_inner().dist() * self.as_inner().pz()
                + T::TWO * operand.nx() * self.as_inner().px() * self.as_inner().py()
                + T::TWO * operand.nz() * self.as_inner().py() * self.as_inner().pz()
                + operand.ny() * self.as_inner().px() * self.as_inner().px()
                + operand.ny() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.nx() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.nx() * self.as_inner().px() * self.as_inner().px())
                + -T::TWO * operand.ny() * self.as_inner().dist() * self.as_inner().pz()
                + -T::TWO * operand.nz() * self.as_inner().dist() * self.as_inner().py()
                + -T::TWO * operand.nz() * self.as_inner().px() * self.as_inner().pz()
                + T::TWO * operand.dist() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.dist() * self.as_inner().ny() * self.as_inner().pz()
                + T::TWO * operand.dist() * self.as_inner().nz() * self.as_inner().py()
                + T::TWO * operand.dist() * self.as_inner().pw() * self.as_inner().px()
                + T::TWO * operand.ny() * self.as_inner().px() * self.as_inner().py()
                + operand.nx() * self.as_inner().py() * self.as_inner().py()
                + operand.nx() * self.as_inner().pz() * self.as_inner().pz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Flector<T>>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            -(operand.as_inner().px() * self.py() * self.py())
                + -(operand.as_inner().px() * self.pz() * self.pz())
                + -T::TWO * operand.as_inner().py() * self.dist() * self.pz()
                + T::TWO * operand.as_inner().py() * self.px() * self.py()
                + T::TWO * operand.as_inner().pz() * self.dist() * self.py()
                + T::TWO * operand.as_inner().pz() * self.px() * self.pz()
                + operand.as_inner().px() * self.dist() * self.dist()
                + operand.as_inner().px() * self.px() * self.px(),
            -(operand.as_inner().py() * self.px() * self.px())
                + -(operand.as_inner().py() * self.pz() * self.pz())
                + -T::TWO * operand.as_inner().pz() * self.dist() * self.px()
                + T::TWO * operand.as_inner().px() * self.dist() * self.pz()
                + T::TWO * operand.as_inner().px() * self.px() * self.py()
                + T::TWO * operand.as_inner().pz() * self.py() * self.pz()
                + operand.as_inner().py() * self.dist() * self.dist()
                + operand.as_inner().py() * self.py() * self.py(),
            -(operand.as_inner().pz() * self.px() * self.px())
                + -(operand.as_inner().pz() * self.py() * self.py())
                + -T::TWO * operand.as_inner().px() * self.dist() * self.py()
                + T::TWO * operand.as_inner().px() * self.px() * self.pz()
                + T::TWO * operand.as_inner().py() * self.dist() * self.px()
                + T::TWO * operand.as_inner().py() * self.py() * self.pz()
                + operand.as_inner().pz() * self.dist() * self.dist()
                + operand.as_inner().pz() * self.pz() * self.pz(),
            -(operand.as_inner().pw() * self.dist() * self.dist())
                + -(operand.as_inner().pw() * self.px() * self.px())
                + -(operand.as_inner().pw() * self.py() * self.py())
                + -(operand.as_inner().pw() * self.pz() * self.pz())
                + -T::TWO * operand.as_inner().px() * self.ny() * self.pz()
                + -T::TWO * operand.as_inner().px() * self.nz() * self.py()
                + -T::TWO * operand.as_inner().py() * self.dist() * self.ny()
                + -T::TWO * operand.as_inner().py() * self.nx() * self.pz()
                + T::TWO * operand.as_inner().px() * self.dist() * self.nx()
                + T::TWO * operand.as_inner().px() * self.pw() * self.px()
                + T::TWO * operand.as_inner().py() * self.nz() * self.px()
                + T::TWO * operand.as_inner().py() * self.pw() * self.py()
                + T::TWO * operand.as_inner().pz() * self.dist() * self.nz()
                + T::TWO * operand.as_inner().pz() * self.nx() * self.py()
                + T::TWO * operand.as_inner().pz() * self.ny() * self.px()
                + T::TWO * operand.as_inner().pz() * self.pw() * self.pz(),
            operand.as_inner().dist() * self.dist() * self.dist()
                + operand.as_inner().dist() * self.px() * self.px()
                + operand.as_inner().dist() * self.py() * self.py()
                + operand.as_inner().dist() * self.pz() * self.pz(),
            -(operand.as_inner().nz() * self.dist() * self.dist())
                + -(operand.as_inner().nz() * self.pz() * self.pz())
                + -T::TWO * operand.as_inner().dist() * self.nx() * self.py()
                + -T::TWO * operand.as_inner().dist() * self.ny() * self.px()
                + -T::TWO * operand.as_inner().nx() * self.px() * self.pz()
                + T::TWO * operand.as_inner().dist() * self.dist() * self.nz()
                + T::TWO * operand.as_inner().dist() * self.pw() * self.pz()
                + T::TWO * operand.as_inner().nx() * self.dist() * self.py()
                + T::TWO * operand.as_inner().ny() * self.dist() * self.px()
                + T::TWO * operand.as_inner().ny() * self.py() * self.pz()
                + operand.as_inner().nz() * self.px() * self.px()
                + operand.as_inner().nz() * self.py() * self.py(),
            -(operand.as_inner().ny() * self.dist() * self.dist())
                + -(operand.as_inner().ny() * self.py() * self.py())
                + -T::TWO * operand.as_inner().dist() * self.nx() * self.pz()
                + -T::TWO * operand.as_inner().dist() * self.pw() * self.py()
                + -T::TWO * operand.as_inner().nz() * self.dist() * self.px()
                + T::TWO * operand.as_inner().dist() * self.dist() * self.ny()
                + T::TWO * operand.as_inner().dist() * self.nz() * self.px()
                + T::TWO * operand.as_inner().nx() * self.dist() * self.pz()
                + T::TWO * operand.as_inner().nx() * self.px() * self.py()
                + T::TWO * operand.as_inner().nz() * self.py() * self.pz()
                + operand.as_inner().ny() * self.px() * self.px()
                + operand.as_inner().ny() * self.pz() * self.pz(),
            -(operand.as_inner().nx() * self.dist() * self.dist())
                + -(operand.as_inner().nx() * self.px() * self.px())
                + -T::TWO * operand.as_inner().ny() * self.dist() * self.pz()
                + -T::TWO * operand.as_inner().nz() * self.dist() * self.py()
                + -T::TWO * operand.as_inner().nz() * self.px() * self.pz()
                + T::TWO * operand.as_inner().dist() * self.dist() * self.nx()
                + T::TWO * operand.as_inner().dist() * self.ny() * self.pz()
                + T::TWO * operand.as_inner().dist() * self.nz() * self.py()
                + T::TWO * operand.as_inner().dist() * self.pw() * self.px()
                + T::TWO * operand.as_inner().ny() * self.px() * self.py()
                + operand.as_inner().nx() * self.py() * self.py()
                + operand.as_inner().nx() * self.pz() * self.pz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Flector<T>>> for Unitized<Flector<T>> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            -(operand.as_inner().px() * self.as_inner().py() * self.as_inner().py())
                + -(operand.as_inner().px() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.as_inner().py() * self.as_inner().dist() * self.as_inner().pz()
                + T::TWO * operand.as_inner().py() * self.as_inner().px() * self.as_inner().py()
                + T::TWO * operand.as_inner().pz() * self.as_inner().dist() * self.as_inner().py()
                + T::TWO * operand.as_inner().pz() * self.as_inner().px() * self.as_inner().pz()
                + operand.as_inner().px() * self.as_inner().dist() * self.as_inner().dist()
                + operand.as_inner().px() * self.as_inner().px() * self.as_inner().px(),
            -(operand.as_inner().py() * self.as_inner().px() * self.as_inner().px())
                + -(operand.as_inner().py() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.as_inner().pz() * self.as_inner().dist() * self.as_inner().px()
                + T::TWO * operand.as_inner().px() * self.as_inner().dist() * self.as_inner().pz()
                + T::TWO * operand.as_inner().px() * self.as_inner().px() * self.as_inner().py()
                + T::TWO * operand.as_inner().pz() * self.as_inner().py() * self.as_inner().pz()
                + operand.as_inner().py() * self.as_inner().dist() * self.as_inner().dist()
                + operand.as_inner().py() * self.as_inner().py() * self.as_inner().py(),
            -(operand.as_inner().pz() * self.as_inner().px() * self.as_inner().px())
                + -(operand.as_inner().pz() * self.as_inner().py() * self.as_inner().py())
                + -T::TWO * operand.as_inner().px() * self.as_inner().dist() * self.as_inner().py()
                + T::TWO * operand.as_inner().px() * self.as_inner().px() * self.as_inner().pz()
                + T::TWO * operand.as_inner().py() * self.as_inner().dist() * self.as_inner().px()
                + T::TWO * operand.as_inner().py() * self.as_inner().py() * self.as_inner().pz()
                + operand.as_inner().pz() * self.as_inner().dist() * self.as_inner().dist()
                + operand.as_inner().pz() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.as_inner().pw() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.as_inner().pw() * self.as_inner().px() * self.as_inner().px())
                + -(operand.as_inner().pw() * self.as_inner().py() * self.as_inner().py())
                + -(operand.as_inner().pw() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.as_inner().px() * self.as_inner().ny() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().px() * self.as_inner().nz() * self.as_inner().py()
                + -T::TWO * operand.as_inner().py() * self.as_inner().dist() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().py() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.as_inner().px() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.as_inner().px() * self.as_inner().pw() * self.as_inner().px()
                + T::TWO * operand.as_inner().py() * self.as_inner().nz() * self.as_inner().px()
                + T::TWO * operand.as_inner().py() * self.as_inner().pw() * self.as_inner().py()
                + T::TWO * operand.as_inner().pz() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.as_inner().pz() * self.as_inner().nx() * self.as_inner().py()
                + T::TWO * operand.as_inner().pz() * self.as_inner().ny() * self.as_inner().px()
                + T::TWO * operand.as_inner().pz() * self.as_inner().pw() * self.as_inner().pz(),
            operand.as_inner().dist() * self.as_inner().dist() * self.as_inner().dist()
                + operand.as_inner().dist() * self.as_inner().px() * self.as_inner().px()
                + operand.as_inner().dist() * self.as_inner().py() * self.as_inner().py()
                + operand.as_inner().dist() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.as_inner().nz() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.as_inner().nz() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.as_inner().dist() * self.as_inner().nx() * self.as_inner().py()
                + -T::TWO * operand.as_inner().dist() * self.as_inner().ny() * self.as_inner().px()
                + -T::TWO * operand.as_inner().nx() * self.as_inner().px() * self.as_inner().pz()
                + T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dist()
                    * self.as_inner().nz()
                + T::TWO * operand.as_inner().dist() * self.as_inner().pw() * self.as_inner().pz()
                + T::TWO * operand.as_inner().nx() * self.as_inner().dist() * self.as_inner().py()
                + T::TWO * operand.as_inner().ny() * self.as_inner().dist() * self.as_inner().px()
                + T::TWO * operand.as_inner().ny() * self.as_inner().py() * self.as_inner().pz()
                + operand.as_inner().nz() * self.as_inner().px() * self.as_inner().px()
                + operand.as_inner().nz() * self.as_inner().py() * self.as_inner().py(),
            -(operand.as_inner().ny() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.as_inner().ny() * self.as_inner().py() * self.as_inner().py())
                + -T::TWO * operand.as_inner().dist() * self.as_inner().nx() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().dist() * self.as_inner().pw() * self.as_inner().py()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().dist() * self.as_inner().px()
                + T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dist()
                    * self.as_inner().ny()
                + T::TWO * operand.as_inner().dist() * self.as_inner().nz() * self.as_inner().px()
                + T::TWO * operand.as_inner().nx() * self.as_inner().dist() * self.as_inner().pz()
                + T::TWO * operand.as_inner().nx() * self.as_inner().px() * self.as_inner().py()
                + T::TWO * operand.as_inner().nz() * self.as_inner().py() * self.as_inner().pz()
                + operand.as_inner().ny() * self.as_inner().px() * self.as_inner().px()
                + operand.as_inner().ny() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.as_inner().nx() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.as_inner().nx() * self.as_inner().px() * self.as_inner().px())
                + -T::TWO * operand.as_inner().ny() * self.as_inner().dist() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().dist() * self.as_inner().py()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().px() * self.as_inner().pz()
                + T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dist()
                    * self.as_inner().nx()
                + T::TWO * operand.as_inner().dist() * self.as_inner().ny() * self.as_inner().pz()
                + T::TWO * operand.as_inner().dist() * self.as_inner().nz() * self.as_inner().py()
                + T::TWO * operand.as_inner().dist() * self.as_inner().pw() * self.as_inner().px()
                + T::TWO * operand.as_inner().ny() * self.as_inner().px() * self.as_inner().py()
                + operand.as_inner().nx() * self.as_inner().py() * self.as_inner().py()
                + operand.as_inner().nx() * self.as_inner().pz() * self.as_inner().pz(),
        )
    }
}
#[doc = "Sandwich product: [`Flector`] x [`Line`] x rev([`Flector`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Flector<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            -(self.dist() * operand.moment_x() * self.py())
                - self.dist() * operand.moment_y() * self.px()
                + self.dist() * operand.moment_z() * self.dist()
                + self.px() * operand.moment_x() * self.pz()
                - self.px() * operand.moment_y() * self.dist()
                - self.px() * operand.moment_z() * self.px()
                - self.py() * operand.moment_x() * self.dist()
                - self.py() * operand.moment_y() * self.pz()
                - self.py() * operand.moment_z() * self.py()
                + self.pz() * operand.moment_x() * self.px()
                - self.pz() * operand.moment_y() * self.py()
                + self.pz() * operand.moment_z() * self.pz(),
            -(self.dist() * operand.moment_x() * self.pz())
                + self.dist() * operand.moment_y() * self.dist()
                + self.dist() * operand.moment_z() * self.px()
                - self.px() * operand.moment_x() * self.py()
                - self.px() * operand.moment_y() * self.px()
                + self.px() * operand.moment_z() * self.dist()
                - self.py() * operand.moment_x() * self.px()
                + self.py() * operand.moment_y() * self.py()
                - self.py() * operand.moment_z() * self.pz()
                - self.pz() * operand.moment_x() * self.dist()
                - self.pz() * operand.moment_y() * self.pz()
                - self.pz() * operand.moment_z() * self.py(),
            -(self.dist() * operand.dir_x() * self.dist())
                + self.dist() * operand.dir_y() * self.pz()
                - self.dist() * operand.dir_z() * self.py()
                - self.dist() * operand.moment_x() * self.pw()
                + self.dist() * operand.moment_y() * self.nz()
                - self.dist() * operand.moment_z() * self.ny()
                + self.nx() * operand.moment_x() * self.px()
                - self.nx() * operand.moment_y() * self.py()
                + self.nx() * operand.moment_z() * self.pz()
                + self.ny() * operand.moment_x() * self.py()
                + self.ny() * operand.moment_y() * self.px()
                - self.ny() * operand.moment_z() * self.dist()
                - self.nz() * operand.moment_x() * self.pz()
                + self.nz() * operand.moment_y() * self.dist()
                + self.nz() * operand.moment_z() * self.px()
                - self.pw() * operand.moment_x() * self.dist()
                - self.pw() * operand.moment_y() * self.pz()
                - self.pw() * operand.moment_z() * self.py()
                - self.px() * operand.dir_x() * self.px()
                - self.px() * operand.dir_y() * self.py()
                - self.px() * operand.dir_z() * self.pz()
                + self.px() * operand.moment_x() * self.nx()
                + self.px() * operand.moment_y() * self.ny()
                + self.px() * operand.moment_z() * self.nz()
                + self.py() * operand.dir_x() * self.py()
                - self.py() * operand.dir_y() * self.px()
                - self.py() * operand.dir_z() * self.dist()
                + self.py() * operand.moment_x() * self.ny()
                - self.py() * operand.moment_y() * self.nx()
                - self.py() * operand.moment_z() * self.pw()
                + self.pz() * operand.dir_x() * self.pz()
                + self.pz() * operand.dir_y() * self.dist()
                - self.pz() * operand.dir_z() * self.px()
                - self.pz() * operand.moment_x() * self.nz()
                - self.pz() * operand.moment_y() * self.pw()
                + self.pz() * operand.moment_z() * self.nx(),
            self.dist() * operand.moment_x() * self.dist()
                + self.dist() * operand.moment_y() * self.pz()
                + self.dist() * operand.moment_z() * self.py()
                + self.px() * operand.moment_x() * self.px()
                - self.px() * operand.moment_y() * self.py()
                + self.px() * operand.moment_z() * self.pz()
                - self.py() * operand.moment_x() * self.py()
                - self.py() * operand.moment_y() * self.px()
                + self.py() * operand.moment_z() * self.dist()
                - self.pz() * operand.moment_x() * self.pz()
                + self.pz() * operand.moment_y() * self.dist()
                + self.pz() * operand.moment_z() * self.px(),
            -(self.dist() * operand.dir_x() * self.pz())
                - self.dist() * operand.dir_y() * self.dist()
                + self.dist() * operand.dir_z() * self.px()
                + self.dist() * operand.moment_x() * self.nz()
                + self.dist() * operand.moment_y() * self.pw()
                - self.dist() * operand.moment_z() * self.nx()
                + self.nx() * operand.moment_x() * self.py()
                + self.nx() * operand.moment_y() * self.px()
                - self.nx() * operand.moment_z() * self.dist()
                - self.ny() * operand.moment_x() * self.px()
                + self.ny() * operand.moment_y() * self.py()
                - self.ny() * operand.moment_z() * self.pz()
                + self.nz() * operand.moment_x() * self.dist()
                + self.nz() * operand.moment_y() * self.pz()
                + self.nz() * operand.moment_z() * self.py()
                - self.pw() * operand.moment_x() * self.pz()
                + self.pw() * operand.moment_y() * self.dist()
                + self.pw() * operand.moment_z() * self.px()
                - self.px() * operand.dir_x() * self.py()
                + self.px() * operand.dir_y() * self.px()
                + self.px() * operand.dir_z() * self.dist()
                - self.px() * operand.moment_x() * self.ny()
                + self.px() * operand.moment_y() * self.nx()
                + self.px() * operand.moment_z() * self.pw()
                - self.py() * operand.dir_x() * self.px()
                - self.py() * operand.dir_y() * self.py()
                - self.py() * operand.dir_z() * self.pz()
                + self.py() * operand.moment_x() * self.nx()
                + self.py() * operand.moment_y() * self.ny()
                + self.py() * operand.moment_z() * self.nz()
                - self.pz() * operand.dir_x() * self.dist()
                + self.pz() * operand.dir_y() * self.pz()
                - self.pz() * operand.dir_z() * self.py()
                - self.pz() * operand.moment_x() * self.pw()
                + self.pz() * operand.moment_y() * self.nz()
                - self.pz() * operand.moment_z() * self.ny(),
            self.dist() * operand.dir_x() * self.py()
                - self.dist() * operand.dir_y() * self.px()
                - self.dist() * operand.dir_z() * self.dist()
                + self.dist() * operand.moment_x() * self.ny()
                - self.dist() * operand.moment_y() * self.nx()
                - self.dist() * operand.moment_z() * self.pw()
                + self.nx() * operand.moment_x() * self.pz()
                - self.nx() * operand.moment_y() * self.dist()
                - self.nx() * operand.moment_z() * self.px()
                + self.ny() * operand.moment_x() * self.dist()
                + self.ny() * operand.moment_y() * self.pz()
                + self.ny() * operand.moment_z() * self.py()
                + self.nz() * operand.moment_x() * self.px()
                - self.nz() * operand.moment_y() * self.py()
                + self.nz() * operand.moment_z() * self.pz()
                + self.pw() * operand.moment_x() * self.py()
                + self.pw() * operand.moment_y() * self.px()
                - self.pw() * operand.moment_z() * self.dist()
                - self.px() * operand.dir_x() * self.pz()
                - self.px() * operand.dir_y() * self.dist()
                + self.px() * operand.dir_z() * self.px()
                + self.px() * operand.moment_x() * self.nz()
                + self.px() * operand.moment_y() * self.pw()
                - self.px() * operand.moment_z() * self.nx()
                + self.py() * operand.dir_x() * self.dist()
                - self.py() * operand.dir_y() * self.pz()
                + self.py() * operand.dir_z() * self.py()
                + self.py() * operand.moment_x() * self.pw()
                - self.py() * operand.moment_y() * self.nz()
                + self.py() * operand.moment_z() * self.ny()
                - self.pz() * operand.dir_x() * self.px()
                - self.pz() * operand.dir_y() * self.py()
                - self.pz() * operand.dir_z() * self.pz()
                + self.pz() * operand.moment_x() * self.nx()
                + self.pz() * operand.moment_y() * self.ny()
                + self.pz() * operand.moment_z() * self.nz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Unitized<Flector<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            -(operand.moment_z() * self.as_inner().px() * self.as_inner().px())
                + -(operand.moment_z() * self.as_inner().py() * self.as_inner().py())
                + -T::TWO * operand.moment_x() * self.as_inner().dist() * self.as_inner().py()
                + -T::TWO * operand.moment_y() * self.as_inner().dist() * self.as_inner().px()
                + -T::TWO * operand.moment_y() * self.as_inner().py() * self.as_inner().pz()
                + T::TWO * operand.moment_x() * self.as_inner().px() * self.as_inner().pz()
                + operand.moment_z() * self.as_inner().dist() * self.as_inner().dist()
                + operand.moment_z() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.moment_y() * self.as_inner().px() * self.as_inner().px())
                + -(operand.moment_y() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.moment_x() * self.as_inner().dist() * self.as_inner().pz()
                + -T::TWO * operand.moment_x() * self.as_inner().px() * self.as_inner().py()
                + -T::TWO * operand.moment_z() * self.as_inner().py() * self.as_inner().pz()
                + T::TWO * operand.moment_z() * self.as_inner().dist() * self.as_inner().px()
                + operand.moment_y() * self.as_inner().dist() * self.as_inner().dist()
                + operand.moment_y() * self.as_inner().py() * self.as_inner().py(),
            -(operand.dir_x() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.dir_x() * self.as_inner().px() * self.as_inner().px())
                + -T::TWO * operand.dir_y() * self.as_inner().px() * self.as_inner().py()
                + -T::TWO * operand.dir_z() * self.as_inner().dist() * self.as_inner().py()
                + -T::TWO * operand.dir_z() * self.as_inner().px() * self.as_inner().pz()
                + -T::TWO * operand.moment_y() * self.as_inner().nx() * self.as_inner().py()
                + -T::TWO * operand.moment_y() * self.as_inner().pw() * self.as_inner().pz()
                + -T::TWO * operand.moment_z() * self.as_inner().dist() * self.as_inner().ny()
                + -T::TWO * operand.moment_z() * self.as_inner().pw() * self.as_inner().py()
                + T::TWO * operand.dir_y() * self.as_inner().dist() * self.as_inner().pz()
                + T::TWO * operand.moment_y() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.moment_y() * self.as_inner().ny() * self.as_inner().px()
                + T::TWO * operand.moment_z() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.moment_z() * self.as_inner().nz() * self.as_inner().px()
                + T::from_i8(-4i8)
                    * operand.moment_x()
                    * self.as_inner().nz()
                    * self.as_inner().pz()
                + T::from_i8(4i8)
                    * operand.moment_x()
                    * self.as_inner().ny()
                    * self.as_inner().py()
                + operand.dir_x() * self.as_inner().py() * self.as_inner().py()
                + operand.dir_x() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.moment_x() * self.as_inner().py() * self.as_inner().py())
                + -(operand.moment_x() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.moment_y() * self.as_inner().px() * self.as_inner().py()
                + T::TWO * operand.moment_y() * self.as_inner().dist() * self.as_inner().pz()
                + T::TWO * operand.moment_z() * self.as_inner().dist() * self.as_inner().py()
                + T::TWO * operand.moment_z() * self.as_inner().px() * self.as_inner().pz()
                + operand.moment_x() * self.as_inner().dist() * self.as_inner().dist()
                + operand.moment_x() * self.as_inner().px() * self.as_inner().px(),
            -(operand.dir_y() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.dir_y() * self.as_inner().py() * self.as_inner().py())
                + -T::TWO * operand.dir_x() * self.as_inner().dist() * self.as_inner().pz()
                + -T::TWO * operand.dir_x() * self.as_inner().px() * self.as_inner().py()
                + -T::TWO * operand.dir_z() * self.as_inner().py() * self.as_inner().pz()
                + -T::TWO * operand.moment_x() * self.as_inner().ny() * self.as_inner().px()
                + -T::TWO * operand.moment_x() * self.as_inner().pw() * self.as_inner().pz()
                + -T::TWO * operand.moment_z() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.moment_z() * self.as_inner().ny() * self.as_inner().pz()
                + T::TWO * operand.dir_z() * self.as_inner().dist() * self.as_inner().px()
                + T::TWO * operand.moment_x() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.moment_x() * self.as_inner().nx() * self.as_inner().py()
                + T::TWO * operand.moment_z() * self.as_inner().nz() * self.as_inner().py()
                + T::TWO * operand.moment_z() * self.as_inner().pw() * self.as_inner().px()
                + T::from_i8(4i8)
                    * operand.moment_y()
                    * self.as_inner().dist()
                    * self.as_inner().pw()
                + T::from_i8(4i8)
                    * operand.moment_y()
                    * self.as_inner().ny()
                    * self.as_inner().py()
                + operand.dir_y() * self.as_inner().px() * self.as_inner().px()
                + operand.dir_y() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.dir_z() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.dir_z() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.dir_x() * self.as_inner().px() * self.as_inner().pz()
                + -T::TWO * operand.dir_y() * self.as_inner().dist() * self.as_inner().px()
                + -T::TWO * operand.dir_y() * self.as_inner().py() * self.as_inner().pz()
                + -T::TWO * operand.moment_y() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.moment_y() * self.as_inner().nz() * self.as_inner().py()
                + T::TWO * operand.dir_x() * self.as_inner().dist() * self.as_inner().py()
                + T::TWO * operand.moment_x() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.moment_x() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.moment_x() * self.as_inner().nz() * self.as_inner().px()
                + T::TWO * operand.moment_x() * self.as_inner().pw() * self.as_inner().py()
                + T::TWO * operand.moment_y() * self.as_inner().ny() * self.as_inner().pz()
                + T::TWO * operand.moment_y() * self.as_inner().pw() * self.as_inner().px()
                + T::from_i8(-4i8)
                    * operand.moment_z()
                    * self.as_inner().dist()
                    * self.as_inner().pw()
                + T::from_i8(4i8)
                    * operand.moment_z()
                    * self.as_inner().nz()
                    * self.as_inner().pz()
                + operand.dir_z() * self.as_inner().px() * self.as_inner().px()
                + operand.dir_z() * self.as_inner().py() * self.as_inner().py(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Line<T>>> for Flector<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(operand.as_inner().moment_z() * self.px() * self.px())
                + -(operand.as_inner().moment_z() * self.py() * self.py())
                + -T::TWO * operand.as_inner().moment_x() * self.dist() * self.py()
                + -T::TWO * operand.as_inner().moment_y() * self.dist() * self.px()
                + -T::TWO * operand.as_inner().moment_y() * self.py() * self.pz()
                + T::TWO * operand.as_inner().moment_x() * self.px() * self.pz()
                + operand.as_inner().moment_z() * self.dist() * self.dist()
                + operand.as_inner().moment_z() * self.pz() * self.pz(),
            -(operand.as_inner().moment_y() * self.px() * self.px())
                + -(operand.as_inner().moment_y() * self.pz() * self.pz())
                + -T::TWO * operand.as_inner().moment_x() * self.dist() * self.pz()
                + -T::TWO * operand.as_inner().moment_x() * self.px() * self.py()
                + -T::TWO * operand.as_inner().moment_z() * self.py() * self.pz()
                + T::TWO * operand.as_inner().moment_z() * self.dist() * self.px()
                + operand.as_inner().moment_y() * self.dist() * self.dist()
                + operand.as_inner().moment_y() * self.py() * self.py(),
            -(operand.as_inner().dir_x() * self.dist() * self.dist())
                + -(operand.as_inner().dir_x() * self.px() * self.px())
                + -T::TWO * operand.as_inner().dir_y() * self.px() * self.py()
                + -T::TWO * operand.as_inner().dir_z() * self.dist() * self.py()
                + -T::TWO * operand.as_inner().dir_z() * self.px() * self.pz()
                + -T::TWO * operand.as_inner().moment_y() * self.nx() * self.py()
                + -T::TWO * operand.as_inner().moment_y() * self.pw() * self.pz()
                + -T::TWO * operand.as_inner().moment_z() * self.dist() * self.ny()
                + -T::TWO * operand.as_inner().moment_z() * self.pw() * self.py()
                + T::TWO * operand.as_inner().dir_y() * self.dist() * self.pz()
                + T::TWO * operand.as_inner().moment_y() * self.dist() * self.nz()
                + T::TWO * operand.as_inner().moment_y() * self.ny() * self.px()
                + T::TWO * operand.as_inner().moment_z() * self.nx() * self.pz()
                + T::TWO * operand.as_inner().moment_z() * self.nz() * self.px()
                + T::from_i8(-4i8) * operand.as_inner().moment_x() * self.nz() * self.pz()
                + T::from_i8(4i8) * operand.as_inner().moment_x() * self.ny() * self.py()
                + operand.as_inner().dir_x() * self.py() * self.py()
                + operand.as_inner().dir_x() * self.pz() * self.pz(),
            -(operand.as_inner().moment_x() * self.py() * self.py())
                + -(operand.as_inner().moment_x() * self.pz() * self.pz())
                + -T::TWO * operand.as_inner().moment_y() * self.px() * self.py()
                + T::TWO * operand.as_inner().moment_y() * self.dist() * self.pz()
                + T::TWO * operand.as_inner().moment_z() * self.dist() * self.py()
                + T::TWO * operand.as_inner().moment_z() * self.px() * self.pz()
                + operand.as_inner().moment_x() * self.dist() * self.dist()
                + operand.as_inner().moment_x() * self.px() * self.px(),
            -(operand.as_inner().dir_y() * self.dist() * self.dist())
                + -(operand.as_inner().dir_y() * self.py() * self.py())
                + -T::TWO * operand.as_inner().dir_x() * self.dist() * self.pz()
                + -T::TWO * operand.as_inner().dir_x() * self.px() * self.py()
                + -T::TWO * operand.as_inner().dir_z() * self.py() * self.pz()
                + -T::TWO * operand.as_inner().moment_x() * self.ny() * self.px()
                + -T::TWO * operand.as_inner().moment_x() * self.pw() * self.pz()
                + -T::TWO * operand.as_inner().moment_z() * self.dist() * self.nx()
                + -T::TWO * operand.as_inner().moment_z() * self.ny() * self.pz()
                + T::TWO * operand.as_inner().dir_z() * self.dist() * self.px()
                + T::TWO * operand.as_inner().moment_x() * self.dist() * self.nz()
                + T::TWO * operand.as_inner().moment_x() * self.nx() * self.py()
                + T::TWO * operand.as_inner().moment_z() * self.nz() * self.py()
                + T::TWO * operand.as_inner().moment_z() * self.pw() * self.px()
                + T::from_i8(4i8) * operand.as_inner().moment_y() * self.dist() * self.pw()
                + T::from_i8(4i8) * operand.as_inner().moment_y() * self.ny() * self.py()
                + operand.as_inner().dir_y() * self.px() * self.px()
                + operand.as_inner().dir_y() * self.pz() * self.pz(),
            -(operand.as_inner().dir_z() * self.dist() * self.dist())
                + -(operand.as_inner().dir_z() * self.pz() * self.pz())
                + -T::TWO * operand.as_inner().dir_x() * self.px() * self.pz()
                + -T::TWO * operand.as_inner().dir_y() * self.dist() * self.px()
                + -T::TWO * operand.as_inner().dir_y() * self.py() * self.pz()
                + -T::TWO * operand.as_inner().moment_y() * self.dist() * self.nx()
                + -T::TWO * operand.as_inner().moment_y() * self.nz() * self.py()
                + T::TWO * operand.as_inner().dir_x() * self.dist() * self.py()
                + T::TWO * operand.as_inner().moment_x() * self.dist() * self.ny()
                + T::TWO * operand.as_inner().moment_x() * self.nx() * self.pz()
                + T::TWO * operand.as_inner().moment_x() * self.nz() * self.px()
                + T::TWO * operand.as_inner().moment_x() * self.pw() * self.py()
                + T::TWO * operand.as_inner().moment_y() * self.ny() * self.pz()
                + T::TWO * operand.as_inner().moment_y() * self.pw() * self.px()
                + T::from_i8(-4i8) * operand.as_inner().moment_z() * self.dist() * self.pw()
                + T::from_i8(4i8) * operand.as_inner().moment_z() * self.nz() * self.pz()
                + operand.as_inner().dir_z() * self.px() * self.px()
                + operand.as_inner().dir_z() * self.py() * self.py(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Line<T>>> for Unitized<Flector<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(operand.as_inner().moment_z() * self.as_inner().px() * self.as_inner().px())
                + -(operand.as_inner().moment_z() * self.as_inner().py() * self.as_inner().py())
                + -T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().dist()
                    * self.as_inner().py()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().dist()
                    * self.as_inner().px()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().py()
                    * self.as_inner().pz()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().px()
                    * self.as_inner().pz()
                + operand.as_inner().moment_z() * self.as_inner().dist() * self.as_inner().dist()
                + operand.as_inner().moment_z() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.as_inner().moment_y() * self.as_inner().px() * self.as_inner().px())
                + -(operand.as_inner().moment_y() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().dist()
                    * self.as_inner().pz()
                + -T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().px()
                    * self.as_inner().py()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().py()
                    * self.as_inner().pz()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().dist()
                    * self.as_inner().px()
                + operand.as_inner().moment_y() * self.as_inner().dist() * self.as_inner().dist()
                + operand.as_inner().moment_y() * self.as_inner().py() * self.as_inner().py(),
            -(operand.as_inner().dir_x() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.as_inner().dir_x() * self.as_inner().px() * self.as_inner().px())
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().px()
                    * self.as_inner().py()
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().dist()
                    * self.as_inner().py()
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().px()
                    * self.as_inner().pz()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().nx()
                    * self.as_inner().py()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().pw()
                    * self.as_inner().pz()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().dist()
                    * self.as_inner().ny()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().pw()
                    * self.as_inner().py()
                + T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().dist()
                    * self.as_inner().pz()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().dist()
                    * self.as_inner().nz()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().ny()
                    * self.as_inner().px()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().nx()
                    * self.as_inner().pz()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().nz()
                    * self.as_inner().px()
                + T::from_i8(-4i8)
                    * operand.as_inner().moment_x()
                    * self.as_inner().nz()
                    * self.as_inner().pz()
                + T::from_i8(4i8)
                    * operand.as_inner().moment_x()
                    * self.as_inner().ny()
                    * self.as_inner().py()
                + operand.as_inner().dir_x() * self.as_inner().py() * self.as_inner().py()
                + operand.as_inner().dir_x() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.as_inner().moment_x() * self.as_inner().py() * self.as_inner().py())
                + -(operand.as_inner().moment_x() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().px()
                    * self.as_inner().py()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().dist()
                    * self.as_inner().pz()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().dist()
                    * self.as_inner().py()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().px()
                    * self.as_inner().pz()
                + operand.as_inner().moment_x() * self.as_inner().dist() * self.as_inner().dist()
                + operand.as_inner().moment_x() * self.as_inner().px() * self.as_inner().px(),
            -(operand.as_inner().dir_y() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.as_inner().dir_y() * self.as_inner().py() * self.as_inner().py())
                + -T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().dist()
                    * self.as_inner().pz()
                + -T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().px()
                    * self.as_inner().py()
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().py()
                    * self.as_inner().pz()
                + -T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().ny()
                    * self.as_inner().px()
                + -T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().pw()
                    * self.as_inner().pz()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().dist()
                    * self.as_inner().nx()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().ny()
                    * self.as_inner().pz()
                + T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().dist()
                    * self.as_inner().px()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().dist()
                    * self.as_inner().nz()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().nx()
                    * self.as_inner().py()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().nz()
                    * self.as_inner().py()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().pw()
                    * self.as_inner().px()
                + T::from_i8(4i8)
                    * operand.as_inner().moment_y()
                    * self.as_inner().dist()
                    * self.as_inner().pw()
                + T::from_i8(4i8)
                    * operand.as_inner().moment_y()
                    * self.as_inner().ny()
                    * self.as_inner().py()
                + operand.as_inner().dir_y() * self.as_inner().px() * self.as_inner().px()
                + operand.as_inner().dir_y() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.as_inner().dir_z() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.as_inner().dir_z() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().px()
                    * self.as_inner().pz()
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().dist()
                    * self.as_inner().px()
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().py()
                    * self.as_inner().pz()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().dist()
                    * self.as_inner().nx()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().nz()
                    * self.as_inner().py()
                + T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().dist()
                    * self.as_inner().py()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().dist()
                    * self.as_inner().ny()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().nx()
                    * self.as_inner().pz()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().nz()
                    * self.as_inner().px()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().pw()
                    * self.as_inner().py()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().ny()
                    * self.as_inner().pz()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().pw()
                    * self.as_inner().px()
                + T::from_i8(-4i8)
                    * operand.as_inner().moment_z()
                    * self.as_inner().dist()
                    * self.as_inner().pw()
                + T::from_i8(4i8)
                    * operand.as_inner().moment_z()
                    * self.as_inner().nz()
                    * self.as_inner().pz()
                + operand.as_inner().dir_z() * self.as_inner().px() * self.as_inner().px()
                + operand.as_inner().dir_z() * self.as_inner().py() * self.as_inner().py(),
        )
    }
}
#[doc = "Sandwich product: [`Flector`] x [`Motor`] x rev([`Flector`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Motor<T>> for Flector<T> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            -(self.dist() * operand.rx() * self.px())
                + self.dist() * operand.s() * self.dist()
                + self.dist() * operand.ty() * self.py()
                - self.dist() * operand.tz() * self.pz()
                + self.px() * operand.rx() * self.dist()
                + self.px() * operand.s() * self.px()
                + self.px() * operand.ty() * self.pz()
                + self.px() * operand.tz() * self.py()
                + self.py() * operand.rx() * self.pz()
                + self.py() * operand.s() * self.py()
                - self.py() * operand.ty() * self.dist()
                - self.py() * operand.tz() * self.px()
                - self.pz() * operand.rx() * self.py()
                + self.pz() * operand.s() * self.pz()
                - self.pz() * operand.ty() * self.px()
                + self.pz() * operand.tz() * self.dist(),
            -(self.dist() * operand.rx() * self.py()) + self.dist() * operand.s() * self.pz()
                - self.dist() * operand.ty() * self.px()
                + self.dist() * operand.tz() * self.dist()
                + self.px() * operand.rx() * self.pz()
                + self.px() * operand.s() * self.py()
                - self.px() * operand.ty() * self.dist()
                - self.px() * operand.tz() * self.px()
                - self.py() * operand.rx() * self.dist()
                - self.py() * operand.s() * self.px()
                - self.py() * operand.ty() * self.pz()
                - self.py() * operand.tz() * self.py()
                + self.pz() * operand.rx() * self.px()
                - self.pz() * operand.s() * self.dist()
                - self.pz() * operand.ty() * self.py()
                + self.pz() * operand.tz() * self.pz(),
            -(self.dist() * operand.rx() * self.pz()) - self.dist() * operand.s() * self.py()
                + self.dist() * operand.ty() * self.dist()
                + self.dist() * operand.tz() * self.px()
                - self.px() * operand.rx() * self.py()
                + self.px() * operand.s() * self.pz()
                - self.px() * operand.ty() * self.px()
                + self.px() * operand.tz() * self.dist()
                - self.py() * operand.rx() * self.px()
                + self.py() * operand.s() * self.dist()
                + self.py() * operand.ty() * self.py()
                - self.py() * operand.tz() * self.pz()
                - self.pz() * operand.rx() * self.dist()
                - self.pz() * operand.s() * self.px()
                - self.pz() * operand.ty() * self.pz()
                - self.pz() * operand.tz() * self.py(),
            self.dist() * operand.ps() * self.px() - self.dist() * operand.rx() * self.pw()
                + self.dist() * operand.ry() * self.pz()
                - self.dist() * operand.rz() * self.py()
                + self.dist() * operand.s() * self.nx()
                - self.dist() * operand.tx() * self.dist()
                + self.dist() * operand.ty() * self.nz()
                - self.dist() * operand.tz() * self.ny()
                + self.nx() * operand.rx() * self.px()
                - self.nx() * operand.s() * self.dist()
                - self.nx() * operand.ty() * self.py()
                + self.nx() * operand.tz() * self.pz()
                + self.ny() * operand.rx() * self.py()
                - self.ny() * operand.s() * self.pz()
                + self.ny() * operand.ty() * self.px()
                - self.ny() * operand.tz() * self.dist()
                - self.nz() * operand.rx() * self.pz()
                - self.nz() * operand.s() * self.py()
                + self.nz() * operand.ty() * self.dist()
                + self.nz() * operand.tz() * self.px()
                - self.pw() * operand.rx() * self.dist()
                - self.pw() * operand.s() * self.px()
                - self.pw() * operand.ty() * self.pz()
                - self.pw() * operand.tz() * self.py()
                - self.px() * operand.ps() * self.dist()
                + self.px() * operand.rx() * self.nx()
                - self.px() * operand.ry() * self.py()
                - self.px() * operand.rz() * self.pz()
                + self.px() * operand.s() * self.pw()
                - self.px() * operand.tx() * self.px()
                + self.px() * operand.ty() * self.ny()
                + self.px() * operand.tz() * self.nz()
                + self.py() * operand.ps() * self.pz()
                + self.py() * operand.rx() * self.ny()
                - self.py() * operand.ry() * self.px()
                - self.py() * operand.rz() * self.dist()
                + self.py() * operand.s() * self.nz()
                + self.py() * operand.tx() * self.py()
                - self.py() * operand.ty() * self.nx()
                - self.py() * operand.tz() * self.pw()
                - self.pz() * operand.ps() * self.py()
                - self.pz() * operand.rx() * self.nz()
                + self.pz() * operand.ry() * self.dist()
                - self.pz() * operand.rz() * self.px()
                + self.pz() * operand.s() * self.ny()
                + self.pz() * operand.tx() * self.pz()
                - self.pz() * operand.ty() * self.pw()
                + self.pz() * operand.tz() * self.nx(),
            self.dist() * operand.rx() * self.dist()
                + self.dist() * operand.s() * self.px()
                + self.dist() * operand.ty() * self.pz()
                + self.dist() * operand.tz() * self.py()
                + self.px() * operand.rx() * self.px()
                - self.px() * operand.s() * self.dist()
                - self.px() * operand.ty() * self.py()
                + self.px() * operand.tz() * self.pz()
                - self.py() * operand.rx() * self.py()
                + self.py() * operand.s() * self.pz()
                - self.py() * operand.ty() * self.px()
                + self.py() * operand.tz() * self.dist()
                - self.pz() * operand.rx() * self.pz()
                - self.pz() * operand.s() * self.py()
                + self.pz() * operand.ty() * self.dist()
                + self.pz() * operand.tz() * self.px(),
            self.dist() * operand.ps() * self.py() + self.dist() * operand.rx() * self.nz()
                - self.dist() * operand.ry() * self.dist()
                + self.dist() * operand.rz() * self.px()
                - self.dist() * operand.s() * self.ny()
                - self.dist() * operand.tx() * self.pz()
                + self.dist() * operand.ty() * self.pw()
                - self.dist() * operand.tz() * self.nx()
                + self.nx() * operand.rx() * self.py()
                - self.nx() * operand.s() * self.pz()
                + self.nx() * operand.ty() * self.px()
                - self.nx() * operand.tz() * self.dist()
                - self.ny() * operand.rx() * self.px()
                + self.ny() * operand.s() * self.dist()
                + self.ny() * operand.ty() * self.py()
                - self.ny() * operand.tz() * self.pz()
                + self.nz() * operand.rx() * self.dist()
                + self.nz() * operand.s() * self.px()
                + self.nz() * operand.ty() * self.pz()
                + self.nz() * operand.tz() * self.py()
                - self.pw() * operand.rx() * self.pz()
                - self.pw() * operand.s() * self.py()
                + self.pw() * operand.ty() * self.dist()
                + self.pw() * operand.tz() * self.px()
                - self.px() * operand.ps() * self.pz()
                - self.px() * operand.rx() * self.ny()
                + self.px() * operand.ry() * self.px()
                + self.px() * operand.rz() * self.dist()
                - self.px() * operand.s() * self.nz()
                - self.px() * operand.tx() * self.py()
                + self.px() * operand.ty() * self.nx()
                + self.px() * operand.tz() * self.pw()
                - self.py() * operand.ps() * self.dist()
                + self.py() * operand.rx() * self.nx()
                - self.py() * operand.ry() * self.py()
                - self.py() * operand.rz() * self.pz()
                + self.py() * operand.s() * self.pw()
                - self.py() * operand.tx() * self.px()
                + self.py() * operand.ty() * self.ny()
                + self.py() * operand.tz() * self.nz()
                + self.pz() * operand.ps() * self.px()
                - self.pz() * operand.rx() * self.pw()
                + self.pz() * operand.ry() * self.pz()
                - self.pz() * operand.rz() * self.py()
                + self.pz() * operand.s() * self.nx()
                - self.pz() * operand.tx() * self.dist()
                + self.pz() * operand.ty() * self.nz()
                - self.pz() * operand.tz() * self.ny(),
            self.dist() * operand.ps() * self.pz() + self.dist() * operand.rx() * self.ny()
                - self.dist() * operand.ry() * self.px()
                - self.dist() * operand.rz() * self.dist()
                + self.dist() * operand.s() * self.nz()
                + self.dist() * operand.tx() * self.py()
                - self.dist() * operand.ty() * self.nx()
                - self.dist() * operand.tz() * self.pw()
                + self.nx() * operand.rx() * self.pz()
                + self.nx() * operand.s() * self.py()
                - self.nx() * operand.ty() * self.dist()
                - self.nx() * operand.tz() * self.px()
                + self.ny() * operand.rx() * self.dist()
                + self.ny() * operand.s() * self.px()
                + self.ny() * operand.ty() * self.pz()
                + self.ny() * operand.tz() * self.py()
                + self.nz() * operand.rx() * self.px()
                - self.nz() * operand.s() * self.dist()
                - self.nz() * operand.ty() * self.py()
                + self.nz() * operand.tz() * self.pz()
                + self.pw() * operand.rx() * self.py()
                - self.pw() * operand.s() * self.pz()
                + self.pw() * operand.ty() * self.px()
                - self.pw() * operand.tz() * self.dist()
                + self.px() * operand.ps() * self.py()
                + self.px() * operand.rx() * self.nz()
                - self.px() * operand.ry() * self.dist()
                + self.px() * operand.rz() * self.px()
                - self.px() * operand.s() * self.ny()
                - self.px() * operand.tx() * self.pz()
                + self.px() * operand.ty() * self.pw()
                - self.px() * operand.tz() * self.nx()
                - self.py() * operand.ps() * self.px()
                + self.py() * operand.rx() * self.pw()
                - self.py() * operand.ry() * self.pz()
                + self.py() * operand.rz() * self.py()
                - self.py() * operand.s() * self.nx()
                + self.py() * operand.tx() * self.dist()
                - self.py() * operand.ty() * self.nz()
                + self.py() * operand.tz() * self.ny()
                - self.pz() * operand.ps() * self.dist()
                + self.pz() * operand.rx() * self.nx()
                - self.pz() * operand.ry() * self.py()
                - self.pz() * operand.rz() * self.pz()
                + self.pz() * operand.s() * self.pw()
                - self.pz() * operand.tx() * self.px()
                + self.pz() * operand.ty() * self.ny()
                + self.pz() * operand.tz() * self.nz(),
            -(self.dist() * operand.ps() * self.dist()) + self.dist() * operand.rx() * self.nx()
                - self.dist() * operand.ry() * self.py()
                - self.dist() * operand.rz() * self.pz()
                + self.dist() * operand.s() * self.pw()
                - self.dist() * operand.tx() * self.px()
                + self.dist() * operand.ty() * self.ny()
                + self.dist() * operand.tz() * self.nz()
                - self.nx() * operand.rx() * self.dist()
                - self.nx() * operand.s() * self.px()
                - self.nx() * operand.ty() * self.pz()
                - self.nx() * operand.tz() * self.py()
                + self.ny() * operand.rx() * self.pz()
                + self.ny() * operand.s() * self.py()
                - self.ny() * operand.ty() * self.dist()
                - self.ny() * operand.tz() * self.px()
                + self.nz() * operand.rx() * self.py()
                - self.nz() * operand.s() * self.pz()
                + self.nz() * operand.ty() * self.px()
                - self.nz() * operand.tz() * self.dist()
                - self.pw() * operand.rx() * self.px()
                + self.pw() * operand.s() * self.dist()
                + self.pw() * operand.ty() * self.py()
                - self.pw() * operand.tz() * self.pz()
                - self.px() * operand.ps() * self.px()
                + self.px() * operand.rx() * self.pw()
                - self.px() * operand.ry() * self.pz()
                + self.px() * operand.rz() * self.py()
                - self.px() * operand.s() * self.nx()
                + self.px() * operand.tx() * self.dist()
                - self.px() * operand.ty() * self.nz()
                + self.px() * operand.tz() * self.ny()
                - self.py() * operand.ps() * self.py()
                - self.py() * operand.rx() * self.nz()
                + self.py() * operand.ry() * self.dist()
                - self.py() * operand.rz() * self.px()
                + self.py() * operand.s() * self.ny()
                + self.py() * operand.tx() * self.pz()
                - self.py() * operand.ty() * self.pw()
                + self.py() * operand.tz() * self.nx()
                - self.pz() * operand.ps() * self.pz()
                - self.pz() * operand.rx() * self.ny()
                + self.pz() * operand.ry() * self.px()
                + self.pz() * operand.rz() * self.dist()
                - self.pz() * operand.s() * self.nz()
                - self.pz() * operand.tx() * self.py()
                + self.pz() * operand.ty() * self.nx()
                + self.pz() * operand.tz() * self.pw(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Motor<T>> for Unitized<Flector<T>> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            operand.s() * self.as_inner().dist() * self.as_inner().dist()
                + operand.s() * self.as_inner().px() * self.as_inner().px()
                + operand.s() * self.as_inner().py() * self.as_inner().py()
                + operand.s() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.tz() * self.as_inner().px() * self.as_inner().px())
                + -(operand.tz() * self.as_inner().py() * self.as_inner().py())
                + -T::TWO * operand.rx() * self.as_inner().dist() * self.as_inner().py()
                + -T::TWO * operand.ty() * self.as_inner().dist() * self.as_inner().px()
                + -T::TWO * operand.ty() * self.as_inner().py() * self.as_inner().pz()
                + T::TWO * operand.rx() * self.as_inner().px() * self.as_inner().pz()
                + operand.tz() * self.as_inner().dist() * self.as_inner().dist()
                + operand.tz() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.ty() * self.as_inner().px() * self.as_inner().px())
                + -(operand.ty() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.rx() * self.as_inner().dist() * self.as_inner().pz()
                + -T::TWO * operand.rx() * self.as_inner().px() * self.as_inner().py()
                + -T::TWO * operand.tz() * self.as_inner().py() * self.as_inner().pz()
                + T::TWO * operand.tz() * self.as_inner().dist() * self.as_inner().px()
                + operand.ty() * self.as_inner().dist() * self.as_inner().dist()
                + operand.ty() * self.as_inner().py() * self.as_inner().py(),
            -(operand.tx() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.tx() * self.as_inner().px() * self.as_inner().px())
                + -T::TWO * operand.ry() * self.as_inner().px() * self.as_inner().py()
                + -T::TWO * operand.rz() * self.as_inner().dist() * self.as_inner().py()
                + -T::TWO * operand.rz() * self.as_inner().px() * self.as_inner().pz()
                + -T::TWO * operand.ty() * self.as_inner().nx() * self.as_inner().py()
                + -T::TWO * operand.ty() * self.as_inner().pw() * self.as_inner().pz()
                + -T::TWO * operand.tz() * self.as_inner().dist() * self.as_inner().ny()
                + -T::TWO * operand.tz() * self.as_inner().pw() * self.as_inner().py()
                + T::TWO * operand.ry() * self.as_inner().dist() * self.as_inner().pz()
                + T::TWO * operand.ty() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.ty() * self.as_inner().ny() * self.as_inner().px()
                + T::TWO * operand.tz() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.tz() * self.as_inner().nz() * self.as_inner().px()
                + T::from_i8(-4i8) * operand.rx() * self.as_inner().nz() * self.as_inner().pz()
                + T::from_i8(4i8) * operand.rx() * self.as_inner().ny() * self.as_inner().py()
                + operand.tx() * self.as_inner().py() * self.as_inner().py()
                + operand.tx() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.rx() * self.as_inner().py() * self.as_inner().py())
                + -(operand.rx() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.ty() * self.as_inner().px() * self.as_inner().py()
                + T::TWO * operand.ty() * self.as_inner().dist() * self.as_inner().pz()
                + T::TWO * operand.tz() * self.as_inner().dist() * self.as_inner().py()
                + T::TWO * operand.tz() * self.as_inner().px() * self.as_inner().pz()
                + operand.rx() * self.as_inner().dist() * self.as_inner().dist()
                + operand.rx() * self.as_inner().px() * self.as_inner().px(),
            -(operand.ry() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.ry() * self.as_inner().py() * self.as_inner().py())
                + -T::TWO * operand.rx() * self.as_inner().ny() * self.as_inner().px()
                + -T::TWO * operand.rx() * self.as_inner().pw() * self.as_inner().pz()
                + -T::TWO * operand.rz() * self.as_inner().py() * self.as_inner().pz()
                + -T::TWO * operand.tx() * self.as_inner().dist() * self.as_inner().pz()
                + -T::TWO * operand.tx() * self.as_inner().px() * self.as_inner().py()
                + -T::TWO * operand.tz() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.tz() * self.as_inner().ny() * self.as_inner().pz()
                + T::TWO * operand.rx() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.rx() * self.as_inner().nx() * self.as_inner().py()
                + T::TWO * operand.rz() * self.as_inner().dist() * self.as_inner().px()
                + T::TWO * operand.tz() * self.as_inner().nz() * self.as_inner().py()
                + T::TWO * operand.tz() * self.as_inner().pw() * self.as_inner().px()
                + T::from_i8(4i8) * operand.ty() * self.as_inner().dist() * self.as_inner().pw()
                + T::from_i8(4i8) * operand.ty() * self.as_inner().ny() * self.as_inner().py()
                + operand.ry() * self.as_inner().px() * self.as_inner().px()
                + operand.ry() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.rz() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.rz() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.ry() * self.as_inner().dist() * self.as_inner().px()
                + -T::TWO * operand.ry() * self.as_inner().py() * self.as_inner().pz()
                + -T::TWO * operand.tx() * self.as_inner().px() * self.as_inner().pz()
                + -T::TWO * operand.ty() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.ty() * self.as_inner().nz() * self.as_inner().py()
                + T::TWO * operand.rx() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.rx() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.rx() * self.as_inner().nz() * self.as_inner().px()
                + T::TWO * operand.rx() * self.as_inner().pw() * self.as_inner().py()
                + T::TWO * operand.tx() * self.as_inner().dist() * self.as_inner().py()
                + T::TWO * operand.ty() * self.as_inner().ny() * self.as_inner().pz()
                + T::TWO * operand.ty() * self.as_inner().pw() * self.as_inner().px()
                + T::from_i8(-4i8) * operand.tz() * self.as_inner().dist() * self.as_inner().pw()
                + T::from_i8(4i8) * operand.tz() * self.as_inner().nz() * self.as_inner().pz()
                + operand.rz() * self.as_inner().px() * self.as_inner().px()
                + operand.rz() * self.as_inner().py() * self.as_inner().py(),
            -(operand.ps() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.ps() * self.as_inner().px() * self.as_inner().px())
                + -(operand.ps() * self.as_inner().py() * self.as_inner().py())
                + -(operand.ps() * self.as_inner().pz() * self.as_inner().pz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Motor<T>>> for Flector<T> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s() * self.dist() * self.dist()
                + operand.as_inner().s() * self.px() * self.px()
                + operand.as_inner().s() * self.py() * self.py()
                + operand.as_inner().s() * self.pz() * self.pz(),
            -(operand.as_inner().tz() * self.px() * self.px())
                + -(operand.as_inner().tz() * self.py() * self.py())
                + -T::TWO * operand.as_inner().rx() * self.dist() * self.py()
                + -T::TWO * operand.as_inner().ty() * self.dist() * self.px()
                + -T::TWO * operand.as_inner().ty() * self.py() * self.pz()
                + T::TWO * operand.as_inner().rx() * self.px() * self.pz()
                + operand.as_inner().tz() * self.dist() * self.dist()
                + operand.as_inner().tz() * self.pz() * self.pz(),
            -(operand.as_inner().ty() * self.px() * self.px())
                + -(operand.as_inner().ty() * self.pz() * self.pz())
                + -T::TWO * operand.as_inner().rx() * self.dist() * self.pz()
                + -T::TWO * operand.as_inner().rx() * self.px() * self.py()
                + -T::TWO * operand.as_inner().tz() * self.py() * self.pz()
                + T::TWO * operand.as_inner().tz() * self.dist() * self.px()
                + operand.as_inner().ty() * self.dist() * self.dist()
                + operand.as_inner().ty() * self.py() * self.py(),
            -(operand.as_inner().tx() * self.dist() * self.dist())
                + -(operand.as_inner().tx() * self.px() * self.px())
                + -T::TWO * operand.as_inner().ry() * self.px() * self.py()
                + -T::TWO * operand.as_inner().rz() * self.dist() * self.py()
                + -T::TWO * operand.as_inner().rz() * self.px() * self.pz()
                + -T::TWO * operand.as_inner().ty() * self.nx() * self.py()
                + -T::TWO * operand.as_inner().ty() * self.pw() * self.pz()
                + -T::TWO * operand.as_inner().tz() * self.dist() * self.ny()
                + -T::TWO * operand.as_inner().tz() * self.pw() * self.py()
                + T::TWO * operand.as_inner().ry() * self.dist() * self.pz()
                + T::TWO * operand.as_inner().ty() * self.dist() * self.nz()
                + T::TWO * operand.as_inner().ty() * self.ny() * self.px()
                + T::TWO * operand.as_inner().tz() * self.nx() * self.pz()
                + T::TWO * operand.as_inner().tz() * self.nz() * self.px()
                + T::from_i8(-4i8) * operand.as_inner().rx() * self.nz() * self.pz()
                + T::from_i8(4i8) * operand.as_inner().rx() * self.ny() * self.py()
                + operand.as_inner().tx() * self.py() * self.py()
                + operand.as_inner().tx() * self.pz() * self.pz(),
            -(operand.as_inner().rx() * self.py() * self.py())
                + -(operand.as_inner().rx() * self.pz() * self.pz())
                + -T::TWO * operand.as_inner().ty() * self.px() * self.py()
                + T::TWO * operand.as_inner().ty() * self.dist() * self.pz()
                + T::TWO * operand.as_inner().tz() * self.dist() * self.py()
                + T::TWO * operand.as_inner().tz() * self.px() * self.pz()
                + operand.as_inner().rx() * self.dist() * self.dist()
                + operand.as_inner().rx() * self.px() * self.px(),
            -(operand.as_inner().ry() * self.dist() * self.dist())
                + -(operand.as_inner().ry() * self.py() * self.py())
                + -T::TWO * operand.as_inner().rx() * self.ny() * self.px()
                + -T::TWO * operand.as_inner().rx() * self.pw() * self.pz()
                + -T::TWO * operand.as_inner().rz() * self.py() * self.pz()
                + -T::TWO * operand.as_inner().tx() * self.dist() * self.pz()
                + -T::TWO * operand.as_inner().tx() * self.px() * self.py()
                + -T::TWO * operand.as_inner().tz() * self.dist() * self.nx()
                + -T::TWO * operand.as_inner().tz() * self.ny() * self.pz()
                + T::TWO * operand.as_inner().rx() * self.dist() * self.nz()
                + T::TWO * operand.as_inner().rx() * self.nx() * self.py()
                + T::TWO * operand.as_inner().rz() * self.dist() * self.px()
                + T::TWO * operand.as_inner().tz() * self.nz() * self.py()
                + T::TWO * operand.as_inner().tz() * self.pw() * self.px()
                + T::from_i8(4i8) * operand.as_inner().ty() * self.dist() * self.pw()
                + T::from_i8(4i8) * operand.as_inner().ty() * self.ny() * self.py()
                + operand.as_inner().ry() * self.px() * self.px()
                + operand.as_inner().ry() * self.pz() * self.pz(),
            -(operand.as_inner().rz() * self.dist() * self.dist())
                + -(operand.as_inner().rz() * self.pz() * self.pz())
                + -T::TWO * operand.as_inner().ry() * self.dist() * self.px()
                + -T::TWO * operand.as_inner().ry() * self.py() * self.pz()
                + -T::TWO * operand.as_inner().tx() * self.px() * self.pz()
                + -T::TWO * operand.as_inner().ty() * self.dist() * self.nx()
                + -T::TWO * operand.as_inner().ty() * self.nz() * self.py()
                + T::TWO * operand.as_inner().rx() * self.dist() * self.ny()
                + T::TWO * operand.as_inner().rx() * self.nx() * self.pz()
                + T::TWO * operand.as_inner().rx() * self.nz() * self.px()
                + T::TWO * operand.as_inner().rx() * self.pw() * self.py()
                + T::TWO * operand.as_inner().tx() * self.dist() * self.py()
                + T::TWO * operand.as_inner().ty() * self.ny() * self.pz()
                + T::TWO * operand.as_inner().ty() * self.pw() * self.px()
                + T::from_i8(-4i8) * operand.as_inner().tz() * self.dist() * self.pw()
                + T::from_i8(4i8) * operand.as_inner().tz() * self.nz() * self.pz()
                + operand.as_inner().rz() * self.px() * self.px()
                + operand.as_inner().rz() * self.py() * self.py(),
            -(operand.as_inner().ps() * self.dist() * self.dist())
                + -(operand.as_inner().ps() * self.px() * self.px())
                + -(operand.as_inner().ps() * self.py() * self.py())
                + -(operand.as_inner().ps() * self.pz() * self.pz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Motor<T>>> for Unitized<Flector<T>> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s() * self.as_inner().dist() * self.as_inner().dist()
                + operand.as_inner().s() * self.as_inner().px() * self.as_inner().px()
                + operand.as_inner().s() * self.as_inner().py() * self.as_inner().py()
                + operand.as_inner().s() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.as_inner().tz() * self.as_inner().px() * self.as_inner().px())
                + -(operand.as_inner().tz() * self.as_inner().py() * self.as_inner().py())
                + -T::TWO * operand.as_inner().rx() * self.as_inner().dist() * self.as_inner().py()
                + -T::TWO * operand.as_inner().ty() * self.as_inner().dist() * self.as_inner().px()
                + -T::TWO * operand.as_inner().ty() * self.as_inner().py() * self.as_inner().pz()
                + T::TWO * operand.as_inner().rx() * self.as_inner().px() * self.as_inner().pz()
                + operand.as_inner().tz() * self.as_inner().dist() * self.as_inner().dist()
                + operand.as_inner().tz() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.as_inner().ty() * self.as_inner().px() * self.as_inner().px())
                + -(operand.as_inner().ty() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.as_inner().rx() * self.as_inner().dist() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().rx() * self.as_inner().px() * self.as_inner().py()
                + -T::TWO * operand.as_inner().tz() * self.as_inner().py() * self.as_inner().pz()
                + T::TWO * operand.as_inner().tz() * self.as_inner().dist() * self.as_inner().px()
                + operand.as_inner().ty() * self.as_inner().dist() * self.as_inner().dist()
                + operand.as_inner().ty() * self.as_inner().py() * self.as_inner().py(),
            -(operand.as_inner().tx() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.as_inner().tx() * self.as_inner().px() * self.as_inner().px())
                + -T::TWO * operand.as_inner().ry() * self.as_inner().px() * self.as_inner().py()
                + -T::TWO * operand.as_inner().rz() * self.as_inner().dist() * self.as_inner().py()
                + -T::TWO * operand.as_inner().rz() * self.as_inner().px() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().ty() * self.as_inner().nx() * self.as_inner().py()
                + -T::TWO * operand.as_inner().ty() * self.as_inner().pw() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().tz() * self.as_inner().dist() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().tz() * self.as_inner().pw() * self.as_inner().py()
                + T::TWO * operand.as_inner().ry() * self.as_inner().dist() * self.as_inner().pz()
                + T::TWO * operand.as_inner().ty() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.as_inner().ty() * self.as_inner().ny() * self.as_inner().px()
                + T::TWO * operand.as_inner().tz() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.as_inner().tz() * self.as_inner().nz() * self.as_inner().px()
                + T::from_i8(-4i8)
                    * operand.as_inner().rx()
                    * self.as_inner().nz()
                    * self.as_inner().pz()
                + T::from_i8(4i8)
                    * operand.as_inner().rx()
                    * self.as_inner().ny()
                    * self.as_inner().py()
                + operand.as_inner().tx() * self.as_inner().py() * self.as_inner().py()
                + operand.as_inner().tx() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.as_inner().rx() * self.as_inner().py() * self.as_inner().py())
                + -(operand.as_inner().rx() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.as_inner().ty() * self.as_inner().px() * self.as_inner().py()
                + T::TWO * operand.as_inner().ty() * self.as_inner().dist() * self.as_inner().pz()
                + T::TWO * operand.as_inner().tz() * self.as_inner().dist() * self.as_inner().py()
                + T::TWO * operand.as_inner().tz() * self.as_inner().px() * self.as_inner().pz()
                + operand.as_inner().rx() * self.as_inner().dist() * self.as_inner().dist()
                + operand.as_inner().rx() * self.as_inner().px() * self.as_inner().px(),
            -(operand.as_inner().ry() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.as_inner().ry() * self.as_inner().py() * self.as_inner().py())
                + -T::TWO * operand.as_inner().rx() * self.as_inner().ny() * self.as_inner().px()
                + -T::TWO * operand.as_inner().rx() * self.as_inner().pw() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().rz() * self.as_inner().py() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().dist() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().px() * self.as_inner().py()
                + -T::TWO * operand.as_inner().tz() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.as_inner().tz() * self.as_inner().ny() * self.as_inner().pz()
                + T::TWO * operand.as_inner().rx() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.as_inner().rx() * self.as_inner().nx() * self.as_inner().py()
                + T::TWO * operand.as_inner().rz() * self.as_inner().dist() * self.as_inner().px()
                + T::TWO * operand.as_inner().tz() * self.as_inner().nz() * self.as_inner().py()
                + T::TWO * operand.as_inner().tz() * self.as_inner().pw() * self.as_inner().px()
                + T::from_i8(4i8)
                    * operand.as_inner().ty()
                    * self.as_inner().dist()
                    * self.as_inner().pw()
                + T::from_i8(4i8)
                    * operand.as_inner().ty()
                    * self.as_inner().ny()
                    * self.as_inner().py()
                + operand.as_inner().ry() * self.as_inner().px() * self.as_inner().px()
                + operand.as_inner().ry() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.as_inner().rz() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.as_inner().rz() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.as_inner().ry() * self.as_inner().dist() * self.as_inner().px()
                + -T::TWO * operand.as_inner().ry() * self.as_inner().py() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().px() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().ty() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.as_inner().ty() * self.as_inner().nz() * self.as_inner().py()
                + T::TWO * operand.as_inner().rx() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.as_inner().rx() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.as_inner().rx() * self.as_inner().nz() * self.as_inner().px()
                + T::TWO * operand.as_inner().rx() * self.as_inner().pw() * self.as_inner().py()
                + T::TWO * operand.as_inner().tx() * self.as_inner().dist() * self.as_inner().py()
                + T::TWO * operand.as_inner().ty() * self.as_inner().ny() * self.as_inner().pz()
                + T::TWO * operand.as_inner().ty() * self.as_inner().pw() * self.as_inner().px()
                + T::from_i8(-4i8)
                    * operand.as_inner().tz()
                    * self.as_inner().dist()
                    * self.as_inner().pw()
                + T::from_i8(4i8)
                    * operand.as_inner().tz()
                    * self.as_inner().nz()
                    * self.as_inner().pz()
                + operand.as_inner().rz() * self.as_inner().px() * self.as_inner().px()
                + operand.as_inner().rz() * self.as_inner().py() * self.as_inner().py(),
            -(operand.as_inner().ps() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.as_inner().ps() * self.as_inner().px() * self.as_inner().px())
                + -(operand.as_inner().ps() * self.as_inner().py() * self.as_inner().py())
                + -(operand.as_inner().ps() * self.as_inner().pz() * self.as_inner().pz()),
        )
    }
}
#[doc = "Sandwich product: [`Flector`] x [`Plane`] x rev([`Flector`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Plane<T>> for Flector<T> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            self.dist() * operand.dist() * self.dist()
                + self.px() * operand.dist() * self.px()
                + self.py() * operand.dist() * self.py()
                + self.pz() * operand.dist() * self.pz(),
            self.dist() * operand.dist() * self.nz()
                + self.dist() * operand.nx() * self.py()
                + self.dist() * operand.ny() * self.px()
                - self.dist() * operand.nz() * self.dist()
                - self.nx() * operand.dist() * self.py()
                - self.ny() * operand.dist() * self.px()
                + self.nz() * operand.dist() * self.dist()
                + self.pw() * operand.dist() * self.pz()
                - self.px() * operand.dist() * self.ny()
                - self.px() * operand.nx() * self.pz()
                + self.px() * operand.ny() * self.dist()
                + self.px() * operand.nz() * self.px()
                - self.py() * operand.dist() * self.nx()
                + self.py() * operand.nx() * self.dist()
                + self.py() * operand.ny() * self.pz()
                + self.py() * operand.nz() * self.py()
                + self.pz() * operand.dist() * self.pw()
                - self.pz() * operand.nx() * self.px()
                + self.pz() * operand.ny() * self.py()
                - self.pz() * operand.nz() * self.pz(),
            self.dist() * operand.dist() * self.ny() + self.dist() * operand.nx() * self.pz()
                - self.dist() * operand.ny() * self.dist()
                - self.dist() * operand.nz() * self.px()
                - self.nx() * operand.dist() * self.pz()
                + self.ny() * operand.dist() * self.dist()
                + self.nz() * operand.dist() * self.px()
                - self.pw() * operand.dist() * self.py()
                + self.px() * operand.dist() * self.nz()
                + self.px() * operand.nx() * self.py()
                + self.px() * operand.ny() * self.px()
                - self.px() * operand.nz() * self.dist()
                - self.py() * operand.dist() * self.pw()
                + self.py() * operand.nx() * self.px()
                - self.py() * operand.ny() * self.py()
                + self.py() * operand.nz() * self.pz()
                - self.pz() * operand.dist() * self.nx()
                + self.pz() * operand.nx() * self.dist()
                + self.pz() * operand.ny() * self.pz()
                + self.pz() * operand.nz() * self.py(),
            self.dist() * operand.dist() * self.nx()
                - self.dist() * operand.nx() * self.dist()
                - self.dist() * operand.ny() * self.pz()
                - self.dist() * operand.nz() * self.py()
                + self.nx() * operand.dist() * self.dist()
                + self.ny() * operand.dist() * self.pz()
                + self.nz() * operand.dist() * self.py()
                + self.pw() * operand.dist() * self.px()
                + self.px() * operand.dist() * self.pw()
                - self.px() * operand.nx() * self.px()
                + self.px() * operand.ny() * self.py()
                - self.px() * operand.nz() * self.pz()
                + self.py() * operand.dist() * self.nz()
                + self.py() * operand.nx() * self.py()
                + self.py() * operand.ny() * self.px()
                - self.py() * operand.nz() * self.dist()
                + self.pz() * operand.dist() * self.ny()
                + self.pz() * operand.nx() * self.pz()
                - self.pz() * operand.ny() * self.dist()
                - self.pz() * operand.nz() * self.px(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Plane<T>> for Unitized<Flector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            operand.dist() * self.as_inner().dist() * self.as_inner().dist()
                + operand.dist() * self.as_inner().px() * self.as_inner().px()
                + operand.dist() * self.as_inner().py() * self.as_inner().py()
                + operand.dist() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.nz() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.nz() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.dist() * self.as_inner().nx() * self.as_inner().py()
                + -T::TWO * operand.dist() * self.as_inner().ny() * self.as_inner().px()
                + -T::TWO * operand.nx() * self.as_inner().px() * self.as_inner().pz()
                + T::TWO * operand.dist() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.dist() * self.as_inner().pw() * self.as_inner().pz()
                + T::TWO * operand.nx() * self.as_inner().dist() * self.as_inner().py()
                + T::TWO * operand.ny() * self.as_inner().dist() * self.as_inner().px()
                + T::TWO * operand.ny() * self.as_inner().py() * self.as_inner().pz()
                + operand.nz() * self.as_inner().px() * self.as_inner().px()
                + operand.nz() * self.as_inner().py() * self.as_inner().py(),
            -(operand.ny() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.ny() * self.as_inner().py() * self.as_inner().py())
                + -T::TWO * operand.dist() * self.as_inner().nx() * self.as_inner().pz()
                + -T::TWO * operand.dist() * self.as_inner().pw() * self.as_inner().py()
                + -T::TWO * operand.nz() * self.as_inner().dist() * self.as_inner().px()
                + T::TWO * operand.dist() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.dist() * self.as_inner().nz() * self.as_inner().px()
                + T::TWO * operand.nx() * self.as_inner().dist() * self.as_inner().pz()
                + T::TWO * operand.nx() * self.as_inner().px() * self.as_inner().py()
                + T::TWO * operand.nz() * self.as_inner().py() * self.as_inner().pz()
                + operand.ny() * self.as_inner().px() * self.as_inner().px()
                + operand.ny() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.nx() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.nx() * self.as_inner().px() * self.as_inner().px())
                + -T::TWO * operand.ny() * self.as_inner().dist() * self.as_inner().pz()
                + -T::TWO * operand.nz() * self.as_inner().dist() * self.as_inner().py()
                + -T::TWO * operand.nz() * self.as_inner().px() * self.as_inner().pz()
                + T::TWO * operand.dist() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.dist() * self.as_inner().ny() * self.as_inner().pz()
                + T::TWO * operand.dist() * self.as_inner().nz() * self.as_inner().py()
                + T::TWO * operand.dist() * self.as_inner().pw() * self.as_inner().px()
                + T::TWO * operand.ny() * self.as_inner().px() * self.as_inner().py()
                + operand.nx() * self.as_inner().py() * self.as_inner().py()
                + operand.nx() * self.as_inner().pz() * self.as_inner().pz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Plane<T>>> for Flector<T> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            operand.as_inner().dist() * self.dist() * self.dist()
                + operand.as_inner().dist() * self.px() * self.px()
                + operand.as_inner().dist() * self.py() * self.py()
                + operand.as_inner().dist() * self.pz() * self.pz(),
            -(operand.as_inner().nz() * self.dist() * self.dist())
                + -(operand.as_inner().nz() * self.pz() * self.pz())
                + -T::TWO * operand.as_inner().dist() * self.nx() * self.py()
                + -T::TWO * operand.as_inner().dist() * self.ny() * self.px()
                + -T::TWO * operand.as_inner().nx() * self.px() * self.pz()
                + T::TWO * operand.as_inner().dist() * self.dist() * self.nz()
                + T::TWO * operand.as_inner().dist() * self.pw() * self.pz()
                + T::TWO * operand.as_inner().nx() * self.dist() * self.py()
                + T::TWO * operand.as_inner().ny() * self.dist() * self.px()
                + T::TWO * operand.as_inner().ny() * self.py() * self.pz()
                + operand.as_inner().nz() * self.px() * self.px()
                + operand.as_inner().nz() * self.py() * self.py(),
            -(operand.as_inner().ny() * self.dist() * self.dist())
                + -(operand.as_inner().ny() * self.py() * self.py())
                + -T::TWO * operand.as_inner().dist() * self.nx() * self.pz()
                + -T::TWO * operand.as_inner().dist() * self.pw() * self.py()
                + -T::TWO * operand.as_inner().nz() * self.dist() * self.px()
                + T::TWO * operand.as_inner().dist() * self.dist() * self.ny()
                + T::TWO * operand.as_inner().dist() * self.nz() * self.px()
                + T::TWO * operand.as_inner().nx() * self.dist() * self.pz()
                + T::TWO * operand.as_inner().nx() * self.px() * self.py()
                + T::TWO * operand.as_inner().nz() * self.py() * self.pz()
                + operand.as_inner().ny() * self.px() * self.px()
                + operand.as_inner().ny() * self.pz() * self.pz(),
            -(operand.as_inner().nx() * self.dist() * self.dist())
                + -(operand.as_inner().nx() * self.px() * self.px())
                + -T::TWO * operand.as_inner().ny() * self.dist() * self.pz()
                + -T::TWO * operand.as_inner().nz() * self.dist() * self.py()
                + -T::TWO * operand.as_inner().nz() * self.px() * self.pz()
                + T::TWO * operand.as_inner().dist() * self.dist() * self.nx()
                + T::TWO * operand.as_inner().dist() * self.ny() * self.pz()
                + T::TWO * operand.as_inner().dist() * self.nz() * self.py()
                + T::TWO * operand.as_inner().dist() * self.pw() * self.px()
                + T::TWO * operand.as_inner().ny() * self.px() * self.py()
                + operand.as_inner().nx() * self.py() * self.py()
                + operand.as_inner().nx() * self.pz() * self.pz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Plane<T>>> for Unitized<Flector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            operand.as_inner().dist() * self.as_inner().dist() * self.as_inner().dist()
                + operand.as_inner().dist() * self.as_inner().px() * self.as_inner().px()
                + operand.as_inner().dist() * self.as_inner().py() * self.as_inner().py()
                + operand.as_inner().dist() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.as_inner().nz() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.as_inner().nz() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.as_inner().dist() * self.as_inner().nx() * self.as_inner().py()
                + -T::TWO * operand.as_inner().dist() * self.as_inner().ny() * self.as_inner().px()
                + -T::TWO * operand.as_inner().nx() * self.as_inner().px() * self.as_inner().pz()
                + T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dist()
                    * self.as_inner().nz()
                + T::TWO * operand.as_inner().dist() * self.as_inner().pw() * self.as_inner().pz()
                + T::TWO * operand.as_inner().nx() * self.as_inner().dist() * self.as_inner().py()
                + T::TWO * operand.as_inner().ny() * self.as_inner().dist() * self.as_inner().px()
                + T::TWO * operand.as_inner().ny() * self.as_inner().py() * self.as_inner().pz()
                + operand.as_inner().nz() * self.as_inner().px() * self.as_inner().px()
                + operand.as_inner().nz() * self.as_inner().py() * self.as_inner().py(),
            -(operand.as_inner().ny() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.as_inner().ny() * self.as_inner().py() * self.as_inner().py())
                + -T::TWO * operand.as_inner().dist() * self.as_inner().nx() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().dist() * self.as_inner().pw() * self.as_inner().py()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().dist() * self.as_inner().px()
                + T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dist()
                    * self.as_inner().ny()
                + T::TWO * operand.as_inner().dist() * self.as_inner().nz() * self.as_inner().px()
                + T::TWO * operand.as_inner().nx() * self.as_inner().dist() * self.as_inner().pz()
                + T::TWO * operand.as_inner().nx() * self.as_inner().px() * self.as_inner().py()
                + T::TWO * operand.as_inner().nz() * self.as_inner().py() * self.as_inner().pz()
                + operand.as_inner().ny() * self.as_inner().px() * self.as_inner().px()
                + operand.as_inner().ny() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.as_inner().nx() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.as_inner().nx() * self.as_inner().px() * self.as_inner().px())
                + -T::TWO * operand.as_inner().ny() * self.as_inner().dist() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().dist() * self.as_inner().py()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().px() * self.as_inner().pz()
                + T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dist()
                    * self.as_inner().nx()
                + T::TWO * operand.as_inner().dist() * self.as_inner().ny() * self.as_inner().pz()
                + T::TWO * operand.as_inner().dist() * self.as_inner().nz() * self.as_inner().py()
                + T::TWO * operand.as_inner().dist() * self.as_inner().pw() * self.as_inner().px()
                + T::TWO * operand.as_inner().ny() * self.as_inner().px() * self.as_inner().py()
                + operand.as_inner().nx() * self.as_inner().py() * self.as_inner().py()
                + operand.as_inner().nx() * self.as_inner().pz() * self.as_inner().pz(),
        )
    }
}
#[doc = "Sandwich product: [`Flector`] x [`Point`] x rev([`Flector`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Flector<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.dist() * operand.x() * self.dist() - self.dist() * operand.y() * self.pz()
                + self.dist() * operand.z() * self.py()
                + self.px() * operand.x() * self.px()
                + self.px() * operand.y() * self.py()
                + self.px() * operand.z() * self.pz()
                - self.py() * operand.x() * self.py()
                + self.py() * operand.y() * self.px()
                + self.py() * operand.z() * self.dist()
                - self.pz() * operand.x() * self.pz()
                - self.pz() * operand.y() * self.dist()
                + self.pz() * operand.z() * self.px(),
            self.dist() * operand.x() * self.pz() + self.dist() * operand.y() * self.dist()
                - self.dist() * operand.z() * self.px()
                + self.px() * operand.x() * self.py()
                - self.px() * operand.y() * self.px()
                - self.px() * operand.z() * self.dist()
                + self.py() * operand.x() * self.px()
                + self.py() * operand.y() * self.py()
                + self.py() * operand.z() * self.pz()
                + self.pz() * operand.x() * self.dist()
                - self.pz() * operand.y() * self.pz()
                + self.pz() * operand.z() * self.py(),
            -(self.dist() * operand.x() * self.py())
                + self.dist() * operand.y() * self.px()
                + self.dist() * operand.z() * self.dist()
                + self.px() * operand.x() * self.pz()
                + self.px() * operand.y() * self.dist()
                - self.px() * operand.z() * self.px()
                - self.py() * operand.x() * self.dist()
                + self.py() * operand.y() * self.pz()
                - self.py() * operand.z() * self.py()
                + self.pz() * operand.x() * self.px()
                + self.pz() * operand.y() * self.py()
                + self.pz() * operand.z() * self.pz(),
            -(self.dist() * operand.w() * self.dist()) + self.dist() * operand.x() * self.nx()
                - self.dist() * operand.y() * self.ny()
                + self.dist() * operand.z() * self.nz()
                + self.nx() * operand.x() * self.dist()
                - self.nx() * operand.y() * self.pz()
                + self.nx() * operand.z() * self.py()
                - self.ny() * operand.x() * self.pz()
                - self.ny() * operand.y() * self.dist()
                + self.ny() * operand.z() * self.px()
                - self.nz() * operand.x() * self.py()
                + self.nz() * operand.y() * self.px()
                + self.nz() * operand.z() * self.dist()
                + self.pw() * operand.x() * self.px()
                + self.pw() * operand.y() * self.py()
                + self.pw() * operand.z() * self.pz()
                - self.px() * operand.w() * self.px()
                + self.px() * operand.x() * self.pw()
                + self.px() * operand.y() * self.nz()
                + self.px() * operand.z() * self.ny()
                - self.py() * operand.w() * self.py()
                - self.py() * operand.x() * self.nz()
                + self.py() * operand.y() * self.pw()
                + self.py() * operand.z() * self.nx()
                - self.pz() * operand.w() * self.pz()
                - self.pz() * operand.x() * self.ny()
                - self.pz() * operand.y() * self.nx()
                + self.pz() * operand.z() * self.pw(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Unitized<Flector<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -(operand.x() * self.as_inner().py() * self.as_inner().py())
                + -(operand.x() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.y() * self.as_inner().dist() * self.as_inner().pz()
                + T::TWO * operand.y() * self.as_inner().px() * self.as_inner().py()
                + T::TWO * operand.z() * self.as_inner().dist() * self.as_inner().py()
                + T::TWO * operand.z() * self.as_inner().px() * self.as_inner().pz()
                + operand.x() * self.as_inner().dist() * self.as_inner().dist()
                + operand.x() * self.as_inner().px() * self.as_inner().px(),
            -(operand.y() * self.as_inner().px() * self.as_inner().px())
                + -(operand.y() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.z() * self.as_inner().dist() * self.as_inner().px()
                + T::TWO * operand.x() * self.as_inner().dist() * self.as_inner().pz()
                + T::TWO * operand.x() * self.as_inner().px() * self.as_inner().py()
                + T::TWO * operand.z() * self.as_inner().py() * self.as_inner().pz()
                + operand.y() * self.as_inner().dist() * self.as_inner().dist()
                + operand.y() * self.as_inner().py() * self.as_inner().py(),
            -(operand.z() * self.as_inner().px() * self.as_inner().px())
                + -(operand.z() * self.as_inner().py() * self.as_inner().py())
                + -T::TWO * operand.x() * self.as_inner().dist() * self.as_inner().py()
                + T::TWO * operand.x() * self.as_inner().px() * self.as_inner().pz()
                + T::TWO * operand.y() * self.as_inner().dist() * self.as_inner().px()
                + T::TWO * operand.y() * self.as_inner().py() * self.as_inner().pz()
                + operand.z() * self.as_inner().dist() * self.as_inner().dist()
                + operand.z() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.w() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.w() * self.as_inner().px() * self.as_inner().px())
                + -(operand.w() * self.as_inner().py() * self.as_inner().py())
                + -(operand.w() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.x() * self.as_inner().ny() * self.as_inner().pz()
                + -T::TWO * operand.x() * self.as_inner().nz() * self.as_inner().py()
                + -T::TWO * operand.y() * self.as_inner().dist() * self.as_inner().ny()
                + -T::TWO * operand.y() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.x() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.x() * self.as_inner().pw() * self.as_inner().px()
                + T::TWO * operand.y() * self.as_inner().nz() * self.as_inner().px()
                + T::TWO * operand.y() * self.as_inner().pw() * self.as_inner().py()
                + T::TWO * operand.z() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.z() * self.as_inner().nx() * self.as_inner().py()
                + T::TWO * operand.z() * self.as_inner().ny() * self.as_inner().px()
                + T::TWO * operand.z() * self.as_inner().pw() * self.as_inner().pz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Point<T>>> for Flector<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x() * self.py() * self.py())
                + -(operand.as_inner().x() * self.pz() * self.pz())
                + -T::TWO * operand.as_inner().y() * self.dist() * self.pz()
                + T::TWO * operand.as_inner().y() * self.px() * self.py()
                + T::TWO * operand.as_inner().z() * self.dist() * self.py()
                + T::TWO * operand.as_inner().z() * self.px() * self.pz()
                + operand.as_inner().x() * self.dist() * self.dist()
                + operand.as_inner().x() * self.px() * self.px(),
            -(operand.as_inner().y() * self.px() * self.px())
                + -(operand.as_inner().y() * self.pz() * self.pz())
                + -T::TWO * operand.as_inner().z() * self.dist() * self.px()
                + T::TWO * operand.as_inner().x() * self.dist() * self.pz()
                + T::TWO * operand.as_inner().x() * self.px() * self.py()
                + T::TWO * operand.as_inner().z() * self.py() * self.pz()
                + operand.as_inner().y() * self.dist() * self.dist()
                + operand.as_inner().y() * self.py() * self.py(),
            -(operand.as_inner().z() * self.px() * self.px())
                + -(operand.as_inner().z() * self.py() * self.py())
                + -T::TWO * operand.as_inner().x() * self.dist() * self.py()
                + T::TWO * operand.as_inner().x() * self.px() * self.pz()
                + T::TWO * operand.as_inner().y() * self.dist() * self.px()
                + T::TWO * operand.as_inner().y() * self.py() * self.pz()
                + operand.as_inner().z() * self.dist() * self.dist()
                + operand.as_inner().z() * self.pz() * self.pz(),
            -(operand.as_inner().w() * self.dist() * self.dist())
                + -(operand.as_inner().w() * self.px() * self.px())
                + -(operand.as_inner().w() * self.py() * self.py())
                + -(operand.as_inner().w() * self.pz() * self.pz())
                + -T::TWO * operand.as_inner().x() * self.ny() * self.pz()
                + -T::TWO * operand.as_inner().x() * self.nz() * self.py()
                + -T::TWO * operand.as_inner().y() * self.dist() * self.ny()
                + -T::TWO * operand.as_inner().y() * self.nx() * self.pz()
                + T::TWO * operand.as_inner().x() * self.dist() * self.nx()
                + T::TWO * operand.as_inner().x() * self.pw() * self.px()
                + T::TWO * operand.as_inner().y() * self.nz() * self.px()
                + T::TWO * operand.as_inner().y() * self.pw() * self.py()
                + T::TWO * operand.as_inner().z() * self.dist() * self.nz()
                + T::TWO * operand.as_inner().z() * self.nx() * self.py()
                + T::TWO * operand.as_inner().z() * self.ny() * self.px()
                + T::TWO * operand.as_inner().z() * self.pw() * self.pz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Point<T>>> for Unitized<Flector<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x() * self.as_inner().py() * self.as_inner().py())
                + -(operand.as_inner().x() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.as_inner().y() * self.as_inner().dist() * self.as_inner().pz()
                + T::TWO * operand.as_inner().y() * self.as_inner().px() * self.as_inner().py()
                + T::TWO * operand.as_inner().z() * self.as_inner().dist() * self.as_inner().py()
                + T::TWO * operand.as_inner().z() * self.as_inner().px() * self.as_inner().pz()
                + operand.as_inner().x() * self.as_inner().dist() * self.as_inner().dist()
                + operand.as_inner().x() * self.as_inner().px() * self.as_inner().px(),
            -(operand.as_inner().y() * self.as_inner().px() * self.as_inner().px())
                + -(operand.as_inner().y() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.as_inner().z() * self.as_inner().dist() * self.as_inner().px()
                + T::TWO * operand.as_inner().x() * self.as_inner().dist() * self.as_inner().pz()
                + T::TWO * operand.as_inner().x() * self.as_inner().px() * self.as_inner().py()
                + T::TWO * operand.as_inner().z() * self.as_inner().py() * self.as_inner().pz()
                + operand.as_inner().y() * self.as_inner().dist() * self.as_inner().dist()
                + operand.as_inner().y() * self.as_inner().py() * self.as_inner().py(),
            -(operand.as_inner().z() * self.as_inner().px() * self.as_inner().px())
                + -(operand.as_inner().z() * self.as_inner().py() * self.as_inner().py())
                + -T::TWO * operand.as_inner().x() * self.as_inner().dist() * self.as_inner().py()
                + T::TWO * operand.as_inner().x() * self.as_inner().px() * self.as_inner().pz()
                + T::TWO * operand.as_inner().y() * self.as_inner().dist() * self.as_inner().px()
                + T::TWO * operand.as_inner().y() * self.as_inner().py() * self.as_inner().pz()
                + operand.as_inner().z() * self.as_inner().dist() * self.as_inner().dist()
                + operand.as_inner().z() * self.as_inner().pz() * self.as_inner().pz(),
            -(operand.as_inner().w() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.as_inner().w() * self.as_inner().px() * self.as_inner().px())
                + -(operand.as_inner().w() * self.as_inner().py() * self.as_inner().py())
                + -(operand.as_inner().w() * self.as_inner().pz() * self.as_inner().pz())
                + -T::TWO * operand.as_inner().x() * self.as_inner().ny() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().x() * self.as_inner().nz() * self.as_inner().py()
                + -T::TWO * operand.as_inner().y() * self.as_inner().dist() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().y() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.as_inner().x() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.as_inner().x() * self.as_inner().pw() * self.as_inner().px()
                + T::TWO * operand.as_inner().y() * self.as_inner().nz() * self.as_inner().px()
                + T::TWO * operand.as_inner().y() * self.as_inner().pw() * self.as_inner().py()
                + T::TWO * operand.as_inner().z() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.as_inner().z() * self.as_inner().nx() * self.as_inner().py()
                + T::TWO * operand.as_inner().z() * self.as_inner().ny() * self.as_inner().px()
                + T::TWO * operand.as_inner().z() * self.as_inner().pw() * self.as_inner().pz(),
        )
    }
}
#[doc = "Sandwich product: [`Flector`] x [`Quadvector`] x rev([`Flector`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Quadvector<T>> for Flector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(self.dist() * operand.ps() * self.dist())
                - self.px() * operand.ps() * self.px()
                - self.py() * operand.ps() * self.py()
                - self.pz() * operand.ps() * self.pz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Quadvector<T>> for Unitized<Flector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(operand.ps() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.ps() * self.as_inner().px() * self.as_inner().px())
                + -(operand.ps() * self.as_inner().py() * self.as_inner().py())
                + -(operand.ps() * self.as_inner().pz() * self.as_inner().pz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Quadvector<T>>> for Flector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(operand.as_inner().ps() * self.dist() * self.dist())
                + -(operand.as_inner().ps() * self.px() * self.px())
                + -(operand.as_inner().ps() * self.py() * self.py())
                + -(operand.as_inner().ps() * self.pz() * self.pz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Quadvector<T>>> for Unitized<Flector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(operand.as_inner().ps() * self.as_inner().dist() * self.as_inner().dist())
                + -(operand.as_inner().ps() * self.as_inner().px() * self.as_inner().px())
                + -(operand.as_inner().ps() * self.as_inner().py() * self.as_inner().py())
                + -(operand.as_inner().ps() * self.as_inner().pz() * self.as_inner().pz()),
        )
    }
}
#[doc = "Sandwich product: [`Flector`] x [`Scalar`] x rev([`Flector`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Flector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.dist() * operand.s() * self.dist()
                + self.px() * operand.s() * self.px()
                + self.py() * operand.s() * self.py()
                + self.pz() * operand.s() * self.pz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unitized<Flector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            operand.s() * self.as_inner().dist() * self.as_inner().dist()
                + operand.s() * self.as_inner().px() * self.as_inner().px()
                + operand.s() * self.as_inner().py() * self.as_inner().py()
                + operand.s() * self.as_inner().pz() * self.as_inner().pz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Flector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Unitized<Flector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Sandwich product: [`Line`] x [`Flector`] x rev([`Line`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Flector<T>> for Line<T> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            self.moment_x() * operand.px() * self.moment_x()
                - self.moment_x() * operand.py() * self.moment_y()
                + self.moment_x() * operand.pz() * self.moment_z()
                + self.moment_y() * operand.dist() * self.moment_z()
                - self.moment_y() * operand.px() * self.moment_y()
                - self.moment_y() * operand.py() * self.moment_x()
                - self.moment_z() * operand.dist() * self.moment_y()
                - self.moment_z() * operand.px() * self.moment_z()
                + self.moment_z() * operand.pz() * self.moment_x(),
            self.moment_x() * operand.dist() * self.moment_z()
                - self.moment_x() * operand.px() * self.moment_y()
                - self.moment_x() * operand.py() * self.moment_x()
                - self.moment_y() * operand.px() * self.moment_x()
                + self.moment_y() * operand.py() * self.moment_y()
                - self.moment_y() * operand.pz() * self.moment_z()
                - self.moment_z() * operand.dist() * self.moment_x()
                - self.moment_z() * operand.py() * self.moment_z()
                - self.moment_z() * operand.pz() * self.moment_y(),
            self.moment_x() * operand.dist() * self.moment_y()
                + self.moment_x() * operand.px() * self.moment_z()
                - self.moment_x() * operand.pz() * self.moment_x()
                - self.moment_y() * operand.dist() * self.moment_x()
                - self.moment_y() * operand.py() * self.moment_z()
                - self.moment_y() * operand.pz() * self.moment_y()
                + self.moment_z() * operand.px() * self.moment_x()
                - self.moment_z() * operand.py() * self.moment_y()
                + self.moment_z() * operand.pz() * self.moment_z(),
            -(self.dir_x() * operand.dist() * self.moment_x())
                - self.dir_x() * operand.py() * self.moment_z()
                - self.dir_x() * operand.pz() * self.moment_y()
                + self.dir_y() * operand.dist() * self.moment_y()
                + self.dir_y() * operand.px() * self.moment_z()
                - self.dir_y() * operand.pz() * self.moment_x()
                - self.dir_z() * operand.dist() * self.moment_z()
                + self.dir_z() * operand.px() * self.moment_y()
                + self.dir_z() * operand.py() * self.moment_x()
                + self.moment_x() * operand.dist() * self.dir_x()
                + self.moment_x() * operand.ny() * self.moment_z()
                - self.moment_x() * operand.nz() * self.moment_y()
                + self.moment_x() * operand.pw() * self.moment_x()
                + self.moment_x() * operand.py() * self.dir_z()
                - self.moment_x() * operand.pz() * self.dir_y()
                - self.moment_y() * operand.dist() * self.dir_y()
                - self.moment_y() * operand.nx() * self.moment_z()
                + self.moment_y() * operand.nz() * self.moment_x()
                + self.moment_y() * operand.pw() * self.moment_y()
                + self.moment_y() * operand.px() * self.dir_z()
                - self.moment_y() * operand.pz() * self.dir_x()
                + self.moment_z() * operand.dist() * self.dir_z()
                + self.moment_z() * operand.nx() * self.moment_y()
                - self.moment_z() * operand.ny() * self.moment_x()
                + self.moment_z() * operand.pw() * self.moment_z()
                + self.moment_z() * operand.px() * self.dir_y()
                - self.moment_z() * operand.py() * self.dir_x(),
            self.moment_x() * operand.dist() * self.moment_x()
                + self.moment_x() * operand.py() * self.moment_z()
                + self.moment_x() * operand.pz() * self.moment_y()
                + self.moment_y() * operand.dist() * self.moment_y()
                + self.moment_y() * operand.px() * self.moment_z()
                - self.moment_y() * operand.pz() * self.moment_x()
                + self.moment_z() * operand.dist() * self.moment_z()
                - self.moment_z() * operand.px() * self.moment_y()
                - self.moment_z() * operand.py() * self.moment_x(),
            self.dir_x() * operand.dist() * self.moment_y()
                + self.dir_x() * operand.px() * self.moment_z()
                - self.dir_x() * operand.pz() * self.moment_x()
                + self.dir_y() * operand.dist() * self.moment_x()
                + self.dir_y() * operand.py() * self.moment_z()
                + self.dir_y() * operand.pz() * self.moment_y()
                + self.dir_z() * operand.px() * self.moment_x()
                - self.dir_z() * operand.py() * self.moment_y()
                + self.dir_z() * operand.pz() * self.moment_z()
                + self.moment_x() * operand.dist() * self.dir_y()
                + self.moment_x() * operand.nx() * self.moment_z()
                - self.moment_x() * operand.nz() * self.moment_x()
                - self.moment_x() * operand.pw() * self.moment_y()
                - self.moment_x() * operand.px() * self.dir_z()
                + self.moment_x() * operand.pz() * self.dir_x()
                + self.moment_y() * operand.dist() * self.dir_x()
                + self.moment_y() * operand.ny() * self.moment_z()
                - self.moment_y() * operand.nz() * self.moment_y()
                + self.moment_y() * operand.pw() * self.moment_x()
                + self.moment_y() * operand.py() * self.dir_z()
                - self.moment_y() * operand.pz() * self.dir_y()
                + self.moment_z() * operand.nx() * self.moment_x()
                + self.moment_z() * operand.ny() * self.moment_y()
                + self.moment_z() * operand.nz() * self.moment_z()
                - self.moment_z() * operand.px() * self.dir_x()
                - self.moment_z() * operand.py() * self.dir_y()
                - self.moment_z() * operand.pz() * self.dir_z(),
            -(self.dir_x() * operand.dist() * self.moment_z())
                + self.dir_x() * operand.px() * self.moment_y()
                + self.dir_x() * operand.py() * self.moment_x()
                - self.dir_y() * operand.px() * self.moment_x()
                + self.dir_y() * operand.py() * self.moment_y()
                - self.dir_y() * operand.pz() * self.moment_z()
                + self.dir_z() * operand.dist() * self.moment_x()
                + self.dir_z() * operand.py() * self.moment_z()
                + self.dir_z() * operand.pz() * self.moment_y()
                + self.moment_x() * operand.dist() * self.dir_z()
                + self.moment_x() * operand.nx() * self.moment_y()
                - self.moment_x() * operand.ny() * self.moment_x()
                + self.moment_x() * operand.pw() * self.moment_z()
                + self.moment_x() * operand.px() * self.dir_y()
                - self.moment_x() * operand.py() * self.dir_x()
                + self.moment_y() * operand.nx() * self.moment_x()
                + self.moment_y() * operand.ny() * self.moment_y()
                + self.moment_y() * operand.nz() * self.moment_z()
                - self.moment_y() * operand.px() * self.dir_x()
                - self.moment_y() * operand.py() * self.dir_y()
                - self.moment_y() * operand.pz() * self.dir_z()
                - self.moment_z() * operand.dist() * self.dir_x()
                - self.moment_z() * operand.ny() * self.moment_z()
                + self.moment_z() * operand.nz() * self.moment_y()
                - self.moment_z() * operand.pw() * self.moment_x()
                - self.moment_z() * operand.py() * self.dir_z()
                + self.moment_z() * operand.pz() * self.dir_y(),
            self.dir_x() * operand.px() * self.moment_x()
                - self.dir_x() * operand.py() * self.moment_y()
                + self.dir_x() * operand.pz() * self.moment_z()
                - self.dir_y() * operand.dist() * self.moment_z()
                + self.dir_y() * operand.px() * self.moment_y()
                + self.dir_y() * operand.py() * self.moment_x()
                - self.dir_z() * operand.dist() * self.moment_y()
                - self.dir_z() * operand.px() * self.moment_z()
                + self.dir_z() * operand.pz() * self.moment_x()
                + self.moment_x() * operand.nx() * self.moment_x()
                + self.moment_x() * operand.ny() * self.moment_y()
                + self.moment_x() * operand.nz() * self.moment_z()
                - self.moment_x() * operand.px() * self.dir_x()
                - self.moment_x() * operand.py() * self.dir_y()
                - self.moment_x() * operand.pz() * self.dir_z()
                - self.moment_y() * operand.dist() * self.dir_z()
                - self.moment_y() * operand.nx() * self.moment_y()
                + self.moment_y() * operand.ny() * self.moment_x()
                - self.moment_y() * operand.pw() * self.moment_z()
                - self.moment_y() * operand.px() * self.dir_y()
                + self.moment_y() * operand.py() * self.dir_x()
                - self.moment_z() * operand.dist() * self.dir_y()
                - self.moment_z() * operand.nx() * self.moment_z()
                + self.moment_z() * operand.nz() * self.moment_x()
                + self.moment_z() * operand.pw() * self.moment_y()
                + self.moment_z() * operand.px() * self.dir_z()
                - self.moment_z() * operand.pz() * self.dir_x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Flector<T>> for Unitized<Line<T>> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            -(operand.px() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + -(operand.px() * self.as_inner().moment_z() * self.as_inner().moment_z())
                + -T::TWO * operand.py() * self.as_inner().moment_x() * self.as_inner().moment_y()
                + T::TWO * operand.pz() * self.as_inner().moment_x() * self.as_inner().moment_z()
                + operand.px() * self.as_inner().moment_x() * self.as_inner().moment_x(),
            -(operand.py() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.py() * self.as_inner().moment_z() * self.as_inner().moment_z())
                + -T::TWO * operand.px() * self.as_inner().moment_x() * self.as_inner().moment_y()
                + -T::TWO * operand.pz() * self.as_inner().moment_y() * self.as_inner().moment_z()
                + operand.py() * self.as_inner().moment_y() * self.as_inner().moment_y(),
            -(operand.pz() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.pz() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + -T::TWO * operand.py() * self.as_inner().moment_y() * self.as_inner().moment_z()
                + T::TWO * operand.px() * self.as_inner().moment_x() * self.as_inner().moment_z()
                + operand.pz() * self.as_inner().moment_z() * self.as_inner().moment_z(),
            -T::TWO * operand.py() * self.as_inner().dir_x() * self.as_inner().moment_z()
                + -T::TWO * operand.pz() * self.as_inner().dir_x() * self.as_inner().moment_y()
                + -T::TWO * operand.pz() * self.as_inner().dir_y() * self.as_inner().moment_x()
                + T::TWO * operand.px() * self.as_inner().dir_y() * self.as_inner().moment_z()
                + T::TWO * operand.px() * self.as_inner().dir_z() * self.as_inner().moment_y()
                + T::TWO * operand.py() * self.as_inner().dir_z() * self.as_inner().moment_x()
                + operand.pw() * self.as_inner().moment_x() * self.as_inner().moment_x()
                + operand.pw() * self.as_inner().moment_y() * self.as_inner().moment_y()
                + operand.pw() * self.as_inner().moment_z() * self.as_inner().moment_z(),
            operand.dist() * self.as_inner().moment_x() * self.as_inner().moment_x()
                + operand.dist() * self.as_inner().moment_y() * self.as_inner().moment_y()
                + operand.dist() * self.as_inner().moment_z() * self.as_inner().moment_z(),
            -(operand.nz() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.nz() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + T::TWO * operand.dist() * self.as_inner().dir_x() * self.as_inner().moment_y()
                + T::TWO * operand.dist() * self.as_inner().dir_y() * self.as_inner().moment_x()
                + T::TWO * operand.nx() * self.as_inner().moment_x() * self.as_inner().moment_z()
                + T::TWO * operand.ny() * self.as_inner().moment_y() * self.as_inner().moment_z()
                + operand.nz() * self.as_inner().moment_z() * self.as_inner().moment_z(),
            -(operand.ny() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.ny() * self.as_inner().moment_z() * self.as_inner().moment_z())
                + -T::TWO * operand.dist() * self.as_inner().dir_x() * self.as_inner().moment_z()
                + T::TWO * operand.dist() * self.as_inner().dir_z() * self.as_inner().moment_x()
                + T::TWO * operand.nx() * self.as_inner().moment_x() * self.as_inner().moment_y()
                + T::TWO * operand.nz() * self.as_inner().moment_y() * self.as_inner().moment_z()
                + operand.ny() * self.as_inner().moment_y() * self.as_inner().moment_y(),
            -(operand.nx() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + -(operand.nx() * self.as_inner().moment_z() * self.as_inner().moment_z())
                + -T::TWO * operand.dist() * self.as_inner().dir_y() * self.as_inner().moment_z()
                + -T::TWO * operand.dist() * self.as_inner().dir_z() * self.as_inner().moment_y()
                + T::TWO * operand.ny() * self.as_inner().moment_x() * self.as_inner().moment_y()
                + T::TWO * operand.nz() * self.as_inner().moment_x() * self.as_inner().moment_z()
                + operand.nx() * self.as_inner().moment_x() * self.as_inner().moment_x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Flector<T>>> for Line<T> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            -(operand.as_inner().px() * self.moment_y() * self.moment_y())
                + -(operand.as_inner().px() * self.moment_z() * self.moment_z())
                + -T::TWO * operand.as_inner().py() * self.moment_x() * self.moment_y()
                + T::TWO * operand.as_inner().pz() * self.moment_x() * self.moment_z()
                + operand.as_inner().px() * self.moment_x() * self.moment_x(),
            -(operand.as_inner().py() * self.moment_x() * self.moment_x())
                + -(operand.as_inner().py() * self.moment_z() * self.moment_z())
                + -T::TWO * operand.as_inner().px() * self.moment_x() * self.moment_y()
                + -T::TWO * operand.as_inner().pz() * self.moment_y() * self.moment_z()
                + operand.as_inner().py() * self.moment_y() * self.moment_y(),
            -(operand.as_inner().pz() * self.moment_x() * self.moment_x())
                + -(operand.as_inner().pz() * self.moment_y() * self.moment_y())
                + -T::TWO * operand.as_inner().py() * self.moment_y() * self.moment_z()
                + T::TWO * operand.as_inner().px() * self.moment_x() * self.moment_z()
                + operand.as_inner().pz() * self.moment_z() * self.moment_z(),
            -T::TWO * operand.as_inner().py() * self.dir_x() * self.moment_z()
                + -T::TWO * operand.as_inner().pz() * self.dir_x() * self.moment_y()
                + -T::TWO * operand.as_inner().pz() * self.dir_y() * self.moment_x()
                + T::TWO * operand.as_inner().px() * self.dir_y() * self.moment_z()
                + T::TWO * operand.as_inner().px() * self.dir_z() * self.moment_y()
                + T::TWO * operand.as_inner().py() * self.dir_z() * self.moment_x()
                + operand.as_inner().pw() * self.moment_x() * self.moment_x()
                + operand.as_inner().pw() * self.moment_y() * self.moment_y()
                + operand.as_inner().pw() * self.moment_z() * self.moment_z(),
            operand.as_inner().dist() * self.moment_x() * self.moment_x()
                + operand.as_inner().dist() * self.moment_y() * self.moment_y()
                + operand.as_inner().dist() * self.moment_z() * self.moment_z(),
            -(operand.as_inner().nz() * self.moment_x() * self.moment_x())
                + -(operand.as_inner().nz() * self.moment_y() * self.moment_y())
                + T::TWO * operand.as_inner().dist() * self.dir_x() * self.moment_y()
                + T::TWO * operand.as_inner().dist() * self.dir_y() * self.moment_x()
                + T::TWO * operand.as_inner().nx() * self.moment_x() * self.moment_z()
                + T::TWO * operand.as_inner().ny() * self.moment_y() * self.moment_z()
                + operand.as_inner().nz() * self.moment_z() * self.moment_z(),
            -(operand.as_inner().ny() * self.moment_x() * self.moment_x())
                + -(operand.as_inner().ny() * self.moment_z() * self.moment_z())
                + -T::TWO * operand.as_inner().dist() * self.dir_x() * self.moment_z()
                + T::TWO * operand.as_inner().dist() * self.dir_z() * self.moment_x()
                + T::TWO * operand.as_inner().nx() * self.moment_x() * self.moment_y()
                + T::TWO * operand.as_inner().nz() * self.moment_y() * self.moment_z()
                + operand.as_inner().ny() * self.moment_y() * self.moment_y(),
            -(operand.as_inner().nx() * self.moment_y() * self.moment_y())
                + -(operand.as_inner().nx() * self.moment_z() * self.moment_z())
                + -T::TWO * operand.as_inner().dist() * self.dir_y() * self.moment_z()
                + -T::TWO * operand.as_inner().dist() * self.dir_z() * self.moment_y()
                + T::TWO * operand.as_inner().ny() * self.moment_x() * self.moment_y()
                + T::TWO * operand.as_inner().nz() * self.moment_x() * self.moment_z()
                + operand.as_inner().nx() * self.moment_x() * self.moment_x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Flector<T>>> for Unitized<Line<T>> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            -(operand.as_inner().px() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + -(operand.as_inner().px()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z())
                + -T::TWO
                    * operand.as_inner().py()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().pz()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + operand.as_inner().px() * self.as_inner().moment_x() * self.as_inner().moment_x(),
            -(operand.as_inner().py() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.as_inner().py()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z())
                + -T::TWO
                    * operand.as_inner().px()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + -T::TWO
                    * operand.as_inner().pz()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + operand.as_inner().py() * self.as_inner().moment_y() * self.as_inner().moment_y(),
            -(operand.as_inner().pz() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.as_inner().pz()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_y())
                + -T::TWO
                    * operand.as_inner().py()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().px()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + operand.as_inner().pz() * self.as_inner().moment_z() * self.as_inner().moment_z(),
            -T::TWO
                * operand.as_inner().py()
                * self.as_inner().dir_x()
                * self.as_inner().moment_z()
                + -T::TWO
                    * operand.as_inner().pz()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_y()
                + -T::TWO
                    * operand.as_inner().pz()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().px()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().px()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().py()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_x()
                + operand.as_inner().pw() * self.as_inner().moment_x() * self.as_inner().moment_x()
                + operand.as_inner().pw() * self.as_inner().moment_y() * self.as_inner().moment_y()
                + operand.as_inner().pw() * self.as_inner().moment_z() * self.as_inner().moment_z(),
            operand.as_inner().dist() * self.as_inner().moment_x() * self.as_inner().moment_x()
                + operand.as_inner().dist()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_y()
                + operand.as_inner().dist()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z(),
            -(operand.as_inner().nz() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.as_inner().nz()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_y())
                + T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().nx()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().ny()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + operand.as_inner().nz() * self.as_inner().moment_z() * self.as_inner().moment_z(),
            -(operand.as_inner().ny() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.as_inner().ny()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z())
                + -T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().nx()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().nz()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + operand.as_inner().ny() * self.as_inner().moment_y() * self.as_inner().moment_y(),
            -(operand.as_inner().nx() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + -(operand.as_inner().nx()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z())
                + -T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_z()
                + -T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().ny()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().nz()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + operand.as_inner().nx() * self.as_inner().moment_x() * self.as_inner().moment_x(),
        )
    }
}
#[doc = "Sandwich product: [`Line`] x [`Line`] x rev([`Line`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.moment_x() * operand.moment_x() * self.moment_z()
                - self.moment_x() * operand.moment_z() * self.moment_x()
                + self.moment_y() * operand.moment_y() * self.moment_z()
                - self.moment_y() * operand.moment_z() * self.moment_y()
                + self.moment_z() * operand.moment_x() * self.moment_x()
                + self.moment_z() * operand.moment_y() * self.moment_y()
                + self.moment_z() * operand.moment_z() * self.moment_z(),
            self.moment_x() * operand.moment_x() * self.moment_y()
                - self.moment_x() * operand.moment_y() * self.moment_x()
                + self.moment_y() * operand.moment_x() * self.moment_x()
                + self.moment_y() * operand.moment_y() * self.moment_y()
                + self.moment_y() * operand.moment_z() * self.moment_z()
                - self.moment_z() * operand.moment_y() * self.moment_z()
                + self.moment_z() * operand.moment_z() * self.moment_y(),
            self.dir_x() * operand.moment_x() * self.moment_x()
                + self.dir_x() * operand.moment_y() * self.moment_y()
                + self.dir_x() * operand.moment_z() * self.moment_z()
                + self.dir_y() * operand.moment_x() * self.moment_y()
                - self.dir_y() * operand.moment_y() * self.moment_x()
                - self.dir_z() * operand.moment_x() * self.moment_z()
                + self.dir_z() * operand.moment_z() * self.moment_x()
                + self.moment_x() * operand.dir_x() * self.moment_x()
                - self.moment_x() * operand.dir_y() * self.moment_y()
                + self.moment_x() * operand.dir_z() * self.moment_z()
                + self.moment_x() * operand.moment_x() * self.dir_x()
                - self.moment_x() * operand.moment_y() * self.dir_y()
                + self.moment_x() * operand.moment_z() * self.dir_z()
                - self.moment_y() * operand.dir_x() * self.moment_y()
                - self.moment_y() * operand.dir_y() * self.moment_x()
                + self.moment_y() * operand.moment_x() * self.dir_y()
                + self.moment_y() * operand.moment_y() * self.dir_x()
                - self.moment_z() * operand.dir_x() * self.moment_z()
                + self.moment_z() * operand.dir_z() * self.moment_x()
                - self.moment_z() * operand.moment_x() * self.dir_z()
                + self.moment_z() * operand.moment_z() * self.dir_x(),
            self.moment_x() * operand.moment_x() * self.moment_x()
                + self.moment_x() * operand.moment_y() * self.moment_y()
                + self.moment_x() * operand.moment_z() * self.moment_z()
                - self.moment_y() * operand.moment_x() * self.moment_y()
                + self.moment_y() * operand.moment_y() * self.moment_x()
                - self.moment_z() * operand.moment_x() * self.moment_z()
                + self.moment_z() * operand.moment_z() * self.moment_x(),
            -(self.dir_x() * operand.moment_x() * self.moment_y())
                + self.dir_x() * operand.moment_y() * self.moment_x()
                + self.dir_y() * operand.moment_x() * self.moment_x()
                + self.dir_y() * operand.moment_y() * self.moment_y()
                + self.dir_y() * operand.moment_z() * self.moment_z()
                + self.dir_z() * operand.moment_y() * self.moment_z()
                - self.dir_z() * operand.moment_z() * self.moment_y()
                - self.moment_x() * operand.dir_x() * self.moment_y()
                - self.moment_x() * operand.dir_y() * self.moment_x()
                + self.moment_x() * operand.moment_x() * self.dir_y()
                + self.moment_x() * operand.moment_y() * self.dir_x()
                - self.moment_y() * operand.dir_x() * self.moment_x()
                + self.moment_y() * operand.dir_y() * self.moment_y()
                - self.moment_y() * operand.dir_z() * self.moment_z()
                - self.moment_y() * operand.moment_x() * self.dir_x()
                + self.moment_y() * operand.moment_y() * self.dir_y()
                - self.moment_y() * operand.moment_z() * self.dir_z()
                - self.moment_z() * operand.dir_y() * self.moment_z()
                - self.moment_z() * operand.dir_z() * self.moment_y()
                + self.moment_z() * operand.moment_y() * self.dir_z()
                + self.moment_z() * operand.moment_z() * self.dir_y(),
            self.dir_x() * operand.moment_x() * self.moment_z()
                - self.dir_x() * operand.moment_z() * self.moment_x()
                - self.dir_y() * operand.moment_y() * self.moment_z()
                + self.dir_y() * operand.moment_z() * self.moment_y()
                + self.dir_z() * operand.moment_x() * self.moment_x()
                + self.dir_z() * operand.moment_y() * self.moment_y()
                + self.dir_z() * operand.moment_z() * self.moment_z()
                + self.moment_x() * operand.dir_x() * self.moment_z()
                - self.moment_x() * operand.dir_z() * self.moment_x()
                + self.moment_x() * operand.moment_x() * self.dir_z()
                - self.moment_x() * operand.moment_z() * self.dir_x()
                - self.moment_y() * operand.dir_y() * self.moment_z()
                - self.moment_y() * operand.dir_z() * self.moment_y()
                + self.moment_y() * operand.moment_y() * self.dir_z()
                + self.moment_y() * operand.moment_z() * self.dir_y()
                + self.moment_z() * operand.dir_x() * self.moment_x()
                - self.moment_z() * operand.dir_y() * self.moment_y()
                + self.moment_z() * operand.dir_z() * self.moment_z()
                + self.moment_z() * operand.moment_x() * self.dir_x()
                - self.moment_z() * operand.moment_y() * self.dir_y()
                + self.moment_z() * operand.moment_z() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            -(operand.moment_z() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.moment_z() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + T::TWO
                    * operand.moment_x()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.moment_y()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + operand.moment_z() * self.as_inner().moment_z() * self.as_inner().moment_z(),
            -(operand.moment_y() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.moment_y() * self.as_inner().moment_z() * self.as_inner().moment_z())
                + T::TWO
                    * operand.moment_x()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.moment_z()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + operand.moment_y() * self.as_inner().moment_y() * self.as_inner().moment_y(),
            -(operand.dir_x() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + -(operand.dir_x() * self.as_inner().moment_z() * self.as_inner().moment_z())
                + -T::TWO
                    * operand.dir_y()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + -T::TWO
                    * operand.moment_y()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.dir_z()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.moment_y()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.moment_z()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.moment_z()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_x()
                + T::from_i8(4i8)
                    * operand.moment_x()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_x()
                + operand.dir_x() * self.as_inner().moment_x() * self.as_inner().moment_x(),
            -(operand.moment_x() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + -(operand.moment_x() * self.as_inner().moment_z() * self.as_inner().moment_z())
                + T::TWO
                    * operand.moment_y()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.moment_z()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + operand.moment_x() * self.as_inner().moment_x() * self.as_inner().moment_x(),
            -(operand.dir_y() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.dir_y() * self.as_inner().moment_z() * self.as_inner().moment_z())
                + -T::TWO
                    * operand.dir_x()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + -T::TWO
                    * operand.dir_z()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + -T::TWO
                    * operand.moment_x()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_y()
                + -T::TWO
                    * operand.moment_z()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.moment_x()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.moment_z()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_z()
                + T::from_i8(4i8)
                    * operand.moment_y()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_y()
                + operand.dir_y() * self.as_inner().moment_y() * self.as_inner().moment_y(),
            -(operand.dir_z() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.dir_z() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + -T::TWO
                    * operand.dir_y()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + -T::TWO
                    * operand.moment_y()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.dir_x()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.moment_x()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.moment_x()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.moment_y()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_y()
                + T::from_i8(-4i8)
                    * operand.moment_z()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_x()
                + T::from_i8(4i8)
                    * operand.moment_z()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_y()
                + operand.dir_z() * self.as_inner().moment_z() * self.as_inner().moment_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Line<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(operand.as_inner().moment_z() * self.moment_x() * self.moment_x())
                + -(operand.as_inner().moment_z() * self.moment_y() * self.moment_y())
                + T::TWO * operand.as_inner().moment_x() * self.moment_x() * self.moment_z()
                + T::TWO * operand.as_inner().moment_y() * self.moment_y() * self.moment_z()
                + operand.as_inner().moment_z() * self.moment_z() * self.moment_z(),
            -(operand.as_inner().moment_y() * self.moment_x() * self.moment_x())
                + -(operand.as_inner().moment_y() * self.moment_z() * self.moment_z())
                + T::TWO * operand.as_inner().moment_x() * self.moment_x() * self.moment_y()
                + T::TWO * operand.as_inner().moment_z() * self.moment_y() * self.moment_z()
                + operand.as_inner().moment_y() * self.moment_y() * self.moment_y(),
            -(operand.as_inner().dir_x() * self.moment_y() * self.moment_y())
                + -(operand.as_inner().dir_x() * self.moment_z() * self.moment_z())
                + -T::TWO * operand.as_inner().dir_y() * self.moment_x() * self.moment_y()
                + -T::TWO * operand.as_inner().moment_y() * self.dir_y() * self.moment_x()
                + T::TWO * operand.as_inner().dir_z() * self.moment_x() * self.moment_z()
                + T::TWO * operand.as_inner().moment_y() * self.dir_x() * self.moment_y()
                + T::TWO * operand.as_inner().moment_z() * self.dir_x() * self.moment_z()
                + T::TWO * operand.as_inner().moment_z() * self.dir_z() * self.moment_x()
                + T::from_i8(4i8) * operand.as_inner().moment_x() * self.dir_x() * self.moment_x()
                + operand.as_inner().dir_x() * self.moment_x() * self.moment_x(),
            -(operand.as_inner().moment_x() * self.moment_y() * self.moment_y())
                + -(operand.as_inner().moment_x() * self.moment_z() * self.moment_z())
                + T::TWO * operand.as_inner().moment_y() * self.moment_x() * self.moment_y()
                + T::TWO * operand.as_inner().moment_z() * self.moment_x() * self.moment_z()
                + operand.as_inner().moment_x() * self.moment_x() * self.moment_x(),
            -(operand.as_inner().dir_y() * self.moment_x() * self.moment_x())
                + -(operand.as_inner().dir_y() * self.moment_z() * self.moment_z())
                + -T::TWO * operand.as_inner().dir_x() * self.moment_x() * self.moment_y()
                + -T::TWO * operand.as_inner().dir_z() * self.moment_y() * self.moment_z()
                + -T::TWO * operand.as_inner().moment_x() * self.dir_x() * self.moment_y()
                + -T::TWO * operand.as_inner().moment_z() * self.dir_z() * self.moment_y()
                + T::TWO * operand.as_inner().moment_x() * self.dir_y() * self.moment_x()
                + T::TWO * operand.as_inner().moment_z() * self.dir_y() * self.moment_z()
                + T::from_i8(4i8) * operand.as_inner().moment_y() * self.dir_y() * self.moment_y()
                + operand.as_inner().dir_y() * self.moment_y() * self.moment_y(),
            -(operand.as_inner().dir_z() * self.moment_x() * self.moment_x())
                + -(operand.as_inner().dir_z() * self.moment_y() * self.moment_y())
                + -T::TWO * operand.as_inner().dir_y() * self.moment_y() * self.moment_z()
                + -T::TWO * operand.as_inner().moment_y() * self.dir_y() * self.moment_z()
                + T::TWO * operand.as_inner().dir_x() * self.moment_x() * self.moment_z()
                + T::TWO * operand.as_inner().moment_x() * self.dir_x() * self.moment_z()
                + T::TWO * operand.as_inner().moment_x() * self.dir_z() * self.moment_x()
                + T::TWO * operand.as_inner().moment_y() * self.dir_z() * self.moment_y()
                + T::from_i8(-4i8) * operand.as_inner().moment_z() * self.dir_x() * self.moment_x()
                + T::from_i8(4i8) * operand.as_inner().moment_z() * self.dir_y() * self.moment_y()
                + operand.as_inner().dir_z() * self.moment_z() * self.moment_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Line<T>>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(operand.as_inner().moment_z()
                * self.as_inner().moment_x()
                * self.as_inner().moment_x())
                + -(operand.as_inner().moment_z()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_y())
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + operand.as_inner().moment_z()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z(),
            -(operand.as_inner().moment_y()
                * self.as_inner().moment_x()
                * self.as_inner().moment_x())
                + -(operand.as_inner().moment_y()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z())
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + operand.as_inner().moment_y()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_y(),
            -(operand.as_inner().dir_x() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + -(operand.as_inner().dir_x()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z())
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_x()
                + T::from_i8(4i8)
                    * operand.as_inner().moment_x()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_x()
                + operand.as_inner().dir_x()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_x(),
            -(operand.as_inner().moment_x()
                * self.as_inner().moment_y()
                * self.as_inner().moment_y())
                + -(operand.as_inner().moment_x()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z())
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + operand.as_inner().moment_x()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_x(),
            -(operand.as_inner().dir_y() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.as_inner().dir_y()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z())
                + -T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + -T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_y()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_z()
                + T::from_i8(4i8)
                    * operand.as_inner().moment_y()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_y()
                + operand.as_inner().dir_y()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_y(),
            -(operand.as_inner().dir_z() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.as_inner().dir_z()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_y())
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_y()
                + T::from_i8(-4i8)
                    * operand.as_inner().moment_z()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_x()
                + T::from_i8(4i8)
                    * operand.as_inner().moment_z()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_y()
                + operand.as_inner().dir_z()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z(),
        )
    }
}
#[doc = "Sandwich product: [`Line`] x [`Motor`] x rev([`Line`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Motor<T>> for Line<T> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            self.moment_x() * operand.s() * self.moment_x()
                + self.moment_x() * operand.ty() * self.moment_z()
                - self.moment_x() * operand.tz() * self.moment_y()
                - self.moment_y() * operand.rx() * self.moment_z()
                + self.moment_y() * operand.s() * self.moment_y()
                + self.moment_y() * operand.tz() * self.moment_x()
                + self.moment_z() * operand.rx() * self.moment_y()
                + self.moment_z() * operand.s() * self.moment_z()
                - self.moment_z() * operand.ty() * self.moment_x(),
            self.moment_x() * operand.rx() * self.moment_z()
                - self.moment_x() * operand.s() * self.moment_y()
                - self.moment_x() * operand.tz() * self.moment_x()
                + self.moment_y() * operand.s() * self.moment_x()
                + self.moment_y() * operand.ty() * self.moment_z()
                - self.moment_y() * operand.tz() * self.moment_y()
                + self.moment_z() * operand.rx() * self.moment_x()
                + self.moment_z() * operand.ty() * self.moment_y()
                + self.moment_z() * operand.tz() * self.moment_z(),
            self.moment_x() * operand.rx() * self.moment_y()
                + self.moment_x() * operand.s() * self.moment_z()
                - self.moment_x() * operand.ty() * self.moment_x()
                + self.moment_y() * operand.rx() * self.moment_x()
                + self.moment_y() * operand.ty() * self.moment_y()
                + self.moment_y() * operand.tz() * self.moment_z()
                - self.moment_z() * operand.s() * self.moment_x()
                - self.moment_z() * operand.ty() * self.moment_z()
                + self.moment_z() * operand.tz() * self.moment_y(),
            self.dir_x() * operand.rx() * self.moment_x()
                + self.dir_x() * operand.ty() * self.moment_y()
                + self.dir_x() * operand.tz() * self.moment_z()
                + self.dir_y() * operand.rx() * self.moment_y()
                + self.dir_y() * operand.s() * self.moment_z()
                - self.dir_y() * operand.ty() * self.moment_x()
                - self.dir_z() * operand.rx() * self.moment_z()
                + self.dir_z() * operand.s() * self.moment_y()
                + self.dir_z() * operand.tz() * self.moment_x()
                + self.moment_x() * operand.rx() * self.dir_x()
                - self.moment_x() * operand.ry() * self.moment_y()
                + self.moment_x() * operand.rz() * self.moment_z()
                + self.moment_x() * operand.tx() * self.moment_x()
                - self.moment_x() * operand.ty() * self.dir_y()
                + self.moment_x() * operand.tz() * self.dir_z()
                + self.moment_y() * operand.ps() * self.moment_z()
                + self.moment_y() * operand.rx() * self.dir_y()
                - self.moment_y() * operand.ry() * self.moment_x()
                - self.moment_y() * operand.s() * self.dir_z()
                - self.moment_y() * operand.tx() * self.moment_y()
                + self.moment_y() * operand.ty() * self.dir_x()
                - self.moment_z() * operand.ps() * self.moment_y()
                - self.moment_z() * operand.rx() * self.dir_z()
                + self.moment_z() * operand.rz() * self.moment_x()
                - self.moment_z() * operand.s() * self.dir_y()
                - self.moment_z() * operand.tx() * self.moment_z()
                + self.moment_z() * operand.tz() * self.dir_x(),
            self.moment_x() * operand.rx() * self.moment_x()
                + self.moment_x() * operand.ty() * self.moment_y()
                + self.moment_x() * operand.tz() * self.moment_z()
                - self.moment_y() * operand.rx() * self.moment_y()
                - self.moment_y() * operand.s() * self.moment_z()
                + self.moment_y() * operand.ty() * self.moment_x()
                - self.moment_z() * operand.rx() * self.moment_z()
                + self.moment_z() * operand.s() * self.moment_y()
                + self.moment_z() * operand.tz() * self.moment_x(),
            -(self.dir_x() * operand.rx() * self.moment_y())
                - self.dir_x() * operand.s() * self.moment_z()
                + self.dir_x() * operand.ty() * self.moment_x()
                + self.dir_y() * operand.rx() * self.moment_x()
                + self.dir_y() * operand.ty() * self.moment_y()
                + self.dir_y() * operand.tz() * self.moment_z()
                + self.dir_z() * operand.s() * self.moment_x()
                + self.dir_z() * operand.ty() * self.moment_z()
                - self.dir_z() * operand.tz() * self.moment_y()
                + self.moment_x() * operand.ps() * self.moment_z()
                + self.moment_x() * operand.rx() * self.dir_y()
                - self.moment_x() * operand.ry() * self.moment_x()
                - self.moment_x() * operand.s() * self.dir_z()
                - self.moment_x() * operand.tx() * self.moment_y()
                + self.moment_x() * operand.ty() * self.dir_x()
                - self.moment_y() * operand.rx() * self.dir_x()
                + self.moment_y() * operand.ry() * self.moment_y()
                - self.moment_y() * operand.rz() * self.moment_z()
                - self.moment_y() * operand.tx() * self.moment_x()
                + self.moment_y() * operand.ty() * self.dir_y()
                - self.moment_y() * operand.tz() * self.dir_z()
                - self.moment_z() * operand.ps() * self.moment_x()
                - self.moment_z() * operand.ry() * self.moment_z()
                - self.moment_z() * operand.rz() * self.moment_y()
                + self.moment_z() * operand.s() * self.dir_x()
                + self.moment_z() * operand.ty() * self.dir_z()
                + self.moment_z() * operand.tz() * self.dir_y(),
            self.dir_x() * operand.rx() * self.moment_z()
                - self.dir_x() * operand.s() * self.moment_y()
                - self.dir_x() * operand.tz() * self.moment_x()
                - self.dir_y() * operand.s() * self.moment_x()
                - self.dir_y() * operand.ty() * self.moment_z()
                + self.dir_y() * operand.tz() * self.moment_y()
                + self.dir_z() * operand.rx() * self.moment_x()
                + self.dir_z() * operand.ty() * self.moment_y()
                + self.dir_z() * operand.tz() * self.moment_z()
                + self.moment_x() * operand.ps() * self.moment_y()
                + self.moment_x() * operand.rx() * self.dir_z()
                - self.moment_x() * operand.rz() * self.moment_x()
                + self.moment_x() * operand.s() * self.dir_y()
                + self.moment_x() * operand.tx() * self.moment_z()
                - self.moment_x() * operand.tz() * self.dir_x()
                - self.moment_y() * operand.ps() * self.moment_x()
                - self.moment_y() * operand.ry() * self.moment_z()
                - self.moment_y() * operand.rz() * self.moment_y()
                + self.moment_y() * operand.s() * self.dir_x()
                + self.moment_y() * operand.ty() * self.dir_z()
                + self.moment_y() * operand.tz() * self.dir_y()
                + self.moment_z() * operand.rx() * self.dir_x()
                - self.moment_z() * operand.ry() * self.moment_y()
                + self.moment_z() * operand.rz() * self.moment_z()
                + self.moment_z() * operand.tx() * self.moment_x()
                - self.moment_z() * operand.ty() * self.dir_y()
                + self.moment_z() * operand.tz() * self.dir_z(),
            -(self.dir_x() * operand.s() * self.moment_x())
                - self.dir_x() * operand.ty() * self.moment_z()
                + self.dir_x() * operand.tz() * self.moment_y()
                - self.dir_y() * operand.rx() * self.moment_z()
                + self.dir_y() * operand.s() * self.moment_y()
                + self.dir_y() * operand.tz() * self.moment_x()
                - self.dir_z() * operand.rx() * self.moment_y()
                - self.dir_z() * operand.s() * self.moment_z()
                + self.dir_z() * operand.ty() * self.moment_x()
                + self.moment_x() * operand.ps() * self.moment_x()
                + self.moment_x() * operand.ry() * self.moment_z()
                + self.moment_x() * operand.rz() * self.moment_y()
                - self.moment_x() * operand.s() * self.dir_x()
                - self.moment_x() * operand.ty() * self.dir_z()
                - self.moment_x() * operand.tz() * self.dir_y()
                + self.moment_y() * operand.ps() * self.moment_y()
                + self.moment_y() * operand.rx() * self.dir_z()
                - self.moment_y() * operand.rz() * self.moment_x()
                + self.moment_y() * operand.s() * self.dir_y()
                + self.moment_y() * operand.tx() * self.moment_z()
                - self.moment_y() * operand.tz() * self.dir_x()
                + self.moment_z() * operand.ps() * self.moment_z()
                + self.moment_z() * operand.rx() * self.dir_y()
                - self.moment_z() * operand.ry() * self.moment_x()
                - self.moment_z() * operand.s() * self.dir_z()
                - self.moment_z() * operand.tx() * self.moment_y()
                + self.moment_z() * operand.ty() * self.dir_x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Motor<T>> for Unitized<Line<T>> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            operand.s() * self.as_inner().moment_x() * self.as_inner().moment_x()
                + operand.s() * self.as_inner().moment_y() * self.as_inner().moment_y()
                + operand.s() * self.as_inner().moment_z() * self.as_inner().moment_z(),
            -(operand.tz() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.tz() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + T::TWO * operand.rx() * self.as_inner().moment_x() * self.as_inner().moment_z()
                + T::TWO * operand.ty() * self.as_inner().moment_y() * self.as_inner().moment_z()
                + operand.tz() * self.as_inner().moment_z() * self.as_inner().moment_z(),
            -(operand.ty() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.ty() * self.as_inner().moment_z() * self.as_inner().moment_z())
                + T::TWO * operand.rx() * self.as_inner().moment_x() * self.as_inner().moment_y()
                + T::TWO * operand.tz() * self.as_inner().moment_y() * self.as_inner().moment_z()
                + operand.ty() * self.as_inner().moment_y() * self.as_inner().moment_y(),
            -(operand.tx() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + -(operand.tx() * self.as_inner().moment_z() * self.as_inner().moment_z())
                + -T::TWO * operand.ry() * self.as_inner().moment_x() * self.as_inner().moment_y()
                + -T::TWO * operand.ty() * self.as_inner().dir_y() * self.as_inner().moment_x()
                + T::TWO * operand.rz() * self.as_inner().moment_x() * self.as_inner().moment_z()
                + T::TWO * operand.ty() * self.as_inner().dir_x() * self.as_inner().moment_y()
                + T::TWO * operand.tz() * self.as_inner().dir_x() * self.as_inner().moment_z()
                + T::TWO * operand.tz() * self.as_inner().dir_z() * self.as_inner().moment_x()
                + T::from_i8(4i8)
                    * operand.rx()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_x()
                + operand.tx() * self.as_inner().moment_x() * self.as_inner().moment_x(),
            -(operand.rx() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + -(operand.rx() * self.as_inner().moment_z() * self.as_inner().moment_z())
                + T::TWO * operand.ty() * self.as_inner().moment_x() * self.as_inner().moment_y()
                + T::TWO * operand.tz() * self.as_inner().moment_x() * self.as_inner().moment_z()
                + operand.rx() * self.as_inner().moment_x() * self.as_inner().moment_x(),
            -(operand.ry() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.ry() * self.as_inner().moment_z() * self.as_inner().moment_z())
                + -T::TWO * operand.rx() * self.as_inner().dir_x() * self.as_inner().moment_y()
                + -T::TWO * operand.rz() * self.as_inner().moment_y() * self.as_inner().moment_z()
                + -T::TWO * operand.tx() * self.as_inner().moment_x() * self.as_inner().moment_y()
                + -T::TWO * operand.tz() * self.as_inner().dir_z() * self.as_inner().moment_y()
                + T::TWO * operand.rx() * self.as_inner().dir_y() * self.as_inner().moment_x()
                + T::TWO * operand.tz() * self.as_inner().dir_y() * self.as_inner().moment_z()
                + T::from_i8(4i8)
                    * operand.ty()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_y()
                + operand.ry() * self.as_inner().moment_y() * self.as_inner().moment_y(),
            -(operand.rz() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.rz() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + -T::TWO * operand.ry() * self.as_inner().moment_y() * self.as_inner().moment_z()
                + -T::TWO * operand.ty() * self.as_inner().dir_y() * self.as_inner().moment_z()
                + T::TWO * operand.rx() * self.as_inner().dir_x() * self.as_inner().moment_z()
                + T::TWO * operand.rx() * self.as_inner().dir_z() * self.as_inner().moment_x()
                + T::TWO * operand.tx() * self.as_inner().moment_x() * self.as_inner().moment_z()
                + T::TWO * operand.ty() * self.as_inner().dir_z() * self.as_inner().moment_y()
                + T::from_i8(-4i8)
                    * operand.tz()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_x()
                + T::from_i8(4i8)
                    * operand.tz()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_y()
                + operand.rz() * self.as_inner().moment_z() * self.as_inner().moment_z(),
            operand.ps() * self.as_inner().moment_x() * self.as_inner().moment_x()
                + operand.ps() * self.as_inner().moment_y() * self.as_inner().moment_y()
                + operand.ps() * self.as_inner().moment_z() * self.as_inner().moment_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Motor<T>>> for Line<T> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s() * self.moment_x() * self.moment_x()
                + operand.as_inner().s() * self.moment_y() * self.moment_y()
                + operand.as_inner().s() * self.moment_z() * self.moment_z(),
            -(operand.as_inner().tz() * self.moment_x() * self.moment_x())
                + -(operand.as_inner().tz() * self.moment_y() * self.moment_y())
                + T::TWO * operand.as_inner().rx() * self.moment_x() * self.moment_z()
                + T::TWO * operand.as_inner().ty() * self.moment_y() * self.moment_z()
                + operand.as_inner().tz() * self.moment_z() * self.moment_z(),
            -(operand.as_inner().ty() * self.moment_x() * self.moment_x())
                + -(operand.as_inner().ty() * self.moment_z() * self.moment_z())
                + T::TWO * operand.as_inner().rx() * self.moment_x() * self.moment_y()
                + T::TWO * operand.as_inner().tz() * self.moment_y() * self.moment_z()
                + operand.as_inner().ty() * self.moment_y() * self.moment_y(),
            -(operand.as_inner().tx() * self.moment_y() * self.moment_y())
                + -(operand.as_inner().tx() * self.moment_z() * self.moment_z())
                + -T::TWO * operand.as_inner().ry() * self.moment_x() * self.moment_y()
                + -T::TWO * operand.as_inner().ty() * self.dir_y() * self.moment_x()
                + T::TWO * operand.as_inner().rz() * self.moment_x() * self.moment_z()
                + T::TWO * operand.as_inner().ty() * self.dir_x() * self.moment_y()
                + T::TWO * operand.as_inner().tz() * self.dir_x() * self.moment_z()
                + T::TWO * operand.as_inner().tz() * self.dir_z() * self.moment_x()
                + T::from_i8(4i8) * operand.as_inner().rx() * self.dir_x() * self.moment_x()
                + operand.as_inner().tx() * self.moment_x() * self.moment_x(),
            -(operand.as_inner().rx() * self.moment_y() * self.moment_y())
                + -(operand.as_inner().rx() * self.moment_z() * self.moment_z())
                + T::TWO * operand.as_inner().ty() * self.moment_x() * self.moment_y()
                + T::TWO * operand.as_inner().tz() * self.moment_x() * self.moment_z()
                + operand.as_inner().rx() * self.moment_x() * self.moment_x(),
            -(operand.as_inner().ry() * self.moment_x() * self.moment_x())
                + -(operand.as_inner().ry() * self.moment_z() * self.moment_z())
                + -T::TWO * operand.as_inner().rx() * self.dir_x() * self.moment_y()
                + -T::TWO * operand.as_inner().rz() * self.moment_y() * self.moment_z()
                + -T::TWO * operand.as_inner().tx() * self.moment_x() * self.moment_y()
                + -T::TWO * operand.as_inner().tz() * self.dir_z() * self.moment_y()
                + T::TWO * operand.as_inner().rx() * self.dir_y() * self.moment_x()
                + T::TWO * operand.as_inner().tz() * self.dir_y() * self.moment_z()
                + T::from_i8(4i8) * operand.as_inner().ty() * self.dir_y() * self.moment_y()
                + operand.as_inner().ry() * self.moment_y() * self.moment_y(),
            -(operand.as_inner().rz() * self.moment_x() * self.moment_x())
                + -(operand.as_inner().rz() * self.moment_y() * self.moment_y())
                + -T::TWO * operand.as_inner().ry() * self.moment_y() * self.moment_z()
                + -T::TWO * operand.as_inner().ty() * self.dir_y() * self.moment_z()
                + T::TWO * operand.as_inner().rx() * self.dir_x() * self.moment_z()
                + T::TWO * operand.as_inner().rx() * self.dir_z() * self.moment_x()
                + T::TWO * operand.as_inner().tx() * self.moment_x() * self.moment_z()
                + T::TWO * operand.as_inner().ty() * self.dir_z() * self.moment_y()
                + T::from_i8(-4i8) * operand.as_inner().tz() * self.dir_x() * self.moment_x()
                + T::from_i8(4i8) * operand.as_inner().tz() * self.dir_y() * self.moment_y()
                + operand.as_inner().rz() * self.moment_z() * self.moment_z(),
            operand.as_inner().ps() * self.moment_x() * self.moment_x()
                + operand.as_inner().ps() * self.moment_y() * self.moment_y()
                + operand.as_inner().ps() * self.moment_z() * self.moment_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Motor<T>>> for Unitized<Line<T>> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s() * self.as_inner().moment_x() * self.as_inner().moment_x()
                + operand.as_inner().s() * self.as_inner().moment_y() * self.as_inner().moment_y()
                + operand.as_inner().s() * self.as_inner().moment_z() * self.as_inner().moment_z(),
            -(operand.as_inner().tz() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.as_inner().tz()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_y())
                + T::TWO
                    * operand.as_inner().rx()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().ty()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + operand.as_inner().tz() * self.as_inner().moment_z() * self.as_inner().moment_z(),
            -(operand.as_inner().ty() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.as_inner().ty()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z())
                + T::TWO
                    * operand.as_inner().rx()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().tz()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + operand.as_inner().ty() * self.as_inner().moment_y() * self.as_inner().moment_y(),
            -(operand.as_inner().tx() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + -(operand.as_inner().tx()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z())
                + -T::TWO
                    * operand.as_inner().ry()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + -T::TWO
                    * operand.as_inner().ty()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().rz()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().ty()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().tz()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().tz()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_x()
                + T::from_i8(4i8)
                    * operand.as_inner().rx()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_x()
                + operand.as_inner().tx() * self.as_inner().moment_x() * self.as_inner().moment_x(),
            -(operand.as_inner().rx() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + -(operand.as_inner().rx()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z())
                + T::TWO
                    * operand.as_inner().ty()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().tz()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + operand.as_inner().rx() * self.as_inner().moment_x() * self.as_inner().moment_x(),
            -(operand.as_inner().ry() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.as_inner().ry()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z())
                + -T::TWO
                    * operand.as_inner().rx()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_y()
                + -T::TWO
                    * operand.as_inner().rz()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + -T::TWO
                    * operand.as_inner().tx()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + -T::TWO
                    * operand.as_inner().tz()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().rx()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().tz()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_z()
                + T::from_i8(4i8)
                    * operand.as_inner().ty()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_y()
                + operand.as_inner().ry() * self.as_inner().moment_y() * self.as_inner().moment_y(),
            -(operand.as_inner().rz() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.as_inner().rz()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_y())
                + -T::TWO
                    * operand.as_inner().ry()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + -T::TWO
                    * operand.as_inner().ty()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().rx()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().rx()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().tx()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().ty()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_y()
                + T::from_i8(-4i8)
                    * operand.as_inner().tz()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_x()
                + T::from_i8(4i8)
                    * operand.as_inner().tz()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_y()
                + operand.as_inner().rz() * self.as_inner().moment_z() * self.as_inner().moment_z(),
            operand.as_inner().ps() * self.as_inner().moment_x() * self.as_inner().moment_x()
                + operand.as_inner().ps() * self.as_inner().moment_y() * self.as_inner().moment_y()
                + operand.as_inner().ps() * self.as_inner().moment_z() * self.as_inner().moment_z(),
        )
    }
}
#[doc = "Sandwich product: [`Line`] x [`Plane`] x rev([`Line`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Plane<T>> for Line<T> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            self.moment_x() * operand.dist() * self.moment_x()
                + self.moment_y() * operand.dist() * self.moment_y()
                + self.moment_z() * operand.dist() * self.moment_z(),
            self.dir_x() * operand.dist() * self.moment_y()
                + self.dir_y() * operand.dist() * self.moment_x()
                + self.moment_x() * operand.dist() * self.dir_y()
                + self.moment_x() * operand.nx() * self.moment_z()
                - self.moment_x() * operand.nz() * self.moment_x()
                + self.moment_y() * operand.dist() * self.dir_x()
                + self.moment_y() * operand.ny() * self.moment_z()
                - self.moment_y() * operand.nz() * self.moment_y()
                + self.moment_z() * operand.nx() * self.moment_x()
                + self.moment_z() * operand.ny() * self.moment_y()
                + self.moment_z() * operand.nz() * self.moment_z(),
            -(self.dir_x() * operand.dist() * self.moment_z())
                + self.dir_z() * operand.dist() * self.moment_x()
                + self.moment_x() * operand.dist() * self.dir_z()
                + self.moment_x() * operand.nx() * self.moment_y()
                - self.moment_x() * operand.ny() * self.moment_x()
                + self.moment_y() * operand.nx() * self.moment_x()
                + self.moment_y() * operand.ny() * self.moment_y()
                + self.moment_y() * operand.nz() * self.moment_z()
                - self.moment_z() * operand.dist() * self.dir_x()
                - self.moment_z() * operand.ny() * self.moment_z()
                + self.moment_z() * operand.nz() * self.moment_y(),
            -(self.dir_y() * operand.dist() * self.moment_z())
                - self.dir_z() * operand.dist() * self.moment_y()
                + self.moment_x() * operand.nx() * self.moment_x()
                + self.moment_x() * operand.ny() * self.moment_y()
                + self.moment_x() * operand.nz() * self.moment_z()
                - self.moment_y() * operand.dist() * self.dir_z()
                - self.moment_y() * operand.nx() * self.moment_y()
                + self.moment_y() * operand.ny() * self.moment_x()
                - self.moment_z() * operand.dist() * self.dir_y()
                - self.moment_z() * operand.nx() * self.moment_z()
                + self.moment_z() * operand.nz() * self.moment_x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Plane<T>> for Unitized<Line<T>> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            operand.dist() * self.as_inner().moment_x() * self.as_inner().moment_x()
                + operand.dist() * self.as_inner().moment_y() * self.as_inner().moment_y()
                + operand.dist() * self.as_inner().moment_z() * self.as_inner().moment_z(),
            -(operand.nz() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.nz() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + T::TWO * operand.dist() * self.as_inner().dir_x() * self.as_inner().moment_y()
                + T::TWO * operand.dist() * self.as_inner().dir_y() * self.as_inner().moment_x()
                + T::TWO * operand.nx() * self.as_inner().moment_x() * self.as_inner().moment_z()
                + T::TWO * operand.ny() * self.as_inner().moment_y() * self.as_inner().moment_z()
                + operand.nz() * self.as_inner().moment_z() * self.as_inner().moment_z(),
            -(operand.ny() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.ny() * self.as_inner().moment_z() * self.as_inner().moment_z())
                + -T::TWO * operand.dist() * self.as_inner().dir_x() * self.as_inner().moment_z()
                + T::TWO * operand.dist() * self.as_inner().dir_z() * self.as_inner().moment_x()
                + T::TWO * operand.nx() * self.as_inner().moment_x() * self.as_inner().moment_y()
                + T::TWO * operand.nz() * self.as_inner().moment_y() * self.as_inner().moment_z()
                + operand.ny() * self.as_inner().moment_y() * self.as_inner().moment_y(),
            -(operand.nx() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + -(operand.nx() * self.as_inner().moment_z() * self.as_inner().moment_z())
                + -T::TWO * operand.dist() * self.as_inner().dir_y() * self.as_inner().moment_z()
                + -T::TWO * operand.dist() * self.as_inner().dir_z() * self.as_inner().moment_y()
                + T::TWO * operand.ny() * self.as_inner().moment_x() * self.as_inner().moment_y()
                + T::TWO * operand.nz() * self.as_inner().moment_x() * self.as_inner().moment_z()
                + operand.nx() * self.as_inner().moment_x() * self.as_inner().moment_x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Plane<T>>> for Line<T> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            operand.as_inner().dist() * self.moment_x() * self.moment_x()
                + operand.as_inner().dist() * self.moment_y() * self.moment_y()
                + operand.as_inner().dist() * self.moment_z() * self.moment_z(),
            -(operand.as_inner().nz() * self.moment_x() * self.moment_x())
                + -(operand.as_inner().nz() * self.moment_y() * self.moment_y())
                + T::TWO * operand.as_inner().dist() * self.dir_x() * self.moment_y()
                + T::TWO * operand.as_inner().dist() * self.dir_y() * self.moment_x()
                + T::TWO * operand.as_inner().nx() * self.moment_x() * self.moment_z()
                + T::TWO * operand.as_inner().ny() * self.moment_y() * self.moment_z()
                + operand.as_inner().nz() * self.moment_z() * self.moment_z(),
            -(operand.as_inner().ny() * self.moment_x() * self.moment_x())
                + -(operand.as_inner().ny() * self.moment_z() * self.moment_z())
                + -T::TWO * operand.as_inner().dist() * self.dir_x() * self.moment_z()
                + T::TWO * operand.as_inner().dist() * self.dir_z() * self.moment_x()
                + T::TWO * operand.as_inner().nx() * self.moment_x() * self.moment_y()
                + T::TWO * operand.as_inner().nz() * self.moment_y() * self.moment_z()
                + operand.as_inner().ny() * self.moment_y() * self.moment_y(),
            -(operand.as_inner().nx() * self.moment_y() * self.moment_y())
                + -(operand.as_inner().nx() * self.moment_z() * self.moment_z())
                + -T::TWO * operand.as_inner().dist() * self.dir_y() * self.moment_z()
                + -T::TWO * operand.as_inner().dist() * self.dir_z() * self.moment_y()
                + T::TWO * operand.as_inner().ny() * self.moment_x() * self.moment_y()
                + T::TWO * operand.as_inner().nz() * self.moment_x() * self.moment_z()
                + operand.as_inner().nx() * self.moment_x() * self.moment_x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Plane<T>>> for Unitized<Line<T>> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            operand.as_inner().dist() * self.as_inner().moment_x() * self.as_inner().moment_x()
                + operand.as_inner().dist()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_y()
                + operand.as_inner().dist()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z(),
            -(operand.as_inner().nz() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.as_inner().nz()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_y())
                + T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().nx()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().ny()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + operand.as_inner().nz() * self.as_inner().moment_z() * self.as_inner().moment_z(),
            -(operand.as_inner().ny() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.as_inner().ny()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z())
                + -T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().nx()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().nz()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + operand.as_inner().ny() * self.as_inner().moment_y() * self.as_inner().moment_y(),
            -(operand.as_inner().nx() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + -(operand.as_inner().nx()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z())
                + -T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_z()
                + -T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().ny()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().nz()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + operand.as_inner().nx() * self.as_inner().moment_x() * self.as_inner().moment_x(),
        )
    }
}
#[doc = "Sandwich product: [`Line`] x [`Point`] x rev([`Line`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.moment_x() * operand.x() * self.moment_x()
                - self.moment_x() * operand.y() * self.moment_y()
                + self.moment_x() * operand.z() * self.moment_z()
                - self.moment_y() * operand.x() * self.moment_y()
                - self.moment_y() * operand.y() * self.moment_x()
                - self.moment_z() * operand.x() * self.moment_z()
                + self.moment_z() * operand.z() * self.moment_x(),
            -(self.moment_x() * operand.x() * self.moment_y())
                - self.moment_x() * operand.y() * self.moment_x()
                - self.moment_y() * operand.x() * self.moment_x()
                + self.moment_y() * operand.y() * self.moment_y()
                - self.moment_y() * operand.z() * self.moment_z()
                - self.moment_z() * operand.y() * self.moment_z()
                - self.moment_z() * operand.z() * self.moment_y(),
            self.moment_x() * operand.x() * self.moment_z()
                - self.moment_x() * operand.z() * self.moment_x()
                - self.moment_y() * operand.y() * self.moment_z()
                - self.moment_y() * operand.z() * self.moment_y()
                + self.moment_z() * operand.x() * self.moment_x()
                - self.moment_z() * operand.y() * self.moment_y()
                + self.moment_z() * operand.z() * self.moment_z(),
            -(self.dir_x() * operand.y() * self.moment_z())
                - self.dir_x() * operand.z() * self.moment_y()
                + self.dir_y() * operand.x() * self.moment_z()
                - self.dir_y() * operand.z() * self.moment_x()
                + self.dir_z() * operand.x() * self.moment_y()
                + self.dir_z() * operand.y() * self.moment_x()
                + self.moment_x() * operand.w() * self.moment_x()
                + self.moment_x() * operand.y() * self.dir_z()
                - self.moment_x() * operand.z() * self.dir_y()
                + self.moment_y() * operand.w() * self.moment_y()
                + self.moment_y() * operand.x() * self.dir_z()
                - self.moment_y() * operand.z() * self.dir_x()
                + self.moment_z() * operand.w() * self.moment_z()
                + self.moment_z() * operand.x() * self.dir_y()
                - self.moment_z() * operand.y() * self.dir_x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Unitized<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -(operand.x() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + -(operand.x() * self.as_inner().moment_z() * self.as_inner().moment_z())
                + -T::TWO * operand.y() * self.as_inner().moment_x() * self.as_inner().moment_y()
                + T::TWO * operand.z() * self.as_inner().moment_x() * self.as_inner().moment_z()
                + operand.x() * self.as_inner().moment_x() * self.as_inner().moment_x(),
            -(operand.y() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.y() * self.as_inner().moment_z() * self.as_inner().moment_z())
                + -T::TWO * operand.x() * self.as_inner().moment_x() * self.as_inner().moment_y()
                + -T::TWO * operand.z() * self.as_inner().moment_y() * self.as_inner().moment_z()
                + operand.y() * self.as_inner().moment_y() * self.as_inner().moment_y(),
            -(operand.z() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.z() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + -T::TWO * operand.y() * self.as_inner().moment_y() * self.as_inner().moment_z()
                + T::TWO * operand.x() * self.as_inner().moment_x() * self.as_inner().moment_z()
                + operand.z() * self.as_inner().moment_z() * self.as_inner().moment_z(),
            -T::TWO * operand.y() * self.as_inner().dir_x() * self.as_inner().moment_z()
                + -T::TWO * operand.z() * self.as_inner().dir_x() * self.as_inner().moment_y()
                + -T::TWO * operand.z() * self.as_inner().dir_y() * self.as_inner().moment_x()
                + T::TWO * operand.x() * self.as_inner().dir_y() * self.as_inner().moment_z()
                + T::TWO * operand.x() * self.as_inner().dir_z() * self.as_inner().moment_y()
                + T::TWO * operand.y() * self.as_inner().dir_z() * self.as_inner().moment_x()
                + operand.w() * self.as_inner().moment_x() * self.as_inner().moment_x()
                + operand.w() * self.as_inner().moment_y() * self.as_inner().moment_y()
                + operand.w() * self.as_inner().moment_z() * self.as_inner().moment_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Point<T>>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x() * self.moment_y() * self.moment_y())
                + -(operand.as_inner().x() * self.moment_z() * self.moment_z())
                + -T::TWO * operand.as_inner().y() * self.moment_x() * self.moment_y()
                + T::TWO * operand.as_inner().z() * self.moment_x() * self.moment_z()
                + operand.as_inner().x() * self.moment_x() * self.moment_x(),
            -(operand.as_inner().y() * self.moment_x() * self.moment_x())
                + -(operand.as_inner().y() * self.moment_z() * self.moment_z())
                + -T::TWO * operand.as_inner().x() * self.moment_x() * self.moment_y()
                + -T::TWO * operand.as_inner().z() * self.moment_y() * self.moment_z()
                + operand.as_inner().y() * self.moment_y() * self.moment_y(),
            -(operand.as_inner().z() * self.moment_x() * self.moment_x())
                + -(operand.as_inner().z() * self.moment_y() * self.moment_y())
                + -T::TWO * operand.as_inner().y() * self.moment_y() * self.moment_z()
                + T::TWO * operand.as_inner().x() * self.moment_x() * self.moment_z()
                + operand.as_inner().z() * self.moment_z() * self.moment_z(),
            -T::TWO * operand.as_inner().y() * self.dir_x() * self.moment_z()
                + -T::TWO * operand.as_inner().z() * self.dir_x() * self.moment_y()
                + -T::TWO * operand.as_inner().z() * self.dir_y() * self.moment_x()
                + T::TWO * operand.as_inner().x() * self.dir_y() * self.moment_z()
                + T::TWO * operand.as_inner().x() * self.dir_z() * self.moment_y()
                + T::TWO * operand.as_inner().y() * self.dir_z() * self.moment_x()
                + operand.as_inner().w() * self.moment_x() * self.moment_x()
                + operand.as_inner().w() * self.moment_y() * self.moment_y()
                + operand.as_inner().w() * self.moment_z() * self.moment_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Point<T>>> for Unitized<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x() * self.as_inner().moment_y() * self.as_inner().moment_y())
                + -(operand.as_inner().x()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z())
                + -T::TWO
                    * operand.as_inner().y()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().z()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + operand.as_inner().x() * self.as_inner().moment_x() * self.as_inner().moment_x(),
            -(operand.as_inner().y() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.as_inner().y()
                    * self.as_inner().moment_z()
                    * self.as_inner().moment_z())
                + -T::TWO
                    * operand.as_inner().x()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_y()
                + -T::TWO
                    * operand.as_inner().z()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + operand.as_inner().y() * self.as_inner().moment_y() * self.as_inner().moment_y(),
            -(operand.as_inner().z() * self.as_inner().moment_x() * self.as_inner().moment_x())
                + -(operand.as_inner().z()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_y())
                + -T::TWO
                    * operand.as_inner().y()
                    * self.as_inner().moment_y()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().x()
                    * self.as_inner().moment_x()
                    * self.as_inner().moment_z()
                + operand.as_inner().z() * self.as_inner().moment_z() * self.as_inner().moment_z(),
            -T::TWO * operand.as_inner().y() * self.as_inner().dir_x() * self.as_inner().moment_z()
                + -T::TWO
                    * operand.as_inner().z()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_y()
                + -T::TWO
                    * operand.as_inner().z()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().x()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().x()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().y()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_x()
                + operand.as_inner().w() * self.as_inner().moment_x() * self.as_inner().moment_x()
                + operand.as_inner().w() * self.as_inner().moment_y() * self.as_inner().moment_y()
                + operand.as_inner().w() * self.as_inner().moment_z() * self.as_inner().moment_z(),
        )
    }
}
#[doc = "Sandwich product: [`Line`] x [`Quadvector`] x rev([`Line`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Quadvector<T>> for Line<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            self.moment_x() * operand.ps() * self.moment_x()
                + self.moment_y() * operand.ps() * self.moment_y()
                + self.moment_z() * operand.ps() * self.moment_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Quadvector<T>> for Unitized<Line<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            operand.ps() * self.as_inner().moment_x() * self.as_inner().moment_x()
                + operand.ps() * self.as_inner().moment_y() * self.as_inner().moment_y()
                + operand.ps() * self.as_inner().moment_z() * self.as_inner().moment_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Quadvector<T>>> for Line<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            operand.as_inner().ps() * self.moment_x() * self.moment_x()
                + operand.as_inner().ps() * self.moment_y() * self.moment_y()
                + operand.as_inner().ps() * self.moment_z() * self.moment_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Quadvector<T>>> for Unitized<Line<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            operand.as_inner().ps() * self.as_inner().moment_x() * self.as_inner().moment_x()
                + operand.as_inner().ps() * self.as_inner().moment_y() * self.as_inner().moment_y()
                + operand.as_inner().ps() * self.as_inner().moment_z() * self.as_inner().moment_z(),
        )
    }
}
#[doc = "Sandwich product: [`Line`] x [`Scalar`] x rev([`Line`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.moment_x() * operand.s() * self.moment_x()
                + self.moment_y() * operand.s() * self.moment_y()
                + self.moment_z() * operand.s() * self.moment_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unitized<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            operand.s() * self.as_inner().moment_x() * self.as_inner().moment_x()
                + operand.s() * self.as_inner().moment_y() * self.as_inner().moment_y()
                + operand.s() * self.as_inner().moment_z() * self.as_inner().moment_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Unitized<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Sandwich product: [`Motor`] x [`Flector`] x rev([`Motor`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Flector<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            -(self.rx() * operand.dist() * self.s()) + self.rx() * operand.px() * self.rx()
                - self.rx() * operand.py() * self.ty()
                + self.rx() * operand.pz() * self.tz()
                + self.s() * operand.dist() * self.rx()
                + self.s() * operand.px() * self.s()
                + self.s() * operand.py() * self.tz()
                + self.s() * operand.pz() * self.ty()
                + self.ty() * operand.dist() * self.tz()
                - self.ty() * operand.px() * self.ty()
                - self.ty() * operand.py() * self.rx()
                + self.ty() * operand.pz() * self.s()
                - self.tz() * operand.dist() * self.ty()
                - self.tz() * operand.px() * self.tz()
                + self.tz() * operand.py() * self.s()
                + self.tz() * operand.pz() * self.rx(),
            self.rx() * operand.dist() * self.tz()
                - self.rx() * operand.px() * self.ty()
                - self.rx() * operand.py() * self.rx()
                + self.rx() * operand.pz() * self.s()
                - self.s() * operand.dist() * self.ty()
                - self.s() * operand.px() * self.tz()
                + self.s() * operand.py() * self.s()
                + self.s() * operand.pz() * self.rx()
                + self.ty() * operand.dist() * self.s()
                - self.ty() * operand.px() * self.rx()
                + self.ty() * operand.py() * self.ty()
                - self.ty() * operand.pz() * self.tz()
                - self.tz() * operand.dist() * self.rx()
                - self.tz() * operand.px() * self.s()
                - self.tz() * operand.py() * self.tz()
                - self.tz() * operand.pz() * self.ty(),
            self.rx() * operand.dist() * self.ty() + self.rx() * operand.px() * self.tz()
                - self.rx() * operand.py() * self.s()
                - self.rx() * operand.pz() * self.rx()
                + self.s() * operand.dist() * self.tz()
                - self.s() * operand.px() * self.ty()
                - self.s() * operand.py() * self.rx()
                + self.s() * operand.pz() * self.s()
                - self.ty() * operand.dist() * self.rx()
                - self.ty() * operand.px() * self.s()
                - self.ty() * operand.py() * self.tz()
                - self.ty() * operand.pz() * self.ty()
                - self.tz() * operand.dist() * self.s()
                + self.tz() * operand.px() * self.rx()
                - self.tz() * operand.py() * self.ty()
                + self.tz() * operand.pz() * self.tz(),
            self.ps() * operand.dist() * self.s() - self.ps() * operand.px() * self.rx()
                + self.ps() * operand.py() * self.ty()
                - self.ps() * operand.pz() * self.tz()
                + self.rx() * operand.dist() * self.tx()
                - self.rx() * operand.nx() * self.s()
                + self.rx() * operand.ny() * self.tz()
                - self.rx() * operand.nz() * self.ty()
                + self.rx() * operand.pw() * self.rx()
                - self.rx() * operand.px() * self.ps()
                + self.rx() * operand.py() * self.rz()
                - self.rx() * operand.pz() * self.ry()
                + self.ry() * operand.dist() * self.ty()
                + self.ry() * operand.px() * self.tz()
                - self.ry() * operand.py() * self.s()
                - self.ry() * operand.pz() * self.rx()
                - self.rz() * operand.dist() * self.tz()
                + self.rz() * operand.px() * self.ty()
                + self.rz() * operand.py() * self.rx()
                - self.rz() * operand.pz() * self.s()
                - self.s() * operand.dist() * self.ps()
                + self.s() * operand.nx() * self.rx()
                + self.s() * operand.ny() * self.ty()
                + self.s() * operand.nz() * self.tz()
                + self.s() * operand.pw() * self.s()
                - self.s() * operand.px() * self.tx()
                - self.s() * operand.py() * self.ry()
                - self.s() * operand.pz() * self.rz()
                - self.tx() * operand.dist() * self.rx()
                - self.tx() * operand.px() * self.s()
                - self.tx() * operand.py() * self.tz()
                - self.tx() * operand.pz() * self.ty()
                - self.ty() * operand.dist() * self.ry()
                - self.ty() * operand.nx() * self.tz()
                - self.ty() * operand.ny() * self.s()
                + self.ty() * operand.nz() * self.rx()
                + self.ty() * operand.pw() * self.ty()
                + self.ty() * operand.px() * self.rz()
                + self.ty() * operand.py() * self.ps()
                - self.ty() * operand.pz() * self.tx()
                + self.tz() * operand.dist() * self.rz()
                + self.tz() * operand.nx() * self.ty()
                - self.tz() * operand.ny() * self.rx()
                - self.tz() * operand.nz() * self.s()
                + self.tz() * operand.pw() * self.tz()
                + self.tz() * operand.px() * self.ry()
                - self.tz() * operand.py() * self.tx()
                - self.tz() * operand.pz() * self.ps(),
            self.rx() * operand.dist() * self.rx()
                + self.rx() * operand.px() * self.s()
                + self.rx() * operand.py() * self.tz()
                + self.rx() * operand.pz() * self.ty()
                + self.s() * operand.dist() * self.s()
                - self.s() * operand.px() * self.rx()
                + self.s() * operand.py() * self.ty()
                - self.s() * operand.pz() * self.tz()
                + self.ty() * operand.dist() * self.ty()
                + self.ty() * operand.px() * self.tz()
                - self.ty() * operand.py() * self.s()
                - self.ty() * operand.pz() * self.rx()
                + self.tz() * operand.dist() * self.tz()
                - self.tz() * operand.px() * self.ty()
                - self.tz() * operand.py() * self.rx()
                + self.tz() * operand.pz() * self.s(),
            -(self.ps() * operand.dist() * self.tz())
                + self.ps() * operand.px() * self.ty()
                + self.ps() * operand.py() * self.rx()
                - self.ps() * operand.pz() * self.s()
                + self.rx() * operand.dist() * self.ry()
                + self.rx() * operand.nx() * self.tz()
                + self.rx() * operand.ny() * self.s()
                - self.rx() * operand.nz() * self.rx()
                - self.rx() * operand.pw() * self.ty()
                - self.rx() * operand.px() * self.rz()
                - self.rx() * operand.py() * self.ps()
                + self.rx() * operand.pz() * self.tx()
                + self.ry() * operand.dist() * self.rx()
                + self.ry() * operand.px() * self.s()
                + self.ry() * operand.py() * self.tz()
                + self.ry() * operand.pz() * self.ty()
                - self.rz() * operand.dist() * self.s()
                + self.rz() * operand.px() * self.rx()
                - self.rz() * operand.py() * self.ty()
                + self.rz() * operand.pz() * self.tz()
                - self.s() * operand.dist() * self.rz()
                - self.s() * operand.nx() * self.ty()
                + self.s() * operand.ny() * self.rx()
                + self.s() * operand.nz() * self.s()
                - self.s() * operand.pw() * self.tz()
                - self.s() * operand.px() * self.ry()
                + self.s() * operand.py() * self.tx()
                + self.s() * operand.pz() * self.ps()
                + self.tx() * operand.dist() * self.ty()
                + self.tx() * operand.px() * self.tz()
                - self.tx() * operand.py() * self.s()
                - self.tx() * operand.pz() * self.rx()
                + self.ty() * operand.dist() * self.tx()
                - self.ty() * operand.nx() * self.s()
                + self.ty() * operand.ny() * self.tz()
                - self.ty() * operand.nz() * self.ty()
                + self.ty() * operand.pw() * self.rx()
                - self.ty() * operand.px() * self.ps()
                + self.ty() * operand.py() * self.rz()
                - self.ty() * operand.pz() * self.ry()
                - self.tz() * operand.dist() * self.ps()
                + self.tz() * operand.nx() * self.rx()
                + self.tz() * operand.ny() * self.ty()
                + self.tz() * operand.nz() * self.tz()
                + self.tz() * operand.pw() * self.s()
                - self.tz() * operand.px() * self.tx()
                - self.tz() * operand.py() * self.ry()
                - self.tz() * operand.pz() * self.rz(),
            -(self.ps() * operand.dist() * self.ty()) - self.ps() * operand.px() * self.tz()
                + self.ps() * operand.py() * self.s()
                + self.ps() * operand.pz() * self.rx()
                + self.rx() * operand.dist() * self.rz()
                + self.rx() * operand.nx() * self.ty()
                - self.rx() * operand.ny() * self.rx()
                - self.rx() * operand.nz() * self.s()
                + self.rx() * operand.pw() * self.tz()
                + self.rx() * operand.px() * self.ry()
                - self.rx() * operand.py() * self.tx()
                - self.rx() * operand.pz() * self.ps()
                + self.ry() * operand.dist() * self.s()
                - self.ry() * operand.px() * self.rx()
                + self.ry() * operand.py() * self.ty()
                - self.ry() * operand.pz() * self.tz()
                + self.rz() * operand.dist() * self.rx()
                + self.rz() * operand.px() * self.s()
                + self.rz() * operand.py() * self.tz()
                + self.rz() * operand.pz() * self.ty()
                + self.s() * operand.dist() * self.ry()
                + self.s() * operand.nx() * self.tz()
                + self.s() * operand.ny() * self.s()
                - self.s() * operand.nz() * self.rx()
                - self.s() * operand.pw() * self.ty()
                - self.s() * operand.px() * self.rz()
                - self.s() * operand.py() * self.ps()
                + self.s() * operand.pz() * self.tx()
                - self.tx() * operand.dist() * self.tz()
                + self.tx() * operand.px() * self.ty()
                + self.tx() * operand.py() * self.rx()
                - self.tx() * operand.pz() * self.s()
                - self.ty() * operand.dist() * self.ps()
                + self.ty() * operand.nx() * self.rx()
                + self.ty() * operand.ny() * self.ty()
                + self.ty() * operand.nz() * self.tz()
                + self.ty() * operand.pw() * self.s()
                - self.ty() * operand.px() * self.tx()
                - self.ty() * operand.py() * self.ry()
                - self.ty() * operand.pz() * self.rz()
                - self.tz() * operand.dist() * self.tx()
                + self.tz() * operand.nx() * self.s()
                - self.tz() * operand.ny() * self.tz()
                + self.tz() * operand.nz() * self.ty()
                - self.tz() * operand.pw() * self.rx()
                + self.tz() * operand.px() * self.ps()
                - self.tz() * operand.py() * self.rz()
                + self.tz() * operand.pz() * self.ry(),
            -(self.ps() * operand.dist() * self.rx())
                - self.ps() * operand.px() * self.s()
                - self.ps() * operand.py() * self.tz()
                - self.ps() * operand.pz() * self.ty()
                - self.rx() * operand.dist() * self.ps()
                + self.rx() * operand.nx() * self.rx()
                + self.rx() * operand.ny() * self.ty()
                + self.rx() * operand.nz() * self.tz()
                + self.rx() * operand.pw() * self.s()
                - self.rx() * operand.px() * self.tx()
                - self.rx() * operand.py() * self.ry()
                - self.rx() * operand.pz() * self.rz()
                - self.ry() * operand.dist() * self.tz()
                + self.ry() * operand.px() * self.ty()
                + self.ry() * operand.py() * self.rx()
                - self.ry() * operand.pz() * self.s()
                - self.rz() * operand.dist() * self.ty()
                - self.rz() * operand.px() * self.tz()
                + self.rz() * operand.py() * self.s()
                + self.rz() * operand.pz() * self.rx()
                - self.s() * operand.dist() * self.tx()
                + self.s() * operand.nx() * self.s()
                - self.s() * operand.ny() * self.tz()
                + self.s() * operand.nz() * self.ty()
                - self.s() * operand.pw() * self.rx()
                + self.s() * operand.px() * self.ps()
                - self.s() * operand.py() * self.rz()
                + self.s() * operand.pz() * self.ry()
                - self.tx() * operand.dist() * self.s()
                + self.tx() * operand.px() * self.rx()
                - self.tx() * operand.py() * self.ty()
                + self.tx() * operand.pz() * self.tz()
                - self.ty() * operand.dist() * self.rz()
                - self.ty() * operand.nx() * self.ty()
                + self.ty() * operand.ny() * self.rx()
                + self.ty() * operand.nz() * self.s()
                - self.ty() * operand.pw() * self.tz()
                - self.ty() * operand.px() * self.ry()
                + self.ty() * operand.py() * self.tx()
                + self.ty() * operand.pz() * self.ps()
                - self.tz() * operand.dist() * self.ry()
                - self.tz() * operand.nx() * self.tz()
                - self.tz() * operand.ny() * self.s()
                + self.tz() * operand.nz() * self.rx()
                + self.tz() * operand.pw() * self.ty()
                + self.tz() * operand.px() * self.rz()
                + self.tz() * operand.py() * self.ps()
                - self.tz() * operand.pz() * self.tx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Flector<T>> for Unitized<Motor<T>> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            -(operand.px() * self.as_inner().ty() * self.as_inner().ty())
                + -(operand.px() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.py() * self.as_inner().rx() * self.as_inner().ty()
                + T::TWO * operand.py() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.pz() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.pz() * self.as_inner().s() * self.as_inner().ty()
                + operand.px() * self.as_inner().rx() * self.as_inner().rx()
                + operand.px() * self.as_inner().s() * self.as_inner().s(),
            -(operand.py() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.py() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.px() * self.as_inner().rx() * self.as_inner().ty()
                + -T::TWO * operand.px() * self.as_inner().s() * self.as_inner().tz()
                + -T::TWO * operand.pz() * self.as_inner().ty() * self.as_inner().tz()
                + T::TWO * operand.pz() * self.as_inner().rx() * self.as_inner().s()
                + operand.py() * self.as_inner().s() * self.as_inner().s()
                + operand.py() * self.as_inner().ty() * self.as_inner().ty(),
            -(operand.pz() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.pz() * self.as_inner().ty() * self.as_inner().ty())
                + -T::TWO * operand.px() * self.as_inner().s() * self.as_inner().ty()
                + -T::TWO * operand.py() * self.as_inner().rx() * self.as_inner().s()
                + -T::TWO * operand.py() * self.as_inner().ty() * self.as_inner().tz()
                + T::TWO * operand.px() * self.as_inner().rx() * self.as_inner().tz()
                + operand.pz() * self.as_inner().s() * self.as_inner().s()
                + operand.pz() * self.as_inner().tz() * self.as_inner().tz(),
            -T::TWO * operand.px() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.px() * self.as_inner().s() * self.as_inner().tx()
                + -T::TWO * operand.py() * self.as_inner().ry() * self.as_inner().s()
                + -T::TWO * operand.py() * self.as_inner().tx() * self.as_inner().tz()
                + -T::TWO * operand.pz() * self.as_inner().ps() * self.as_inner().tz()
                + -T::TWO * operand.pz() * self.as_inner().rx() * self.as_inner().ry()
                + -T::TWO * operand.pz() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.pz() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.px() * self.as_inner().ry() * self.as_inner().tz()
                + T::TWO * operand.px() * self.as_inner().rz() * self.as_inner().ty()
                + T::TWO * operand.py() * self.as_inner().ps() * self.as_inner().ty()
                + T::TWO * operand.py() * self.as_inner().rx() * self.as_inner().rz()
                + operand.pw() * self.as_inner().rx() * self.as_inner().rx()
                + operand.pw() * self.as_inner().s() * self.as_inner().s()
                + operand.pw() * self.as_inner().ty() * self.as_inner().ty()
                + operand.pw() * self.as_inner().tz() * self.as_inner().tz(),
            operand.dist() * self.as_inner().rx() * self.as_inner().rx()
                + operand.dist() * self.as_inner().s() * self.as_inner().s()
                + operand.dist() * self.as_inner().ty() * self.as_inner().ty()
                + operand.dist() * self.as_inner().tz() * self.as_inner().tz(),
            -(operand.nz() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.nz() * self.as_inner().ty() * self.as_inner().ty())
                + -T::TWO * operand.dist() * self.as_inner().ps() * self.as_inner().tz()
                + -T::TWO * operand.dist() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.nx() * self.as_inner().s() * self.as_inner().ty()
                + T::TWO * operand.dist() * self.as_inner().rx() * self.as_inner().ry()
                + T::TWO * operand.dist() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.nx() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.ny() * self.as_inner().rx() * self.as_inner().s()
                + T::TWO * operand.ny() * self.as_inner().ty() * self.as_inner().tz()
                + operand.nz() * self.as_inner().s() * self.as_inner().s()
                + operand.nz() * self.as_inner().tz() * self.as_inner().tz(),
            -(operand.ny() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.ny() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.dist() * self.as_inner().ps() * self.as_inner().ty()
                + -T::TWO * operand.dist() * self.as_inner().tx() * self.as_inner().tz()
                + -T::TWO * operand.nz() * self.as_inner().rx() * self.as_inner().s()
                + T::TWO * operand.dist() * self.as_inner().rx() * self.as_inner().rz()
                + T::TWO * operand.dist() * self.as_inner().ry() * self.as_inner().s()
                + T::TWO * operand.nx() * self.as_inner().rx() * self.as_inner().ty()
                + T::TWO * operand.nx() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.nz() * self.as_inner().ty() * self.as_inner().tz()
                + operand.ny() * self.as_inner().s() * self.as_inner().s()
                + operand.ny() * self.as_inner().ty() * self.as_inner().ty(),
            -(operand.nx() * self.as_inner().ty() * self.as_inner().ty())
                + -(operand.nx() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.dist() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.dist() * self.as_inner().ry() * self.as_inner().tz()
                + -T::TWO * operand.dist() * self.as_inner().rz() * self.as_inner().ty()
                + -T::TWO * operand.dist() * self.as_inner().s() * self.as_inner().tx()
                + -T::TWO * operand.ny() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.ny() * self.as_inner().rx() * self.as_inner().ty()
                + T::TWO * operand.nz() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.nz() * self.as_inner().s() * self.as_inner().ty()
                + operand.nx() * self.as_inner().rx() * self.as_inner().rx()
                + operand.nx() * self.as_inner().s() * self.as_inner().s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Flector<T>>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            -(operand.as_inner().px() * self.ty() * self.ty())
                + -(operand.as_inner().px() * self.tz() * self.tz())
                + -T::TWO * operand.as_inner().py() * self.rx() * self.ty()
                + T::TWO * operand.as_inner().py() * self.s() * self.tz()
                + T::TWO * operand.as_inner().pz() * self.rx() * self.tz()
                + T::TWO * operand.as_inner().pz() * self.s() * self.ty()
                + operand.as_inner().px() * self.rx() * self.rx()
                + operand.as_inner().px() * self.s() * self.s(),
            -(operand.as_inner().py() * self.rx() * self.rx())
                + -(operand.as_inner().py() * self.tz() * self.tz())
                + -T::TWO * operand.as_inner().px() * self.rx() * self.ty()
                + -T::TWO * operand.as_inner().px() * self.s() * self.tz()
                + -T::TWO * operand.as_inner().pz() * self.ty() * self.tz()
                + T::TWO * operand.as_inner().pz() * self.rx() * self.s()
                + operand.as_inner().py() * self.s() * self.s()
                + operand.as_inner().py() * self.ty() * self.ty(),
            -(operand.as_inner().pz() * self.rx() * self.rx())
                + -(operand.as_inner().pz() * self.ty() * self.ty())
                + -T::TWO * operand.as_inner().px() * self.s() * self.ty()
                + -T::TWO * operand.as_inner().py() * self.rx() * self.s()
                + -T::TWO * operand.as_inner().py() * self.ty() * self.tz()
                + T::TWO * operand.as_inner().px() * self.rx() * self.tz()
                + operand.as_inner().pz() * self.s() * self.s()
                + operand.as_inner().pz() * self.tz() * self.tz(),
            -T::TWO * operand.as_inner().px() * self.ps() * self.rx()
                + -T::TWO * operand.as_inner().px() * self.s() * self.tx()
                + -T::TWO * operand.as_inner().py() * self.ry() * self.s()
                + -T::TWO * operand.as_inner().py() * self.tx() * self.tz()
                + -T::TWO * operand.as_inner().pz() * self.ps() * self.tz()
                + -T::TWO * operand.as_inner().pz() * self.rx() * self.ry()
                + -T::TWO * operand.as_inner().pz() * self.rz() * self.s()
                + -T::TWO * operand.as_inner().pz() * self.tx() * self.ty()
                + T::TWO * operand.as_inner().px() * self.ry() * self.tz()
                + T::TWO * operand.as_inner().px() * self.rz() * self.ty()
                + T::TWO * operand.as_inner().py() * self.ps() * self.ty()
                + T::TWO * operand.as_inner().py() * self.rx() * self.rz()
                + operand.as_inner().pw() * self.rx() * self.rx()
                + operand.as_inner().pw() * self.s() * self.s()
                + operand.as_inner().pw() * self.ty() * self.ty()
                + operand.as_inner().pw() * self.tz() * self.tz(),
            operand.as_inner().dist() * self.rx() * self.rx()
                + operand.as_inner().dist() * self.s() * self.s()
                + operand.as_inner().dist() * self.ty() * self.ty()
                + operand.as_inner().dist() * self.tz() * self.tz(),
            -(operand.as_inner().nz() * self.rx() * self.rx())
                + -(operand.as_inner().nz() * self.ty() * self.ty())
                + -T::TWO * operand.as_inner().dist() * self.ps() * self.tz()
                + -T::TWO * operand.as_inner().dist() * self.rz() * self.s()
                + -T::TWO * operand.as_inner().nx() * self.s() * self.ty()
                + T::TWO * operand.as_inner().dist() * self.rx() * self.ry()
                + T::TWO * operand.as_inner().dist() * self.tx() * self.ty()
                + T::TWO * operand.as_inner().nx() * self.rx() * self.tz()
                + T::TWO * operand.as_inner().ny() * self.rx() * self.s()
                + T::TWO * operand.as_inner().ny() * self.ty() * self.tz()
                + operand.as_inner().nz() * self.s() * self.s()
                + operand.as_inner().nz() * self.tz() * self.tz(),
            -(operand.as_inner().ny() * self.rx() * self.rx())
                + -(operand.as_inner().ny() * self.tz() * self.tz())
                + -T::TWO * operand.as_inner().dist() * self.ps() * self.ty()
                + -T::TWO * operand.as_inner().dist() * self.tx() * self.tz()
                + -T::TWO * operand.as_inner().nz() * self.rx() * self.s()
                + T::TWO * operand.as_inner().dist() * self.rx() * self.rz()
                + T::TWO * operand.as_inner().dist() * self.ry() * self.s()
                + T::TWO * operand.as_inner().nx() * self.rx() * self.ty()
                + T::TWO * operand.as_inner().nx() * self.s() * self.tz()
                + T::TWO * operand.as_inner().nz() * self.ty() * self.tz()
                + operand.as_inner().ny() * self.s() * self.s()
                + operand.as_inner().ny() * self.ty() * self.ty(),
            -(operand.as_inner().nx() * self.ty() * self.ty())
                + -(operand.as_inner().nx() * self.tz() * self.tz())
                + -T::TWO * operand.as_inner().dist() * self.ps() * self.rx()
                + -T::TWO * operand.as_inner().dist() * self.ry() * self.tz()
                + -T::TWO * operand.as_inner().dist() * self.rz() * self.ty()
                + -T::TWO * operand.as_inner().dist() * self.s() * self.tx()
                + -T::TWO * operand.as_inner().ny() * self.s() * self.tz()
                + T::TWO * operand.as_inner().ny() * self.rx() * self.ty()
                + T::TWO * operand.as_inner().nz() * self.rx() * self.tz()
                + T::TWO * operand.as_inner().nz() * self.s() * self.ty()
                + operand.as_inner().nx() * self.rx() * self.rx()
                + operand.as_inner().nx() * self.s() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Flector<T>>> for Unitized<Motor<T>> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            -(operand.as_inner().px() * self.as_inner().ty() * self.as_inner().ty())
                + -(operand.as_inner().px() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.as_inner().py() * self.as_inner().rx() * self.as_inner().ty()
                + T::TWO * operand.as_inner().py() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.as_inner().pz() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.as_inner().pz() * self.as_inner().s() * self.as_inner().ty()
                + operand.as_inner().px() * self.as_inner().rx() * self.as_inner().rx()
                + operand.as_inner().px() * self.as_inner().s() * self.as_inner().s(),
            -(operand.as_inner().py() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.as_inner().py() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.as_inner().px() * self.as_inner().rx() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().px() * self.as_inner().s() * self.as_inner().tz()
                + -T::TWO * operand.as_inner().pz() * self.as_inner().ty() * self.as_inner().tz()
                + T::TWO * operand.as_inner().pz() * self.as_inner().rx() * self.as_inner().s()
                + operand.as_inner().py() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().py() * self.as_inner().ty() * self.as_inner().ty(),
            -(operand.as_inner().pz() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.as_inner().pz() * self.as_inner().ty() * self.as_inner().ty())
                + -T::TWO * operand.as_inner().px() * self.as_inner().s() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().py() * self.as_inner().rx() * self.as_inner().s()
                + -T::TWO * operand.as_inner().py() * self.as_inner().ty() * self.as_inner().tz()
                + T::TWO * operand.as_inner().px() * self.as_inner().rx() * self.as_inner().tz()
                + operand.as_inner().pz() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().pz() * self.as_inner().tz() * self.as_inner().tz(),
            -T::TWO * operand.as_inner().px() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.as_inner().px() * self.as_inner().s() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().py() * self.as_inner().ry() * self.as_inner().s()
                + -T::TWO * operand.as_inner().py() * self.as_inner().tx() * self.as_inner().tz()
                + -T::TWO * operand.as_inner().pz() * self.as_inner().ps() * self.as_inner().tz()
                + -T::TWO * operand.as_inner().pz() * self.as_inner().rx() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().pz() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.as_inner().pz() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.as_inner().px() * self.as_inner().ry() * self.as_inner().tz()
                + T::TWO * operand.as_inner().px() * self.as_inner().rz() * self.as_inner().ty()
                + T::TWO * operand.as_inner().py() * self.as_inner().ps() * self.as_inner().ty()
                + T::TWO * operand.as_inner().py() * self.as_inner().rx() * self.as_inner().rz()
                + operand.as_inner().pw() * self.as_inner().rx() * self.as_inner().rx()
                + operand.as_inner().pw() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().pw() * self.as_inner().ty() * self.as_inner().ty()
                + operand.as_inner().pw() * self.as_inner().tz() * self.as_inner().tz(),
            operand.as_inner().dist() * self.as_inner().rx() * self.as_inner().rx()
                + operand.as_inner().dist() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().dist() * self.as_inner().ty() * self.as_inner().ty()
                + operand.as_inner().dist() * self.as_inner().tz() * self.as_inner().tz(),
            -(operand.as_inner().nz() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.as_inner().nz() * self.as_inner().ty() * self.as_inner().ty())
                + -T::TWO * operand.as_inner().dist() * self.as_inner().ps() * self.as_inner().tz()
                + -T::TWO * operand.as_inner().dist() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.as_inner().nx() * self.as_inner().s() * self.as_inner().ty()
                + T::TWO * operand.as_inner().dist() * self.as_inner().rx() * self.as_inner().ry()
                + T::TWO * operand.as_inner().dist() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.as_inner().nx() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.as_inner().ny() * self.as_inner().rx() * self.as_inner().s()
                + T::TWO * operand.as_inner().ny() * self.as_inner().ty() * self.as_inner().tz()
                + operand.as_inner().nz() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().nz() * self.as_inner().tz() * self.as_inner().tz(),
            -(operand.as_inner().ny() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.as_inner().ny() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.as_inner().dist() * self.as_inner().ps() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().dist() * self.as_inner().tx() * self.as_inner().tz()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().rx() * self.as_inner().s()
                + T::TWO * operand.as_inner().dist() * self.as_inner().rx() * self.as_inner().rz()
                + T::TWO * operand.as_inner().dist() * self.as_inner().ry() * self.as_inner().s()
                + T::TWO * operand.as_inner().nx() * self.as_inner().rx() * self.as_inner().ty()
                + T::TWO * operand.as_inner().nx() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.as_inner().nz() * self.as_inner().ty() * self.as_inner().tz()
                + operand.as_inner().ny() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().ny() * self.as_inner().ty() * self.as_inner().ty(),
            -(operand.as_inner().nx() * self.as_inner().ty() * self.as_inner().ty())
                + -(operand.as_inner().nx() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.as_inner().dist() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.as_inner().dist() * self.as_inner().ry() * self.as_inner().tz()
                + -T::TWO * operand.as_inner().dist() * self.as_inner().rz() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().dist() * self.as_inner().s() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.as_inner().ny() * self.as_inner().rx() * self.as_inner().ty()
                + T::TWO * operand.as_inner().nz() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.as_inner().nz() * self.as_inner().s() * self.as_inner().ty()
                + operand.as_inner().nx() * self.as_inner().rx() * self.as_inner().rx()
                + operand.as_inner().nx() * self.as_inner().s() * self.as_inner().s(),
        )
    }
}
#[doc = "Sandwich product: [`Motor`] x [`Line`] x rev([`Motor`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Motor<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.rx() * operand.moment_x() * self.tz() + self.rx() * operand.moment_y() * self.s()
                - self.rx() * operand.moment_z() * self.rx()
                - self.s() * operand.moment_x() * self.ty()
                + self.s() * operand.moment_y() * self.rx()
                + self.s() * operand.moment_z() * self.s()
                - self.ty() * operand.moment_x() * self.s()
                + self.ty() * operand.moment_y() * self.tz()
                - self.ty() * operand.moment_z() * self.ty()
                + self.tz() * operand.moment_x() * self.rx()
                + self.tz() * operand.moment_y() * self.ty()
                + self.tz() * operand.moment_z() * self.tz(),
            self.rx() * operand.moment_x() * self.ty()
                - self.rx() * operand.moment_y() * self.rx()
                - self.rx() * operand.moment_z() * self.s()
                + self.s() * operand.moment_x() * self.tz()
                + self.s() * operand.moment_y() * self.s()
                - self.s() * operand.moment_z() * self.rx()
                + self.ty() * operand.moment_x() * self.rx()
                + self.ty() * operand.moment_y() * self.ty()
                + self.ty() * operand.moment_z() * self.tz()
                + self.tz() * operand.moment_x() * self.s()
                - self.tz() * operand.moment_y() * self.tz()
                + self.tz() * operand.moment_z() * self.ty(),
            -(self.ps() * operand.moment_x() * self.s())
                + self.ps() * operand.moment_y() * self.tz()
                - self.ps() * operand.moment_z() * self.ty()
                + self.rx() * operand.dir_x() * self.rx()
                - self.rx() * operand.dir_y() * self.ty()
                + self.rx() * operand.dir_z() * self.tz()
                + self.rx() * operand.moment_x() * self.tx()
                - self.rx() * operand.moment_y() * self.ry()
                + self.rx() * operand.moment_z() * self.rz()
                + self.ry() * operand.moment_x() * self.ty()
                - self.ry() * operand.moment_y() * self.rx()
                - self.ry() * operand.moment_z() * self.s()
                - self.rz() * operand.moment_x() * self.tz()
                - self.rz() * operand.moment_y() * self.s()
                + self.rz() * operand.moment_z() * self.rx()
                + self.s() * operand.dir_x() * self.s()
                + self.s() * operand.dir_y() * self.tz()
                + self.s() * operand.dir_z() * self.ty()
                - self.s() * operand.moment_x() * self.ps()
                - self.s() * operand.moment_y() * self.rz()
                - self.s() * operand.moment_z() * self.ry()
                + self.tx() * operand.moment_x() * self.rx()
                + self.tx() * operand.moment_y() * self.ty()
                + self.tx() * operand.moment_z() * self.tz()
                - self.ty() * operand.dir_x() * self.ty()
                - self.ty() * operand.dir_y() * self.rx()
                + self.ty() * operand.dir_z() * self.s()
                + self.ty() * operand.moment_x() * self.ry()
                + self.ty() * operand.moment_y() * self.tx()
                - self.ty() * operand.moment_z() * self.ps()
                - self.tz() * operand.dir_x() * self.tz()
                + self.tz() * operand.dir_y() * self.s()
                + self.tz() * operand.dir_z() * self.rx()
                - self.tz() * operand.moment_x() * self.rz()
                + self.tz() * operand.moment_y() * self.ps()
                + self.tz() * operand.moment_z() * self.tx(),
            self.rx() * operand.moment_x() * self.rx()
                + self.rx() * operand.moment_y() * self.ty()
                + self.rx() * operand.moment_z() * self.tz()
                + self.s() * operand.moment_x() * self.s()
                - self.s() * operand.moment_y() * self.tz()
                + self.s() * operand.moment_z() * self.ty()
                - self.ty() * operand.moment_x() * self.ty()
                + self.ty() * operand.moment_y() * self.rx()
                + self.ty() * operand.moment_z() * self.s()
                - self.tz() * operand.moment_x() * self.tz()
                - self.tz() * operand.moment_y() * self.s()
                + self.tz() * operand.moment_z() * self.rx(),
            self.ps() * operand.moment_x() * self.tz() + self.ps() * operand.moment_y() * self.s()
                - self.ps() * operand.moment_z() * self.rx()
                - self.rx() * operand.dir_x() * self.ty()
                - self.rx() * operand.dir_y() * self.rx()
                + self.rx() * operand.dir_z() * self.s()
                + self.rx() * operand.moment_x() * self.ry()
                + self.rx() * operand.moment_y() * self.tx()
                - self.rx() * operand.moment_z() * self.ps()
                + self.ry() * operand.moment_x() * self.rx()
                + self.ry() * operand.moment_y() * self.ty()
                + self.ry() * operand.moment_z() * self.tz()
                - self.rz() * operand.moment_x() * self.s()
                + self.rz() * operand.moment_y() * self.tz()
                - self.rz() * operand.moment_z() * self.ty()
                - self.s() * operand.dir_x() * self.tz()
                + self.s() * operand.dir_y() * self.s()
                + self.s() * operand.dir_z() * self.rx()
                - self.s() * operand.moment_x() * self.rz()
                + self.s() * operand.moment_y() * self.ps()
                + self.s() * operand.moment_z() * self.tx()
                - self.tx() * operand.moment_x() * self.ty()
                + self.tx() * operand.moment_y() * self.rx()
                + self.tx() * operand.moment_z() * self.s()
                - self.ty() * operand.dir_x() * self.rx()
                + self.ty() * operand.dir_y() * self.ty()
                - self.ty() * operand.dir_z() * self.tz()
                - self.ty() * operand.moment_x() * self.tx()
                + self.ty() * operand.moment_y() * self.ry()
                - self.ty() * operand.moment_z() * self.rz()
                - self.tz() * operand.dir_x() * self.s()
                - self.tz() * operand.dir_y() * self.tz()
                - self.tz() * operand.dir_z() * self.ty()
                + self.tz() * operand.moment_x() * self.ps()
                + self.tz() * operand.moment_y() * self.rz()
                + self.tz() * operand.moment_z() * self.ry(),
            self.ps() * operand.moment_x() * self.ty()
                - self.ps() * operand.moment_y() * self.rx()
                - self.ps() * operand.moment_z() * self.s()
                + self.rx() * operand.dir_x() * self.tz()
                - self.rx() * operand.dir_y() * self.s()
                - self.rx() * operand.dir_z() * self.rx()
                + self.rx() * operand.moment_x() * self.rz()
                - self.rx() * operand.moment_y() * self.ps()
                - self.rx() * operand.moment_z() * self.tx()
                + self.ry() * operand.moment_x() * self.s()
                - self.ry() * operand.moment_y() * self.tz()
                + self.ry() * operand.moment_z() * self.ty()
                + self.rz() * operand.moment_x() * self.rx()
                + self.rz() * operand.moment_y() * self.ty()
                + self.rz() * operand.moment_z() * self.tz()
                - self.s() * operand.dir_x() * self.ty()
                - self.s() * operand.dir_y() * self.rx()
                + self.s() * operand.dir_z() * self.s()
                + self.s() * operand.moment_x() * self.ry()
                + self.s() * operand.moment_y() * self.tx()
                - self.s() * operand.moment_z() * self.ps()
                + self.tx() * operand.moment_x() * self.tz()
                + self.tx() * operand.moment_y() * self.s()
                - self.tx() * operand.moment_z() * self.rx()
                - self.ty() * operand.dir_x() * self.s()
                - self.ty() * operand.dir_y() * self.tz()
                - self.ty() * operand.dir_z() * self.ty()
                + self.ty() * operand.moment_x() * self.ps()
                + self.ty() * operand.moment_y() * self.rz()
                + self.ty() * operand.moment_z() * self.ry()
                + self.tz() * operand.dir_x() * self.rx()
                - self.tz() * operand.dir_y() * self.ty()
                + self.tz() * operand.dir_z() * self.tz()
                + self.tz() * operand.moment_x() * self.tx()
                - self.tz() * operand.moment_y() * self.ry()
                + self.tz() * operand.moment_z() * self.rz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Unitized<Motor<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            -(operand.moment_z() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.moment_z() * self.as_inner().ty() * self.as_inner().ty())
                + -T::TWO * operand.moment_x() * self.as_inner().s() * self.as_inner().ty()
                + T::TWO * operand.moment_x() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.moment_y() * self.as_inner().rx() * self.as_inner().s()
                + T::TWO * operand.moment_y() * self.as_inner().ty() * self.as_inner().tz()
                + operand.moment_z() * self.as_inner().s() * self.as_inner().s()
                + operand.moment_z() * self.as_inner().tz() * self.as_inner().tz(),
            -(operand.moment_y() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.moment_y() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.moment_z() * self.as_inner().rx() * self.as_inner().s()
                + T::TWO * operand.moment_x() * self.as_inner().rx() * self.as_inner().ty()
                + T::TWO * operand.moment_x() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.moment_z() * self.as_inner().ty() * self.as_inner().tz()
                + operand.moment_y() * self.as_inner().s() * self.as_inner().s()
                + operand.moment_y() * self.as_inner().ty() * self.as_inner().ty(),
            -(operand.dir_x() * self.as_inner().ty() * self.as_inner().ty())
                + -(operand.dir_x() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.dir_y() * self.as_inner().rx() * self.as_inner().ty()
                + -T::TWO * operand.moment_y() * self.as_inner().rx() * self.as_inner().ry()
                + -T::TWO * operand.moment_y() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.moment_z() * self.as_inner().ps() * self.as_inner().ty()
                + -T::TWO * operand.moment_z() * self.as_inner().ry() * self.as_inner().s()
                + T::TWO * operand.dir_y() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.dir_z() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.dir_z() * self.as_inner().s() * self.as_inner().ty()
                + T::TWO * operand.moment_y() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.moment_y() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.moment_z() * self.as_inner().rx() * self.as_inner().rz()
                + T::TWO * operand.moment_z() * self.as_inner().tx() * self.as_inner().tz()
                + T::from_i8(-4i8)
                    * operand.moment_x()
                    * self.as_inner().rz()
                    * self.as_inner().tz()
                + T::from_i8(4i8)
                    * operand.moment_x()
                    * self.as_inner().ry()
                    * self.as_inner().ty()
                + operand.dir_x() * self.as_inner().rx() * self.as_inner().rx()
                + operand.dir_x() * self.as_inner().s() * self.as_inner().s(),
            -(operand.moment_x() * self.as_inner().ty() * self.as_inner().ty())
                + -(operand.moment_x() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.moment_y() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.moment_y() * self.as_inner().rx() * self.as_inner().ty()
                + T::TWO * operand.moment_z() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.moment_z() * self.as_inner().s() * self.as_inner().ty()
                + operand.moment_x() * self.as_inner().rx() * self.as_inner().rx()
                + operand.moment_x() * self.as_inner().s() * self.as_inner().s(),
            -(operand.dir_y() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.dir_y() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.dir_x() * self.as_inner().rx() * self.as_inner().ty()
                + -T::TWO * operand.dir_x() * self.as_inner().s() * self.as_inner().tz()
                + -T::TWO * operand.dir_z() * self.as_inner().ty() * self.as_inner().tz()
                + -T::TWO * operand.moment_x() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.moment_x() * self.as_inner().tx() * self.as_inner().ty()
                + -T::TWO * operand.moment_z() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.moment_z() * self.as_inner().rz() * self.as_inner().ty()
                + T::TWO * operand.dir_z() * self.as_inner().rx() * self.as_inner().s()
                + T::TWO * operand.moment_x() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.moment_x() * self.as_inner().rx() * self.as_inner().ry()
                + T::TWO * operand.moment_z() * self.as_inner().ry() * self.as_inner().tz()
                + T::TWO * operand.moment_z() * self.as_inner().s() * self.as_inner().tx()
                + T::from_i8(4i8)
                    * operand.moment_y()
                    * self.as_inner().rx()
                    * self.as_inner().tx()
                + T::from_i8(4i8)
                    * operand.moment_y()
                    * self.as_inner().rz()
                    * self.as_inner().tz()
                + operand.dir_y() * self.as_inner().s() * self.as_inner().s()
                + operand.dir_y() * self.as_inner().ty() * self.as_inner().ty(),
            -(operand.dir_z() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.dir_z() * self.as_inner().ty() * self.as_inner().ty())
                + -T::TWO * operand.dir_x() * self.as_inner().s() * self.as_inner().ty()
                + -T::TWO * operand.dir_y() * self.as_inner().rx() * self.as_inner().s()
                + -T::TWO * operand.dir_y() * self.as_inner().ty() * self.as_inner().tz()
                + -T::TWO * operand.moment_y() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.moment_y() * self.as_inner().ry() * self.as_inner().tz()
                + T::TWO * operand.dir_x() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.moment_x() * self.as_inner().ps() * self.as_inner().ty()
                + T::TWO * operand.moment_x() * self.as_inner().rx() * self.as_inner().rz()
                + T::TWO * operand.moment_x() * self.as_inner().ry() * self.as_inner().s()
                + T::TWO * operand.moment_x() * self.as_inner().tx() * self.as_inner().tz()
                + T::TWO * operand.moment_y() * self.as_inner().rz() * self.as_inner().ty()
                + T::TWO * operand.moment_y() * self.as_inner().s() * self.as_inner().tx()
                + T::from_i8(-4i8)
                    * operand.moment_z()
                    * self.as_inner().rx()
                    * self.as_inner().tx()
                + T::from_i8(4i8)
                    * operand.moment_z()
                    * self.as_inner().ry()
                    * self.as_inner().ty()
                + operand.dir_z() * self.as_inner().s() * self.as_inner().s()
                + operand.dir_z() * self.as_inner().tz() * self.as_inner().tz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Line<T>>> for Motor<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(operand.as_inner().moment_z() * self.rx() * self.rx())
                + -(operand.as_inner().moment_z() * self.ty() * self.ty())
                + -T::TWO * operand.as_inner().moment_x() * self.s() * self.ty()
                + T::TWO * operand.as_inner().moment_x() * self.rx() * self.tz()
                + T::TWO * operand.as_inner().moment_y() * self.rx() * self.s()
                + T::TWO * operand.as_inner().moment_y() * self.ty() * self.tz()
                + operand.as_inner().moment_z() * self.s() * self.s()
                + operand.as_inner().moment_z() * self.tz() * self.tz(),
            -(operand.as_inner().moment_y() * self.rx() * self.rx())
                + -(operand.as_inner().moment_y() * self.tz() * self.tz())
                + -T::TWO * operand.as_inner().moment_z() * self.rx() * self.s()
                + T::TWO * operand.as_inner().moment_x() * self.rx() * self.ty()
                + T::TWO * operand.as_inner().moment_x() * self.s() * self.tz()
                + T::TWO * operand.as_inner().moment_z() * self.ty() * self.tz()
                + operand.as_inner().moment_y() * self.s() * self.s()
                + operand.as_inner().moment_y() * self.ty() * self.ty(),
            -(operand.as_inner().dir_x() * self.ty() * self.ty())
                + -(operand.as_inner().dir_x() * self.tz() * self.tz())
                + -T::TWO * operand.as_inner().dir_y() * self.rx() * self.ty()
                + -T::TWO * operand.as_inner().moment_y() * self.rx() * self.ry()
                + -T::TWO * operand.as_inner().moment_y() * self.rz() * self.s()
                + -T::TWO * operand.as_inner().moment_z() * self.ps() * self.ty()
                + -T::TWO * operand.as_inner().moment_z() * self.ry() * self.s()
                + T::TWO * operand.as_inner().dir_y() * self.s() * self.tz()
                + T::TWO * operand.as_inner().dir_z() * self.rx() * self.tz()
                + T::TWO * operand.as_inner().dir_z() * self.s() * self.ty()
                + T::TWO * operand.as_inner().moment_y() * self.ps() * self.tz()
                + T::TWO * operand.as_inner().moment_y() * self.tx() * self.ty()
                + T::TWO * operand.as_inner().moment_z() * self.rx() * self.rz()
                + T::TWO * operand.as_inner().moment_z() * self.tx() * self.tz()
                + T::from_i8(-4i8) * operand.as_inner().moment_x() * self.rz() * self.tz()
                + T::from_i8(4i8) * operand.as_inner().moment_x() * self.ry() * self.ty()
                + operand.as_inner().dir_x() * self.rx() * self.rx()
                + operand.as_inner().dir_x() * self.s() * self.s(),
            -(operand.as_inner().moment_x() * self.ty() * self.ty())
                + -(operand.as_inner().moment_x() * self.tz() * self.tz())
                + -T::TWO * operand.as_inner().moment_y() * self.s() * self.tz()
                + T::TWO * operand.as_inner().moment_y() * self.rx() * self.ty()
                + T::TWO * operand.as_inner().moment_z() * self.rx() * self.tz()
                + T::TWO * operand.as_inner().moment_z() * self.s() * self.ty()
                + operand.as_inner().moment_x() * self.rx() * self.rx()
                + operand.as_inner().moment_x() * self.s() * self.s(),
            -(operand.as_inner().dir_y() * self.rx() * self.rx())
                + -(operand.as_inner().dir_y() * self.tz() * self.tz())
                + -T::TWO * operand.as_inner().dir_x() * self.rx() * self.ty()
                + -T::TWO * operand.as_inner().dir_x() * self.s() * self.tz()
                + -T::TWO * operand.as_inner().dir_z() * self.ty() * self.tz()
                + -T::TWO * operand.as_inner().moment_x() * self.rz() * self.s()
                + -T::TWO * operand.as_inner().moment_x() * self.tx() * self.ty()
                + -T::TWO * operand.as_inner().moment_z() * self.ps() * self.rx()
                + -T::TWO * operand.as_inner().moment_z() * self.rz() * self.ty()
                + T::TWO * operand.as_inner().dir_z() * self.rx() * self.s()
                + T::TWO * operand.as_inner().moment_x() * self.ps() * self.tz()
                + T::TWO * operand.as_inner().moment_x() * self.rx() * self.ry()
                + T::TWO * operand.as_inner().moment_z() * self.ry() * self.tz()
                + T::TWO * operand.as_inner().moment_z() * self.s() * self.tx()
                + T::from_i8(4i8) * operand.as_inner().moment_y() * self.rx() * self.tx()
                + T::from_i8(4i8) * operand.as_inner().moment_y() * self.rz() * self.tz()
                + operand.as_inner().dir_y() * self.s() * self.s()
                + operand.as_inner().dir_y() * self.ty() * self.ty(),
            -(operand.as_inner().dir_z() * self.rx() * self.rx())
                + -(operand.as_inner().dir_z() * self.ty() * self.ty())
                + -T::TWO * operand.as_inner().dir_x() * self.s() * self.ty()
                + -T::TWO * operand.as_inner().dir_y() * self.rx() * self.s()
                + -T::TWO * operand.as_inner().dir_y() * self.ty() * self.tz()
                + -T::TWO * operand.as_inner().moment_y() * self.ps() * self.rx()
                + -T::TWO * operand.as_inner().moment_y() * self.ry() * self.tz()
                + T::TWO * operand.as_inner().dir_x() * self.rx() * self.tz()
                + T::TWO * operand.as_inner().moment_x() * self.ps() * self.ty()
                + T::TWO * operand.as_inner().moment_x() * self.rx() * self.rz()
                + T::TWO * operand.as_inner().moment_x() * self.ry() * self.s()
                + T::TWO * operand.as_inner().moment_x() * self.tx() * self.tz()
                + T::TWO * operand.as_inner().moment_y() * self.rz() * self.ty()
                + T::TWO * operand.as_inner().moment_y() * self.s() * self.tx()
                + T::from_i8(-4i8) * operand.as_inner().moment_z() * self.rx() * self.tx()
                + T::from_i8(4i8) * operand.as_inner().moment_z() * self.ry() * self.ty()
                + operand.as_inner().dir_z() * self.s() * self.s()
                + operand.as_inner().dir_z() * self.tz() * self.tz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Line<T>>> for Unitized<Motor<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(operand.as_inner().moment_z() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.as_inner().moment_z() * self.as_inner().ty() * self.as_inner().ty())
                + -T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().s()
                    * self.as_inner().ty()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().rx()
                    * self.as_inner().tz()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().rx()
                    * self.as_inner().s()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().ty()
                    * self.as_inner().tz()
                + operand.as_inner().moment_z() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().moment_z() * self.as_inner().tz() * self.as_inner().tz(),
            -(operand.as_inner().moment_y() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.as_inner().moment_y() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().rx()
                    * self.as_inner().s()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().rx()
                    * self.as_inner().ty()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().s()
                    * self.as_inner().tz()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().ty()
                    * self.as_inner().tz()
                + operand.as_inner().moment_y() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().moment_y() * self.as_inner().ty() * self.as_inner().ty(),
            -(operand.as_inner().dir_x() * self.as_inner().ty() * self.as_inner().ty())
                + -(operand.as_inner().dir_x() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().rx()
                    * self.as_inner().ty()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().rx()
                    * self.as_inner().ry()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().rz()
                    * self.as_inner().s()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().ps()
                    * self.as_inner().ty()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().ry()
                    * self.as_inner().s()
                + T::TWO * operand.as_inner().dir_y() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().s() * self.as_inner().ty()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().ps()
                    * self.as_inner().tz()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().tx()
                    * self.as_inner().ty()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().rx()
                    * self.as_inner().rz()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().tx()
                    * self.as_inner().tz()
                + T::from_i8(-4i8)
                    * operand.as_inner().moment_x()
                    * self.as_inner().rz()
                    * self.as_inner().tz()
                + T::from_i8(4i8)
                    * operand.as_inner().moment_x()
                    * self.as_inner().ry()
                    * self.as_inner().ty()
                + operand.as_inner().dir_x() * self.as_inner().rx() * self.as_inner().rx()
                + operand.as_inner().dir_x() * self.as_inner().s() * self.as_inner().s(),
            -(operand.as_inner().moment_x() * self.as_inner().ty() * self.as_inner().ty())
                + -(operand.as_inner().moment_x() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().s()
                    * self.as_inner().tz()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().rx()
                    * self.as_inner().ty()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().rx()
                    * self.as_inner().tz()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().s()
                    * self.as_inner().ty()
                + operand.as_inner().moment_x() * self.as_inner().rx() * self.as_inner().rx()
                + operand.as_inner().moment_x() * self.as_inner().s() * self.as_inner().s(),
            -(operand.as_inner().dir_y() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.as_inner().dir_y() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().rx()
                    * self.as_inner().ty()
                + -T::TWO * operand.as_inner().dir_x() * self.as_inner().s() * self.as_inner().tz()
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().ty()
                    * self.as_inner().tz()
                + -T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().rz()
                    * self.as_inner().s()
                + -T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().tx()
                    * self.as_inner().ty()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().ps()
                    * self.as_inner().rx()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().rz()
                    * self.as_inner().ty()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().rx() * self.as_inner().s()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().ps()
                    * self.as_inner().tz()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().rx()
                    * self.as_inner().ry()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().ry()
                    * self.as_inner().tz()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().s()
                    * self.as_inner().tx()
                + T::from_i8(4i8)
                    * operand.as_inner().moment_y()
                    * self.as_inner().rx()
                    * self.as_inner().tx()
                + T::from_i8(4i8)
                    * operand.as_inner().moment_y()
                    * self.as_inner().rz()
                    * self.as_inner().tz()
                + operand.as_inner().dir_y() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().dir_y() * self.as_inner().ty() * self.as_inner().ty(),
            -(operand.as_inner().dir_z() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.as_inner().dir_z() * self.as_inner().ty() * self.as_inner().ty())
                + -T::TWO * operand.as_inner().dir_x() * self.as_inner().s() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().dir_y() * self.as_inner().rx() * self.as_inner().s()
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().ty()
                    * self.as_inner().tz()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().ps()
                    * self.as_inner().rx()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().ry()
                    * self.as_inner().tz()
                + T::TWO * operand.as_inner().dir_x() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().ps()
                    * self.as_inner().ty()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().rx()
                    * self.as_inner().rz()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().ry()
                    * self.as_inner().s()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().tx()
                    * self.as_inner().tz()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().rz()
                    * self.as_inner().ty()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().s()
                    * self.as_inner().tx()
                + T::from_i8(-4i8)
                    * operand.as_inner().moment_z()
                    * self.as_inner().rx()
                    * self.as_inner().tx()
                + T::from_i8(4i8)
                    * operand.as_inner().moment_z()
                    * self.as_inner().ry()
                    * self.as_inner().ty()
                + operand.as_inner().dir_z() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().dir_z() * self.as_inner().tz() * self.as_inner().tz(),
        )
    }
}
#[doc = "Sandwich product: [`Motor`] x [`Motor`] x rev([`Motor`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Motor<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            -(self.rx() * operand.rx() * self.s())
                + self.rx() * operand.s() * self.rx()
                + self.rx() * operand.ty() * self.tz()
                - self.rx() * operand.tz() * self.ty()
                + self.s() * operand.rx() * self.rx()
                + self.s() * operand.s() * self.s()
                + self.s() * operand.ty() * self.ty()
                + self.s() * operand.tz() * self.tz()
                - self.ty() * operand.rx() * self.tz()
                + self.ty() * operand.s() * self.ty()
                - self.ty() * operand.ty() * self.s()
                + self.ty() * operand.tz() * self.rx()
                + self.tz() * operand.rx() * self.ty()
                + self.tz() * operand.s() * self.tz()
                - self.tz() * operand.ty() * self.rx()
                - self.tz() * operand.tz() * self.s(),
            self.rx() * operand.rx() * self.tz() - self.rx() * operand.s() * self.ty()
                + self.rx() * operand.ty() * self.s()
                - self.rx() * operand.tz() * self.rx()
                - self.s() * operand.rx() * self.ty()
                - self.s() * operand.s() * self.tz()
                + self.s() * operand.ty() * self.rx()
                + self.s() * operand.tz() * self.s()
                - self.ty() * operand.rx() * self.s()
                + self.ty() * operand.s() * self.rx()
                + self.ty() * operand.ty() * self.tz()
                - self.ty() * operand.tz() * self.ty()
                + self.tz() * operand.rx() * self.rx()
                + self.tz() * operand.s() * self.s()
                + self.tz() * operand.ty() * self.ty()
                + self.tz() * operand.tz() * self.tz(),
            self.rx() * operand.rx() * self.ty() + self.rx() * operand.s() * self.tz()
                - self.rx() * operand.ty() * self.rx()
                - self.rx() * operand.tz() * self.s()
                + self.s() * operand.rx() * self.tz()
                - self.s() * operand.s() * self.ty()
                + self.s() * operand.ty() * self.s()
                - self.s() * operand.tz() * self.rx()
                + self.ty() * operand.rx() * self.rx()
                + self.ty() * operand.s() * self.s()
                + self.ty() * operand.ty() * self.ty()
                + self.ty() * operand.tz() * self.tz()
                + self.tz() * operand.rx() * self.s()
                - self.tz() * operand.s() * self.rx()
                - self.tz() * operand.ty() * self.tz()
                + self.tz() * operand.tz() * self.ty(),
            -(self.ps() * operand.rx() * self.s())
                + self.ps() * operand.s() * self.rx()
                + self.ps() * operand.ty() * self.tz()
                - self.ps() * operand.tz() * self.ty()
                - self.rx() * operand.ps() * self.s()
                + self.rx() * operand.rx() * self.tx()
                - self.rx() * operand.ry() * self.ty()
                + self.rx() * operand.rz() * self.tz()
                - self.rx() * operand.s() * self.ps()
                + self.rx() * operand.tx() * self.rx()
                - self.rx() * operand.ty() * self.ry()
                + self.rx() * operand.tz() * self.rz()
                + self.ry() * operand.rx() * self.ty()
                + self.ry() * operand.s() * self.tz()
                - self.ry() * operand.ty() * self.rx()
                - self.ry() * operand.tz() * self.s()
                - self.rz() * operand.rx() * self.tz()
                + self.rz() * operand.s() * self.ty()
                - self.rz() * operand.ty() * self.s()
                + self.rz() * operand.tz() * self.rx()
                + self.s() * operand.ps() * self.rx()
                - self.s() * operand.rx() * self.ps()
                + self.s() * operand.ry() * self.tz()
                + self.s() * operand.rz() * self.ty()
                - self.s() * operand.s() * self.tx()
                + self.s() * operand.tx() * self.s()
                - self.s() * operand.ty() * self.rz()
                - self.s() * operand.tz() * self.ry()
                + self.tx() * operand.rx() * self.rx()
                + self.tx() * operand.s() * self.s()
                + self.tx() * operand.ty() * self.ty()
                + self.tx() * operand.tz() * self.tz()
                + self.ty() * operand.ps() * self.tz()
                + self.ty() * operand.rx() * self.ry()
                - self.ty() * operand.ry() * self.rx()
                + self.ty() * operand.rz() * self.s()
                - self.ty() * operand.s() * self.rz()
                - self.ty() * operand.tx() * self.ty()
                + self.ty() * operand.ty() * self.tx()
                - self.ty() * operand.tz() * self.ps()
                - self.tz() * operand.ps() * self.ty()
                - self.tz() * operand.rx() * self.rz()
                + self.tz() * operand.ry() * self.s()
                + self.tz() * operand.rz() * self.rx()
                - self.tz() * operand.s() * self.ry()
                - self.tz() * operand.tx() * self.tz()
                + self.tz() * operand.ty() * self.ps()
                + self.tz() * operand.tz() * self.tx(),
            self.rx() * operand.rx() * self.rx()
                + self.rx() * operand.s() * self.s()
                + self.rx() * operand.ty() * self.ty()
                + self.rx() * operand.tz() * self.tz()
                + self.s() * operand.rx() * self.s()
                - self.s() * operand.s() * self.rx()
                - self.s() * operand.ty() * self.tz()
                + self.s() * operand.tz() * self.ty()
                - self.ty() * operand.rx() * self.ty()
                - self.ty() * operand.s() * self.tz()
                + self.ty() * operand.ty() * self.rx()
                + self.ty() * operand.tz() * self.s()
                - self.tz() * operand.rx() * self.tz()
                + self.tz() * operand.s() * self.ty()
                - self.tz() * operand.ty() * self.s()
                + self.tz() * operand.tz() * self.rx(),
            self.ps() * operand.rx() * self.tz() - self.ps() * operand.s() * self.ty()
                + self.ps() * operand.ty() * self.s()
                - self.ps() * operand.tz() * self.rx()
                + self.rx() * operand.ps() * self.tz()
                + self.rx() * operand.rx() * self.ry()
                - self.rx() * operand.ry() * self.rx()
                + self.rx() * operand.rz() * self.s()
                - self.rx() * operand.s() * self.rz()
                - self.rx() * operand.tx() * self.ty()
                + self.rx() * operand.ty() * self.tx()
                - self.rx() * operand.tz() * self.ps()
                + self.ry() * operand.rx() * self.rx()
                + self.ry() * operand.s() * self.s()
                + self.ry() * operand.ty() * self.ty()
                + self.ry() * operand.tz() * self.tz()
                - self.rz() * operand.rx() * self.s()
                + self.rz() * operand.s() * self.rx()
                + self.rz() * operand.ty() * self.tz()
                - self.rz() * operand.tz() * self.ty()
                - self.s() * operand.ps() * self.ty()
                - self.s() * operand.rx() * self.rz()
                + self.s() * operand.ry() * self.s()
                + self.s() * operand.rz() * self.rx()
                - self.s() * operand.s() * self.ry()
                - self.s() * operand.tx() * self.tz()
                + self.s() * operand.ty() * self.ps()
                + self.s() * operand.tz() * self.tx()
                - self.tx() * operand.rx() * self.ty()
                - self.tx() * operand.s() * self.tz()
                + self.tx() * operand.ty() * self.rx()
                + self.tx() * operand.tz() * self.s()
                + self.ty() * operand.ps() * self.s()
                - self.ty() * operand.rx() * self.tx()
                + self.ty() * operand.ry() * self.ty()
                - self.ty() * operand.rz() * self.tz()
                + self.ty() * operand.s() * self.ps()
                - self.ty() * operand.tx() * self.rx()
                + self.ty() * operand.ty() * self.ry()
                - self.ty() * operand.tz() * self.rz()
                - self.tz() * operand.ps() * self.rx()
                + self.tz() * operand.rx() * self.ps()
                - self.tz() * operand.ry() * self.tz()
                - self.tz() * operand.rz() * self.ty()
                + self.tz() * operand.s() * self.tx()
                - self.tz() * operand.tx() * self.s()
                + self.tz() * operand.ty() * self.rz()
                + self.tz() * operand.tz() * self.ry(),
            self.ps() * operand.rx() * self.ty() + self.ps() * operand.s() * self.tz()
                - self.ps() * operand.ty() * self.rx()
                - self.ps() * operand.tz() * self.s()
                + self.rx() * operand.ps() * self.ty()
                + self.rx() * operand.rx() * self.rz()
                - self.rx() * operand.ry() * self.s()
                - self.rx() * operand.rz() * self.rx()
                + self.rx() * operand.s() * self.ry()
                + self.rx() * operand.tx() * self.tz()
                - self.rx() * operand.ty() * self.ps()
                - self.rx() * operand.tz() * self.tx()
                + self.ry() * operand.rx() * self.s()
                - self.ry() * operand.s() * self.rx()
                - self.ry() * operand.ty() * self.tz()
                + self.ry() * operand.tz() * self.ty()
                + self.rz() * operand.rx() * self.rx()
                + self.rz() * operand.s() * self.s()
                + self.rz() * operand.ty() * self.ty()
                + self.rz() * operand.tz() * self.tz()
                + self.s() * operand.ps() * self.tz()
                + self.s() * operand.rx() * self.ry()
                - self.s() * operand.ry() * self.rx()
                + self.s() * operand.rz() * self.s()
                - self.s() * operand.s() * self.rz()
                - self.s() * operand.tx() * self.ty()
                + self.s() * operand.ty() * self.tx()
                - self.s() * operand.tz() * self.ps()
                + self.tx() * operand.rx() * self.tz()
                - self.tx() * operand.s() * self.ty()
                + self.tx() * operand.ty() * self.s()
                - self.tx() * operand.tz() * self.rx()
                - self.ty() * operand.ps() * self.rx()
                + self.ty() * operand.rx() * self.ps()
                - self.ty() * operand.ry() * self.tz()
                - self.ty() * operand.rz() * self.ty()
                + self.ty() * operand.s() * self.tx()
                - self.ty() * operand.tx() * self.s()
                + self.ty() * operand.ty() * self.rz()
                + self.ty() * operand.tz() * self.ry()
                - self.tz() * operand.ps() * self.s()
                + self.tz() * operand.rx() * self.tx()
                - self.tz() * operand.ry() * self.ty()
                + self.tz() * operand.rz() * self.tz()
                - self.tz() * operand.s() * self.ps()
                + self.tz() * operand.tx() * self.rx()
                - self.tz() * operand.ty() * self.ry()
                + self.tz() * operand.tz() * self.rz(),
            self.ps() * operand.rx() * self.rx()
                + self.ps() * operand.s() * self.s()
                + self.ps() * operand.ty() * self.ty()
                + self.ps() * operand.tz() * self.tz()
                + self.rx() * operand.ps() * self.rx()
                - self.rx() * operand.rx() * self.ps()
                + self.rx() * operand.ry() * self.tz()
                + self.rx() * operand.rz() * self.ty()
                - self.rx() * operand.s() * self.tx()
                + self.rx() * operand.tx() * self.s()
                - self.rx() * operand.ty() * self.rz()
                - self.rx() * operand.tz() * self.ry()
                - self.ry() * operand.rx() * self.tz()
                + self.ry() * operand.s() * self.ty()
                - self.ry() * operand.ty() * self.s()
                + self.ry() * operand.tz() * self.rx()
                - self.rz() * operand.rx() * self.ty()
                - self.rz() * operand.s() * self.tz()
                + self.rz() * operand.ty() * self.rx()
                + self.rz() * operand.tz() * self.s()
                + self.s() * operand.ps() * self.s()
                - self.s() * operand.rx() * self.tx()
                + self.s() * operand.ry() * self.ty()
                - self.s() * operand.rz() * self.tz()
                + self.s() * operand.s() * self.ps()
                - self.s() * operand.tx() * self.rx()
                + self.s() * operand.ty() * self.ry()
                - self.s() * operand.tz() * self.rz()
                + self.tx() * operand.rx() * self.s()
                - self.tx() * operand.s() * self.rx()
                - self.tx() * operand.ty() * self.tz()
                + self.tx() * operand.tz() * self.ty()
                + self.ty() * operand.ps() * self.ty()
                + self.ty() * operand.rx() * self.rz()
                - self.ty() * operand.ry() * self.s()
                - self.ty() * operand.rz() * self.rx()
                + self.ty() * operand.s() * self.ry()
                + self.ty() * operand.tx() * self.tz()
                - self.ty() * operand.ty() * self.ps()
                - self.ty() * operand.tz() * self.tx()
                + self.tz() * operand.ps() * self.tz()
                + self.tz() * operand.rx() * self.ry()
                - self.tz() * operand.ry() * self.rx()
                + self.tz() * operand.rz() * self.s()
                - self.tz() * operand.s() * self.rz()
                - self.tz() * operand.tx() * self.ty()
                + self.tz() * operand.ty() * self.tx()
                - self.tz() * operand.tz() * self.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Motor<T>> for Unitized<Motor<T>> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            operand.s() * self.as_inner().rx() * self.as_inner().rx()
                + operand.s() * self.as_inner().s() * self.as_inner().s()
                + operand.s() * self.as_inner().ty() * self.as_inner().ty()
                + operand.s() * self.as_inner().tz() * self.as_inner().tz(),
            -(operand.tz() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.tz() * self.as_inner().ty() * self.as_inner().ty())
                + -T::TWO * operand.rx() * self.as_inner().s() * self.as_inner().ty()
                + T::TWO * operand.rx() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.ty() * self.as_inner().rx() * self.as_inner().s()
                + T::TWO * operand.ty() * self.as_inner().ty() * self.as_inner().tz()
                + operand.tz() * self.as_inner().s() * self.as_inner().s()
                + operand.tz() * self.as_inner().tz() * self.as_inner().tz(),
            -(operand.ty() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.ty() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.tz() * self.as_inner().rx() * self.as_inner().s()
                + T::TWO * operand.rx() * self.as_inner().rx() * self.as_inner().ty()
                + T::TWO * operand.rx() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.tz() * self.as_inner().ty() * self.as_inner().tz()
                + operand.ty() * self.as_inner().s() * self.as_inner().s()
                + operand.ty() * self.as_inner().ty() * self.as_inner().ty(),
            -(operand.tx() * self.as_inner().ty() * self.as_inner().ty())
                + -(operand.tx() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.ry() * self.as_inner().rx() * self.as_inner().ty()
                + -T::TWO * operand.ty() * self.as_inner().rx() * self.as_inner().ry()
                + -T::TWO * operand.ty() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.tz() * self.as_inner().ps() * self.as_inner().ty()
                + -T::TWO * operand.tz() * self.as_inner().ry() * self.as_inner().s()
                + T::TWO * operand.ry() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.rz() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.rz() * self.as_inner().s() * self.as_inner().ty()
                + T::TWO * operand.ty() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.ty() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.tz() * self.as_inner().rx() * self.as_inner().rz()
                + T::TWO * operand.tz() * self.as_inner().tx() * self.as_inner().tz()
                + T::from_i8(-4i8) * operand.rx() * self.as_inner().rz() * self.as_inner().tz()
                + T::from_i8(4i8) * operand.rx() * self.as_inner().ry() * self.as_inner().ty()
                + operand.tx() * self.as_inner().rx() * self.as_inner().rx()
                + operand.tx() * self.as_inner().s() * self.as_inner().s(),
            -(operand.rx() * self.as_inner().ty() * self.as_inner().ty())
                + -(operand.rx() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.ty() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.ty() * self.as_inner().rx() * self.as_inner().ty()
                + T::TWO * operand.tz() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.tz() * self.as_inner().s() * self.as_inner().ty()
                + operand.rx() * self.as_inner().rx() * self.as_inner().rx()
                + operand.rx() * self.as_inner().s() * self.as_inner().s(),
            -(operand.ry() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.ry() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.rx() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.rx() * self.as_inner().tx() * self.as_inner().ty()
                + -T::TWO * operand.rz() * self.as_inner().ty() * self.as_inner().tz()
                + -T::TWO * operand.tx() * self.as_inner().rx() * self.as_inner().ty()
                + -T::TWO * operand.tx() * self.as_inner().s() * self.as_inner().tz()
                + -T::TWO * operand.tz() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.tz() * self.as_inner().rz() * self.as_inner().ty()
                + T::TWO * operand.rx() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.rx() * self.as_inner().rx() * self.as_inner().ry()
                + T::TWO * operand.rz() * self.as_inner().rx() * self.as_inner().s()
                + T::TWO * operand.tz() * self.as_inner().ry() * self.as_inner().tz()
                + T::TWO * operand.tz() * self.as_inner().s() * self.as_inner().tx()
                + T::from_i8(4i8) * operand.ty() * self.as_inner().rx() * self.as_inner().tx()
                + T::from_i8(4i8) * operand.ty() * self.as_inner().rz() * self.as_inner().tz()
                + operand.ry() * self.as_inner().s() * self.as_inner().s()
                + operand.ry() * self.as_inner().ty() * self.as_inner().ty(),
            -(operand.rz() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.rz() * self.as_inner().ty() * self.as_inner().ty())
                + -T::TWO * operand.ry() * self.as_inner().rx() * self.as_inner().s()
                + -T::TWO * operand.ry() * self.as_inner().ty() * self.as_inner().tz()
                + -T::TWO * operand.tx() * self.as_inner().s() * self.as_inner().ty()
                + -T::TWO * operand.ty() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.ty() * self.as_inner().ry() * self.as_inner().tz()
                + T::TWO * operand.rx() * self.as_inner().ps() * self.as_inner().ty()
                + T::TWO * operand.rx() * self.as_inner().rx() * self.as_inner().rz()
                + T::TWO * operand.rx() * self.as_inner().ry() * self.as_inner().s()
                + T::TWO * operand.rx() * self.as_inner().tx() * self.as_inner().tz()
                + T::TWO * operand.tx() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.ty() * self.as_inner().rz() * self.as_inner().ty()
                + T::TWO * operand.ty() * self.as_inner().s() * self.as_inner().tx()
                + T::from_i8(-4i8) * operand.tz() * self.as_inner().rx() * self.as_inner().tx()
                + T::from_i8(4i8) * operand.tz() * self.as_inner().ry() * self.as_inner().ty()
                + operand.rz() * self.as_inner().s() * self.as_inner().s()
                + operand.rz() * self.as_inner().tz() * self.as_inner().tz(),
            operand.ps() * self.as_inner().rx() * self.as_inner().rx()
                + operand.ps() * self.as_inner().s() * self.as_inner().s()
                + operand.ps() * self.as_inner().ty() * self.as_inner().ty()
                + operand.ps() * self.as_inner().tz() * self.as_inner().tz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Motor<T>>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s() * self.rx() * self.rx()
                + operand.as_inner().s() * self.s() * self.s()
                + operand.as_inner().s() * self.ty() * self.ty()
                + operand.as_inner().s() * self.tz() * self.tz(),
            -(operand.as_inner().tz() * self.rx() * self.rx())
                + -(operand.as_inner().tz() * self.ty() * self.ty())
                + -T::TWO * operand.as_inner().rx() * self.s() * self.ty()
                + T::TWO * operand.as_inner().rx() * self.rx() * self.tz()
                + T::TWO * operand.as_inner().ty() * self.rx() * self.s()
                + T::TWO * operand.as_inner().ty() * self.ty() * self.tz()
                + operand.as_inner().tz() * self.s() * self.s()
                + operand.as_inner().tz() * self.tz() * self.tz(),
            -(operand.as_inner().ty() * self.rx() * self.rx())
                + -(operand.as_inner().ty() * self.tz() * self.tz())
                + -T::TWO * operand.as_inner().tz() * self.rx() * self.s()
                + T::TWO * operand.as_inner().rx() * self.rx() * self.ty()
                + T::TWO * operand.as_inner().rx() * self.s() * self.tz()
                + T::TWO * operand.as_inner().tz() * self.ty() * self.tz()
                + operand.as_inner().ty() * self.s() * self.s()
                + operand.as_inner().ty() * self.ty() * self.ty(),
            -(operand.as_inner().tx() * self.ty() * self.ty())
                + -(operand.as_inner().tx() * self.tz() * self.tz())
                + -T::TWO * operand.as_inner().ry() * self.rx() * self.ty()
                + -T::TWO * operand.as_inner().ty() * self.rx() * self.ry()
                + -T::TWO * operand.as_inner().ty() * self.rz() * self.s()
                + -T::TWO * operand.as_inner().tz() * self.ps() * self.ty()
                + -T::TWO * operand.as_inner().tz() * self.ry() * self.s()
                + T::TWO * operand.as_inner().ry() * self.s() * self.tz()
                + T::TWO * operand.as_inner().rz() * self.rx() * self.tz()
                + T::TWO * operand.as_inner().rz() * self.s() * self.ty()
                + T::TWO * operand.as_inner().ty() * self.ps() * self.tz()
                + T::TWO * operand.as_inner().ty() * self.tx() * self.ty()
                + T::TWO * operand.as_inner().tz() * self.rx() * self.rz()
                + T::TWO * operand.as_inner().tz() * self.tx() * self.tz()
                + T::from_i8(-4i8) * operand.as_inner().rx() * self.rz() * self.tz()
                + T::from_i8(4i8) * operand.as_inner().rx() * self.ry() * self.ty()
                + operand.as_inner().tx() * self.rx() * self.rx()
                + operand.as_inner().tx() * self.s() * self.s(),
            -(operand.as_inner().rx() * self.ty() * self.ty())
                + -(operand.as_inner().rx() * self.tz() * self.tz())
                + -T::TWO * operand.as_inner().ty() * self.s() * self.tz()
                + T::TWO * operand.as_inner().ty() * self.rx() * self.ty()
                + T::TWO * operand.as_inner().tz() * self.rx() * self.tz()
                + T::TWO * operand.as_inner().tz() * self.s() * self.ty()
                + operand.as_inner().rx() * self.rx() * self.rx()
                + operand.as_inner().rx() * self.s() * self.s(),
            -(operand.as_inner().ry() * self.rx() * self.rx())
                + -(operand.as_inner().ry() * self.tz() * self.tz())
                + -T::TWO * operand.as_inner().rx() * self.rz() * self.s()
                + -T::TWO * operand.as_inner().rx() * self.tx() * self.ty()
                + -T::TWO * operand.as_inner().rz() * self.ty() * self.tz()
                + -T::TWO * operand.as_inner().tx() * self.rx() * self.ty()
                + -T::TWO * operand.as_inner().tx() * self.s() * self.tz()
                + -T::TWO * operand.as_inner().tz() * self.ps() * self.rx()
                + -T::TWO * operand.as_inner().tz() * self.rz() * self.ty()
                + T::TWO * operand.as_inner().rx() * self.ps() * self.tz()
                + T::TWO * operand.as_inner().rx() * self.rx() * self.ry()
                + T::TWO * operand.as_inner().rz() * self.rx() * self.s()
                + T::TWO * operand.as_inner().tz() * self.ry() * self.tz()
                + T::TWO * operand.as_inner().tz() * self.s() * self.tx()
                + T::from_i8(4i8) * operand.as_inner().ty() * self.rx() * self.tx()
                + T::from_i8(4i8) * operand.as_inner().ty() * self.rz() * self.tz()
                + operand.as_inner().ry() * self.s() * self.s()
                + operand.as_inner().ry() * self.ty() * self.ty(),
            -(operand.as_inner().rz() * self.rx() * self.rx())
                + -(operand.as_inner().rz() * self.ty() * self.ty())
                + -T::TWO * operand.as_inner().ry() * self.rx() * self.s()
                + -T::TWO * operand.as_inner().ry() * self.ty() * self.tz()
                + -T::TWO * operand.as_inner().tx() * self.s() * self.ty()
                + -T::TWO * operand.as_inner().ty() * self.ps() * self.rx()
                + -T::TWO * operand.as_inner().ty() * self.ry() * self.tz()
                + T::TWO * operand.as_inner().rx() * self.ps() * self.ty()
                + T::TWO * operand.as_inner().rx() * self.rx() * self.rz()
                + T::TWO * operand.as_inner().rx() * self.ry() * self.s()
                + T::TWO * operand.as_inner().rx() * self.tx() * self.tz()
                + T::TWO * operand.as_inner().tx() * self.rx() * self.tz()
                + T::TWO * operand.as_inner().ty() * self.rz() * self.ty()
                + T::TWO * operand.as_inner().ty() * self.s() * self.tx()
                + T::from_i8(-4i8) * operand.as_inner().tz() * self.rx() * self.tx()
                + T::from_i8(4i8) * operand.as_inner().tz() * self.ry() * self.ty()
                + operand.as_inner().rz() * self.s() * self.s()
                + operand.as_inner().rz() * self.tz() * self.tz(),
            operand.as_inner().ps() * self.rx() * self.rx()
                + operand.as_inner().ps() * self.s() * self.s()
                + operand.as_inner().ps() * self.ty() * self.ty()
                + operand.as_inner().ps() * self.tz() * self.tz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Motor<T>>> for Unitized<Motor<T>> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s() * self.as_inner().rx() * self.as_inner().rx()
                + operand.as_inner().s() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().s() * self.as_inner().ty() * self.as_inner().ty()
                + operand.as_inner().s() * self.as_inner().tz() * self.as_inner().tz(),
            -(operand.as_inner().tz() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.as_inner().tz() * self.as_inner().ty() * self.as_inner().ty())
                + -T::TWO * operand.as_inner().rx() * self.as_inner().s() * self.as_inner().ty()
                + T::TWO * operand.as_inner().rx() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.as_inner().ty() * self.as_inner().rx() * self.as_inner().s()
                + T::TWO * operand.as_inner().ty() * self.as_inner().ty() * self.as_inner().tz()
                + operand.as_inner().tz() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().tz() * self.as_inner().tz() * self.as_inner().tz(),
            -(operand.as_inner().ty() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.as_inner().ty() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.as_inner().tz() * self.as_inner().rx() * self.as_inner().s()
                + T::TWO * operand.as_inner().rx() * self.as_inner().rx() * self.as_inner().ty()
                + T::TWO * operand.as_inner().rx() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.as_inner().tz() * self.as_inner().ty() * self.as_inner().tz()
                + operand.as_inner().ty() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().ty() * self.as_inner().ty() * self.as_inner().ty(),
            -(operand.as_inner().tx() * self.as_inner().ty() * self.as_inner().ty())
                + -(operand.as_inner().tx() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.as_inner().ry() * self.as_inner().rx() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().ty() * self.as_inner().rx() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().ty() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.as_inner().tz() * self.as_inner().ps() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().tz() * self.as_inner().ry() * self.as_inner().s()
                + T::TWO * operand.as_inner().ry() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.as_inner().rz() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.as_inner().rz() * self.as_inner().s() * self.as_inner().ty()
                + T::TWO * operand.as_inner().ty() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.as_inner().ty() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.as_inner().tz() * self.as_inner().rx() * self.as_inner().rz()
                + T::TWO * operand.as_inner().tz() * self.as_inner().tx() * self.as_inner().tz()
                + T::from_i8(-4i8)
                    * operand.as_inner().rx()
                    * self.as_inner().rz()
                    * self.as_inner().tz()
                + T::from_i8(4i8)
                    * operand.as_inner().rx()
                    * self.as_inner().ry()
                    * self.as_inner().ty()
                + operand.as_inner().tx() * self.as_inner().rx() * self.as_inner().rx()
                + operand.as_inner().tx() * self.as_inner().s() * self.as_inner().s(),
            -(operand.as_inner().rx() * self.as_inner().ty() * self.as_inner().ty())
                + -(operand.as_inner().rx() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.as_inner().ty() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.as_inner().ty() * self.as_inner().rx() * self.as_inner().ty()
                + T::TWO * operand.as_inner().tz() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.as_inner().tz() * self.as_inner().s() * self.as_inner().ty()
                + operand.as_inner().rx() * self.as_inner().rx() * self.as_inner().rx()
                + operand.as_inner().rx() * self.as_inner().s() * self.as_inner().s(),
            -(operand.as_inner().ry() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.as_inner().ry() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.as_inner().rx() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.as_inner().rx() * self.as_inner().tx() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().rz() * self.as_inner().ty() * self.as_inner().tz()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().rx() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().s() * self.as_inner().tz()
                + -T::TWO * operand.as_inner().tz() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.as_inner().tz() * self.as_inner().rz() * self.as_inner().ty()
                + T::TWO * operand.as_inner().rx() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.as_inner().rx() * self.as_inner().rx() * self.as_inner().ry()
                + T::TWO * operand.as_inner().rz() * self.as_inner().rx() * self.as_inner().s()
                + T::TWO * operand.as_inner().tz() * self.as_inner().ry() * self.as_inner().tz()
                + T::TWO * operand.as_inner().tz() * self.as_inner().s() * self.as_inner().tx()
                + T::from_i8(4i8)
                    * operand.as_inner().ty()
                    * self.as_inner().rx()
                    * self.as_inner().tx()
                + T::from_i8(4i8)
                    * operand.as_inner().ty()
                    * self.as_inner().rz()
                    * self.as_inner().tz()
                + operand.as_inner().ry() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().ry() * self.as_inner().ty() * self.as_inner().ty(),
            -(operand.as_inner().rz() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.as_inner().rz() * self.as_inner().ty() * self.as_inner().ty())
                + -T::TWO * operand.as_inner().ry() * self.as_inner().rx() * self.as_inner().s()
                + -T::TWO * operand.as_inner().ry() * self.as_inner().ty() * self.as_inner().tz()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().s() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().ty() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.as_inner().ty() * self.as_inner().ry() * self.as_inner().tz()
                + T::TWO * operand.as_inner().rx() * self.as_inner().ps() * self.as_inner().ty()
                + T::TWO * operand.as_inner().rx() * self.as_inner().rx() * self.as_inner().rz()
                + T::TWO * operand.as_inner().rx() * self.as_inner().ry() * self.as_inner().s()
                + T::TWO * operand.as_inner().rx() * self.as_inner().tx() * self.as_inner().tz()
                + T::TWO * operand.as_inner().tx() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.as_inner().ty() * self.as_inner().rz() * self.as_inner().ty()
                + T::TWO * operand.as_inner().ty() * self.as_inner().s() * self.as_inner().tx()
                + T::from_i8(-4i8)
                    * operand.as_inner().tz()
                    * self.as_inner().rx()
                    * self.as_inner().tx()
                + T::from_i8(4i8)
                    * operand.as_inner().tz()
                    * self.as_inner().ry()
                    * self.as_inner().ty()
                + operand.as_inner().rz() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().rz() * self.as_inner().tz() * self.as_inner().tz(),
            operand.as_inner().ps() * self.as_inner().rx() * self.as_inner().rx()
                + operand.as_inner().ps() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().ps() * self.as_inner().ty() * self.as_inner().ty()
                + operand.as_inner().ps() * self.as_inner().tz() * self.as_inner().tz(),
        )
    }
}
#[doc = "Sandwich product: [`Motor`] x [`Plane`] x rev([`Motor`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Plane<T>> for Motor<T> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            self.rx() * operand.dist() * self.rx()
                + self.s() * operand.dist() * self.s()
                + self.ty() * operand.dist() * self.ty()
                + self.tz() * operand.dist() * self.tz(),
            -(self.ps() * operand.dist() * self.tz())
                + self.rx() * operand.dist() * self.ry()
                + self.rx() * operand.nx() * self.tz()
                + self.rx() * operand.ny() * self.s()
                - self.rx() * operand.nz() * self.rx()
                + self.ry() * operand.dist() * self.rx()
                - self.rz() * operand.dist() * self.s()
                - self.s() * operand.dist() * self.rz()
                - self.s() * operand.nx() * self.ty()
                + self.s() * operand.ny() * self.rx()
                + self.s() * operand.nz() * self.s()
                + self.tx() * operand.dist() * self.ty()
                + self.ty() * operand.dist() * self.tx()
                - self.ty() * operand.nx() * self.s()
                + self.ty() * operand.ny() * self.tz()
                - self.ty() * operand.nz() * self.ty()
                - self.tz() * operand.dist() * self.ps()
                + self.tz() * operand.nx() * self.rx()
                + self.tz() * operand.ny() * self.ty()
                + self.tz() * operand.nz() * self.tz(),
            -(self.ps() * operand.dist() * self.ty())
                + self.rx() * operand.dist() * self.rz()
                + self.rx() * operand.nx() * self.ty()
                - self.rx() * operand.ny() * self.rx()
                - self.rx() * operand.nz() * self.s()
                + self.ry() * operand.dist() * self.s()
                + self.rz() * operand.dist() * self.rx()
                + self.s() * operand.dist() * self.ry()
                + self.s() * operand.nx() * self.tz()
                + self.s() * operand.ny() * self.s()
                - self.s() * operand.nz() * self.rx()
                - self.tx() * operand.dist() * self.tz()
                - self.ty() * operand.dist() * self.ps()
                + self.ty() * operand.nx() * self.rx()
                + self.ty() * operand.ny() * self.ty()
                + self.ty() * operand.nz() * self.tz()
                - self.tz() * operand.dist() * self.tx()
                + self.tz() * operand.nx() * self.s()
                - self.tz() * operand.ny() * self.tz()
                + self.tz() * operand.nz() * self.ty(),
            -(self.ps() * operand.dist() * self.rx()) - self.rx() * operand.dist() * self.ps()
                + self.rx() * operand.nx() * self.rx()
                + self.rx() * operand.ny() * self.ty()
                + self.rx() * operand.nz() * self.tz()
                - self.ry() * operand.dist() * self.tz()
                - self.rz() * operand.dist() * self.ty()
                - self.s() * operand.dist() * self.tx()
                + self.s() * operand.nx() * self.s()
                - self.s() * operand.ny() * self.tz()
                + self.s() * operand.nz() * self.ty()
                - self.tx() * operand.dist() * self.s()
                - self.ty() * operand.dist() * self.rz()
                - self.ty() * operand.nx() * self.ty()
                + self.ty() * operand.ny() * self.rx()
                + self.ty() * operand.nz() * self.s()
                - self.tz() * operand.dist() * self.ry()
                - self.tz() * operand.nx() * self.tz()
                - self.tz() * operand.ny() * self.s()
                + self.tz() * operand.nz() * self.rx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Plane<T>> for Unitized<Motor<T>> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            operand.dist() * self.as_inner().rx() * self.as_inner().rx()
                + operand.dist() * self.as_inner().s() * self.as_inner().s()
                + operand.dist() * self.as_inner().ty() * self.as_inner().ty()
                + operand.dist() * self.as_inner().tz() * self.as_inner().tz(),
            -(operand.nz() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.nz() * self.as_inner().ty() * self.as_inner().ty())
                + -T::TWO * operand.dist() * self.as_inner().ps() * self.as_inner().tz()
                + -T::TWO * operand.dist() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.nx() * self.as_inner().s() * self.as_inner().ty()
                + T::TWO * operand.dist() * self.as_inner().rx() * self.as_inner().ry()
                + T::TWO * operand.dist() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.nx() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.ny() * self.as_inner().rx() * self.as_inner().s()
                + T::TWO * operand.ny() * self.as_inner().ty() * self.as_inner().tz()
                + operand.nz() * self.as_inner().s() * self.as_inner().s()
                + operand.nz() * self.as_inner().tz() * self.as_inner().tz(),
            -(operand.ny() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.ny() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.dist() * self.as_inner().ps() * self.as_inner().ty()
                + -T::TWO * operand.dist() * self.as_inner().tx() * self.as_inner().tz()
                + -T::TWO * operand.nz() * self.as_inner().rx() * self.as_inner().s()
                + T::TWO * operand.dist() * self.as_inner().rx() * self.as_inner().rz()
                + T::TWO * operand.dist() * self.as_inner().ry() * self.as_inner().s()
                + T::TWO * operand.nx() * self.as_inner().rx() * self.as_inner().ty()
                + T::TWO * operand.nx() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.nz() * self.as_inner().ty() * self.as_inner().tz()
                + operand.ny() * self.as_inner().s() * self.as_inner().s()
                + operand.ny() * self.as_inner().ty() * self.as_inner().ty(),
            -(operand.nx() * self.as_inner().ty() * self.as_inner().ty())
                + -(operand.nx() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.dist() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.dist() * self.as_inner().ry() * self.as_inner().tz()
                + -T::TWO * operand.dist() * self.as_inner().rz() * self.as_inner().ty()
                + -T::TWO * operand.dist() * self.as_inner().s() * self.as_inner().tx()
                + -T::TWO * operand.ny() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.ny() * self.as_inner().rx() * self.as_inner().ty()
                + T::TWO * operand.nz() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.nz() * self.as_inner().s() * self.as_inner().ty()
                + operand.nx() * self.as_inner().rx() * self.as_inner().rx()
                + operand.nx() * self.as_inner().s() * self.as_inner().s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Plane<T>>> for Motor<T> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            operand.as_inner().dist() * self.rx() * self.rx()
                + operand.as_inner().dist() * self.s() * self.s()
                + operand.as_inner().dist() * self.ty() * self.ty()
                + operand.as_inner().dist() * self.tz() * self.tz(),
            -(operand.as_inner().nz() * self.rx() * self.rx())
                + -(operand.as_inner().nz() * self.ty() * self.ty())
                + -T::TWO * operand.as_inner().dist() * self.ps() * self.tz()
                + -T::TWO * operand.as_inner().dist() * self.rz() * self.s()
                + -T::TWO * operand.as_inner().nx() * self.s() * self.ty()
                + T::TWO * operand.as_inner().dist() * self.rx() * self.ry()
                + T::TWO * operand.as_inner().dist() * self.tx() * self.ty()
                + T::TWO * operand.as_inner().nx() * self.rx() * self.tz()
                + T::TWO * operand.as_inner().ny() * self.rx() * self.s()
                + T::TWO * operand.as_inner().ny() * self.ty() * self.tz()
                + operand.as_inner().nz() * self.s() * self.s()
                + operand.as_inner().nz() * self.tz() * self.tz(),
            -(operand.as_inner().ny() * self.rx() * self.rx())
                + -(operand.as_inner().ny() * self.tz() * self.tz())
                + -T::TWO * operand.as_inner().dist() * self.ps() * self.ty()
                + -T::TWO * operand.as_inner().dist() * self.tx() * self.tz()
                + -T::TWO * operand.as_inner().nz() * self.rx() * self.s()
                + T::TWO * operand.as_inner().dist() * self.rx() * self.rz()
                + T::TWO * operand.as_inner().dist() * self.ry() * self.s()
                + T::TWO * operand.as_inner().nx() * self.rx() * self.ty()
                + T::TWO * operand.as_inner().nx() * self.s() * self.tz()
                + T::TWO * operand.as_inner().nz() * self.ty() * self.tz()
                + operand.as_inner().ny() * self.s() * self.s()
                + operand.as_inner().ny() * self.ty() * self.ty(),
            -(operand.as_inner().nx() * self.ty() * self.ty())
                + -(operand.as_inner().nx() * self.tz() * self.tz())
                + -T::TWO * operand.as_inner().dist() * self.ps() * self.rx()
                + -T::TWO * operand.as_inner().dist() * self.ry() * self.tz()
                + -T::TWO * operand.as_inner().dist() * self.rz() * self.ty()
                + -T::TWO * operand.as_inner().dist() * self.s() * self.tx()
                + -T::TWO * operand.as_inner().ny() * self.s() * self.tz()
                + T::TWO * operand.as_inner().ny() * self.rx() * self.ty()
                + T::TWO * operand.as_inner().nz() * self.rx() * self.tz()
                + T::TWO * operand.as_inner().nz() * self.s() * self.ty()
                + operand.as_inner().nx() * self.rx() * self.rx()
                + operand.as_inner().nx() * self.s() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Plane<T>>> for Unitized<Motor<T>> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            operand.as_inner().dist() * self.as_inner().rx() * self.as_inner().rx()
                + operand.as_inner().dist() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().dist() * self.as_inner().ty() * self.as_inner().ty()
                + operand.as_inner().dist() * self.as_inner().tz() * self.as_inner().tz(),
            -(operand.as_inner().nz() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.as_inner().nz() * self.as_inner().ty() * self.as_inner().ty())
                + -T::TWO * operand.as_inner().dist() * self.as_inner().ps() * self.as_inner().tz()
                + -T::TWO * operand.as_inner().dist() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.as_inner().nx() * self.as_inner().s() * self.as_inner().ty()
                + T::TWO * operand.as_inner().dist() * self.as_inner().rx() * self.as_inner().ry()
                + T::TWO * operand.as_inner().dist() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.as_inner().nx() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.as_inner().ny() * self.as_inner().rx() * self.as_inner().s()
                + T::TWO * operand.as_inner().ny() * self.as_inner().ty() * self.as_inner().tz()
                + operand.as_inner().nz() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().nz() * self.as_inner().tz() * self.as_inner().tz(),
            -(operand.as_inner().ny() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.as_inner().ny() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.as_inner().dist() * self.as_inner().ps() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().dist() * self.as_inner().tx() * self.as_inner().tz()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().rx() * self.as_inner().s()
                + T::TWO * operand.as_inner().dist() * self.as_inner().rx() * self.as_inner().rz()
                + T::TWO * operand.as_inner().dist() * self.as_inner().ry() * self.as_inner().s()
                + T::TWO * operand.as_inner().nx() * self.as_inner().rx() * self.as_inner().ty()
                + T::TWO * operand.as_inner().nx() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.as_inner().nz() * self.as_inner().ty() * self.as_inner().tz()
                + operand.as_inner().ny() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().ny() * self.as_inner().ty() * self.as_inner().ty(),
            -(operand.as_inner().nx() * self.as_inner().ty() * self.as_inner().ty())
                + -(operand.as_inner().nx() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.as_inner().dist() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.as_inner().dist() * self.as_inner().ry() * self.as_inner().tz()
                + -T::TWO * operand.as_inner().dist() * self.as_inner().rz() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().dist() * self.as_inner().s() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.as_inner().ny() * self.as_inner().rx() * self.as_inner().ty()
                + T::TWO * operand.as_inner().nz() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.as_inner().nz() * self.as_inner().s() * self.as_inner().ty()
                + operand.as_inner().nx() * self.as_inner().rx() * self.as_inner().rx()
                + operand.as_inner().nx() * self.as_inner().s() * self.as_inner().s(),
        )
    }
}
#[doc = "Sandwich product: [`Motor`] x [`Point`] x rev([`Motor`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Motor<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.rx() * operand.x() * self.rx() - self.rx() * operand.y() * self.ty()
                + self.rx() * operand.z() * self.tz()
                + self.s() * operand.x() * self.s()
                + self.s() * operand.y() * self.tz()
                + self.s() * operand.z() * self.ty()
                - self.ty() * operand.x() * self.ty()
                - self.ty() * operand.y() * self.rx()
                + self.ty() * operand.z() * self.s()
                - self.tz() * operand.x() * self.tz()
                + self.tz() * operand.y() * self.s()
                + self.tz() * operand.z() * self.rx(),
            -(self.rx() * operand.x() * self.ty()) - self.rx() * operand.y() * self.rx()
                + self.rx() * operand.z() * self.s()
                - self.s() * operand.x() * self.tz()
                + self.s() * operand.y() * self.s()
                + self.s() * operand.z() * self.rx()
                - self.ty() * operand.x() * self.rx()
                + self.ty() * operand.y() * self.ty()
                - self.ty() * operand.z() * self.tz()
                - self.tz() * operand.x() * self.s()
                - self.tz() * operand.y() * self.tz()
                - self.tz() * operand.z() * self.ty(),
            self.rx() * operand.x() * self.tz()
                - self.rx() * operand.y() * self.s()
                - self.rx() * operand.z() * self.rx()
                - self.s() * operand.x() * self.ty()
                - self.s() * operand.y() * self.rx()
                + self.s() * operand.z() * self.s()
                - self.ty() * operand.x() * self.s()
                - self.ty() * operand.y() * self.tz()
                - self.ty() * operand.z() * self.ty()
                + self.tz() * operand.x() * self.rx()
                - self.tz() * operand.y() * self.ty()
                + self.tz() * operand.z() * self.tz(),
            -(self.ps() * operand.x() * self.rx()) + self.ps() * operand.y() * self.ty()
                - self.ps() * operand.z() * self.tz()
                + self.rx() * operand.w() * self.rx()
                - self.rx() * operand.x() * self.ps()
                + self.rx() * operand.y() * self.rz()
                - self.rx() * operand.z() * self.ry()
                + self.ry() * operand.x() * self.tz()
                - self.ry() * operand.y() * self.s()
                - self.ry() * operand.z() * self.rx()
                + self.rz() * operand.x() * self.ty()
                + self.rz() * operand.y() * self.rx()
                - self.rz() * operand.z() * self.s()
                + self.s() * operand.w() * self.s()
                - self.s() * operand.x() * self.tx()
                - self.s() * operand.y() * self.ry()
                - self.s() * operand.z() * self.rz()
                - self.tx() * operand.x() * self.s()
                - self.tx() * operand.y() * self.tz()
                - self.tx() * operand.z() * self.ty()
                + self.ty() * operand.w() * self.ty()
                + self.ty() * operand.x() * self.rz()
                + self.ty() * operand.y() * self.ps()
                - self.ty() * operand.z() * self.tx()
                + self.tz() * operand.w() * self.tz()
                + self.tz() * operand.x() * self.ry()
                - self.tz() * operand.y() * self.tx()
                - self.tz() * operand.z() * self.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Unitized<Motor<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -(operand.x() * self.as_inner().ty() * self.as_inner().ty())
                + -(operand.x() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.y() * self.as_inner().rx() * self.as_inner().ty()
                + T::TWO * operand.y() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.z() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.z() * self.as_inner().s() * self.as_inner().ty()
                + operand.x() * self.as_inner().rx() * self.as_inner().rx()
                + operand.x() * self.as_inner().s() * self.as_inner().s(),
            -(operand.y() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.y() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.x() * self.as_inner().rx() * self.as_inner().ty()
                + -T::TWO * operand.x() * self.as_inner().s() * self.as_inner().tz()
                + -T::TWO * operand.z() * self.as_inner().ty() * self.as_inner().tz()
                + T::TWO * operand.z() * self.as_inner().rx() * self.as_inner().s()
                + operand.y() * self.as_inner().s() * self.as_inner().s()
                + operand.y() * self.as_inner().ty() * self.as_inner().ty(),
            -(operand.z() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.z() * self.as_inner().ty() * self.as_inner().ty())
                + -T::TWO * operand.x() * self.as_inner().s() * self.as_inner().ty()
                + -T::TWO * operand.y() * self.as_inner().rx() * self.as_inner().s()
                + -T::TWO * operand.y() * self.as_inner().ty() * self.as_inner().tz()
                + T::TWO * operand.x() * self.as_inner().rx() * self.as_inner().tz()
                + operand.z() * self.as_inner().s() * self.as_inner().s()
                + operand.z() * self.as_inner().tz() * self.as_inner().tz(),
            -T::TWO * operand.x() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.x() * self.as_inner().s() * self.as_inner().tx()
                + -T::TWO * operand.y() * self.as_inner().ry() * self.as_inner().s()
                + -T::TWO * operand.y() * self.as_inner().tx() * self.as_inner().tz()
                + -T::TWO * operand.z() * self.as_inner().ps() * self.as_inner().tz()
                + -T::TWO * operand.z() * self.as_inner().rx() * self.as_inner().ry()
                + -T::TWO * operand.z() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.z() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.x() * self.as_inner().ry() * self.as_inner().tz()
                + T::TWO * operand.x() * self.as_inner().rz() * self.as_inner().ty()
                + T::TWO * operand.y() * self.as_inner().ps() * self.as_inner().ty()
                + T::TWO * operand.y() * self.as_inner().rx() * self.as_inner().rz()
                + operand.w() * self.as_inner().rx() * self.as_inner().rx()
                + operand.w() * self.as_inner().s() * self.as_inner().s()
                + operand.w() * self.as_inner().ty() * self.as_inner().ty()
                + operand.w() * self.as_inner().tz() * self.as_inner().tz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Point<T>>> for Motor<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x() * self.ty() * self.ty())
                + -(operand.as_inner().x() * self.tz() * self.tz())
                + -T::TWO * operand.as_inner().y() * self.rx() * self.ty()
                + T::TWO * operand.as_inner().y() * self.s() * self.tz()
                + T::TWO * operand.as_inner().z() * self.rx() * self.tz()
                + T::TWO * operand.as_inner().z() * self.s() * self.ty()
                + operand.as_inner().x() * self.rx() * self.rx()
                + operand.as_inner().x() * self.s() * self.s(),
            -(operand.as_inner().y() * self.rx() * self.rx())
                + -(operand.as_inner().y() * self.tz() * self.tz())
                + -T::TWO * operand.as_inner().x() * self.rx() * self.ty()
                + -T::TWO * operand.as_inner().x() * self.s() * self.tz()
                + -T::TWO * operand.as_inner().z() * self.ty() * self.tz()
                + T::TWO * operand.as_inner().z() * self.rx() * self.s()
                + operand.as_inner().y() * self.s() * self.s()
                + operand.as_inner().y() * self.ty() * self.ty(),
            -(operand.as_inner().z() * self.rx() * self.rx())
                + -(operand.as_inner().z() * self.ty() * self.ty())
                + -T::TWO * operand.as_inner().x() * self.s() * self.ty()
                + -T::TWO * operand.as_inner().y() * self.rx() * self.s()
                + -T::TWO * operand.as_inner().y() * self.ty() * self.tz()
                + T::TWO * operand.as_inner().x() * self.rx() * self.tz()
                + operand.as_inner().z() * self.s() * self.s()
                + operand.as_inner().z() * self.tz() * self.tz(),
            -T::TWO * operand.as_inner().x() * self.ps() * self.rx()
                + -T::TWO * operand.as_inner().x() * self.s() * self.tx()
                + -T::TWO * operand.as_inner().y() * self.ry() * self.s()
                + -T::TWO * operand.as_inner().y() * self.tx() * self.tz()
                + -T::TWO * operand.as_inner().z() * self.ps() * self.tz()
                + -T::TWO * operand.as_inner().z() * self.rx() * self.ry()
                + -T::TWO * operand.as_inner().z() * self.rz() * self.s()
                + -T::TWO * operand.as_inner().z() * self.tx() * self.ty()
                + T::TWO * operand.as_inner().x() * self.ry() * self.tz()
                + T::TWO * operand.as_inner().x() * self.rz() * self.ty()
                + T::TWO * operand.as_inner().y() * self.ps() * self.ty()
                + T::TWO * operand.as_inner().y() * self.rx() * self.rz()
                + operand.as_inner().w() * self.rx() * self.rx()
                + operand.as_inner().w() * self.s() * self.s()
                + operand.as_inner().w() * self.ty() * self.ty()
                + operand.as_inner().w() * self.tz() * self.tz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Point<T>>> for Unitized<Motor<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x() * self.as_inner().ty() * self.as_inner().ty())
                + -(operand.as_inner().x() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.as_inner().y() * self.as_inner().rx() * self.as_inner().ty()
                + T::TWO * operand.as_inner().y() * self.as_inner().s() * self.as_inner().tz()
                + T::TWO * operand.as_inner().z() * self.as_inner().rx() * self.as_inner().tz()
                + T::TWO * operand.as_inner().z() * self.as_inner().s() * self.as_inner().ty()
                + operand.as_inner().x() * self.as_inner().rx() * self.as_inner().rx()
                + operand.as_inner().x() * self.as_inner().s() * self.as_inner().s(),
            -(operand.as_inner().y() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.as_inner().y() * self.as_inner().tz() * self.as_inner().tz())
                + -T::TWO * operand.as_inner().x() * self.as_inner().rx() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().x() * self.as_inner().s() * self.as_inner().tz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().ty() * self.as_inner().tz()
                + T::TWO * operand.as_inner().z() * self.as_inner().rx() * self.as_inner().s()
                + operand.as_inner().y() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().y() * self.as_inner().ty() * self.as_inner().ty(),
            -(operand.as_inner().z() * self.as_inner().rx() * self.as_inner().rx())
                + -(operand.as_inner().z() * self.as_inner().ty() * self.as_inner().ty())
                + -T::TWO * operand.as_inner().x() * self.as_inner().s() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().y() * self.as_inner().rx() * self.as_inner().s()
                + -T::TWO * operand.as_inner().y() * self.as_inner().ty() * self.as_inner().tz()
                + T::TWO * operand.as_inner().x() * self.as_inner().rx() * self.as_inner().tz()
                + operand.as_inner().z() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().z() * self.as_inner().tz() * self.as_inner().tz(),
            -T::TWO * operand.as_inner().x() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.as_inner().x() * self.as_inner().s() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().y() * self.as_inner().ry() * self.as_inner().s()
                + -T::TWO * operand.as_inner().y() * self.as_inner().tx() * self.as_inner().tz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().ps() * self.as_inner().tz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().rx() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().z() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.as_inner().z() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.as_inner().x() * self.as_inner().ry() * self.as_inner().tz()
                + T::TWO * operand.as_inner().x() * self.as_inner().rz() * self.as_inner().ty()
                + T::TWO * operand.as_inner().y() * self.as_inner().ps() * self.as_inner().ty()
                + T::TWO * operand.as_inner().y() * self.as_inner().rx() * self.as_inner().rz()
                + operand.as_inner().w() * self.as_inner().rx() * self.as_inner().rx()
                + operand.as_inner().w() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().w() * self.as_inner().ty() * self.as_inner().ty()
                + operand.as_inner().w() * self.as_inner().tz() * self.as_inner().tz(),
        )
    }
}
#[doc = "Sandwich product: [`Motor`] x [`Quadvector`] x rev([`Motor`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Quadvector<T>> for Motor<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            self.rx() * operand.ps() * self.rx()
                + self.s() * operand.ps() * self.s()
                + self.ty() * operand.ps() * self.ty()
                + self.tz() * operand.ps() * self.tz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Quadvector<T>> for Unitized<Motor<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            operand.ps() * self.as_inner().rx() * self.as_inner().rx()
                + operand.ps() * self.as_inner().s() * self.as_inner().s()
                + operand.ps() * self.as_inner().ty() * self.as_inner().ty()
                + operand.ps() * self.as_inner().tz() * self.as_inner().tz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Quadvector<T>>> for Motor<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            operand.as_inner().ps() * self.rx() * self.rx()
                + operand.as_inner().ps() * self.s() * self.s()
                + operand.as_inner().ps() * self.ty() * self.ty()
                + operand.as_inner().ps() * self.tz() * self.tz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Quadvector<T>>> for Unitized<Motor<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            operand.as_inner().ps() * self.as_inner().rx() * self.as_inner().rx()
                + operand.as_inner().ps() * self.as_inner().s() * self.as_inner().s()
                + operand.as_inner().ps() * self.as_inner().ty() * self.as_inner().ty()
                + operand.as_inner().ps() * self.as_inner().tz() * self.as_inner().tz(),
        )
    }
}
#[doc = "Sandwich product: [`Motor`] x [`Scalar`] x rev([`Motor`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Motor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.rx() * operand.s() * self.rx()
                + self.s() * operand.s() * self.s()
                + self.ty() * operand.s() * self.ty()
                + self.tz() * operand.s() * self.tz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unitized<Motor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            operand.s() * self.as_inner().rx() * self.as_inner().rx()
                + operand.s() * self.as_inner().s() * self.as_inner().s()
                + operand.s() * self.as_inner().ty() * self.as_inner().ty()
                + operand.s() * self.as_inner().tz() * self.as_inner().tz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Motor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Unitized<Motor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Sandwich product: [`Plane`] x [`Flector`] x rev([`Plane`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Flector<T>> for Plane<T> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            self.dist() * operand.px() * self.dist(),
            self.dist() * operand.py() * self.dist(),
            self.dist() * operand.pz() * self.dist(),
            -(self.dist() * operand.pw() * self.dist()) + self.dist() * operand.px() * self.nx()
                - self.dist() * operand.py() * self.ny()
                + self.dist() * operand.pz() * self.nz()
                + self.nx() * operand.px() * self.dist()
                - self.ny() * operand.py() * self.dist()
                + self.nz() * operand.pz() * self.dist(),
            self.dist() * operand.dist() * self.dist(),
            self.dist() * operand.dist() * self.nz()
                - self.dist() * operand.nz() * self.dist()
                - self.dist() * operand.px() * self.ny()
                - self.dist() * operand.py() * self.nx()
                + self.nx() * operand.py() * self.dist()
                + self.ny() * operand.px() * self.dist()
                + self.nz() * operand.dist() * self.dist(),
            self.dist() * operand.dist() * self.ny() - self.dist() * operand.ny() * self.dist()
                + self.dist() * operand.px() * self.nz()
                - self.dist() * operand.pz() * self.nx()
                + self.nx() * operand.pz() * self.dist()
                + self.ny() * operand.dist() * self.dist()
                - self.nz() * operand.px() * self.dist(),
            self.dist() * operand.dist() * self.nx() - self.dist() * operand.nx() * self.dist()
                + self.dist() * operand.py() * self.nz()
                + self.dist() * operand.pz() * self.ny()
                + self.nx() * operand.dist() * self.dist()
                - self.ny() * operand.pz() * self.dist()
                - self.nz() * operand.py() * self.dist(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Flector<T>> for Unitized<Plane<T>> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            operand.px() * self.as_inner().dist() * self.as_inner().dist(),
            operand.py() * self.as_inner().dist() * self.as_inner().dist(),
            operand.pz() * self.as_inner().dist() * self.as_inner().dist(),
            -(operand.pw() * self.as_inner().dist() * self.as_inner().dist())
                + -T::TWO * operand.py() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.px() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.pz() * self.as_inner().dist() * self.as_inner().nz(),
            operand.dist() * self.as_inner().dist() * self.as_inner().dist(),
            -(operand.nz() * self.as_inner().dist() * self.as_inner().dist())
                + T::TWO * operand.dist() * self.as_inner().dist() * self.as_inner().nz(),
            -(operand.ny() * self.as_inner().dist() * self.as_inner().dist())
                + T::TWO * operand.dist() * self.as_inner().dist() * self.as_inner().ny(),
            -(operand.nx() * self.as_inner().dist() * self.as_inner().dist())
                + T::TWO * operand.dist() * self.as_inner().dist() * self.as_inner().nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Flector<T>>> for Plane<T> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            operand.as_inner().px() * self.dist() * self.dist(),
            operand.as_inner().py() * self.dist() * self.dist(),
            operand.as_inner().pz() * self.dist() * self.dist(),
            -(operand.as_inner().pw() * self.dist() * self.dist())
                + -T::TWO * operand.as_inner().py() * self.dist() * self.ny()
                + T::TWO * operand.as_inner().px() * self.dist() * self.nx()
                + T::TWO * operand.as_inner().pz() * self.dist() * self.nz(),
            operand.as_inner().dist() * self.dist() * self.dist(),
            -(operand.as_inner().nz() * self.dist() * self.dist())
                + T::TWO * operand.as_inner().dist() * self.dist() * self.nz(),
            -(operand.as_inner().ny() * self.dist() * self.dist())
                + T::TWO * operand.as_inner().dist() * self.dist() * self.ny(),
            -(operand.as_inner().nx() * self.dist() * self.dist())
                + T::TWO * operand.as_inner().dist() * self.dist() * self.nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Flector<T>>> for Unitized<Plane<T>> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            operand.as_inner().px() * self.as_inner().dist() * self.as_inner().dist(),
            operand.as_inner().py() * self.as_inner().dist() * self.as_inner().dist(),
            operand.as_inner().pz() * self.as_inner().dist() * self.as_inner().dist(),
            -(operand.as_inner().pw() * self.as_inner().dist() * self.as_inner().dist())
                + -T::TWO * operand.as_inner().py() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.as_inner().px() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.as_inner().pz() * self.as_inner().dist() * self.as_inner().nz(),
            operand.as_inner().dist() * self.as_inner().dist() * self.as_inner().dist(),
            -(operand.as_inner().nz() * self.as_inner().dist() * self.as_inner().dist())
                + T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dist()
                    * self.as_inner().nz(),
            -(operand.as_inner().ny() * self.as_inner().dist() * self.as_inner().dist())
                + T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dist()
                    * self.as_inner().ny(),
            -(operand.as_inner().nx() * self.as_inner().dist() * self.as_inner().dist())
                + T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dist()
                    * self.as_inner().nx(),
        )
    }
}
#[doc = "Sandwich product: [`Plane`] x [`Line`] x rev([`Plane`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Plane<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.dist() * operand.moment_z() * self.dist(),
            self.dist() * operand.moment_y() * self.dist(),
            -(self.dist() * operand.dir_x() * self.dist())
                + self.dist() * operand.moment_y() * self.nz()
                - self.dist() * operand.moment_z() * self.ny()
                - self.ny() * operand.moment_z() * self.dist()
                + self.nz() * operand.moment_y() * self.dist(),
            self.dist() * operand.moment_x() * self.dist(),
            -(self.dist() * operand.dir_y() * self.dist())
                + self.dist() * operand.moment_x() * self.nz()
                - self.dist() * operand.moment_z() * self.nx()
                - self.nx() * operand.moment_z() * self.dist()
                + self.nz() * operand.moment_x() * self.dist(),
            -(self.dist() * operand.dir_z() * self.dist())
                + self.dist() * operand.moment_x() * self.ny()
                - self.dist() * operand.moment_y() * self.nx()
                - self.nx() * operand.moment_y() * self.dist()
                + self.ny() * operand.moment_x() * self.dist(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Unitized<Plane<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            operand.moment_z() * self.as_inner().dist() * self.as_inner().dist(),
            operand.moment_y() * self.as_inner().dist() * self.as_inner().dist(),
            -(operand.dir_x() * self.as_inner().dist() * self.as_inner().dist())
                + -T::TWO * operand.moment_z() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.moment_y() * self.as_inner().dist() * self.as_inner().nz(),
            operand.moment_x() * self.as_inner().dist() * self.as_inner().dist(),
            -(operand.dir_y() * self.as_inner().dist() * self.as_inner().dist())
                + -T::TWO * operand.moment_z() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.moment_x() * self.as_inner().dist() * self.as_inner().nz(),
            -(operand.dir_z() * self.as_inner().dist() * self.as_inner().dist())
                + -T::TWO * operand.moment_y() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.moment_x() * self.as_inner().dist() * self.as_inner().ny(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Line<T>>> for Plane<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            operand.as_inner().moment_z() * self.dist() * self.dist(),
            operand.as_inner().moment_y() * self.dist() * self.dist(),
            -(operand.as_inner().dir_x() * self.dist() * self.dist())
                + -T::TWO * operand.as_inner().moment_z() * self.dist() * self.ny()
                + T::TWO * operand.as_inner().moment_y() * self.dist() * self.nz(),
            operand.as_inner().moment_x() * self.dist() * self.dist(),
            -(operand.as_inner().dir_y() * self.dist() * self.dist())
                + -T::TWO * operand.as_inner().moment_z() * self.dist() * self.nx()
                + T::TWO * operand.as_inner().moment_x() * self.dist() * self.nz(),
            -(operand.as_inner().dir_z() * self.dist() * self.dist())
                + -T::TWO * operand.as_inner().moment_y() * self.dist() * self.nx()
                + T::TWO * operand.as_inner().moment_x() * self.dist() * self.ny(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Line<T>>> for Unitized<Plane<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            operand.as_inner().moment_z() * self.as_inner().dist() * self.as_inner().dist(),
            operand.as_inner().moment_y() * self.as_inner().dist() * self.as_inner().dist(),
            -(operand.as_inner().dir_x() * self.as_inner().dist() * self.as_inner().dist())
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().dist()
                    * self.as_inner().ny()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().dist()
                    * self.as_inner().nz(),
            operand.as_inner().moment_x() * self.as_inner().dist() * self.as_inner().dist(),
            -(operand.as_inner().dir_y() * self.as_inner().dist() * self.as_inner().dist())
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().dist()
                    * self.as_inner().nx()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().dist()
                    * self.as_inner().nz(),
            -(operand.as_inner().dir_z() * self.as_inner().dist() * self.as_inner().dist())
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().dist()
                    * self.as_inner().nx()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().dist()
                    * self.as_inner().ny(),
        )
    }
}
#[doc = "Sandwich product: [`Plane`] x [`Motor`] x rev([`Plane`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Motor<T>> for Plane<T> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            self.dist() * operand.s() * self.dist(),
            self.dist() * operand.tz() * self.dist(),
            self.dist() * operand.ty() * self.dist(),
            self.dist() * operand.s() * self.nx() - self.dist() * operand.tx() * self.dist()
                + self.dist() * operand.ty() * self.nz()
                - self.dist() * operand.tz() * self.ny()
                - self.nx() * operand.s() * self.dist()
                - self.ny() * operand.tz() * self.dist()
                + self.nz() * operand.ty() * self.dist(),
            self.dist() * operand.rx() * self.dist(),
            self.dist() * operand.rx() * self.nz()
                - self.dist() * operand.ry() * self.dist()
                - self.dist() * operand.s() * self.ny()
                - self.dist() * operand.tz() * self.nx()
                - self.nx() * operand.tz() * self.dist()
                + self.ny() * operand.s() * self.dist()
                + self.nz() * operand.rx() * self.dist(),
            self.dist() * operand.rx() * self.ny() - self.dist() * operand.rz() * self.dist()
                + self.dist() * operand.s() * self.nz()
                - self.dist() * operand.ty() * self.nx()
                - self.nx() * operand.ty() * self.dist()
                + self.ny() * operand.rx() * self.dist()
                - self.nz() * operand.s() * self.dist(),
            -(self.dist() * operand.ps() * self.dist())
                + self.dist() * operand.rx() * self.nx()
                + self.dist() * operand.ty() * self.ny()
                + self.dist() * operand.tz() * self.nz()
                - self.nx() * operand.rx() * self.dist()
                - self.ny() * operand.ty() * self.dist()
                - self.nz() * operand.tz() * self.dist(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Motor<T>> for Unitized<Plane<T>> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            operand.s() * self.as_inner().dist() * self.as_inner().dist(),
            operand.tz() * self.as_inner().dist() * self.as_inner().dist(),
            operand.ty() * self.as_inner().dist() * self.as_inner().dist(),
            -(operand.tx() * self.as_inner().dist() * self.as_inner().dist())
                + -T::TWO * operand.tz() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.ty() * self.as_inner().dist() * self.as_inner().nz(),
            operand.rx() * self.as_inner().dist() * self.as_inner().dist(),
            -(operand.ry() * self.as_inner().dist() * self.as_inner().dist())
                + -T::TWO * operand.tz() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.rx() * self.as_inner().dist() * self.as_inner().nz(),
            -(operand.rz() * self.as_inner().dist() * self.as_inner().dist())
                + -T::TWO * operand.ty() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.rx() * self.as_inner().dist() * self.as_inner().ny(),
            -(operand.ps() * self.as_inner().dist() * self.as_inner().dist()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Motor<T>>> for Plane<T> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s() * self.dist() * self.dist(),
            operand.as_inner().tz() * self.dist() * self.dist(),
            operand.as_inner().ty() * self.dist() * self.dist(),
            -(operand.as_inner().tx() * self.dist() * self.dist())
                + -T::TWO * operand.as_inner().tz() * self.dist() * self.ny()
                + T::TWO * operand.as_inner().ty() * self.dist() * self.nz(),
            operand.as_inner().rx() * self.dist() * self.dist(),
            -(operand.as_inner().ry() * self.dist() * self.dist())
                + -T::TWO * operand.as_inner().tz() * self.dist() * self.nx()
                + T::TWO * operand.as_inner().rx() * self.dist() * self.nz(),
            -(operand.as_inner().rz() * self.dist() * self.dist())
                + -T::TWO * operand.as_inner().ty() * self.dist() * self.nx()
                + T::TWO * operand.as_inner().rx() * self.dist() * self.ny(),
            -(operand.as_inner().ps() * self.dist() * self.dist()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Motor<T>>> for Unitized<Plane<T>> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s() * self.as_inner().dist() * self.as_inner().dist(),
            operand.as_inner().tz() * self.as_inner().dist() * self.as_inner().dist(),
            operand.as_inner().ty() * self.as_inner().dist() * self.as_inner().dist(),
            -(operand.as_inner().tx() * self.as_inner().dist() * self.as_inner().dist())
                + -T::TWO * operand.as_inner().tz() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.as_inner().ty() * self.as_inner().dist() * self.as_inner().nz(),
            operand.as_inner().rx() * self.as_inner().dist() * self.as_inner().dist(),
            -(operand.as_inner().ry() * self.as_inner().dist() * self.as_inner().dist())
                + -T::TWO * operand.as_inner().tz() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.as_inner().rx() * self.as_inner().dist() * self.as_inner().nz(),
            -(operand.as_inner().rz() * self.as_inner().dist() * self.as_inner().dist())
                + -T::TWO * operand.as_inner().ty() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.as_inner().rx() * self.as_inner().dist() * self.as_inner().ny(),
            -(operand.as_inner().ps() * self.as_inner().dist() * self.as_inner().dist()),
        )
    }
}
#[doc = "Sandwich product: [`Plane`] x [`Plane`] x rev([`Plane`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Plane<T>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            self.dist() * operand.dist() * self.dist(),
            self.dist() * operand.dist() * self.nz() - self.dist() * operand.nz() * self.dist()
                + self.nz() * operand.dist() * self.dist(),
            self.dist() * operand.dist() * self.ny() - self.dist() * operand.ny() * self.dist()
                + self.ny() * operand.dist() * self.dist(),
            self.dist() * operand.dist() * self.nx() - self.dist() * operand.nx() * self.dist()
                + self.nx() * operand.dist() * self.dist(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Plane<T>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            operand.dist() * self.as_inner().dist() * self.as_inner().dist(),
            -(operand.nz() * self.as_inner().dist() * self.as_inner().dist())
                + T::TWO * operand.dist() * self.as_inner().dist() * self.as_inner().nz(),
            -(operand.ny() * self.as_inner().dist() * self.as_inner().dist())
                + T::TWO * operand.dist() * self.as_inner().dist() * self.as_inner().ny(),
            -(operand.nx() * self.as_inner().dist() * self.as_inner().dist())
                + T::TWO * operand.dist() * self.as_inner().dist() * self.as_inner().nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Plane<T>>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            operand.as_inner().dist() * self.dist() * self.dist(),
            -(operand.as_inner().nz() * self.dist() * self.dist())
                + T::TWO * operand.as_inner().dist() * self.dist() * self.nz(),
            -(operand.as_inner().ny() * self.dist() * self.dist())
                + T::TWO * operand.as_inner().dist() * self.dist() * self.ny(),
            -(operand.as_inner().nx() * self.dist() * self.dist())
                + T::TWO * operand.as_inner().dist() * self.dist() * self.nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Plane<T>>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            operand.as_inner().dist() * self.as_inner().dist() * self.as_inner().dist(),
            -(operand.as_inner().nz() * self.as_inner().dist() * self.as_inner().dist())
                + T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dist()
                    * self.as_inner().nz(),
            -(operand.as_inner().ny() * self.as_inner().dist() * self.as_inner().dist())
                + T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dist()
                    * self.as_inner().ny(),
            -(operand.as_inner().nx() * self.as_inner().dist() * self.as_inner().dist())
                + T::TWO
                    * operand.as_inner().dist()
                    * self.as_inner().dist()
                    * self.as_inner().nx(),
        )
    }
}
#[doc = "Sandwich product: [`Plane`] x [`Point`] x rev([`Plane`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.dist() * operand.x() * self.dist(),
            self.dist() * operand.y() * self.dist(),
            self.dist() * operand.z() * self.dist(),
            -(self.dist() * operand.w() * self.dist()) + self.dist() * operand.x() * self.nx()
                - self.dist() * operand.y() * self.ny()
                + self.dist() * operand.z() * self.nz()
                + self.nx() * operand.x() * self.dist()
                - self.ny() * operand.y() * self.dist()
                + self.nz() * operand.z() * self.dist(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Unitized<Plane<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            operand.x() * self.as_inner().dist() * self.as_inner().dist(),
            operand.y() * self.as_inner().dist() * self.as_inner().dist(),
            operand.z() * self.as_inner().dist() * self.as_inner().dist(),
            -(operand.w() * self.as_inner().dist() * self.as_inner().dist())
                + -T::TWO * operand.y() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.x() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.z() * self.as_inner().dist() * self.as_inner().nz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Point<T>>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            operand.as_inner().x() * self.dist() * self.dist(),
            operand.as_inner().y() * self.dist() * self.dist(),
            operand.as_inner().z() * self.dist() * self.dist(),
            -(operand.as_inner().w() * self.dist() * self.dist())
                + -T::TWO * operand.as_inner().y() * self.dist() * self.ny()
                + T::TWO * operand.as_inner().x() * self.dist() * self.nx()
                + T::TWO * operand.as_inner().z() * self.dist() * self.nz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Point<T>>> for Unitized<Plane<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            operand.as_inner().x() * self.as_inner().dist() * self.as_inner().dist(),
            operand.as_inner().y() * self.as_inner().dist() * self.as_inner().dist(),
            operand.as_inner().z() * self.as_inner().dist() * self.as_inner().dist(),
            -(operand.as_inner().w() * self.as_inner().dist() * self.as_inner().dist())
                + -T::TWO * operand.as_inner().y() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.as_inner().x() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.as_inner().z() * self.as_inner().dist() * self.as_inner().nz(),
        )
    }
}
#[doc = "Sandwich product: [`Plane`] x [`Quadvector`] x rev([`Plane`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Quadvector<T>> for Plane<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(-(self.dist() * operand.ps() * self.dist()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Quadvector<T>> for Unitized<Plane<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(-(operand.ps() * self.as_inner().dist() * self.as_inner().dist()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Quadvector<T>>> for Plane<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(-(operand.as_inner().ps() * self.dist() * self.dist()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Quadvector<T>>> for Unitized<Plane<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(operand.as_inner().ps() * self.as_inner().dist() * self.as_inner().dist()),
        )
    }
}
#[doc = "Sandwich product: [`Plane`] x [`Scalar`] x rev([`Plane`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Plane<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.dist() * operand.s() * self.dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unitized<Plane<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s() * self.as_inner().dist() * self.as_inner().dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Plane<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Unitized<Plane<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Sandwich product: [`Point`] x [`Flector`] x rev([`Point`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Flector<T>> for Point<T> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            self.x() * operand.px() * self.x()
                + self.x() * operand.py() * self.y()
                + self.x() * operand.pz() * self.z()
                - self.y() * operand.dist() * self.z()
                - self.y() * operand.px() * self.y()
                + self.y() * operand.py() * self.x()
                + self.z() * operand.dist() * self.y()
                - self.z() * operand.px() * self.z()
                + self.z() * operand.pz() * self.x(),
            self.x() * operand.dist() * self.z() + self.x() * operand.px() * self.y()
                - self.x() * operand.py() * self.x()
                + self.y() * operand.px() * self.x()
                + self.y() * operand.py() * self.y()
                + self.y() * operand.pz() * self.z()
                - self.z() * operand.dist() * self.x()
                - self.z() * operand.py() * self.z()
                + self.z() * operand.pz() * self.y(),
            -(self.x() * operand.dist() * self.y()) + self.x() * operand.px() * self.z()
                - self.x() * operand.pz() * self.x()
                + self.y() * operand.dist() * self.x()
                + self.y() * operand.py() * self.z()
                - self.y() * operand.pz() * self.y()
                + self.z() * operand.px() * self.x()
                + self.z() * operand.py() * self.y()
                + self.z() * operand.pz() * self.z(),
            self.w() * operand.px() * self.x()
                + self.w() * operand.py() * self.y()
                + self.w() * operand.pz() * self.z()
                - self.x() * operand.ny() * self.z()
                - self.x() * operand.nz() * self.y()
                - self.x() * operand.pw() * self.x()
                + self.x() * operand.px() * self.w()
                - self.y() * operand.nx() * self.z()
                + self.y() * operand.nz() * self.x()
                - self.y() * operand.pw() * self.y()
                + self.y() * operand.py() * self.w()
                + self.z() * operand.nx() * self.y()
                + self.z() * operand.ny() * self.x()
                - self.z() * operand.pw() * self.z()
                + self.z() * operand.pz() * self.w(),
            self.x() * operand.dist() * self.x() + self.x() * operand.py() * self.z()
                - self.x() * operand.pz() * self.y()
                + self.y() * operand.dist() * self.y()
                - self.y() * operand.px() * self.z()
                + self.y() * operand.pz() * self.x()
                + self.z() * operand.dist() * self.z()
                + self.z() * operand.px() * self.y()
                - self.z() * operand.py() * self.x(),
            self.w() * operand.dist() * self.z() + self.w() * operand.px() * self.y()
                - self.w() * operand.py() * self.x()
                - self.x() * operand.nx() * self.z()
                + self.x() * operand.nz() * self.x()
                - self.x() * operand.pw() * self.y()
                + self.x() * operand.py() * self.w()
                + self.y() * operand.ny() * self.z()
                + self.y() * operand.nz() * self.y()
                + self.y() * operand.pw() * self.x()
                - self.y() * operand.px() * self.w()
                + self.z() * operand.dist() * self.w()
                - self.z() * operand.nx() * self.x()
                + self.z() * operand.ny() * self.y()
                - self.z() * operand.nz() * self.z(),
            -(self.w() * operand.dist() * self.y()) + self.w() * operand.px() * self.z()
                - self.w() * operand.pz() * self.x()
                + self.x() * operand.nx() * self.y()
                + self.x() * operand.ny() * self.x()
                - self.x() * operand.pw() * self.z()
                + self.x() * operand.pz() * self.w()
                - self.y() * operand.dist() * self.w()
                + self.y() * operand.nx() * self.x()
                - self.y() * operand.ny() * self.y()
                + self.y() * operand.nz() * self.z()
                + self.z() * operand.ny() * self.z()
                + self.z() * operand.nz() * self.y()
                + self.z() * operand.pw() * self.x()
                - self.z() * operand.px() * self.w(),
            self.w() * operand.dist() * self.x() + self.w() * operand.py() * self.z()
                - self.w() * operand.pz() * self.y()
                + self.x() * operand.dist() * self.w()
                - self.x() * operand.nx() * self.x()
                + self.x() * operand.ny() * self.y()
                - self.x() * operand.nz() * self.z()
                + self.y() * operand.nx() * self.y()
                + self.y() * operand.ny() * self.x()
                - self.y() * operand.pw() * self.z()
                + self.y() * operand.pz() * self.w()
                + self.z() * operand.nx() * self.z()
                - self.z() * operand.nz() * self.x()
                + self.z() * operand.pw() * self.y()
                - self.z() * operand.py() * self.w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Flector<T>> for Unitized<Point<T>> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            -(operand.px() * self.as_inner().y() * self.as_inner().y())
                + -(operand.px() * self.as_inner().z() * self.as_inner().z())
                + T::TWO * operand.py() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.pz() * self.as_inner().x() * self.as_inner().z()
                + operand.px() * self.as_inner().x() * self.as_inner().x(),
            -(operand.py() * self.as_inner().x() * self.as_inner().x())
                + -(operand.py() * self.as_inner().z() * self.as_inner().z())
                + T::TWO * operand.px() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.pz() * self.as_inner().y() * self.as_inner().z()
                + operand.py() * self.as_inner().y() * self.as_inner().y(),
            -(operand.pz() * self.as_inner().x() * self.as_inner().x())
                + -(operand.pz() * self.as_inner().y() * self.as_inner().y())
                + T::TWO * operand.px() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.py() * self.as_inner().y() * self.as_inner().z()
                + operand.pz() * self.as_inner().z() * self.as_inner().z(),
            -(operand.pw() * self.as_inner().x() * self.as_inner().x())
                + -(operand.pw() * self.as_inner().y() * self.as_inner().y())
                + -(operand.pw() * self.as_inner().z() * self.as_inner().z())
                + T::TWO * operand.px() * self.as_inner().w() * self.as_inner().x()
                + T::TWO * operand.py() * self.as_inner().w() * self.as_inner().y()
                + T::TWO * operand.pz() * self.as_inner().w() * self.as_inner().z(),
            operand.dist() * self.as_inner().x() * self.as_inner().x()
                + operand.dist() * self.as_inner().y() * self.as_inner().y()
                + operand.dist() * self.as_inner().z() * self.as_inner().z(),
            -(operand.nz() * self.as_inner().z() * self.as_inner().z())
                + -T::TWO * operand.nx() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.dist() * self.as_inner().w() * self.as_inner().z()
                + T::TWO * operand.ny() * self.as_inner().y() * self.as_inner().z()
                + operand.nz() * self.as_inner().x() * self.as_inner().x()
                + operand.nz() * self.as_inner().y() * self.as_inner().y(),
            -(operand.ny() * self.as_inner().y() * self.as_inner().y())
                + -T::TWO * operand.dist() * self.as_inner().w() * self.as_inner().y()
                + T::TWO * operand.nx() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.nz() * self.as_inner().y() * self.as_inner().z()
                + operand.ny() * self.as_inner().x() * self.as_inner().x()
                + operand.ny() * self.as_inner().z() * self.as_inner().z(),
            -(operand.nx() * self.as_inner().x() * self.as_inner().x())
                + -T::TWO * operand.nz() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.dist() * self.as_inner().w() * self.as_inner().x()
                + T::TWO * operand.ny() * self.as_inner().x() * self.as_inner().y()
                + operand.nx() * self.as_inner().y() * self.as_inner().y()
                + operand.nx() * self.as_inner().z() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Flector<T>>> for Point<T> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            -(operand.as_inner().px() * self.y() * self.y())
                + -(operand.as_inner().px() * self.z() * self.z())
                + T::TWO * operand.as_inner().py() * self.x() * self.y()
                + T::TWO * operand.as_inner().pz() * self.x() * self.z()
                + operand.as_inner().px() * self.x() * self.x(),
            -(operand.as_inner().py() * self.x() * self.x())
                + -(operand.as_inner().py() * self.z() * self.z())
                + T::TWO * operand.as_inner().px() * self.x() * self.y()
                + T::TWO * operand.as_inner().pz() * self.y() * self.z()
                + operand.as_inner().py() * self.y() * self.y(),
            -(operand.as_inner().pz() * self.x() * self.x())
                + -(operand.as_inner().pz() * self.y() * self.y())
                + T::TWO * operand.as_inner().px() * self.x() * self.z()
                + T::TWO * operand.as_inner().py() * self.y() * self.z()
                + operand.as_inner().pz() * self.z() * self.z(),
            -(operand.as_inner().pw() * self.x() * self.x())
                + -(operand.as_inner().pw() * self.y() * self.y())
                + -(operand.as_inner().pw() * self.z() * self.z())
                + T::TWO * operand.as_inner().px() * self.w() * self.x()
                + T::TWO * operand.as_inner().py() * self.w() * self.y()
                + T::TWO * operand.as_inner().pz() * self.w() * self.z(),
            operand.as_inner().dist() * self.x() * self.x()
                + operand.as_inner().dist() * self.y() * self.y()
                + operand.as_inner().dist() * self.z() * self.z(),
            -(operand.as_inner().nz() * self.z() * self.z())
                + -T::TWO * operand.as_inner().nx() * self.x() * self.z()
                + T::TWO * operand.as_inner().dist() * self.w() * self.z()
                + T::TWO * operand.as_inner().ny() * self.y() * self.z()
                + operand.as_inner().nz() * self.x() * self.x()
                + operand.as_inner().nz() * self.y() * self.y(),
            -(operand.as_inner().ny() * self.y() * self.y())
                + -T::TWO * operand.as_inner().dist() * self.w() * self.y()
                + T::TWO * operand.as_inner().nx() * self.x() * self.y()
                + T::TWO * operand.as_inner().nz() * self.y() * self.z()
                + operand.as_inner().ny() * self.x() * self.x()
                + operand.as_inner().ny() * self.z() * self.z(),
            -(operand.as_inner().nx() * self.x() * self.x())
                + -T::TWO * operand.as_inner().nz() * self.x() * self.z()
                + T::TWO * operand.as_inner().dist() * self.w() * self.x()
                + T::TWO * operand.as_inner().ny() * self.x() * self.y()
                + operand.as_inner().nx() * self.y() * self.y()
                + operand.as_inner().nx() * self.z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Flector<T>>> for Unitized<Point<T>> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            -(operand.as_inner().px() * self.as_inner().y() * self.as_inner().y())
                + -(operand.as_inner().px() * self.as_inner().z() * self.as_inner().z())
                + T::TWO * operand.as_inner().py() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().pz() * self.as_inner().x() * self.as_inner().z()
                + operand.as_inner().px() * self.as_inner().x() * self.as_inner().x(),
            -(operand.as_inner().py() * self.as_inner().x() * self.as_inner().x())
                + -(operand.as_inner().py() * self.as_inner().z() * self.as_inner().z())
                + T::TWO * operand.as_inner().px() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().pz() * self.as_inner().y() * self.as_inner().z()
                + operand.as_inner().py() * self.as_inner().y() * self.as_inner().y(),
            -(operand.as_inner().pz() * self.as_inner().x() * self.as_inner().x())
                + -(operand.as_inner().pz() * self.as_inner().y() * self.as_inner().y())
                + T::TWO * operand.as_inner().px() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.as_inner().py() * self.as_inner().y() * self.as_inner().z()
                + operand.as_inner().pz() * self.as_inner().z() * self.as_inner().z(),
            -(operand.as_inner().pw() * self.as_inner().x() * self.as_inner().x())
                + -(operand.as_inner().pw() * self.as_inner().y() * self.as_inner().y())
                + -(operand.as_inner().pw() * self.as_inner().z() * self.as_inner().z())
                + T::TWO * operand.as_inner().px() * self.as_inner().w() * self.as_inner().x()
                + T::TWO * operand.as_inner().py() * self.as_inner().w() * self.as_inner().y()
                + T::TWO * operand.as_inner().pz() * self.as_inner().w() * self.as_inner().z(),
            operand.as_inner().dist() * self.as_inner().x() * self.as_inner().x()
                + operand.as_inner().dist() * self.as_inner().y() * self.as_inner().y()
                + operand.as_inner().dist() * self.as_inner().z() * self.as_inner().z(),
            -(operand.as_inner().nz() * self.as_inner().z() * self.as_inner().z())
                + -T::TWO * operand.as_inner().nx() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.as_inner().dist() * self.as_inner().w() * self.as_inner().z()
                + T::TWO * operand.as_inner().ny() * self.as_inner().y() * self.as_inner().z()
                + operand.as_inner().nz() * self.as_inner().x() * self.as_inner().x()
                + operand.as_inner().nz() * self.as_inner().y() * self.as_inner().y(),
            -(operand.as_inner().ny() * self.as_inner().y() * self.as_inner().y())
                + -T::TWO * operand.as_inner().dist() * self.as_inner().w() * self.as_inner().y()
                + T::TWO * operand.as_inner().nx() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().nz() * self.as_inner().y() * self.as_inner().z()
                + operand.as_inner().ny() * self.as_inner().x() * self.as_inner().x()
                + operand.as_inner().ny() * self.as_inner().z() * self.as_inner().z(),
            -(operand.as_inner().nx() * self.as_inner().x() * self.as_inner().x())
                + -T::TWO * operand.as_inner().nz() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.as_inner().dist() * self.as_inner().w() * self.as_inner().x()
                + T::TWO * operand.as_inner().ny() * self.as_inner().x() * self.as_inner().y()
                + operand.as_inner().nx() * self.as_inner().y() * self.as_inner().y()
                + operand.as_inner().nx() * self.as_inner().z() * self.as_inner().z(),
        )
    }
}
#[doc = "Sandwich product: [`Point`] x [`Line`] x rev([`Point`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.x() * operand.moment_x() * self.z()
                - self.x() * operand.moment_z() * self.x()
                - self.y() * operand.moment_y() * self.z()
                - self.y() * operand.moment_z() * self.y()
                + self.z() * operand.moment_x() * self.x()
                - self.z() * operand.moment_y() * self.y()
                + self.z() * operand.moment_z() * self.z(),
            -(self.x() * operand.moment_x() * self.y())
                - self.x() * operand.moment_y() * self.x()
                - self.y() * operand.moment_x() * self.x()
                + self.y() * operand.moment_y() * self.y()
                - self.y() * operand.moment_z() * self.z()
                - self.z() * operand.moment_y() * self.z()
                - self.z() * operand.moment_z() * self.y(),
            -(self.w() * operand.moment_y() * self.z())
                - self.w() * operand.moment_z() * self.y()
                - self.x() * operand.dir_x() * self.x()
                - self.x() * operand.dir_y() * self.y()
                - self.x() * operand.dir_z() * self.z()
                + self.y() * operand.dir_x() * self.y()
                - self.y() * operand.dir_y() * self.x()
                - self.y() * operand.moment_z() * self.w()
                + self.z() * operand.dir_x() * self.z()
                - self.z() * operand.dir_z() * self.x()
                - self.z() * operand.moment_y() * self.w(),
            self.x() * operand.moment_x() * self.x() - self.x() * operand.moment_y() * self.y()
                + self.x() * operand.moment_z() * self.z()
                - self.y() * operand.moment_x() * self.y()
                - self.y() * operand.moment_y() * self.x()
                - self.z() * operand.moment_x() * self.z()
                + self.z() * operand.moment_z() * self.x(),
            -(self.w() * operand.moment_x() * self.z()) + self.w() * operand.moment_z() * self.x()
                - self.x() * operand.dir_x() * self.y()
                + self.x() * operand.dir_y() * self.x()
                + self.x() * operand.moment_z() * self.w()
                - self.y() * operand.dir_x() * self.x()
                - self.y() * operand.dir_y() * self.y()
                - self.y() * operand.dir_z() * self.z()
                + self.z() * operand.dir_y() * self.z()
                - self.z() * operand.dir_z() * self.y()
                - self.z() * operand.moment_x() * self.w(),
            self.w() * operand.moment_x() * self.y() + self.w() * operand.moment_y() * self.x()
                - self.x() * operand.dir_x() * self.z()
                + self.x() * operand.dir_z() * self.x()
                + self.x() * operand.moment_y() * self.w()
                - self.y() * operand.dir_y() * self.z()
                + self.y() * operand.dir_z() * self.y()
                + self.y() * operand.moment_x() * self.w()
                - self.z() * operand.dir_x() * self.x()
                - self.z() * operand.dir_y() * self.y()
                - self.z() * operand.dir_z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Unitized<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            -(operand.moment_z() * self.as_inner().x() * self.as_inner().x())
                + -(operand.moment_z() * self.as_inner().y() * self.as_inner().y())
                + -T::TWO * operand.moment_y() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.moment_x() * self.as_inner().x() * self.as_inner().z()
                + operand.moment_z() * self.as_inner().z() * self.as_inner().z(),
            -(operand.moment_y() * self.as_inner().x() * self.as_inner().x())
                + -(operand.moment_y() * self.as_inner().z() * self.as_inner().z())
                + -T::TWO * operand.moment_x() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.moment_z() * self.as_inner().y() * self.as_inner().z()
                + operand.moment_y() * self.as_inner().y() * self.as_inner().y(),
            -(operand.dir_x() * self.as_inner().x() * self.as_inner().x())
                + -T::TWO * operand.dir_y() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.dir_z() * self.as_inner().x() * self.as_inner().z()
                + -T::TWO * operand.moment_y() * self.as_inner().w() * self.as_inner().z()
                + -T::TWO * operand.moment_z() * self.as_inner().w() * self.as_inner().y()
                + operand.dir_x() * self.as_inner().y() * self.as_inner().y()
                + operand.dir_x() * self.as_inner().z() * self.as_inner().z(),
            -(operand.moment_x() * self.as_inner().y() * self.as_inner().y())
                + -(operand.moment_x() * self.as_inner().z() * self.as_inner().z())
                + -T::TWO * operand.moment_y() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.moment_z() * self.as_inner().x() * self.as_inner().z()
                + operand.moment_x() * self.as_inner().x() * self.as_inner().x(),
            -(operand.dir_y() * self.as_inner().y() * self.as_inner().y())
                + -T::TWO * operand.dir_x() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.dir_z() * self.as_inner().y() * self.as_inner().z()
                + -T::TWO * operand.moment_x() * self.as_inner().w() * self.as_inner().z()
                + T::TWO * operand.moment_z() * self.as_inner().w() * self.as_inner().x()
                + operand.dir_y() * self.as_inner().x() * self.as_inner().x()
                + operand.dir_y() * self.as_inner().z() * self.as_inner().z(),
            -(operand.dir_z() * self.as_inner().z() * self.as_inner().z())
                + -T::TWO * operand.dir_x() * self.as_inner().x() * self.as_inner().z()
                + -T::TWO * operand.dir_y() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.moment_x() * self.as_inner().w() * self.as_inner().y()
                + T::TWO * operand.moment_y() * self.as_inner().w() * self.as_inner().x()
                + operand.dir_z() * self.as_inner().x() * self.as_inner().x()
                + operand.dir_z() * self.as_inner().y() * self.as_inner().y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Line<T>>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(operand.as_inner().moment_z() * self.x() * self.x())
                + -(operand.as_inner().moment_z() * self.y() * self.y())
                + -T::TWO * operand.as_inner().moment_y() * self.y() * self.z()
                + T::TWO * operand.as_inner().moment_x() * self.x() * self.z()
                + operand.as_inner().moment_z() * self.z() * self.z(),
            -(operand.as_inner().moment_y() * self.x() * self.x())
                + -(operand.as_inner().moment_y() * self.z() * self.z())
                + -T::TWO * operand.as_inner().moment_x() * self.x() * self.y()
                + -T::TWO * operand.as_inner().moment_z() * self.y() * self.z()
                + operand.as_inner().moment_y() * self.y() * self.y(),
            -(operand.as_inner().dir_x() * self.x() * self.x())
                + -T::TWO * operand.as_inner().dir_y() * self.x() * self.y()
                + -T::TWO * operand.as_inner().dir_z() * self.x() * self.z()
                + -T::TWO * operand.as_inner().moment_y() * self.w() * self.z()
                + -T::TWO * operand.as_inner().moment_z() * self.w() * self.y()
                + operand.as_inner().dir_x() * self.y() * self.y()
                + operand.as_inner().dir_x() * self.z() * self.z(),
            -(operand.as_inner().moment_x() * self.y() * self.y())
                + -(operand.as_inner().moment_x() * self.z() * self.z())
                + -T::TWO * operand.as_inner().moment_y() * self.x() * self.y()
                + T::TWO * operand.as_inner().moment_z() * self.x() * self.z()
                + operand.as_inner().moment_x() * self.x() * self.x(),
            -(operand.as_inner().dir_y() * self.y() * self.y())
                + -T::TWO * operand.as_inner().dir_x() * self.x() * self.y()
                + -T::TWO * operand.as_inner().dir_z() * self.y() * self.z()
                + -T::TWO * operand.as_inner().moment_x() * self.w() * self.z()
                + T::TWO * operand.as_inner().moment_z() * self.w() * self.x()
                + operand.as_inner().dir_y() * self.x() * self.x()
                + operand.as_inner().dir_y() * self.z() * self.z(),
            -(operand.as_inner().dir_z() * self.z() * self.z())
                + -T::TWO * operand.as_inner().dir_x() * self.x() * self.z()
                + -T::TWO * operand.as_inner().dir_y() * self.y() * self.z()
                + T::TWO * operand.as_inner().moment_x() * self.w() * self.y()
                + T::TWO * operand.as_inner().moment_y() * self.w() * self.x()
                + operand.as_inner().dir_z() * self.x() * self.x()
                + operand.as_inner().dir_z() * self.y() * self.y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Line<T>>> for Unitized<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(operand.as_inner().moment_z() * self.as_inner().x() * self.as_inner().x())
                + -(operand.as_inner().moment_z() * self.as_inner().y() * self.as_inner().y())
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().y()
                    * self.as_inner().z()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().x()
                    * self.as_inner().z()
                + operand.as_inner().moment_z() * self.as_inner().z() * self.as_inner().z(),
            -(operand.as_inner().moment_y() * self.as_inner().x() * self.as_inner().x())
                + -(operand.as_inner().moment_y() * self.as_inner().z() * self.as_inner().z())
                + -T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().x()
                    * self.as_inner().y()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().y()
                    * self.as_inner().z()
                + operand.as_inner().moment_y() * self.as_inner().y() * self.as_inner().y(),
            -(operand.as_inner().dir_x() * self.as_inner().x() * self.as_inner().x())
                + -T::TWO * operand.as_inner().dir_y() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.as_inner().dir_z() * self.as_inner().x() * self.as_inner().z()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().w()
                    * self.as_inner().z()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().w()
                    * self.as_inner().y()
                + operand.as_inner().dir_x() * self.as_inner().y() * self.as_inner().y()
                + operand.as_inner().dir_x() * self.as_inner().z() * self.as_inner().z(),
            -(operand.as_inner().moment_x() * self.as_inner().y() * self.as_inner().y())
                + -(operand.as_inner().moment_x() * self.as_inner().z() * self.as_inner().z())
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().x()
                    * self.as_inner().y()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().x()
                    * self.as_inner().z()
                + operand.as_inner().moment_x() * self.as_inner().x() * self.as_inner().x(),
            -(operand.as_inner().dir_y() * self.as_inner().y() * self.as_inner().y())
                + -T::TWO * operand.as_inner().dir_x() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.as_inner().dir_z() * self.as_inner().y() * self.as_inner().z()
                + -T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().w()
                    * self.as_inner().z()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().w()
                    * self.as_inner().x()
                + operand.as_inner().dir_y() * self.as_inner().x() * self.as_inner().x()
                + operand.as_inner().dir_y() * self.as_inner().z() * self.as_inner().z(),
            -(operand.as_inner().dir_z() * self.as_inner().z() * self.as_inner().z())
                + -T::TWO * operand.as_inner().dir_x() * self.as_inner().x() * self.as_inner().z()
                + -T::TWO * operand.as_inner().dir_y() * self.as_inner().y() * self.as_inner().z()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().w()
                    * self.as_inner().y()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().w()
                    * self.as_inner().x()
                + operand.as_inner().dir_z() * self.as_inner().x() * self.as_inner().x()
                + operand.as_inner().dir_z() * self.as_inner().y() * self.as_inner().y(),
        )
    }
}
#[doc = "Sandwich product: [`Point`] x [`Motor`] x rev([`Point`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Motor<T>> for Point<T> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            self.x() * operand.s() * self.x()
                + self.x() * operand.ty() * self.z()
                + self.x() * operand.tz() * self.y()
                + self.y() * operand.rx() * self.z()
                + self.y() * operand.s() * self.y()
                - self.y() * operand.tz() * self.x()
                - self.z() * operand.rx() * self.y()
                + self.z() * operand.s() * self.z()
                - self.z() * operand.ty() * self.x(),
            self.x() * operand.rx() * self.z() + self.x() * operand.s() * self.y()
                - self.x() * operand.tz() * self.x()
                - self.y() * operand.s() * self.x()
                - self.y() * operand.ty() * self.z()
                - self.y() * operand.tz() * self.y()
                + self.z() * operand.rx() * self.x()
                - self.z() * operand.ty() * self.y()
                + self.z() * operand.tz() * self.z(),
            -(self.x() * operand.rx() * self.y()) + self.x() * operand.s() * self.z()
                - self.x() * operand.ty() * self.x()
                - self.y() * operand.rx() * self.x()
                + self.y() * operand.ty() * self.y()
                - self.y() * operand.tz() * self.z()
                - self.z() * operand.s() * self.x()
                - self.z() * operand.ty() * self.z()
                - self.z() * operand.tz() * self.y(),
            -(self.w() * operand.s() * self.x())
                - self.w() * operand.ty() * self.z()
                - self.w() * operand.tz() * self.y()
                - self.x() * operand.ry() * self.y()
                - self.x() * operand.rz() * self.z()
                + self.x() * operand.s() * self.w()
                - self.x() * operand.tx() * self.x()
                + self.y() * operand.ps() * self.z()
                - self.y() * operand.ry() * self.x()
                + self.y() * operand.tx() * self.y()
                - self.y() * operand.tz() * self.w()
                - self.z() * operand.ps() * self.y()
                - self.z() * operand.rz() * self.x()
                + self.z() * operand.tx() * self.z()
                - self.z() * operand.ty() * self.w(),
            self.x() * operand.rx() * self.x() - self.x() * operand.ty() * self.y()
                + self.x() * operand.tz() * self.z()
                - self.y() * operand.rx() * self.y()
                + self.y() * operand.s() * self.z()
                - self.y() * operand.ty() * self.x()
                - self.z() * operand.rx() * self.z()
                - self.z() * operand.s() * self.y()
                + self.z() * operand.tz() * self.x(),
            -(self.w() * operand.rx() * self.z()) - self.w() * operand.s() * self.y()
                + self.w() * operand.tz() * self.x()
                - self.x() * operand.ps() * self.z()
                + self.x() * operand.ry() * self.x()
                - self.x() * operand.tx() * self.y()
                + self.x() * operand.tz() * self.w()
                - self.y() * operand.ry() * self.y()
                - self.y() * operand.rz() * self.z()
                + self.y() * operand.s() * self.w()
                - self.y() * operand.tx() * self.x()
                + self.z() * operand.ps() * self.x()
                - self.z() * operand.rx() * self.w()
                + self.z() * operand.ry() * self.z()
                - self.z() * operand.rz() * self.y(),
            self.w() * operand.rx() * self.y() - self.w() * operand.s() * self.z()
                + self.w() * operand.ty() * self.x()
                + self.x() * operand.ps() * self.y()
                + self.x() * operand.rz() * self.x()
                - self.x() * operand.tx() * self.z()
                + self.x() * operand.ty() * self.w()
                - self.y() * operand.ps() * self.x()
                + self.y() * operand.rx() * self.w()
                - self.y() * operand.ry() * self.z()
                + self.y() * operand.rz() * self.y()
                - self.z() * operand.ry() * self.y()
                - self.z() * operand.rz() * self.z()
                + self.z() * operand.s() * self.w()
                - self.z() * operand.tx() * self.x(),
            -(self.w() * operand.rx() * self.x()) + self.w() * operand.ty() * self.y()
                - self.w() * operand.tz() * self.z()
                - self.x() * operand.ps() * self.x()
                + self.x() * operand.rx() * self.w()
                - self.x() * operand.ry() * self.z()
                + self.x() * operand.rz() * self.y()
                - self.y() * operand.ps() * self.y()
                - self.y() * operand.rz() * self.x()
                + self.y() * operand.tx() * self.z()
                - self.y() * operand.ty() * self.w()
                - self.z() * operand.ps() * self.z()
                + self.z() * operand.ry() * self.x()
                - self.z() * operand.tx() * self.y()
                + self.z() * operand.tz() * self.w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Motor<T>> for Unitized<Point<T>> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            operand.s() * self.as_inner().x() * self.as_inner().x()
                + operand.s() * self.as_inner().y() * self.as_inner().y()
                + operand.s() * self.as_inner().z() * self.as_inner().z(),
            -(operand.tz() * self.as_inner().x() * self.as_inner().x())
                + -(operand.tz() * self.as_inner().y() * self.as_inner().y())
                + -T::TWO * operand.ty() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.rx() * self.as_inner().x() * self.as_inner().z()
                + operand.tz() * self.as_inner().z() * self.as_inner().z(),
            -(operand.ty() * self.as_inner().x() * self.as_inner().x())
                + -(operand.ty() * self.as_inner().z() * self.as_inner().z())
                + -T::TWO * operand.rx() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.tz() * self.as_inner().y() * self.as_inner().z()
                + operand.ty() * self.as_inner().y() * self.as_inner().y(),
            -(operand.tx() * self.as_inner().x() * self.as_inner().x())
                + -T::TWO * operand.ry() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.rz() * self.as_inner().x() * self.as_inner().z()
                + -T::TWO * operand.ty() * self.as_inner().w() * self.as_inner().z()
                + -T::TWO * operand.tz() * self.as_inner().w() * self.as_inner().y()
                + operand.tx() * self.as_inner().y() * self.as_inner().y()
                + operand.tx() * self.as_inner().z() * self.as_inner().z(),
            -(operand.rx() * self.as_inner().y() * self.as_inner().y())
                + -(operand.rx() * self.as_inner().z() * self.as_inner().z())
                + -T::TWO * operand.ty() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.tz() * self.as_inner().x() * self.as_inner().z()
                + operand.rx() * self.as_inner().x() * self.as_inner().x(),
            -(operand.ry() * self.as_inner().y() * self.as_inner().y())
                + -T::TWO * operand.rx() * self.as_inner().w() * self.as_inner().z()
                + -T::TWO * operand.rz() * self.as_inner().y() * self.as_inner().z()
                + -T::TWO * operand.tx() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.tz() * self.as_inner().w() * self.as_inner().x()
                + operand.ry() * self.as_inner().x() * self.as_inner().x()
                + operand.ry() * self.as_inner().z() * self.as_inner().z(),
            -(operand.rz() * self.as_inner().z() * self.as_inner().z())
                + -T::TWO * operand.ry() * self.as_inner().y() * self.as_inner().z()
                + -T::TWO * operand.tx() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.rx() * self.as_inner().w() * self.as_inner().y()
                + T::TWO * operand.ty() * self.as_inner().w() * self.as_inner().x()
                + operand.rz() * self.as_inner().x() * self.as_inner().x()
                + operand.rz() * self.as_inner().y() * self.as_inner().y(),
            -(operand.ps() * self.as_inner().x() * self.as_inner().x())
                + -(operand.ps() * self.as_inner().y() * self.as_inner().y())
                + -(operand.ps() * self.as_inner().z() * self.as_inner().z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Motor<T>>> for Point<T> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s() * self.x() * self.x()
                + operand.as_inner().s() * self.y() * self.y()
                + operand.as_inner().s() * self.z() * self.z(),
            -(operand.as_inner().tz() * self.x() * self.x())
                + -(operand.as_inner().tz() * self.y() * self.y())
                + -T::TWO * operand.as_inner().ty() * self.y() * self.z()
                + T::TWO * operand.as_inner().rx() * self.x() * self.z()
                + operand.as_inner().tz() * self.z() * self.z(),
            -(operand.as_inner().ty() * self.x() * self.x())
                + -(operand.as_inner().ty() * self.z() * self.z())
                + -T::TWO * operand.as_inner().rx() * self.x() * self.y()
                + -T::TWO * operand.as_inner().tz() * self.y() * self.z()
                + operand.as_inner().ty() * self.y() * self.y(),
            -(operand.as_inner().tx() * self.x() * self.x())
                + -T::TWO * operand.as_inner().ry() * self.x() * self.y()
                + -T::TWO * operand.as_inner().rz() * self.x() * self.z()
                + -T::TWO * operand.as_inner().ty() * self.w() * self.z()
                + -T::TWO * operand.as_inner().tz() * self.w() * self.y()
                + operand.as_inner().tx() * self.y() * self.y()
                + operand.as_inner().tx() * self.z() * self.z(),
            -(operand.as_inner().rx() * self.y() * self.y())
                + -(operand.as_inner().rx() * self.z() * self.z())
                + -T::TWO * operand.as_inner().ty() * self.x() * self.y()
                + T::TWO * operand.as_inner().tz() * self.x() * self.z()
                + operand.as_inner().rx() * self.x() * self.x(),
            -(operand.as_inner().ry() * self.y() * self.y())
                + -T::TWO * operand.as_inner().rx() * self.w() * self.z()
                + -T::TWO * operand.as_inner().rz() * self.y() * self.z()
                + -T::TWO * operand.as_inner().tx() * self.x() * self.y()
                + T::TWO * operand.as_inner().tz() * self.w() * self.x()
                + operand.as_inner().ry() * self.x() * self.x()
                + operand.as_inner().ry() * self.z() * self.z(),
            -(operand.as_inner().rz() * self.z() * self.z())
                + -T::TWO * operand.as_inner().ry() * self.y() * self.z()
                + -T::TWO * operand.as_inner().tx() * self.x() * self.z()
                + T::TWO * operand.as_inner().rx() * self.w() * self.y()
                + T::TWO * operand.as_inner().ty() * self.w() * self.x()
                + operand.as_inner().rz() * self.x() * self.x()
                + operand.as_inner().rz() * self.y() * self.y(),
            -(operand.as_inner().ps() * self.x() * self.x())
                + -(operand.as_inner().ps() * self.y() * self.y())
                + -(operand.as_inner().ps() * self.z() * self.z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Motor<T>>> for Unitized<Point<T>> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s() * self.as_inner().x() * self.as_inner().x()
                + operand.as_inner().s() * self.as_inner().y() * self.as_inner().y()
                + operand.as_inner().s() * self.as_inner().z() * self.as_inner().z(),
            -(operand.as_inner().tz() * self.as_inner().x() * self.as_inner().x())
                + -(operand.as_inner().tz() * self.as_inner().y() * self.as_inner().y())
                + -T::TWO * operand.as_inner().ty() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.as_inner().rx() * self.as_inner().x() * self.as_inner().z()
                + operand.as_inner().tz() * self.as_inner().z() * self.as_inner().z(),
            -(operand.as_inner().ty() * self.as_inner().x() * self.as_inner().x())
                + -(operand.as_inner().ty() * self.as_inner().z() * self.as_inner().z())
                + -T::TWO * operand.as_inner().rx() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.as_inner().tz() * self.as_inner().y() * self.as_inner().z()
                + operand.as_inner().ty() * self.as_inner().y() * self.as_inner().y(),
            -(operand.as_inner().tx() * self.as_inner().x() * self.as_inner().x())
                + -T::TWO * operand.as_inner().ry() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.as_inner().rz() * self.as_inner().x() * self.as_inner().z()
                + -T::TWO * operand.as_inner().ty() * self.as_inner().w() * self.as_inner().z()
                + -T::TWO * operand.as_inner().tz() * self.as_inner().w() * self.as_inner().y()
                + operand.as_inner().tx() * self.as_inner().y() * self.as_inner().y()
                + operand.as_inner().tx() * self.as_inner().z() * self.as_inner().z(),
            -(operand.as_inner().rx() * self.as_inner().y() * self.as_inner().y())
                + -(operand.as_inner().rx() * self.as_inner().z() * self.as_inner().z())
                + -T::TWO * operand.as_inner().ty() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().tz() * self.as_inner().x() * self.as_inner().z()
                + operand.as_inner().rx() * self.as_inner().x() * self.as_inner().x(),
            -(operand.as_inner().ry() * self.as_inner().y() * self.as_inner().y())
                + -T::TWO * operand.as_inner().rx() * self.as_inner().w() * self.as_inner().z()
                + -T::TWO * operand.as_inner().rz() * self.as_inner().y() * self.as_inner().z()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().tz() * self.as_inner().w() * self.as_inner().x()
                + operand.as_inner().ry() * self.as_inner().x() * self.as_inner().x()
                + operand.as_inner().ry() * self.as_inner().z() * self.as_inner().z(),
            -(operand.as_inner().rz() * self.as_inner().z() * self.as_inner().z())
                + -T::TWO * operand.as_inner().ry() * self.as_inner().y() * self.as_inner().z()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.as_inner().rx() * self.as_inner().w() * self.as_inner().y()
                + T::TWO * operand.as_inner().ty() * self.as_inner().w() * self.as_inner().x()
                + operand.as_inner().rz() * self.as_inner().x() * self.as_inner().x()
                + operand.as_inner().rz() * self.as_inner().y() * self.as_inner().y(),
            -(operand.as_inner().ps() * self.as_inner().x() * self.as_inner().x())
                + -(operand.as_inner().ps() * self.as_inner().y() * self.as_inner().y())
                + -(operand.as_inner().ps() * self.as_inner().z() * self.as_inner().z()),
        )
    }
}
#[doc = "Sandwich product: [`Point`] x [`Plane`] x rev([`Point`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Plane<T>> for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            self.x() * operand.dist() * self.x()
                + self.y() * operand.dist() * self.y()
                + self.z() * operand.dist() * self.z(),
            self.w() * operand.dist() * self.z() - self.x() * operand.nx() * self.z()
                + self.x() * operand.nz() * self.x()
                + self.y() * operand.ny() * self.z()
                + self.y() * operand.nz() * self.y()
                + self.z() * operand.dist() * self.w()
                - self.z() * operand.nx() * self.x()
                + self.z() * operand.ny() * self.y()
                - self.z() * operand.nz() * self.z(),
            -(self.w() * operand.dist() * self.y())
                + self.x() * operand.nx() * self.y()
                + self.x() * operand.ny() * self.x()
                - self.y() * operand.dist() * self.w()
                + self.y() * operand.nx() * self.x()
                - self.y() * operand.ny() * self.y()
                + self.y() * operand.nz() * self.z()
                + self.z() * operand.ny() * self.z()
                + self.z() * operand.nz() * self.y(),
            self.w() * operand.dist() * self.x() + self.x() * operand.dist() * self.w()
                - self.x() * operand.nx() * self.x()
                + self.x() * operand.ny() * self.y()
                - self.x() * operand.nz() * self.z()
                + self.y() * operand.nx() * self.y()
                + self.y() * operand.ny() * self.x()
                + self.z() * operand.nx() * self.z()
                - self.z() * operand.nz() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Plane<T>> for Unitized<Point<T>> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            operand.dist() * self.as_inner().x() * self.as_inner().x()
                + operand.dist() * self.as_inner().y() * self.as_inner().y()
                + operand.dist() * self.as_inner().z() * self.as_inner().z(),
            -(operand.nz() * self.as_inner().z() * self.as_inner().z())
                + -T::TWO * operand.nx() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.dist() * self.as_inner().w() * self.as_inner().z()
                + T::TWO * operand.ny() * self.as_inner().y() * self.as_inner().z()
                + operand.nz() * self.as_inner().x() * self.as_inner().x()
                + operand.nz() * self.as_inner().y() * self.as_inner().y(),
            -(operand.ny() * self.as_inner().y() * self.as_inner().y())
                + -T::TWO * operand.dist() * self.as_inner().w() * self.as_inner().y()
                + T::TWO * operand.nx() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.nz() * self.as_inner().y() * self.as_inner().z()
                + operand.ny() * self.as_inner().x() * self.as_inner().x()
                + operand.ny() * self.as_inner().z() * self.as_inner().z(),
            -(operand.nx() * self.as_inner().x() * self.as_inner().x())
                + -T::TWO * operand.nz() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.dist() * self.as_inner().w() * self.as_inner().x()
                + T::TWO * operand.ny() * self.as_inner().x() * self.as_inner().y()
                + operand.nx() * self.as_inner().y() * self.as_inner().y()
                + operand.nx() * self.as_inner().z() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Plane<T>>> for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            operand.as_inner().dist() * self.x() * self.x()
                + operand.as_inner().dist() * self.y() * self.y()
                + operand.as_inner().dist() * self.z() * self.z(),
            -(operand.as_inner().nz() * self.z() * self.z())
                + -T::TWO * operand.as_inner().nx() * self.x() * self.z()
                + T::TWO * operand.as_inner().dist() * self.w() * self.z()
                + T::TWO * operand.as_inner().ny() * self.y() * self.z()
                + operand.as_inner().nz() * self.x() * self.x()
                + operand.as_inner().nz() * self.y() * self.y(),
            -(operand.as_inner().ny() * self.y() * self.y())
                + -T::TWO * operand.as_inner().dist() * self.w() * self.y()
                + T::TWO * operand.as_inner().nx() * self.x() * self.y()
                + T::TWO * operand.as_inner().nz() * self.y() * self.z()
                + operand.as_inner().ny() * self.x() * self.x()
                + operand.as_inner().ny() * self.z() * self.z(),
            -(operand.as_inner().nx() * self.x() * self.x())
                + -T::TWO * operand.as_inner().nz() * self.x() * self.z()
                + T::TWO * operand.as_inner().dist() * self.w() * self.x()
                + T::TWO * operand.as_inner().ny() * self.x() * self.y()
                + operand.as_inner().nx() * self.y() * self.y()
                + operand.as_inner().nx() * self.z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Plane<T>>> for Unitized<Point<T>> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            operand.as_inner().dist() * self.as_inner().x() * self.as_inner().x()
                + operand.as_inner().dist() * self.as_inner().y() * self.as_inner().y()
                + operand.as_inner().dist() * self.as_inner().z() * self.as_inner().z(),
            -(operand.as_inner().nz() * self.as_inner().z() * self.as_inner().z())
                + -T::TWO * operand.as_inner().nx() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.as_inner().dist() * self.as_inner().w() * self.as_inner().z()
                + T::TWO * operand.as_inner().ny() * self.as_inner().y() * self.as_inner().z()
                + operand.as_inner().nz() * self.as_inner().x() * self.as_inner().x()
                + operand.as_inner().nz() * self.as_inner().y() * self.as_inner().y(),
            -(operand.as_inner().ny() * self.as_inner().y() * self.as_inner().y())
                + -T::TWO * operand.as_inner().dist() * self.as_inner().w() * self.as_inner().y()
                + T::TWO * operand.as_inner().nx() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().nz() * self.as_inner().y() * self.as_inner().z()
                + operand.as_inner().ny() * self.as_inner().x() * self.as_inner().x()
                + operand.as_inner().ny() * self.as_inner().z() * self.as_inner().z(),
            -(operand.as_inner().nx() * self.as_inner().x() * self.as_inner().x())
                + -T::TWO * operand.as_inner().nz() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.as_inner().dist() * self.as_inner().w() * self.as_inner().x()
                + T::TWO * operand.as_inner().ny() * self.as_inner().x() * self.as_inner().y()
                + operand.as_inner().nx() * self.as_inner().y() * self.as_inner().y()
                + operand.as_inner().nx() * self.as_inner().z() * self.as_inner().z(),
        )
    }
}
#[doc = "Sandwich product: [`Point`] x [`Point`] x rev([`Point`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.x() * operand.x() * self.x()
                + self.x() * operand.y() * self.y()
                + self.x() * operand.z() * self.z()
                - self.y() * operand.x() * self.y()
                + self.y() * operand.y() * self.x()
                - self.z() * operand.x() * self.z()
                + self.z() * operand.z() * self.x(),
            self.x() * operand.x() * self.y() - self.x() * operand.y() * self.x()
                + self.y() * operand.x() * self.x()
                + self.y() * operand.y() * self.y()
                + self.y() * operand.z() * self.z()
                - self.z() * operand.y() * self.z()
                + self.z() * operand.z() * self.y(),
            self.x() * operand.x() * self.z() - self.x() * operand.z() * self.x()
                + self.y() * operand.y() * self.z()
                - self.y() * operand.z() * self.y()
                + self.z() * operand.x() * self.x()
                + self.z() * operand.y() * self.y()
                + self.z() * operand.z() * self.z(),
            self.w() * operand.x() * self.x()
                + self.w() * operand.y() * self.y()
                + self.w() * operand.z() * self.z()
                - self.x() * operand.w() * self.x()
                + self.x() * operand.x() * self.w()
                - self.y() * operand.w() * self.y()
                + self.y() * operand.y() * self.w()
                - self.z() * operand.w() * self.z()
                + self.z() * operand.z() * self.w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -(operand.x() * self.as_inner().y() * self.as_inner().y())
                + -(operand.x() * self.as_inner().z() * self.as_inner().z())
                + T::TWO * operand.y() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.z() * self.as_inner().x() * self.as_inner().z()
                + operand.x() * self.as_inner().x() * self.as_inner().x(),
            -(operand.y() * self.as_inner().x() * self.as_inner().x())
                + -(operand.y() * self.as_inner().z() * self.as_inner().z())
                + T::TWO * operand.x() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.z() * self.as_inner().y() * self.as_inner().z()
                + operand.y() * self.as_inner().y() * self.as_inner().y(),
            -(operand.z() * self.as_inner().x() * self.as_inner().x())
                + -(operand.z() * self.as_inner().y() * self.as_inner().y())
                + T::TWO * operand.x() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.y() * self.as_inner().y() * self.as_inner().z()
                + operand.z() * self.as_inner().z() * self.as_inner().z(),
            -(operand.w() * self.as_inner().x() * self.as_inner().x())
                + -(operand.w() * self.as_inner().y() * self.as_inner().y())
                + -(operand.w() * self.as_inner().z() * self.as_inner().z())
                + T::TWO * operand.x() * self.as_inner().w() * self.as_inner().x()
                + T::TWO * operand.y() * self.as_inner().w() * self.as_inner().y()
                + T::TWO * operand.z() * self.as_inner().w() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Point<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x() * self.y() * self.y())
                + -(operand.as_inner().x() * self.z() * self.z())
                + T::TWO * operand.as_inner().y() * self.x() * self.y()
                + T::TWO * operand.as_inner().z() * self.x() * self.z()
                + operand.as_inner().x() * self.x() * self.x(),
            -(operand.as_inner().y() * self.x() * self.x())
                + -(operand.as_inner().y() * self.z() * self.z())
                + T::TWO * operand.as_inner().x() * self.x() * self.y()
                + T::TWO * operand.as_inner().z() * self.y() * self.z()
                + operand.as_inner().y() * self.y() * self.y(),
            -(operand.as_inner().z() * self.x() * self.x())
                + -(operand.as_inner().z() * self.y() * self.y())
                + T::TWO * operand.as_inner().x() * self.x() * self.z()
                + T::TWO * operand.as_inner().y() * self.y() * self.z()
                + operand.as_inner().z() * self.z() * self.z(),
            -(operand.as_inner().w() * self.x() * self.x())
                + -(operand.as_inner().w() * self.y() * self.y())
                + -(operand.as_inner().w() * self.z() * self.z())
                + T::TWO * operand.as_inner().x() * self.w() * self.x()
                + T::TWO * operand.as_inner().y() * self.w() * self.y()
                + T::TWO * operand.as_inner().z() * self.w() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Point<T>>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x() * self.as_inner().y() * self.as_inner().y())
                + -(operand.as_inner().x() * self.as_inner().z() * self.as_inner().z())
                + T::TWO * operand.as_inner().y() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().z() * self.as_inner().x() * self.as_inner().z()
                + operand.as_inner().x() * self.as_inner().x() * self.as_inner().x(),
            -(operand.as_inner().y() * self.as_inner().x() * self.as_inner().x())
                + -(operand.as_inner().y() * self.as_inner().z() * self.as_inner().z())
                + T::TWO * operand.as_inner().x() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().z() * self.as_inner().y() * self.as_inner().z()
                + operand.as_inner().y() * self.as_inner().y() * self.as_inner().y(),
            -(operand.as_inner().z() * self.as_inner().x() * self.as_inner().x())
                + -(operand.as_inner().z() * self.as_inner().y() * self.as_inner().y())
                + T::TWO * operand.as_inner().x() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.as_inner().y() * self.as_inner().y() * self.as_inner().z()
                + operand.as_inner().z() * self.as_inner().z() * self.as_inner().z(),
            -(operand.as_inner().w() * self.as_inner().x() * self.as_inner().x())
                + -(operand.as_inner().w() * self.as_inner().y() * self.as_inner().y())
                + -(operand.as_inner().w() * self.as_inner().z() * self.as_inner().z())
                + T::TWO * operand.as_inner().x() * self.as_inner().w() * self.as_inner().x()
                + T::TWO * operand.as_inner().y() * self.as_inner().w() * self.as_inner().y()
                + T::TWO * operand.as_inner().z() * self.as_inner().w() * self.as_inner().z(),
        )
    }
}
#[doc = "Sandwich product: [`Point`] x [`Quadvector`] x rev([`Point`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Quadvector<T>> for Point<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(self.x() * operand.ps() * self.x())
                - self.y() * operand.ps() * self.y()
                - self.z() * operand.ps() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Quadvector<T>> for Unitized<Point<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(operand.ps() * self.as_inner().x() * self.as_inner().x())
                + -(operand.ps() * self.as_inner().y() * self.as_inner().y())
                + -(operand.ps() * self.as_inner().z() * self.as_inner().z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Quadvector<T>>> for Point<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(operand.as_inner().ps() * self.x() * self.x())
                + -(operand.as_inner().ps() * self.y() * self.y())
                + -(operand.as_inner().ps() * self.z() * self.z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Quadvector<T>>> for Unitized<Point<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(operand.as_inner().ps() * self.as_inner().x() * self.as_inner().x())
                + -(operand.as_inner().ps() * self.as_inner().y() * self.as_inner().y())
                + -(operand.as_inner().ps() * self.as_inner().z() * self.as_inner().z()),
        )
    }
}
#[doc = "Sandwich product: [`Point`] x [`Scalar`] x rev([`Point`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.x() * operand.s() * self.x()
                + self.y() * operand.s() * self.y()
                + self.z() * operand.s() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unitized<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            operand.s() * self.as_inner().x() * self.as_inner().x()
                + operand.s() * self.as_inner().y() * self.as_inner().y()
                + operand.s() * self.as_inner().z() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Unitized<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Sandwich product: [`Quadvector`] x [`Flector`] x rev([`Quadvector`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Flector<T>> for Quadvector<T> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Flector<T>> for Unitized<Quadvector<T>> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Flector<T>>> for Quadvector<T> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Flector<T>>> for Unitized<Quadvector<T>> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[doc = "Sandwich product: [`Quadvector`] x [`Line`] x rev([`Quadvector`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Quadvector<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Unitized<Quadvector<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Line<T>>> for Quadvector<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Line<T>>> for Unitized<Quadvector<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[doc = "Sandwich product: [`Quadvector`] x [`Motor`] x rev([`Quadvector`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Motor<T>> for Quadvector<T> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Motor<T>> for Unitized<Quadvector<T>> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Motor<T>>> for Quadvector<T> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Motor<T>>> for Unitized<Quadvector<T>> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[doc = "Sandwich product: [`Quadvector`] x [`Plane`] x rev([`Quadvector`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Plane<T>> for Quadvector<T> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Plane<T>> for Unitized<Quadvector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Plane<T>>> for Quadvector<T> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Plane<T>>> for Unitized<Quadvector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Sandwich product: [`Quadvector`] x [`Point`] x rev([`Quadvector`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Quadvector<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Unitized<Quadvector<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Point<T>>> for Quadvector<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Point<T>>> for Unitized<Quadvector<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Sandwich product: [`Quadvector`] x [`Quadvector`] x rev([`Quadvector`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Quadvector<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Quadvector<T>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Quadvector<T>>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Quadvector<T>>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[doc = "Sandwich product: [`Quadvector`] x [`Scalar`] x rev([`Quadvector`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Quadvector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unitized<Quadvector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Quadvector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Unitized<Quadvector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Sandwich product: [`Scalar`] x [`Flector`] x rev([`Scalar`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Flector<T>> for Scalar<T> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            self.s() * operand.px() * self.s(),
            self.s() * operand.py() * self.s(),
            self.s() * operand.pz() * self.s(),
            self.s() * operand.pw() * self.s(),
            self.s() * operand.dist() * self.s(),
            self.s() * operand.nz() * self.s(),
            self.s() * operand.ny() * self.s(),
            self.s() * operand.nx() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Flector<T>> for Unitized<Scalar<T>> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Flector<T>>> for Scalar<T> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            operand.as_inner().px() * self.s() * self.s(),
            operand.as_inner().py() * self.s() * self.s(),
            operand.as_inner().pz() * self.s() * self.s(),
            operand.as_inner().pw() * self.s() * self.s(),
            operand.as_inner().dist() * self.s() * self.s(),
            operand.as_inner().nz() * self.s() * self.s(),
            operand.as_inner().ny() * self.s() * self.s(),
            operand.as_inner().nx() * self.s() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Flector<T>>> for Unitized<Scalar<T>> {
    type Output = Flector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[doc = "Sandwich product: [`Scalar`] x [`Line`] x rev([`Scalar`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.s() * operand.moment_z() * self.s(),
            self.s() * operand.moment_y() * self.s(),
            self.s() * operand.dir_x() * self.s(),
            self.s() * operand.moment_x() * self.s(),
            self.s() * operand.dir_y() * self.s(),
            self.s() * operand.dir_z() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Unitized<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Line<T>>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            operand.as_inner().moment_z() * self.s() * self.s(),
            operand.as_inner().moment_y() * self.s() * self.s(),
            operand.as_inner().dir_x() * self.s() * self.s(),
            operand.as_inner().moment_x() * self.s() * self.s(),
            operand.as_inner().dir_y() * self.s() * self.s(),
            operand.as_inner().dir_z() * self.s() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Line<T>>> for Unitized<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[doc = "Sandwich product: [`Scalar`] x [`Motor`] x rev([`Scalar`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Motor<T>> for Scalar<T> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            self.s() * operand.s() * self.s(),
            self.s() * operand.tz() * self.s(),
            self.s() * operand.ty() * self.s(),
            self.s() * operand.tx() * self.s(),
            self.s() * operand.rx() * self.s(),
            self.s() * operand.ry() * self.s(),
            self.s() * operand.rz() * self.s(),
            self.s() * operand.ps() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Motor<T>> for Unitized<Scalar<T>> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Motor<T>>> for Scalar<T> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s() * self.s() * self.s(),
            operand.as_inner().tz() * self.s() * self.s(),
            operand.as_inner().ty() * self.s() * self.s(),
            operand.as_inner().tx() * self.s() * self.s(),
            operand.as_inner().rx() * self.s() * self.s(),
            operand.as_inner().ry() * self.s() * self.s(),
            operand.as_inner().rz() * self.s() * self.s(),
            operand.as_inner().ps() * self.s() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Motor<T>>> for Unitized<Scalar<T>> {
    type Output = Motor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[doc = "Sandwich product: [`Scalar`] x [`Plane`] x rev([`Scalar`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Plane<T>> for Scalar<T> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            self.s() * operand.dist() * self.s(),
            self.s() * operand.nz() * self.s(),
            self.s() * operand.ny() * self.s(),
            self.s() * operand.nx() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Plane<T>> for Unitized<Scalar<T>> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Plane<T>>> for Scalar<T> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            operand.as_inner().dist() * self.s() * self.s(),
            operand.as_inner().nz() * self.s() * self.s(),
            operand.as_inner().ny() * self.s() * self.s(),
            operand.as_inner().nx() * self.s() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Plane<T>>> for Unitized<Scalar<T>> {
    type Output = Plane<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Sandwich product: [`Scalar`] x [`Point`] x rev([`Scalar`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.s() * operand.x() * self.s(),
            self.s() * operand.y() * self.s(),
            self.s() * operand.z() * self.s(),
            self.s() * operand.w() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Unitized<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Point<T>>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            operand.as_inner().x() * self.s() * self.s(),
            operand.as_inner().y() * self.s() * self.s(),
            operand.as_inner().z() * self.s() * self.s(),
            operand.as_inner().w() * self.s() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Point<T>>> for Unitized<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Sandwich product: [`Scalar`] x [`Quadvector`] x rev([`Scalar`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Quadvector<T>> for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(self.s() * operand.ps() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Quadvector<T>> for Unitized<Scalar<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Quadvector<T>>> for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(operand.as_inner().ps() * self.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Quadvector<T>>> for Unitized<Scalar<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[doc = "Sandwich product: [`Scalar`] x [`Scalar`] x rev([`Scalar`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * operand.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Antisandwich product: [`Flector`] x [`Flector`] x antirev([`Flector`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Flector<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            self.dist() * operand.nx() * self.pw() + self.dist() * operand.ny() * self.nz()
                - self.dist() * operand.nz() * self.ny()
                - self.dist() * operand.pw() * self.nx()
                - self.nx() * operand.dist() * self.pw()
                + self.nx() * operand.nx() * self.px()
                - self.nx() * operand.ny() * self.py()
                + self.nx() * operand.nz() * self.pz()
                - self.nx() * operand.pw() * self.dist()
                + self.nx() * operand.px() * self.nx()
                - self.nx() * operand.py() * self.ny()
                + self.nx() * operand.pz() * self.nz()
                - self.ny() * operand.dist() * self.nz()
                + self.ny() * operand.nx() * self.py()
                + self.ny() * operand.ny() * self.px()
                + self.ny() * operand.nz() * self.dist()
                + self.ny() * operand.pw() * self.pz()
                - self.ny() * operand.px() * self.ny()
                - self.ny() * operand.py() * self.nx()
                - self.ny() * operand.pz() * self.pw()
                + self.nz() * operand.dist() * self.ny()
                - self.nz() * operand.nx() * self.pz()
                - self.nz() * operand.ny() * self.dist()
                + self.nz() * operand.nz() * self.px()
                + self.nz() * operand.pw() * self.py()
                - self.nz() * operand.px() * self.nz()
                - self.nz() * operand.py() * self.pw()
                + self.nz() * operand.pz() * self.nx()
                + self.pw() * operand.dist() * self.nx()
                - self.pw() * operand.nx() * self.dist()
                + self.pw() * operand.ny() * self.pz()
                + self.pw() * operand.nz() * self.py()
                - self.pw() * operand.pw() * self.px()
                + self.pw() * operand.px() * self.pw()
                - self.pw() * operand.py() * self.nz()
                - self.pw() * operand.pz() * self.ny()
                - self.px() * operand.nx() * self.nx()
                - self.px() * operand.ny() * self.ny()
                - self.px() * operand.nz() * self.nz()
                - self.px() * operand.pw() * self.pw()
                - self.py() * operand.nx() * self.ny()
                + self.py() * operand.ny() * self.nx()
                - self.py() * operand.nz() * self.pw()
                + self.py() * operand.pw() * self.nz()
                + self.pz() * operand.nx() * self.nz()
                - self.pz() * operand.ny() * self.pw()
                - self.pz() * operand.nz() * self.nx()
                + self.pz() * operand.pw() * self.ny(),
            self.dist() * operand.nx() * self.nz()
                - self.dist() * operand.ny() * self.pw()
                - self.dist() * operand.nz() * self.nx()
                + self.dist() * operand.pw() * self.ny()
                - self.nx() * operand.dist() * self.nz()
                + self.nx() * operand.nx() * self.py()
                + self.nx() * operand.ny() * self.px()
                + self.nx() * operand.nz() * self.dist()
                + self.nx() * operand.pw() * self.pz()
                - self.nx() * operand.px() * self.ny()
                - self.nx() * operand.py() * self.nx()
                - self.nx() * operand.pz() * self.pw()
                + self.ny() * operand.dist() * self.pw()
                - self.ny() * operand.nx() * self.px()
                + self.ny() * operand.ny() * self.py()
                - self.ny() * operand.nz() * self.pz()
                + self.ny() * operand.pw() * self.dist()
                - self.ny() * operand.px() * self.nx()
                + self.ny() * operand.py() * self.ny()
                - self.ny() * operand.pz() * self.nz()
                + self.nz() * operand.dist() * self.nx()
                - self.nz() * operand.nx() * self.dist()
                + self.nz() * operand.ny() * self.pz()
                + self.nz() * operand.nz() * self.py()
                - self.nz() * operand.pw() * self.px()
                + self.nz() * operand.px() * self.pw()
                - self.nz() * operand.py() * self.nz()
                - self.nz() * operand.pz() * self.ny()
                - self.pw() * operand.dist() * self.ny()
                + self.pw() * operand.nx() * self.pz()
                + self.pw() * operand.ny() * self.dist()
                - self.pw() * operand.nz() * self.px()
                - self.pw() * operand.pw() * self.py()
                + self.pw() * operand.px() * self.nz()
                + self.pw() * operand.py() * self.pw()
                - self.pw() * operand.pz() * self.nx()
                + self.px() * operand.nx() * self.ny()
                - self.px() * operand.ny() * self.nx()
                + self.px() * operand.nz() * self.pw()
                - self.px() * operand.pw() * self.nz()
                - self.py() * operand.nx() * self.nx()
                - self.py() * operand.ny() * self.ny()
                - self.py() * operand.nz() * self.nz()
                - self.py() * operand.pw() * self.pw()
                - self.pz() * operand.nx() * self.pw()
                - self.pz() * operand.ny() * self.nz()
                + self.pz() * operand.nz() * self.ny()
                + self.pz() * operand.pw() * self.nx(),
            self.dist() * operand.nx() * self.ny() - self.dist() * operand.ny() * self.nx()
                + self.dist() * operand.nz() * self.pw()
                - self.dist() * operand.pw() * self.nz()
                - self.nx() * operand.dist() * self.ny()
                + self.nx() * operand.nx() * self.pz()
                + self.nx() * operand.ny() * self.dist()
                - self.nx() * operand.nz() * self.px()
                - self.nx() * operand.pw() * self.py()
                + self.nx() * operand.px() * self.nz()
                + self.nx() * operand.py() * self.pw()
                - self.nx() * operand.pz() * self.nx()
                + self.ny() * operand.dist() * self.nx()
                - self.ny() * operand.nx() * self.dist()
                + self.ny() * operand.ny() * self.pz()
                + self.ny() * operand.nz() * self.py()
                - self.ny() * operand.pw() * self.px()
                + self.ny() * operand.px() * self.pw()
                - self.ny() * operand.py() * self.nz()
                - self.ny() * operand.pz() * self.ny()
                - self.nz() * operand.dist() * self.pw()
                + self.nz() * operand.nx() * self.px()
                - self.nz() * operand.ny() * self.py()
                + self.nz() * operand.nz() * self.pz()
                - self.nz() * operand.pw() * self.dist()
                + self.nz() * operand.px() * self.nx()
                - self.nz() * operand.py() * self.ny()
                + self.nz() * operand.pz() * self.nz()
                + self.pw() * operand.dist() * self.nz()
                - self.pw() * operand.nx() * self.py()
                - self.pw() * operand.ny() * self.px()
                - self.pw() * operand.nz() * self.dist()
                - self.pw() * operand.pw() * self.pz()
                + self.pw() * operand.px() * self.ny()
                + self.pw() * operand.py() * self.nx()
                + self.pw() * operand.pz() * self.pw()
                - self.px() * operand.nx() * self.nz()
                + self.px() * operand.ny() * self.pw()
                + self.px() * operand.nz() * self.nx()
                - self.px() * operand.pw() * self.ny()
                + self.py() * operand.nx() * self.pw()
                + self.py() * operand.ny() * self.nz()
                - self.py() * operand.nz() * self.ny()
                - self.py() * operand.pw() * self.nx()
                - self.pz() * operand.nx() * self.nx()
                - self.pz() * operand.ny() * self.ny()
                - self.pz() * operand.nz() * self.nz()
                - self.pz() * operand.pw() * self.pw(),
            self.nx() * operand.nx() * self.pw() + self.nx() * operand.ny() * self.nz()
                - self.nx() * operand.nz() * self.ny()
                - self.nx() * operand.pw() * self.nx()
                - self.ny() * operand.nx() * self.nz()
                + self.ny() * operand.ny() * self.pw()
                + self.ny() * operand.nz() * self.nx()
                - self.ny() * operand.pw() * self.ny()
                + self.nz() * operand.nx() * self.ny()
                - self.nz() * operand.ny() * self.nx()
                + self.nz() * operand.nz() * self.pw()
                - self.nz() * operand.pw() * self.nz()
                - self.pw() * operand.nx() * self.nx()
                - self.pw() * operand.ny() * self.ny()
                - self.pw() * operand.nz() * self.nz()
                - self.pw() * operand.pw() * self.pw(),
            -(self.dist() * operand.nx() * self.nx())
                - self.dist() * operand.ny() * self.ny()
                - self.dist() * operand.nz() * self.nz()
                - self.dist() * operand.pw() * self.pw()
                + self.nx() * operand.dist() * self.nx()
                - self.nx() * operand.nx() * self.dist()
                + self.nx() * operand.ny() * self.pz()
                + self.nx() * operand.nz() * self.py()
                - self.nx() * operand.pw() * self.px()
                + self.nx() * operand.px() * self.pw()
                - self.nx() * operand.py() * self.nz()
                - self.nx() * operand.pz() * self.ny()
                + self.ny() * operand.dist() * self.ny()
                - self.ny() * operand.nx() * self.pz()
                - self.ny() * operand.ny() * self.dist()
                + self.ny() * operand.nz() * self.px()
                + self.ny() * operand.pw() * self.py()
                - self.ny() * operand.px() * self.nz()
                - self.ny() * operand.py() * self.pw()
                + self.ny() * operand.pz() * self.nx()
                + self.nz() * operand.dist() * self.nz()
                - self.nz() * operand.nx() * self.py()
                - self.nz() * operand.ny() * self.px()
                - self.nz() * operand.nz() * self.dist()
                - self.nz() * operand.pw() * self.pz()
                + self.nz() * operand.px() * self.ny()
                + self.nz() * operand.py() * self.nx()
                + self.nz() * operand.pz() * self.pw()
                + self.pw() * operand.dist() * self.pw()
                - self.pw() * operand.nx() * self.px()
                + self.pw() * operand.ny() * self.py()
                - self.pw() * operand.nz() * self.pz()
                + self.pw() * operand.pw() * self.dist()
                - self.pw() * operand.px() * self.nx()
                + self.pw() * operand.py() * self.ny()
                - self.pw() * operand.pz() * self.nz()
                - self.px() * operand.nx() * self.pw()
                - self.px() * operand.ny() * self.nz()
                + self.px() * operand.nz() * self.ny()
                + self.px() * operand.pw() * self.nx()
                - self.py() * operand.nx() * self.nz()
                + self.py() * operand.ny() * self.pw()
                + self.py() * operand.nz() * self.nx()
                - self.py() * operand.pw() * self.ny()
                - self.pz() * operand.nx() * self.ny()
                + self.pz() * operand.ny() * self.nx()
                - self.pz() * operand.nz() * self.pw()
                + self.pz() * operand.pw() * self.nz(),
            -(self.nx() * operand.nx() * self.nz())
                + self.nx() * operand.ny() * self.pw()
                + self.nx() * operand.nz() * self.nx()
                - self.nx() * operand.pw() * self.ny()
                - self.ny() * operand.nx() * self.pw()
                - self.ny() * operand.ny() * self.nz()
                + self.ny() * operand.nz() * self.ny()
                + self.ny() * operand.pw() * self.nx()
                - self.nz() * operand.nx() * self.nx()
                - self.nz() * operand.ny() * self.ny()
                - self.nz() * operand.nz() * self.nz()
                - self.nz() * operand.pw() * self.pw()
                - self.pw() * operand.nx() * self.ny()
                + self.pw() * operand.ny() * self.nx()
                - self.pw() * operand.nz() * self.pw()
                + self.pw() * operand.pw() * self.nz(),
            -(self.nx() * operand.nx() * self.ny()) + self.nx() * operand.ny() * self.nx()
                - self.nx() * operand.nz() * self.pw()
                + self.nx() * operand.pw() * self.nz()
                - self.ny() * operand.nx() * self.nx()
                - self.ny() * operand.ny() * self.ny()
                - self.ny() * operand.nz() * self.nz()
                - self.ny() * operand.pw() * self.pw()
                + self.nz() * operand.nx() * self.pw()
                + self.nz() * operand.ny() * self.nz()
                - self.nz() * operand.nz() * self.ny()
                - self.nz() * operand.pw() * self.nx()
                + self.pw() * operand.nx() * self.nz()
                - self.pw() * operand.ny() * self.pw()
                - self.pw() * operand.nz() * self.nx()
                + self.pw() * operand.pw() * self.ny(),
            -(self.nx() * operand.nx() * self.nx())
                - self.nx() * operand.ny() * self.ny()
                - self.nx() * operand.nz() * self.nz()
                - self.nx() * operand.pw() * self.pw()
                + self.ny() * operand.nx() * self.ny()
                - self.ny() * operand.ny() * self.nx()
                + self.ny() * operand.nz() * self.pw()
                - self.ny() * operand.pw() * self.nz()
                + self.nz() * operand.nx() * self.nz()
                - self.nz() * operand.ny() * self.pw()
                - self.nz() * operand.nz() * self.nx()
                + self.nz() * operand.pw() * self.ny()
                - self.pw() * operand.nx() * self.pw()
                - self.pw() * operand.ny() * self.nz()
                + self.pw() * operand.nz() * self.ny()
                + self.pw() * operand.pw() * self.nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Flector<T>> for Unitized<Flector<T>> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            -T::TWO * operand.pw() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.pw() * self.as_inner().pw() * self.as_inner().px()
                + -T::TWO * operand.px() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.px() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.py() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.py() * self.as_inner().nz() * self.as_inner().pw()
                + -T::TWO * operand.pz() * self.as_inner().ny() * self.as_inner().pw()
                + T::TWO * operand.pw() * self.as_inner().ny() * self.as_inner().pz()
                + T::TWO * operand.pw() * self.as_inner().nz() * self.as_inner().py()
                + T::TWO * operand.pz() * self.as_inner().nx() * self.as_inner().nz()
                + operand.px(),
            -(operand.py())
                + -T::TWO * operand.pw() * self.as_inner().nz() * self.as_inner().px()
                + -T::TWO * operand.pw() * self.as_inner().pw() * self.as_inner().py()
                + -T::TWO * operand.px() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.pz() * self.as_inner().nx() * self.as_inner().pw()
                + -T::TWO * operand.pz() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.pw() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.pw() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.px() * self.as_inner().nz() * self.as_inner().pw()
                + T::TWO * operand.py() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.py() * self.as_inner().pw() * self.as_inner().pw(),
            -(operand.pz())
                + -T::TWO * operand.pw() * self.as_inner().dist() * self.as_inner().nz()
                + -T::TWO * operand.pw() * self.as_inner().nx() * self.as_inner().py()
                + -T::TWO * operand.pw() * self.as_inner().ny() * self.as_inner().px()
                + -T::TWO * operand.pw() * self.as_inner().pw() * self.as_inner().pz()
                + -T::TWO * operand.py() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.px() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.px() * self.as_inner().ny() * self.as_inner().pw()
                + T::TWO * operand.py() * self.as_inner().nx() * self.as_inner().pw()
                + T::TWO * operand.pz() * self.as_inner().nz() * self.as_inner().nz()
                + T::TWO * operand.pz() * self.as_inner().pw() * self.as_inner().pw(),
            -(operand.pw()),
            -T::TWO * operand.nx() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.nx() * self.as_inner().ny() * self.as_inner().pz()
                + -T::TWO * operand.nx() * self.as_inner().nz() * self.as_inner().py()
                + -T::TWO * operand.nx() * self.as_inner().pw() * self.as_inner().px()
                + -T::TWO * operand.ny() * self.as_inner().dist() * self.as_inner().ny()
                + -T::TWO * operand.ny() * self.as_inner().nz() * self.as_inner().px()
                + -T::TWO * operand.nz() * self.as_inner().dist() * self.as_inner().nz()
                + -T::TWO * operand.nz() * self.as_inner().pw() * self.as_inner().pz()
                + T::TWO * operand.ny() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.ny() * self.as_inner().pw() * self.as_inner().py()
                + T::TWO * operand.nz() * self.as_inner().nx() * self.as_inner().py()
                + T::TWO * operand.nz() * self.as_inner().ny() * self.as_inner().px()
                + operand.dist(),
            -T::TWO * operand.nx() * self.as_inner().nx() * self.as_inner().nz()
                + -T::TWO * operand.nx() * self.as_inner().ny() * self.as_inner().pw()
                + -T::TWO * operand.ny() * self.as_inner().ny() * self.as_inner().nz()
                + -T::TWO * operand.nz() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.nz() * self.as_inner().pw() * self.as_inner().pw()
                + T::TWO * operand.ny() * self.as_inner().nx() * self.as_inner().pw()
                + operand.nz(),
            -T::TWO * operand.nx() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.ny() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.ny() * self.as_inner().pw() * self.as_inner().pw()
                + -T::TWO * operand.nz() * self.as_inner().nx() * self.as_inner().pw()
                + -T::TWO * operand.nz() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.nx() * self.as_inner().nz() * self.as_inner().pw()
                + operand.ny(),
            -(operand.nx())
                + -T::TWO * operand.ny() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.ny() * self.as_inner().nz() * self.as_inner().pw()
                + -T::TWO * operand.nz() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.nx() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.nx() * self.as_inner().nz() * self.as_inner().nz()
                + T::TWO * operand.nz() * self.as_inner().ny() * self.as_inner().pw(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Flector<T>>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            -(operand.as_inner().px() * self.ny() * self.ny())
                + -(operand.as_inner().px() * self.nz() * self.nz())
                + -T::TWO * operand.as_inner().pw() * self.dist() * self.nx()
                + -T::TWO * operand.as_inner().pw() * self.pw() * self.px()
                + -T::TWO * operand.as_inner().py() * self.nx() * self.ny()
                + -T::TWO * operand.as_inner().py() * self.nz() * self.pw()
                + -T::TWO * operand.as_inner().pz() * self.ny() * self.pw()
                + T::TWO * operand.as_inner().pw() * self.ny() * self.pz()
                + T::TWO * operand.as_inner().pw() * self.nz() * self.py()
                + T::TWO * operand.as_inner().pz() * self.nx() * self.nz()
                + operand.as_inner().px() * self.nx() * self.nx()
                + operand.as_inner().px() * self.pw() * self.pw(),
            -(operand.as_inner().py() * self.nx() * self.nx())
                + -(operand.as_inner().py() * self.nz() * self.nz())
                + -T::TWO * operand.as_inner().pw() * self.nz() * self.px()
                + -T::TWO * operand.as_inner().pw() * self.pw() * self.py()
                + -T::TWO * operand.as_inner().px() * self.nx() * self.ny()
                + -T::TWO * operand.as_inner().pz() * self.nx() * self.pw()
                + -T::TWO * operand.as_inner().pz() * self.ny() * self.nz()
                + T::TWO * operand.as_inner().pw() * self.dist() * self.ny()
                + T::TWO * operand.as_inner().pw() * self.nx() * self.pz()
                + T::TWO * operand.as_inner().px() * self.nz() * self.pw()
                + operand.as_inner().py() * self.ny() * self.ny()
                + operand.as_inner().py() * self.pw() * self.pw(),
            -(operand.as_inner().pz() * self.nx() * self.nx())
                + -(operand.as_inner().pz() * self.ny() * self.ny())
                + -T::TWO * operand.as_inner().pw() * self.dist() * self.nz()
                + -T::TWO * operand.as_inner().pw() * self.nx() * self.py()
                + -T::TWO * operand.as_inner().pw() * self.ny() * self.px()
                + -T::TWO * operand.as_inner().pw() * self.pw() * self.pz()
                + -T::TWO * operand.as_inner().py() * self.ny() * self.nz()
                + T::TWO * operand.as_inner().px() * self.nx() * self.nz()
                + T::TWO * operand.as_inner().px() * self.ny() * self.pw()
                + T::TWO * operand.as_inner().py() * self.nx() * self.pw()
                + operand.as_inner().pz() * self.nz() * self.nz()
                + operand.as_inner().pz() * self.pw() * self.pw(),
            -(operand.as_inner().pw() * self.nx() * self.nx())
                + -(operand.as_inner().pw() * self.ny() * self.ny())
                + -(operand.as_inner().pw() * self.nz() * self.nz())
                + -(operand.as_inner().pw() * self.pw() * self.pw()),
            -T::TWO * operand.as_inner().nx() * self.dist() * self.nx()
                + -T::TWO * operand.as_inner().nx() * self.ny() * self.pz()
                + -T::TWO * operand.as_inner().nx() * self.nz() * self.py()
                + -T::TWO * operand.as_inner().nx() * self.pw() * self.px()
                + -T::TWO * operand.as_inner().ny() * self.dist() * self.ny()
                + -T::TWO * operand.as_inner().ny() * self.nz() * self.px()
                + -T::TWO * operand.as_inner().nz() * self.dist() * self.nz()
                + -T::TWO * operand.as_inner().nz() * self.pw() * self.pz()
                + T::TWO * operand.as_inner().ny() * self.nx() * self.pz()
                + T::TWO * operand.as_inner().ny() * self.pw() * self.py()
                + T::TWO * operand.as_inner().nz() * self.nx() * self.py()
                + T::TWO * operand.as_inner().nz() * self.ny() * self.px()
                + operand.as_inner().dist() * self.nx() * self.nx()
                + operand.as_inner().dist() * self.ny() * self.ny()
                + operand.as_inner().dist() * self.nz() * self.nz()
                + operand.as_inner().dist() * self.pw() * self.pw(),
            -(operand.as_inner().nz() * self.nz() * self.nz())
                + -(operand.as_inner().nz() * self.pw() * self.pw())
                + -T::TWO * operand.as_inner().nx() * self.nx() * self.nz()
                + -T::TWO * operand.as_inner().nx() * self.ny() * self.pw()
                + -T::TWO * operand.as_inner().ny() * self.ny() * self.nz()
                + T::TWO * operand.as_inner().ny() * self.nx() * self.pw()
                + operand.as_inner().nz() * self.nx() * self.nx()
                + operand.as_inner().nz() * self.ny() * self.ny(),
            -(operand.as_inner().ny() * self.ny() * self.ny())
                + -(operand.as_inner().ny() * self.pw() * self.pw())
                + -T::TWO * operand.as_inner().nx() * self.nx() * self.ny()
                + -T::TWO * operand.as_inner().nz() * self.nx() * self.pw()
                + -T::TWO * operand.as_inner().nz() * self.ny() * self.nz()
                + T::TWO * operand.as_inner().nx() * self.nz() * self.pw()
                + operand.as_inner().ny() * self.nx() * self.nx()
                + operand.as_inner().ny() * self.nz() * self.nz(),
            -(operand.as_inner().nx() * self.nx() * self.nx())
                + -(operand.as_inner().nx() * self.pw() * self.pw())
                + -T::TWO * operand.as_inner().ny() * self.nx() * self.ny()
                + -T::TWO * operand.as_inner().ny() * self.nz() * self.pw()
                + -T::TWO * operand.as_inner().nz() * self.nx() * self.nz()
                + T::TWO * operand.as_inner().nz() * self.ny() * self.pw()
                + operand.as_inner().nx() * self.ny() * self.ny()
                + operand.as_inner().nx() * self.nz() * self.nz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Flector<T>>> for Unitized<Flector<T>> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            -T::TWO * operand.as_inner().pw() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.as_inner().pw() * self.as_inner().pw() * self.as_inner().px()
                + -T::TWO * operand.as_inner().px() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().px() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().py() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().py() * self.as_inner().nz() * self.as_inner().pw()
                + -T::TWO * operand.as_inner().pz() * self.as_inner().ny() * self.as_inner().pw()
                + T::TWO * operand.as_inner().pw() * self.as_inner().ny() * self.as_inner().pz()
                + T::TWO * operand.as_inner().pw() * self.as_inner().nz() * self.as_inner().py()
                + T::TWO * operand.as_inner().pz() * self.as_inner().nx() * self.as_inner().nz()
                + operand.as_inner().px(),
            -(operand.as_inner().py())
                + -T::TWO * operand.as_inner().pw() * self.as_inner().nz() * self.as_inner().px()
                + -T::TWO * operand.as_inner().pw() * self.as_inner().pw() * self.as_inner().py()
                + -T::TWO * operand.as_inner().px() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().pz() * self.as_inner().nx() * self.as_inner().pw()
                + -T::TWO * operand.as_inner().pz() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.as_inner().pw() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.as_inner().pw() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.as_inner().px() * self.as_inner().nz() * self.as_inner().pw()
                + T::TWO * operand.as_inner().py() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.as_inner().py() * self.as_inner().pw() * self.as_inner().pw(),
            -(operand.as_inner().pz())
                + -T::TWO * operand.as_inner().pw() * self.as_inner().dist() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().pw() * self.as_inner().nx() * self.as_inner().py()
                + -T::TWO * operand.as_inner().pw() * self.as_inner().ny() * self.as_inner().px()
                + -T::TWO * operand.as_inner().pw() * self.as_inner().pw() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().py() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.as_inner().px() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.as_inner().px() * self.as_inner().ny() * self.as_inner().pw()
                + T::TWO * operand.as_inner().py() * self.as_inner().nx() * self.as_inner().pw()
                + T::TWO * operand.as_inner().pz() * self.as_inner().nz() * self.as_inner().nz()
                + T::TWO * operand.as_inner().pz() * self.as_inner().pw() * self.as_inner().pw(),
            -(operand.as_inner().pw()),
            -T::TWO * operand.as_inner().nx() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.as_inner().nx() * self.as_inner().ny() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().nx() * self.as_inner().nz() * self.as_inner().py()
                + -T::TWO * operand.as_inner().nx() * self.as_inner().pw() * self.as_inner().px()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().dist() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().nz() * self.as_inner().px()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().dist() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().pw() * self.as_inner().pz()
                + T::TWO * operand.as_inner().ny() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.as_inner().ny() * self.as_inner().pw() * self.as_inner().py()
                + T::TWO * operand.as_inner().nz() * self.as_inner().nx() * self.as_inner().py()
                + T::TWO * operand.as_inner().nz() * self.as_inner().ny() * self.as_inner().px()
                + operand.as_inner().dist(),
            -T::TWO * operand.as_inner().nx() * self.as_inner().nx() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().nx() * self.as_inner().ny() * self.as_inner().pw()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().ny() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().pw() * self.as_inner().pw()
                + T::TWO * operand.as_inner().ny() * self.as_inner().nx() * self.as_inner().pw()
                + operand.as_inner().nz(),
            -T::TWO * operand.as_inner().nx() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().pw() * self.as_inner().pw()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().nx() * self.as_inner().pw()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.as_inner().nx() * self.as_inner().nz() * self.as_inner().pw()
                + operand.as_inner().ny(),
            -(operand.as_inner().nx())
                + -T::TWO * operand.as_inner().ny() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().nz() * self.as_inner().pw()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.as_inner().nx() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.as_inner().nx() * self.as_inner().nz() * self.as_inner().nz()
                + T::TWO * operand.as_inner().nz() * self.as_inner().ny() * self.as_inner().pw(),
        )
    }
}
#[doc = "Antisandwich product: [`Flector`] x [`Line`] x antirev([`Flector`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Flector<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            -(self.dist() * operand.dir_x() * self.ny())
                - self.dist() * operand.dir_y() * self.nx()
                - self.dist() * operand.dir_z() * self.pw()
                + self.nx() * operand.dir_x() * self.pz()
                - self.nx() * operand.dir_y() * self.dist()
                - self.nx() * operand.dir_z() * self.px()
                + self.nx() * operand.moment_x() * self.nz()
                - self.nx() * operand.moment_y() * self.pw()
                - self.nx() * operand.moment_z() * self.nx()
                - self.ny() * operand.dir_x() * self.dist()
                - self.ny() * operand.dir_y() * self.pz()
                + self.ny() * operand.dir_z() * self.py()
                + self.ny() * operand.moment_x() * self.pw()
                + self.ny() * operand.moment_y() * self.nz()
                - self.ny() * operand.moment_z() * self.ny()
                + self.nz() * operand.dir_x() * self.px()
                + self.nz() * operand.dir_y() * self.py()
                + self.nz() * operand.dir_z() * self.pz()
                + self.nz() * operand.moment_x() * self.nx()
                + self.nz() * operand.moment_y() * self.ny()
                + self.nz() * operand.moment_z() * self.nz()
                - self.pw() * operand.dir_x() * self.py()
                + self.pw() * operand.dir_y() * self.px()
                - self.pw() * operand.dir_z() * self.dist()
                + self.pw() * operand.moment_x() * self.ny()
                - self.pw() * operand.moment_y() * self.nx()
                + self.pw() * operand.moment_z() * self.pw()
                + self.px() * operand.dir_x() * self.nz()
                + self.px() * operand.dir_y() * self.pw()
                - self.px() * operand.dir_z() * self.nx()
                - self.py() * operand.dir_x() * self.pw()
                + self.py() * operand.dir_y() * self.nz()
                + self.py() * operand.dir_z() * self.ny()
                + self.pz() * operand.dir_x() * self.nx()
                - self.pz() * operand.dir_y() * self.ny()
                + self.pz() * operand.dir_z() * self.nz(),
            self.dist() * operand.dir_x() * self.nz() + self.dist() * operand.dir_y() * self.pw()
                - self.dist() * operand.dir_z() * self.nx()
                - self.nx() * operand.dir_x() * self.py()
                + self.nx() * operand.dir_y() * self.px()
                - self.nx() * operand.dir_z() * self.dist()
                + self.nx() * operand.moment_x() * self.ny()
                - self.nx() * operand.moment_y() * self.nx()
                + self.nx() * operand.moment_z() * self.pw()
                + self.ny() * operand.dir_x() * self.px()
                + self.ny() * operand.dir_y() * self.py()
                + self.ny() * operand.dir_z() * self.pz()
                + self.ny() * operand.moment_x() * self.nx()
                + self.ny() * operand.moment_y() * self.ny()
                + self.ny() * operand.moment_z() * self.nz()
                + self.nz() * operand.dir_x() * self.dist()
                + self.nz() * operand.dir_y() * self.pz()
                - self.nz() * operand.dir_z() * self.py()
                - self.nz() * operand.moment_x() * self.pw()
                - self.nz() * operand.moment_y() * self.nz()
                + self.nz() * operand.moment_z() * self.ny()
                - self.pw() * operand.dir_x() * self.pz()
                + self.pw() * operand.dir_y() * self.dist()
                + self.pw() * operand.dir_z() * self.px()
                - self.pw() * operand.moment_x() * self.nz()
                + self.pw() * operand.moment_y() * self.pw()
                + self.pw() * operand.moment_z() * self.nx()
                + self.px() * operand.dir_x() * self.ny()
                + self.px() * operand.dir_y() * self.nx()
                + self.px() * operand.dir_z() * self.pw()
                - self.py() * operand.dir_x() * self.nx()
                + self.py() * operand.dir_y() * self.ny()
                - self.py() * operand.dir_z() * self.nz()
                - self.pz() * operand.dir_x() * self.pw()
                + self.pz() * operand.dir_y() * self.nz()
                + self.pz() * operand.dir_z() * self.ny(),
            -(self.nx() * operand.dir_x() * self.nx()) + self.nx() * operand.dir_y() * self.ny()
                - self.nx() * operand.dir_z() * self.nz()
                + self.ny() * operand.dir_x() * self.ny()
                + self.ny() * operand.dir_y() * self.nx()
                + self.ny() * operand.dir_z() * self.pw()
                + self.nz() * operand.dir_x() * self.nz()
                + self.nz() * operand.dir_y() * self.pw()
                - self.nz() * operand.dir_z() * self.nx()
                - self.pw() * operand.dir_x() * self.pw()
                + self.pw() * operand.dir_y() * self.nz()
                + self.pw() * operand.dir_z() * self.ny(),
            -(self.dist() * operand.dir_x() * self.pw())
                + self.dist() * operand.dir_y() * self.nz()
                + self.dist() * operand.dir_z() * self.ny()
                + self.nx() * operand.dir_x() * self.px()
                + self.nx() * operand.dir_y() * self.py()
                + self.nx() * operand.dir_z() * self.pz()
                + self.nx() * operand.moment_x() * self.nx()
                + self.nx() * operand.moment_y() * self.ny()
                + self.nx() * operand.moment_z() * self.nz()
                + self.ny() * operand.dir_x() * self.py()
                - self.ny() * operand.dir_y() * self.px()
                + self.ny() * operand.dir_z() * self.dist()
                - self.ny() * operand.moment_x() * self.ny()
                + self.ny() * operand.moment_y() * self.nx()
                - self.ny() * operand.moment_z() * self.pw()
                - self.nz() * operand.dir_x() * self.pz()
                + self.nz() * operand.dir_y() * self.dist()
                + self.nz() * operand.dir_z() * self.px()
                - self.nz() * operand.moment_x() * self.nz()
                + self.nz() * operand.moment_y() * self.pw()
                + self.nz() * operand.moment_z() * self.nx()
                - self.pw() * operand.dir_x() * self.dist()
                - self.pw() * operand.dir_y() * self.pz()
                + self.pw() * operand.dir_z() * self.py()
                + self.pw() * operand.moment_x() * self.pw()
                + self.pw() * operand.moment_y() * self.nz()
                - self.pw() * operand.moment_z() * self.ny()
                + self.px() * operand.dir_x() * self.nx()
                - self.px() * operand.dir_y() * self.ny()
                + self.px() * operand.dir_z() * self.nz()
                + self.py() * operand.dir_x() * self.ny()
                + self.py() * operand.dir_y() * self.nx()
                + self.py() * operand.dir_z() * self.pw()
                - self.pz() * operand.dir_x() * self.nz()
                - self.pz() * operand.dir_y() * self.pw()
                + self.pz() * operand.dir_z() * self.nx(),
            self.nx() * operand.dir_x() * self.ny()
                + self.nx() * operand.dir_y() * self.nx()
                + self.nx() * operand.dir_z() * self.pw()
                + self.ny() * operand.dir_x() * self.nx()
                - self.ny() * operand.dir_y() * self.ny()
                + self.ny() * operand.dir_z() * self.nz()
                - self.nz() * operand.dir_x() * self.pw()
                + self.nz() * operand.dir_y() * self.nz()
                + self.nz() * operand.dir_z() * self.ny()
                - self.pw() * operand.dir_x() * self.nz()
                - self.pw() * operand.dir_y() * self.pw()
                + self.pw() * operand.dir_z() * self.nx(),
            -(self.nx() * operand.dir_x() * self.nz()) - self.nx() * operand.dir_y() * self.pw()
                + self.nx() * operand.dir_z() * self.nx()
                - self.ny() * operand.dir_x() * self.pw()
                + self.ny() * operand.dir_y() * self.nz()
                + self.ny() * operand.dir_z() * self.ny()
                - self.nz() * operand.dir_x() * self.nx()
                + self.nz() * operand.dir_y() * self.ny()
                - self.nz() * operand.dir_z() * self.nz()
                - self.pw() * operand.dir_x() * self.ny()
                - self.pw() * operand.dir_y() * self.nx()
                - self.pw() * operand.dir_z() * self.pw(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Unitized<Flector<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            -(operand.moment_z())
                + -T::TWO * operand.dir_x() * self.as_inner().dist() * self.as_inner().ny()
                + -T::TWO * operand.dir_x() * self.as_inner().pw() * self.as_inner().py()
                + -T::TWO * operand.dir_y() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.dir_y() * self.as_inner().ny() * self.as_inner().pz()
                + -T::TWO * operand.moment_y() * self.as_inner().nx() * self.as_inner().pw()
                + T::TWO * operand.dir_x() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.dir_x() * self.as_inner().nz() * self.as_inner().px()
                + T::TWO * operand.dir_y() * self.as_inner().nz() * self.as_inner().py()
                + T::TWO * operand.dir_y() * self.as_inner().pw() * self.as_inner().px()
                + T::TWO * operand.moment_x() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.moment_x() * self.as_inner().ny() * self.as_inner().pw()
                + T::TWO * operand.moment_y() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.moment_z() * self.as_inner().nz() * self.as_inner().nz()
                + T::TWO * operand.moment_z() * self.as_inner().pw() * self.as_inner().pw()
                + T::from_i8(-4i8)
                    * operand.dir_z()
                    * self.as_inner().dist()
                    * self.as_inner().pw()
                + T::from_i8(4i8) * operand.dir_z() * self.as_inner().nz() * self.as_inner().pz(),
            -(operand.moment_y())
                + -T::TWO * operand.dir_x() * self.as_inner().nx() * self.as_inner().py()
                + -T::TWO * operand.dir_x() * self.as_inner().pw() * self.as_inner().pz()
                + -T::TWO * operand.dir_z() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.dir_z() * self.as_inner().nz() * self.as_inner().py()
                + -T::TWO * operand.moment_x() * self.as_inner().nz() * self.as_inner().pw()
                + T::TWO * operand.dir_x() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.dir_x() * self.as_inner().ny() * self.as_inner().px()
                + T::TWO * operand.dir_z() * self.as_inner().ny() * self.as_inner().pz()
                + T::TWO * operand.dir_z() * self.as_inner().pw() * self.as_inner().px()
                + T::TWO * operand.moment_x() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.moment_y() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.moment_y() * self.as_inner().pw() * self.as_inner().pw()
                + T::TWO * operand.moment_z() * self.as_inner().nx() * self.as_inner().pw()
                + T::TWO * operand.moment_z() * self.as_inner().ny() * self.as_inner().nz()
                + T::from_i8(4i8) * operand.dir_y() * self.as_inner().dist() * self.as_inner().pw()
                + T::from_i8(4i8) * operand.dir_y() * self.as_inner().ny() * self.as_inner().py(),
            -(operand.dir_x())
                + -T::TWO * operand.dir_z() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.dir_x() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.dir_x() * self.as_inner().nz() * self.as_inner().nz()
                + T::TWO * operand.dir_y() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.dir_y() * self.as_inner().nz() * self.as_inner().pw()
                + T::TWO * operand.dir_z() * self.as_inner().ny() * self.as_inner().pw(),
            -T::TWO * operand.dir_y() * self.as_inner().ny() * self.as_inner().px()
                + -T::TWO * operand.dir_y() * self.as_inner().pw() * self.as_inner().pz()
                + -T::TWO * operand.moment_x() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.moment_x() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.moment_z() * self.as_inner().ny() * self.as_inner().pw()
                + T::TWO * operand.dir_y() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.dir_y() * self.as_inner().nx() * self.as_inner().py()
                + T::TWO * operand.dir_z() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.dir_z() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.dir_z() * self.as_inner().nz() * self.as_inner().px()
                + T::TWO * operand.dir_z() * self.as_inner().pw() * self.as_inner().py()
                + T::TWO * operand.moment_y() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.moment_y() * self.as_inner().nz() * self.as_inner().pw()
                + T::TWO * operand.moment_z() * self.as_inner().nx() * self.as_inner().nz()
                + T::from_i8(-4i8) * operand.dir_x() * self.as_inner().nz() * self.as_inner().pz()
                + T::from_i8(4i8) * operand.dir_x() * self.as_inner().ny() * self.as_inner().py()
                + operand.moment_x(),
            -T::TWO * operand.dir_x() * self.as_inner().nz() * self.as_inner().pw()
                + -T::TWO * operand.dir_y() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.dir_y() * self.as_inner().pw() * self.as_inner().pw()
                + T::TWO * operand.dir_x() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.dir_z() * self.as_inner().nx() * self.as_inner().pw()
                + T::TWO * operand.dir_z() * self.as_inner().ny() * self.as_inner().nz()
                + operand.dir_y(),
            -T::TWO * operand.dir_x() * self.as_inner().nx() * self.as_inner().nz()
                + -T::TWO * operand.dir_x() * self.as_inner().ny() * self.as_inner().pw()
                + -T::TWO * operand.dir_y() * self.as_inner().nx() * self.as_inner().pw()
                + -T::TWO * operand.dir_z() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.dir_z() * self.as_inner().pw() * self.as_inner().pw()
                + T::TWO * operand.dir_y() * self.as_inner().ny() * self.as_inner().nz()
                + operand.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Line<T>>> for Flector<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(operand.as_inner().moment_z() * self.nx() * self.nx())
                + -(operand.as_inner().moment_z() * self.ny() * self.ny())
                + -T::TWO * operand.as_inner().dir_x() * self.dist() * self.ny()
                + -T::TWO * operand.as_inner().dir_x() * self.pw() * self.py()
                + -T::TWO * operand.as_inner().dir_y() * self.dist() * self.nx()
                + -T::TWO * operand.as_inner().dir_y() * self.ny() * self.pz()
                + -T::TWO * operand.as_inner().moment_y() * self.nx() * self.pw()
                + T::TWO * operand.as_inner().dir_x() * self.nx() * self.pz()
                + T::TWO * operand.as_inner().dir_x() * self.nz() * self.px()
                + T::TWO * operand.as_inner().dir_y() * self.nz() * self.py()
                + T::TWO * operand.as_inner().dir_y() * self.pw() * self.px()
                + T::TWO * operand.as_inner().moment_x() * self.nx() * self.nz()
                + T::TWO * operand.as_inner().moment_x() * self.ny() * self.pw()
                + T::TWO * operand.as_inner().moment_y() * self.ny() * self.nz()
                + T::from_i8(-4i8) * operand.as_inner().dir_z() * self.dist() * self.pw()
                + T::from_i8(4i8) * operand.as_inner().dir_z() * self.nz() * self.pz()
                + operand.as_inner().moment_z() * self.nz() * self.nz()
                + operand.as_inner().moment_z() * self.pw() * self.pw(),
            -(operand.as_inner().moment_y() * self.nx() * self.nx())
                + -(operand.as_inner().moment_y() * self.nz() * self.nz())
                + -T::TWO * operand.as_inner().dir_x() * self.nx() * self.py()
                + -T::TWO * operand.as_inner().dir_x() * self.pw() * self.pz()
                + -T::TWO * operand.as_inner().dir_z() * self.dist() * self.nx()
                + -T::TWO * operand.as_inner().dir_z() * self.nz() * self.py()
                + -T::TWO * operand.as_inner().moment_x() * self.nz() * self.pw()
                + T::TWO * operand.as_inner().dir_x() * self.dist() * self.nz()
                + T::TWO * operand.as_inner().dir_x() * self.ny() * self.px()
                + T::TWO * operand.as_inner().dir_z() * self.ny() * self.pz()
                + T::TWO * operand.as_inner().dir_z() * self.pw() * self.px()
                + T::TWO * operand.as_inner().moment_x() * self.nx() * self.ny()
                + T::TWO * operand.as_inner().moment_z() * self.nx() * self.pw()
                + T::TWO * operand.as_inner().moment_z() * self.ny() * self.nz()
                + T::from_i8(4i8) * operand.as_inner().dir_y() * self.dist() * self.pw()
                + T::from_i8(4i8) * operand.as_inner().dir_y() * self.ny() * self.py()
                + operand.as_inner().moment_y() * self.ny() * self.ny()
                + operand.as_inner().moment_y() * self.pw() * self.pw(),
            -(operand.as_inner().dir_x() * self.nx() * self.nx())
                + -(operand.as_inner().dir_x() * self.pw() * self.pw())
                + -T::TWO * operand.as_inner().dir_z() * self.nx() * self.nz()
                + T::TWO * operand.as_inner().dir_y() * self.nx() * self.ny()
                + T::TWO * operand.as_inner().dir_y() * self.nz() * self.pw()
                + T::TWO * operand.as_inner().dir_z() * self.ny() * self.pw()
                + operand.as_inner().dir_x() * self.ny() * self.ny()
                + operand.as_inner().dir_x() * self.nz() * self.nz(),
            -(operand.as_inner().moment_x() * self.ny() * self.ny())
                + -(operand.as_inner().moment_x() * self.nz() * self.nz())
                + -T::TWO * operand.as_inner().dir_y() * self.ny() * self.px()
                + -T::TWO * operand.as_inner().dir_y() * self.pw() * self.pz()
                + -T::TWO * operand.as_inner().moment_z() * self.ny() * self.pw()
                + T::TWO * operand.as_inner().dir_y() * self.dist() * self.nz()
                + T::TWO * operand.as_inner().dir_y() * self.nx() * self.py()
                + T::TWO * operand.as_inner().dir_z() * self.dist() * self.ny()
                + T::TWO * operand.as_inner().dir_z() * self.nx() * self.pz()
                + T::TWO * operand.as_inner().dir_z() * self.nz() * self.px()
                + T::TWO * operand.as_inner().dir_z() * self.pw() * self.py()
                + T::TWO * operand.as_inner().moment_y() * self.nx() * self.ny()
                + T::TWO * operand.as_inner().moment_y() * self.nz() * self.pw()
                + T::TWO * operand.as_inner().moment_z() * self.nx() * self.nz()
                + T::from_i8(-4i8) * operand.as_inner().dir_x() * self.nz() * self.pz()
                + T::from_i8(4i8) * operand.as_inner().dir_x() * self.ny() * self.py()
                + operand.as_inner().moment_x() * self.nx() * self.nx()
                + operand.as_inner().moment_x() * self.pw() * self.pw(),
            -(operand.as_inner().dir_y() * self.ny() * self.ny())
                + -(operand.as_inner().dir_y() * self.pw() * self.pw())
                + -T::TWO * operand.as_inner().dir_x() * self.nz() * self.pw()
                + T::TWO * operand.as_inner().dir_x() * self.nx() * self.ny()
                + T::TWO * operand.as_inner().dir_z() * self.nx() * self.pw()
                + T::TWO * operand.as_inner().dir_z() * self.ny() * self.nz()
                + operand.as_inner().dir_y() * self.nx() * self.nx()
                + operand.as_inner().dir_y() * self.nz() * self.nz(),
            -(operand.as_inner().dir_z() * self.nz() * self.nz())
                + -(operand.as_inner().dir_z() * self.pw() * self.pw())
                + -T::TWO * operand.as_inner().dir_x() * self.nx() * self.nz()
                + -T::TWO * operand.as_inner().dir_x() * self.ny() * self.pw()
                + -T::TWO * operand.as_inner().dir_y() * self.nx() * self.pw()
                + T::TWO * operand.as_inner().dir_y() * self.ny() * self.nz()
                + operand.as_inner().dir_z() * self.nx() * self.nx()
                + operand.as_inner().dir_z() * self.ny() * self.ny(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Line<T>>> for Unitized<Flector<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(operand.as_inner().moment_z())
                + -T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().dist()
                    * self.as_inner().ny()
                + -T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().pw()
                    * self.as_inner().py()
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().dist()
                    * self.as_inner().nx()
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().ny()
                    * self.as_inner().pz()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().nx()
                    * self.as_inner().pw()
                + T::TWO * operand.as_inner().dir_x() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.as_inner().dir_x() * self.as_inner().nz() * self.as_inner().px()
                + T::TWO * operand.as_inner().dir_y() * self.as_inner().nz() * self.as_inner().py()
                + T::TWO * operand.as_inner().dir_y() * self.as_inner().pw() * self.as_inner().px()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().nx()
                    * self.as_inner().nz()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().ny()
                    * self.as_inner().pw()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().ny()
                    * self.as_inner().nz()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().nz()
                    * self.as_inner().nz()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().pw()
                    * self.as_inner().pw()
                + T::from_i8(-4i8)
                    * operand.as_inner().dir_z()
                    * self.as_inner().dist()
                    * self.as_inner().pw()
                + T::from_i8(4i8)
                    * operand.as_inner().dir_z()
                    * self.as_inner().nz()
                    * self.as_inner().pz(),
            -(operand.as_inner().moment_y())
                + -T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().nx()
                    * self.as_inner().py()
                + -T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().pw()
                    * self.as_inner().pz()
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().dist()
                    * self.as_inner().nx()
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().nz()
                    * self.as_inner().py()
                + -T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().nz()
                    * self.as_inner().pw()
                + T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().dist()
                    * self.as_inner().nz()
                + T::TWO * operand.as_inner().dir_x() * self.as_inner().ny() * self.as_inner().px()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().ny() * self.as_inner().pz()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().pw() * self.as_inner().px()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().nx()
                    * self.as_inner().ny()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().ny()
                    * self.as_inner().ny()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().pw()
                    * self.as_inner().pw()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().nx()
                    * self.as_inner().pw()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().ny()
                    * self.as_inner().nz()
                + T::from_i8(4i8)
                    * operand.as_inner().dir_y()
                    * self.as_inner().dist()
                    * self.as_inner().pw()
                + T::from_i8(4i8)
                    * operand.as_inner().dir_y()
                    * self.as_inner().ny()
                    * self.as_inner().py(),
            -(operand.as_inner().dir_x())
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().nx()
                    * self.as_inner().nz()
                + T::TWO * operand.as_inner().dir_x() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.as_inner().dir_x() * self.as_inner().nz() * self.as_inner().nz()
                + T::TWO * operand.as_inner().dir_y() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.as_inner().dir_y() * self.as_inner().nz() * self.as_inner().pw()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().ny() * self.as_inner().pw(),
            -T::TWO * operand.as_inner().dir_y() * self.as_inner().ny() * self.as_inner().px()
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().pw()
                    * self.as_inner().pz()
                + -T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().ny()
                    * self.as_inner().ny()
                + -T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().nz()
                    * self.as_inner().nz()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().ny()
                    * self.as_inner().pw()
                + T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().dist()
                    * self.as_inner().nz()
                + T::TWO * operand.as_inner().dir_y() * self.as_inner().nx() * self.as_inner().py()
                + T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().dist()
                    * self.as_inner().ny()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().nz() * self.as_inner().px()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().pw() * self.as_inner().py()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().nx()
                    * self.as_inner().ny()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().nz()
                    * self.as_inner().pw()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().nx()
                    * self.as_inner().nz()
                + T::from_i8(-4i8)
                    * operand.as_inner().dir_x()
                    * self.as_inner().nz()
                    * self.as_inner().pz()
                + T::from_i8(4i8)
                    * operand.as_inner().dir_x()
                    * self.as_inner().ny()
                    * self.as_inner().py()
                + operand.as_inner().moment_x(),
            -T::TWO * operand.as_inner().dir_x() * self.as_inner().nz() * self.as_inner().pw()
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().ny()
                    * self.as_inner().ny()
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().pw()
                    * self.as_inner().pw()
                + T::TWO * operand.as_inner().dir_x() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().nx() * self.as_inner().pw()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().ny() * self.as_inner().nz()
                + operand.as_inner().dir_y(),
            -T::TWO * operand.as_inner().dir_x() * self.as_inner().nx() * self.as_inner().nz()
                + -T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().ny()
                    * self.as_inner().pw()
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().nx()
                    * self.as_inner().pw()
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().nz()
                    * self.as_inner().nz()
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().pw()
                    * self.as_inner().pw()
                + T::TWO * operand.as_inner().dir_y() * self.as_inner().ny() * self.as_inner().nz()
                + operand.as_inner().dir_z(),
        )
    }
}
#[doc = "Antisandwich product: [`Flector`] x [`Motor`] x antirev([`Flector`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Motor<T>> for Flector<T> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            self.dist() * operand.ps() * self.pw() + self.dist() * operand.ry() * self.ny()
                - self.dist() * operand.rz() * self.nz()
                - self.dist() * operand.tx() * self.nx()
                - self.nx() * operand.ps() * self.px()
                - self.nx() * operand.rx() * self.pw()
                + self.nx() * operand.ry() * self.pz()
                - self.nx() * operand.rz() * self.py()
                + self.nx() * operand.s() * self.nx()
                + self.nx() * operand.tx() * self.dist()
                - self.nx() * operand.ty() * self.nz()
                + self.nx() * operand.tz() * self.ny()
                + self.ny() * operand.ps() * self.py()
                + self.ny() * operand.rx() * self.nz()
                - self.ny() * operand.ry() * self.dist()
                - self.ny() * operand.rz() * self.px()
                + self.ny() * operand.s() * self.ny()
                + self.ny() * operand.tx() * self.pz()
                - self.ny() * operand.ty() * self.pw()
                - self.ny() * operand.tz() * self.nx()
                - self.nz() * operand.ps() * self.pz()
                - self.nz() * operand.rx() * self.ny()
                - self.nz() * operand.ry() * self.px()
                + self.nz() * operand.rz() * self.dist()
                + self.nz() * operand.s() * self.nz()
                + self.nz() * operand.tx() * self.py()
                + self.nz() * operand.ty() * self.nx()
                - self.nz() * operand.tz() * self.pw()
                + self.pw() * operand.ps() * self.dist()
                + self.pw() * operand.rx() * self.nx()
                + self.pw() * operand.ry() * self.py()
                + self.pw() * operand.rz() * self.pz()
                + self.pw() * operand.s() * self.pw()
                + self.pw() * operand.tx() * self.px()
                + self.pw() * operand.ty() * self.ny()
                + self.pw() * operand.tz() * self.nz()
                - self.px() * operand.ps() * self.nx()
                + self.px() * operand.ry() * self.nz()
                + self.px() * operand.rz() * self.ny()
                - self.px() * operand.tx() * self.pw()
                + self.py() * operand.ps() * self.ny()
                - self.py() * operand.ry() * self.pw()
                + self.py() * operand.rz() * self.nx()
                - self.py() * operand.tx() * self.nz()
                - self.pz() * operand.ps() * self.nz()
                - self.pz() * operand.ry() * self.nx()
                - self.pz() * operand.rz() * self.pw()
                - self.pz() * operand.tx() * self.ny(),
            -(self.dist() * operand.ps() * self.nz())
                - self.dist() * operand.ry() * self.nx()
                - self.dist() * operand.rz() * self.pw()
                - self.dist() * operand.tx() * self.ny()
                + self.nx() * operand.ps() * self.py()
                + self.nx() * operand.rx() * self.nz()
                - self.nx() * operand.ry() * self.dist()
                - self.nx() * operand.rz() * self.px()
                + self.nx() * operand.s() * self.ny()
                + self.nx() * operand.tx() * self.pz()
                - self.nx() * operand.ty() * self.pw()
                - self.nx() * operand.tz() * self.nx()
                + self.ny() * operand.ps() * self.px()
                + self.ny() * operand.rx() * self.pw()
                - self.ny() * operand.ry() * self.pz()
                + self.ny() * operand.rz() * self.py()
                - self.ny() * operand.s() * self.nx()
                - self.ny() * operand.tx() * self.dist()
                + self.ny() * operand.ty() * self.nz()
                - self.ny() * operand.tz() * self.ny()
                + self.nz() * operand.ps() * self.dist()
                + self.nz() * operand.rx() * self.nx()
                + self.nz() * operand.ry() * self.py()
                + self.nz() * operand.rz() * self.pz()
                + self.nz() * operand.s() * self.pw()
                + self.nz() * operand.tx() * self.px()
                + self.nz() * operand.ty() * self.ny()
                + self.nz() * operand.tz() * self.nz()
                + self.pw() * operand.ps() * self.pz()
                + self.pw() * operand.rx() * self.ny()
                + self.pw() * operand.ry() * self.px()
                - self.pw() * operand.rz() * self.dist()
                - self.pw() * operand.s() * self.nz()
                - self.pw() * operand.tx() * self.py()
                - self.pw() * operand.ty() * self.nx()
                + self.pw() * operand.tz() * self.pw()
                - self.px() * operand.ps() * self.ny()
                + self.px() * operand.ry() * self.pw()
                - self.px() * operand.rz() * self.nx()
                + self.px() * operand.tx() * self.nz()
                - self.py() * operand.ps() * self.nx()
                + self.py() * operand.ry() * self.nz()
                + self.py() * operand.rz() * self.ny()
                - self.py() * operand.tx() * self.pw()
                - self.pz() * operand.ps() * self.pw()
                - self.pz() * operand.ry() * self.ny()
                + self.pz() * operand.rz() * self.nz()
                + self.pz() * operand.tx() * self.nx(),
            -(self.dist() * operand.ps() * self.ny()) + self.dist() * operand.ry() * self.pw()
                - self.dist() * operand.rz() * self.nx()
                + self.dist() * operand.tx() * self.nz()
                + self.nx() * operand.ps() * self.pz()
                + self.nx() * operand.rx() * self.ny()
                + self.nx() * operand.ry() * self.px()
                - self.nx() * operand.rz() * self.dist()
                - self.nx() * operand.s() * self.nz()
                - self.nx() * operand.tx() * self.py()
                - self.nx() * operand.ty() * self.nx()
                + self.nx() * operand.tz() * self.pw()
                + self.ny() * operand.ps() * self.dist()
                + self.ny() * operand.rx() * self.nx()
                + self.ny() * operand.ry() * self.py()
                + self.ny() * operand.rz() * self.pz()
                + self.ny() * operand.s() * self.pw()
                + self.ny() * operand.tx() * self.px()
                + self.ny() * operand.ty() * self.ny()
                + self.ny() * operand.tz() * self.nz()
                - self.nz() * operand.ps() * self.px()
                - self.nz() * operand.rx() * self.pw()
                + self.nz() * operand.ry() * self.pz()
                - self.nz() * operand.rz() * self.py()
                + self.nz() * operand.s() * self.nx()
                + self.nz() * operand.tx() * self.dist()
                - self.nz() * operand.ty() * self.nz()
                + self.nz() * operand.tz() * self.ny()
                - self.pw() * operand.ps() * self.py()
                - self.pw() * operand.rx() * self.nz()
                + self.pw() * operand.ry() * self.dist()
                + self.pw() * operand.rz() * self.px()
                - self.pw() * operand.s() * self.ny()
                - self.pw() * operand.tx() * self.pz()
                + self.pw() * operand.ty() * self.pw()
                + self.pw() * operand.tz() * self.nx()
                + self.px() * operand.ps() * self.nz()
                + self.px() * operand.ry() * self.nx()
                + self.px() * operand.rz() * self.pw()
                + self.px() * operand.tx() * self.ny()
                + self.py() * operand.ps() * self.pw()
                + self.py() * operand.ry() * self.ny()
                - self.py() * operand.rz() * self.nz()
                - self.py() * operand.tx() * self.nx()
                - self.pz() * operand.ps() * self.nx()
                + self.pz() * operand.ry() * self.nz()
                + self.pz() * operand.rz() * self.ny()
                - self.pz() * operand.tx() * self.pw(),
            self.nx() * operand.ps() * self.pw() + self.nx() * operand.ry() * self.ny()
                - self.nx() * operand.rz() * self.nz()
                - self.nx() * operand.tx() * self.nx()
                + self.ny() * operand.ps() * self.nz()
                + self.ny() * operand.ry() * self.nx()
                + self.ny() * operand.rz() * self.pw()
                + self.ny() * operand.tx() * self.ny()
                - self.nz() * operand.ps() * self.ny()
                + self.nz() * operand.ry() * self.pw()
                - self.nz() * operand.rz() * self.nx()
                + self.nz() * operand.tx() * self.nz()
                - self.pw() * operand.ps() * self.nx()
                + self.pw() * operand.ry() * self.nz()
                + self.pw() * operand.rz() * self.ny()
                - self.pw() * operand.tx() * self.pw(),
            -(self.dist() * operand.ps() * self.nx())
                + self.dist() * operand.ry() * self.nz()
                + self.dist() * operand.rz() * self.ny()
                - self.dist() * operand.tx() * self.pw()
                + self.nx() * operand.ps() * self.dist()
                + self.nx() * operand.rx() * self.nx()
                + self.nx() * operand.ry() * self.py()
                + self.nx() * operand.rz() * self.pz()
                + self.nx() * operand.s() * self.pw()
                + self.nx() * operand.tx() * self.px()
                + self.nx() * operand.ty() * self.ny()
                + self.nx() * operand.tz() * self.nz()
                - self.ny() * operand.ps() * self.pz()
                - self.ny() * operand.rx() * self.ny()
                - self.ny() * operand.ry() * self.px()
                + self.ny() * operand.rz() * self.dist()
                + self.ny() * operand.s() * self.nz()
                + self.ny() * operand.tx() * self.py()
                + self.ny() * operand.ty() * self.nx()
                - self.ny() * operand.tz() * self.pw()
                - self.nz() * operand.ps() * self.py()
                - self.nz() * operand.rx() * self.nz()
                + self.nz() * operand.ry() * self.dist()
                + self.nz() * operand.rz() * self.px()
                - self.nz() * operand.s() * self.ny()
                - self.nz() * operand.tx() * self.pz()
                + self.nz() * operand.ty() * self.pw()
                + self.nz() * operand.tz() * self.nx()
                + self.pw() * operand.ps() * self.px()
                + self.pw() * operand.rx() * self.pw()
                - self.pw() * operand.ry() * self.pz()
                + self.pw() * operand.rz() * self.py()
                - self.pw() * operand.s() * self.nx()
                - self.pw() * operand.tx() * self.dist()
                + self.pw() * operand.ty() * self.nz()
                - self.pw() * operand.tz() * self.ny()
                - self.px() * operand.ps() * self.pw()
                - self.px() * operand.ry() * self.ny()
                + self.px() * operand.rz() * self.nz()
                + self.px() * operand.tx() * self.nx()
                + self.py() * operand.ps() * self.nz()
                + self.py() * operand.ry() * self.nx()
                + self.py() * operand.rz() * self.pw()
                + self.py() * operand.tx() * self.ny()
                + self.pz() * operand.ps() * self.ny()
                - self.pz() * operand.ry() * self.pw()
                + self.pz() * operand.rz() * self.nx()
                - self.pz() * operand.tx() * self.nz(),
            self.nx() * operand.ps() * self.nz()
                + self.nx() * operand.ry() * self.nx()
                + self.nx() * operand.rz() * self.pw()
                + self.nx() * operand.tx() * self.ny()
                - self.ny() * operand.ps() * self.pw()
                - self.ny() * operand.ry() * self.ny()
                + self.ny() * operand.rz() * self.nz()
                + self.ny() * operand.tx() * self.nx()
                - self.nz() * operand.ps() * self.nx()
                + self.nz() * operand.ry() * self.nz()
                + self.nz() * operand.rz() * self.ny()
                - self.nz() * operand.tx() * self.pw()
                + self.pw() * operand.ps() * self.ny()
                - self.pw() * operand.ry() * self.pw()
                + self.pw() * operand.rz() * self.nx()
                - self.pw() * operand.tx() * self.nz(),
            self.nx() * operand.ps() * self.ny() - self.nx() * operand.ry() * self.pw()
                + self.nx() * operand.rz() * self.nx()
                - self.nx() * operand.tx() * self.nz()
                - self.ny() * operand.ps() * self.nx()
                + self.ny() * operand.ry() * self.nz()
                + self.ny() * operand.rz() * self.ny()
                - self.ny() * operand.tx() * self.pw()
                + self.nz() * operand.ps() * self.pw()
                + self.nz() * operand.ry() * self.ny()
                - self.nz() * operand.rz() * self.nz()
                - self.nz() * operand.tx() * self.nx()
                - self.pw() * operand.ps() * self.nz()
                - self.pw() * operand.ry() * self.nx()
                - self.pw() * operand.rz() * self.pw()
                - self.pw() * operand.tx() * self.ny(),
            -(self.nx() * operand.ps() * self.nx())
                + self.nx() * operand.ry() * self.nz()
                + self.nx() * operand.rz() * self.ny()
                - self.nx() * operand.tx() * self.pw()
                - self.ny() * operand.ps() * self.ny()
                + self.ny() * operand.ry() * self.pw()
                - self.ny() * operand.rz() * self.nx()
                + self.ny() * operand.tx() * self.nz()
                - self.nz() * operand.ps() * self.nz()
                - self.nz() * operand.ry() * self.nx()
                - self.nz() * operand.rz() * self.pw()
                - self.nz() * operand.tx() * self.ny()
                - self.pw() * operand.ps() * self.pw()
                - self.pw() * operand.ry() * self.ny()
                + self.pw() * operand.rz() * self.nz()
                + self.pw() * operand.tx() * self.nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Motor<T>> for Unitized<Flector<T>> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            operand.s(),
            -(operand.tz())
                + -T::TWO * operand.ry() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.ry() * self.as_inner().ny() * self.as_inner().pz()
                + -T::TWO * operand.tx() * self.as_inner().dist() * self.as_inner().ny()
                + -T::TWO * operand.tx() * self.as_inner().pw() * self.as_inner().py()
                + -T::TWO * operand.ty() * self.as_inner().nx() * self.as_inner().pw()
                + T::TWO * operand.rx() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.rx() * self.as_inner().ny() * self.as_inner().pw()
                + T::TWO * operand.ry() * self.as_inner().nz() * self.as_inner().py()
                + T::TWO * operand.ry() * self.as_inner().pw() * self.as_inner().px()
                + T::TWO * operand.tx() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.tx() * self.as_inner().nz() * self.as_inner().px()
                + T::TWO * operand.ty() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.tz() * self.as_inner().nz() * self.as_inner().nz()
                + T::TWO * operand.tz() * self.as_inner().pw() * self.as_inner().pw()
                + T::from_i8(-4i8) * operand.rz() * self.as_inner().dist() * self.as_inner().pw()
                + T::from_i8(4i8) * operand.rz() * self.as_inner().nz() * self.as_inner().pz(),
            -(operand.ty())
                + -T::TWO * operand.rx() * self.as_inner().nz() * self.as_inner().pw()
                + -T::TWO * operand.rz() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.rz() * self.as_inner().nz() * self.as_inner().py()
                + -T::TWO * operand.tx() * self.as_inner().nx() * self.as_inner().py()
                + -T::TWO * operand.tx() * self.as_inner().pw() * self.as_inner().pz()
                + T::TWO * operand.rx() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.rz() * self.as_inner().ny() * self.as_inner().pz()
                + T::TWO * operand.rz() * self.as_inner().pw() * self.as_inner().px()
                + T::TWO * operand.tx() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.tx() * self.as_inner().ny() * self.as_inner().px()
                + T::TWO * operand.ty() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.ty() * self.as_inner().pw() * self.as_inner().pw()
                + T::TWO * operand.tz() * self.as_inner().nx() * self.as_inner().pw()
                + T::TWO * operand.tz() * self.as_inner().ny() * self.as_inner().nz()
                + T::from_i8(4i8) * operand.ry() * self.as_inner().dist() * self.as_inner().pw()
                + T::from_i8(4i8) * operand.ry() * self.as_inner().ny() * self.as_inner().py(),
            -(operand.tx())
                + -T::TWO * operand.rz() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.ry() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.ry() * self.as_inner().nz() * self.as_inner().pw()
                + T::TWO * operand.rz() * self.as_inner().ny() * self.as_inner().pw()
                + T::TWO * operand.tx() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.tx() * self.as_inner().nz() * self.as_inner().nz(),
            -T::TWO * operand.rx() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.rx() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.ry() * self.as_inner().ny() * self.as_inner().px()
                + -T::TWO * operand.ry() * self.as_inner().pw() * self.as_inner().pz()
                + -T::TWO * operand.tz() * self.as_inner().ny() * self.as_inner().pw()
                + T::TWO * operand.ry() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.ry() * self.as_inner().nx() * self.as_inner().py()
                + T::TWO * operand.rz() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.rz() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.rz() * self.as_inner().nz() * self.as_inner().px()
                + T::TWO * operand.rz() * self.as_inner().pw() * self.as_inner().py()
                + T::TWO * operand.ty() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.ty() * self.as_inner().nz() * self.as_inner().pw()
                + T::TWO * operand.tz() * self.as_inner().nx() * self.as_inner().nz()
                + T::from_i8(-4i8) * operand.tx() * self.as_inner().nz() * self.as_inner().pz()
                + T::from_i8(4i8) * operand.tx() * self.as_inner().ny() * self.as_inner().py()
                + operand.rx(),
            -T::TWO * operand.ry() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.ry() * self.as_inner().pw() * self.as_inner().pw()
                + -T::TWO * operand.tx() * self.as_inner().nz() * self.as_inner().pw()
                + T::TWO * operand.rz() * self.as_inner().nx() * self.as_inner().pw()
                + T::TWO * operand.rz() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.tx() * self.as_inner().nx() * self.as_inner().ny()
                + operand.ry(),
            -T::TWO * operand.ry() * self.as_inner().nx() * self.as_inner().pw()
                + -T::TWO * operand.rz() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.rz() * self.as_inner().pw() * self.as_inner().pw()
                + -T::TWO * operand.tx() * self.as_inner().nx() * self.as_inner().nz()
                + -T::TWO * operand.tx() * self.as_inner().ny() * self.as_inner().pw()
                + T::TWO * operand.ry() * self.as_inner().ny() * self.as_inner().nz()
                + operand.rz(),
            -(operand.ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Motor<T>>> for Flector<T> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s() * self.nx() * self.nx()
                + operand.as_inner().s() * self.ny() * self.ny()
                + operand.as_inner().s() * self.nz() * self.nz()
                + operand.as_inner().s() * self.pw() * self.pw(),
            -(operand.as_inner().tz() * self.nx() * self.nx())
                + -(operand.as_inner().tz() * self.ny() * self.ny())
                + -T::TWO * operand.as_inner().ry() * self.dist() * self.nx()
                + -T::TWO * operand.as_inner().ry() * self.ny() * self.pz()
                + -T::TWO * operand.as_inner().tx() * self.dist() * self.ny()
                + -T::TWO * operand.as_inner().tx() * self.pw() * self.py()
                + -T::TWO * operand.as_inner().ty() * self.nx() * self.pw()
                + T::TWO * operand.as_inner().rx() * self.nx() * self.nz()
                + T::TWO * operand.as_inner().rx() * self.ny() * self.pw()
                + T::TWO * operand.as_inner().ry() * self.nz() * self.py()
                + T::TWO * operand.as_inner().ry() * self.pw() * self.px()
                + T::TWO * operand.as_inner().tx() * self.nx() * self.pz()
                + T::TWO * operand.as_inner().tx() * self.nz() * self.px()
                + T::TWO * operand.as_inner().ty() * self.ny() * self.nz()
                + T::from_i8(-4i8) * operand.as_inner().rz() * self.dist() * self.pw()
                + T::from_i8(4i8) * operand.as_inner().rz() * self.nz() * self.pz()
                + operand.as_inner().tz() * self.nz() * self.nz()
                + operand.as_inner().tz() * self.pw() * self.pw(),
            -(operand.as_inner().ty() * self.nx() * self.nx())
                + -(operand.as_inner().ty() * self.nz() * self.nz())
                + -T::TWO * operand.as_inner().rx() * self.nz() * self.pw()
                + -T::TWO * operand.as_inner().rz() * self.dist() * self.nx()
                + -T::TWO * operand.as_inner().rz() * self.nz() * self.py()
                + -T::TWO * operand.as_inner().tx() * self.nx() * self.py()
                + -T::TWO * operand.as_inner().tx() * self.pw() * self.pz()
                + T::TWO * operand.as_inner().rx() * self.nx() * self.ny()
                + T::TWO * operand.as_inner().rz() * self.ny() * self.pz()
                + T::TWO * operand.as_inner().rz() * self.pw() * self.px()
                + T::TWO * operand.as_inner().tx() * self.dist() * self.nz()
                + T::TWO * operand.as_inner().tx() * self.ny() * self.px()
                + T::TWO * operand.as_inner().tz() * self.nx() * self.pw()
                + T::TWO * operand.as_inner().tz() * self.ny() * self.nz()
                + T::from_i8(4i8) * operand.as_inner().ry() * self.dist() * self.pw()
                + T::from_i8(4i8) * operand.as_inner().ry() * self.ny() * self.py()
                + operand.as_inner().ty() * self.ny() * self.ny()
                + operand.as_inner().ty() * self.pw() * self.pw(),
            -(operand.as_inner().tx() * self.nx() * self.nx())
                + -(operand.as_inner().tx() * self.pw() * self.pw())
                + -T::TWO * operand.as_inner().rz() * self.nx() * self.nz()
                + T::TWO * operand.as_inner().ry() * self.nx() * self.ny()
                + T::TWO * operand.as_inner().ry() * self.nz() * self.pw()
                + T::TWO * operand.as_inner().rz() * self.ny() * self.pw()
                + operand.as_inner().tx() * self.ny() * self.ny()
                + operand.as_inner().tx() * self.nz() * self.nz(),
            -(operand.as_inner().rx() * self.ny() * self.ny())
                + -(operand.as_inner().rx() * self.nz() * self.nz())
                + -T::TWO * operand.as_inner().ry() * self.ny() * self.px()
                + -T::TWO * operand.as_inner().ry() * self.pw() * self.pz()
                + -T::TWO * operand.as_inner().tz() * self.ny() * self.pw()
                + T::TWO * operand.as_inner().ry() * self.dist() * self.nz()
                + T::TWO * operand.as_inner().ry() * self.nx() * self.py()
                + T::TWO * operand.as_inner().rz() * self.dist() * self.ny()
                + T::TWO * operand.as_inner().rz() * self.nx() * self.pz()
                + T::TWO * operand.as_inner().rz() * self.nz() * self.px()
                + T::TWO * operand.as_inner().rz() * self.pw() * self.py()
                + T::TWO * operand.as_inner().ty() * self.nx() * self.ny()
                + T::TWO * operand.as_inner().ty() * self.nz() * self.pw()
                + T::TWO * operand.as_inner().tz() * self.nx() * self.nz()
                + T::from_i8(-4i8) * operand.as_inner().tx() * self.nz() * self.pz()
                + T::from_i8(4i8) * operand.as_inner().tx() * self.ny() * self.py()
                + operand.as_inner().rx() * self.nx() * self.nx()
                + operand.as_inner().rx() * self.pw() * self.pw(),
            -(operand.as_inner().ry() * self.ny() * self.ny())
                + -(operand.as_inner().ry() * self.pw() * self.pw())
                + -T::TWO * operand.as_inner().tx() * self.nz() * self.pw()
                + T::TWO * operand.as_inner().rz() * self.nx() * self.pw()
                + T::TWO * operand.as_inner().rz() * self.ny() * self.nz()
                + T::TWO * operand.as_inner().tx() * self.nx() * self.ny()
                + operand.as_inner().ry() * self.nx() * self.nx()
                + operand.as_inner().ry() * self.nz() * self.nz(),
            -(operand.as_inner().rz() * self.nz() * self.nz())
                + -(operand.as_inner().rz() * self.pw() * self.pw())
                + -T::TWO * operand.as_inner().ry() * self.nx() * self.pw()
                + -T::TWO * operand.as_inner().tx() * self.nx() * self.nz()
                + -T::TWO * operand.as_inner().tx() * self.ny() * self.pw()
                + T::TWO * operand.as_inner().ry() * self.ny() * self.nz()
                + operand.as_inner().rz() * self.nx() * self.nx()
                + operand.as_inner().rz() * self.ny() * self.ny(),
            -(operand.as_inner().ps() * self.nx() * self.nx())
                + -(operand.as_inner().ps() * self.ny() * self.ny())
                + -(operand.as_inner().ps() * self.nz() * self.nz())
                + -(operand.as_inner().ps() * self.pw() * self.pw()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Motor<T>>> for Unitized<Flector<T>> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s(),
            -(operand.as_inner().tz())
                + -T::TWO * operand.as_inner().ry() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.as_inner().ry() * self.as_inner().ny() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().dist() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().pw() * self.as_inner().py()
                + -T::TWO * operand.as_inner().ty() * self.as_inner().nx() * self.as_inner().pw()
                + T::TWO * operand.as_inner().rx() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.as_inner().rx() * self.as_inner().ny() * self.as_inner().pw()
                + T::TWO * operand.as_inner().ry() * self.as_inner().nz() * self.as_inner().py()
                + T::TWO * operand.as_inner().ry() * self.as_inner().pw() * self.as_inner().px()
                + T::TWO * operand.as_inner().tx() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.as_inner().tx() * self.as_inner().nz() * self.as_inner().px()
                + T::TWO * operand.as_inner().ty() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.as_inner().tz() * self.as_inner().nz() * self.as_inner().nz()
                + T::TWO * operand.as_inner().tz() * self.as_inner().pw() * self.as_inner().pw()
                + T::from_i8(-4i8)
                    * operand.as_inner().rz()
                    * self.as_inner().dist()
                    * self.as_inner().pw()
                + T::from_i8(4i8)
                    * operand.as_inner().rz()
                    * self.as_inner().nz()
                    * self.as_inner().pz(),
            -(operand.as_inner().ty())
                + -T::TWO * operand.as_inner().rx() * self.as_inner().nz() * self.as_inner().pw()
                + -T::TWO * operand.as_inner().rz() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.as_inner().rz() * self.as_inner().nz() * self.as_inner().py()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().nx() * self.as_inner().py()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().pw() * self.as_inner().pz()
                + T::TWO * operand.as_inner().rx() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.as_inner().rz() * self.as_inner().ny() * self.as_inner().pz()
                + T::TWO * operand.as_inner().rz() * self.as_inner().pw() * self.as_inner().px()
                + T::TWO * operand.as_inner().tx() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.as_inner().tx() * self.as_inner().ny() * self.as_inner().px()
                + T::TWO * operand.as_inner().ty() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.as_inner().ty() * self.as_inner().pw() * self.as_inner().pw()
                + T::TWO * operand.as_inner().tz() * self.as_inner().nx() * self.as_inner().pw()
                + T::TWO * operand.as_inner().tz() * self.as_inner().ny() * self.as_inner().nz()
                + T::from_i8(4i8)
                    * operand.as_inner().ry()
                    * self.as_inner().dist()
                    * self.as_inner().pw()
                + T::from_i8(4i8)
                    * operand.as_inner().ry()
                    * self.as_inner().ny()
                    * self.as_inner().py(),
            -(operand.as_inner().tx())
                + -T::TWO * operand.as_inner().rz() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.as_inner().ry() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.as_inner().ry() * self.as_inner().nz() * self.as_inner().pw()
                + T::TWO * operand.as_inner().rz() * self.as_inner().ny() * self.as_inner().pw()
                + T::TWO * operand.as_inner().tx() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.as_inner().tx() * self.as_inner().nz() * self.as_inner().nz(),
            -T::TWO * operand.as_inner().rx() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().rx() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().ry() * self.as_inner().ny() * self.as_inner().px()
                + -T::TWO * operand.as_inner().ry() * self.as_inner().pw() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().tz() * self.as_inner().ny() * self.as_inner().pw()
                + T::TWO * operand.as_inner().ry() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.as_inner().ry() * self.as_inner().nx() * self.as_inner().py()
                + T::TWO * operand.as_inner().rz() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.as_inner().rz() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.as_inner().rz() * self.as_inner().nz() * self.as_inner().px()
                + T::TWO * operand.as_inner().rz() * self.as_inner().pw() * self.as_inner().py()
                + T::TWO * operand.as_inner().ty() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.as_inner().ty() * self.as_inner().nz() * self.as_inner().pw()
                + T::TWO * operand.as_inner().tz() * self.as_inner().nx() * self.as_inner().nz()
                + T::from_i8(-4i8)
                    * operand.as_inner().tx()
                    * self.as_inner().nz()
                    * self.as_inner().pz()
                + T::from_i8(4i8)
                    * operand.as_inner().tx()
                    * self.as_inner().ny()
                    * self.as_inner().py()
                + operand.as_inner().rx(),
            -T::TWO * operand.as_inner().ry() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().ry() * self.as_inner().pw() * self.as_inner().pw()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().nz() * self.as_inner().pw()
                + T::TWO * operand.as_inner().rz() * self.as_inner().nx() * self.as_inner().pw()
                + T::TWO * operand.as_inner().rz() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.as_inner().tx() * self.as_inner().nx() * self.as_inner().ny()
                + operand.as_inner().ry(),
            -T::TWO * operand.as_inner().ry() * self.as_inner().nx() * self.as_inner().pw()
                + -T::TWO * operand.as_inner().rz() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().rz() * self.as_inner().pw() * self.as_inner().pw()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().nx() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().ny() * self.as_inner().pw()
                + T::TWO * operand.as_inner().ry() * self.as_inner().ny() * self.as_inner().nz()
                + operand.as_inner().rz(),
            -(operand.as_inner().ps()),
        )
    }
}
#[doc = "Antisandwich product: [`Flector`] x [`Plane`] x antirev([`Flector`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Plane<T>> for Flector<T> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            -(self.dist() * operand.nx() * self.nx())
                - self.dist() * operand.ny() * self.ny()
                - self.dist() * operand.nz() * self.nz()
                + self.nx() * operand.dist() * self.nx()
                - self.nx() * operand.nx() * self.dist()
                + self.nx() * operand.ny() * self.pz()
                + self.nx() * operand.nz() * self.py()
                + self.ny() * operand.dist() * self.ny()
                - self.ny() * operand.nx() * self.pz()
                - self.ny() * operand.ny() * self.dist()
                + self.ny() * operand.nz() * self.px()
                + self.nz() * operand.dist() * self.nz()
                - self.nz() * operand.nx() * self.py()
                - self.nz() * operand.ny() * self.px()
                - self.nz() * operand.nz() * self.dist()
                + self.pw() * operand.dist() * self.pw()
                - self.pw() * operand.nx() * self.px()
                + self.pw() * operand.ny() * self.py()
                - self.pw() * operand.nz() * self.pz()
                - self.px() * operand.nx() * self.pw()
                - self.px() * operand.ny() * self.nz()
                + self.px() * operand.nz() * self.ny()
                - self.py() * operand.nx() * self.nz()
                + self.py() * operand.ny() * self.pw()
                + self.py() * operand.nz() * self.nx()
                - self.pz() * operand.nx() * self.ny()
                + self.pz() * operand.ny() * self.nx()
                - self.pz() * operand.nz() * self.pw(),
            -(self.nx() * operand.nx() * self.nz())
                + self.nx() * operand.ny() * self.pw()
                + self.nx() * operand.nz() * self.nx()
                - self.ny() * operand.nx() * self.pw()
                - self.ny() * operand.ny() * self.nz()
                + self.ny() * operand.nz() * self.ny()
                - self.nz() * operand.nx() * self.nx()
                - self.nz() * operand.ny() * self.ny()
                - self.nz() * operand.nz() * self.nz()
                - self.pw() * operand.nx() * self.ny()
                + self.pw() * operand.ny() * self.nx()
                - self.pw() * operand.nz() * self.pw(),
            -(self.nx() * operand.nx() * self.ny()) + self.nx() * operand.ny() * self.nx()
                - self.nx() * operand.nz() * self.pw()
                - self.ny() * operand.nx() * self.nx()
                - self.ny() * operand.ny() * self.ny()
                - self.ny() * operand.nz() * self.nz()
                + self.nz() * operand.nx() * self.pw()
                + self.nz() * operand.ny() * self.nz()
                - self.nz() * operand.nz() * self.ny()
                + self.pw() * operand.nx() * self.nz()
                - self.pw() * operand.ny() * self.pw()
                - self.pw() * operand.nz() * self.nx(),
            -(self.nx() * operand.nx() * self.nx())
                - self.nx() * operand.ny() * self.ny()
                - self.nx() * operand.nz() * self.nz()
                + self.ny() * operand.nx() * self.ny()
                - self.ny() * operand.ny() * self.nx()
                + self.ny() * operand.nz() * self.pw()
                + self.nz() * operand.nx() * self.nz()
                - self.nz() * operand.ny() * self.pw()
                - self.nz() * operand.nz() * self.nx()
                - self.pw() * operand.nx() * self.pw()
                - self.pw() * operand.ny() * self.nz()
                + self.pw() * operand.nz() * self.ny(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Plane<T>> for Unitized<Flector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            -T::TWO * operand.nx() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.nx() * self.as_inner().ny() * self.as_inner().pz()
                + -T::TWO * operand.nx() * self.as_inner().nz() * self.as_inner().py()
                + -T::TWO * operand.nx() * self.as_inner().pw() * self.as_inner().px()
                + -T::TWO * operand.ny() * self.as_inner().dist() * self.as_inner().ny()
                + -T::TWO * operand.ny() * self.as_inner().nz() * self.as_inner().px()
                + -T::TWO * operand.nz() * self.as_inner().dist() * self.as_inner().nz()
                + -T::TWO * operand.nz() * self.as_inner().pw() * self.as_inner().pz()
                + T::TWO * operand.ny() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.ny() * self.as_inner().pw() * self.as_inner().py()
                + T::TWO * operand.nz() * self.as_inner().nx() * self.as_inner().py()
                + T::TWO * operand.nz() * self.as_inner().ny() * self.as_inner().px()
                + operand.dist(),
            -T::TWO * operand.nx() * self.as_inner().nx() * self.as_inner().nz()
                + -T::TWO * operand.nx() * self.as_inner().ny() * self.as_inner().pw()
                + -T::TWO * operand.ny() * self.as_inner().ny() * self.as_inner().nz()
                + -T::TWO * operand.nz() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.nz() * self.as_inner().pw() * self.as_inner().pw()
                + T::TWO * operand.ny() * self.as_inner().nx() * self.as_inner().pw()
                + operand.nz(),
            -T::TWO * operand.nx() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.ny() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.ny() * self.as_inner().pw() * self.as_inner().pw()
                + -T::TWO * operand.nz() * self.as_inner().nx() * self.as_inner().pw()
                + -T::TWO * operand.nz() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.nx() * self.as_inner().nz() * self.as_inner().pw()
                + operand.ny(),
            -(operand.nx())
                + -T::TWO * operand.ny() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.ny() * self.as_inner().nz() * self.as_inner().pw()
                + -T::TWO * operand.nz() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.nx() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.nx() * self.as_inner().nz() * self.as_inner().nz()
                + T::TWO * operand.nz() * self.as_inner().ny() * self.as_inner().pw(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Plane<T>>> for Flector<T> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -T::TWO * operand.as_inner().nx() * self.dist() * self.nx()
                + -T::TWO * operand.as_inner().nx() * self.ny() * self.pz()
                + -T::TWO * operand.as_inner().nx() * self.nz() * self.py()
                + -T::TWO * operand.as_inner().nx() * self.pw() * self.px()
                + -T::TWO * operand.as_inner().ny() * self.dist() * self.ny()
                + -T::TWO * operand.as_inner().ny() * self.nz() * self.px()
                + -T::TWO * operand.as_inner().nz() * self.dist() * self.nz()
                + -T::TWO * operand.as_inner().nz() * self.pw() * self.pz()
                + T::TWO * operand.as_inner().ny() * self.nx() * self.pz()
                + T::TWO * operand.as_inner().ny() * self.pw() * self.py()
                + T::TWO * operand.as_inner().nz() * self.nx() * self.py()
                + T::TWO * operand.as_inner().nz() * self.ny() * self.px()
                + operand.as_inner().dist() * self.nx() * self.nx()
                + operand.as_inner().dist() * self.ny() * self.ny()
                + operand.as_inner().dist() * self.nz() * self.nz()
                + operand.as_inner().dist() * self.pw() * self.pw(),
            -(operand.as_inner().nz() * self.nz() * self.nz())
                + -(operand.as_inner().nz() * self.pw() * self.pw())
                + -T::TWO * operand.as_inner().nx() * self.nx() * self.nz()
                + -T::TWO * operand.as_inner().nx() * self.ny() * self.pw()
                + -T::TWO * operand.as_inner().ny() * self.ny() * self.nz()
                + T::TWO * operand.as_inner().ny() * self.nx() * self.pw()
                + operand.as_inner().nz() * self.nx() * self.nx()
                + operand.as_inner().nz() * self.ny() * self.ny(),
            -(operand.as_inner().ny() * self.ny() * self.ny())
                + -(operand.as_inner().ny() * self.pw() * self.pw())
                + -T::TWO * operand.as_inner().nx() * self.nx() * self.ny()
                + -T::TWO * operand.as_inner().nz() * self.nx() * self.pw()
                + -T::TWO * operand.as_inner().nz() * self.ny() * self.nz()
                + T::TWO * operand.as_inner().nx() * self.nz() * self.pw()
                + operand.as_inner().ny() * self.nx() * self.nx()
                + operand.as_inner().ny() * self.nz() * self.nz(),
            -(operand.as_inner().nx() * self.nx() * self.nx())
                + -(operand.as_inner().nx() * self.pw() * self.pw())
                + -T::TWO * operand.as_inner().ny() * self.nx() * self.ny()
                + -T::TWO * operand.as_inner().ny() * self.nz() * self.pw()
                + -T::TWO * operand.as_inner().nz() * self.nx() * self.nz()
                + T::TWO * operand.as_inner().nz() * self.ny() * self.pw()
                + operand.as_inner().nx() * self.ny() * self.ny()
                + operand.as_inner().nx() * self.nz() * self.nz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Plane<T>>> for Unitized<Flector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -T::TWO * operand.as_inner().nx() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.as_inner().nx() * self.as_inner().ny() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().nx() * self.as_inner().nz() * self.as_inner().py()
                + -T::TWO * operand.as_inner().nx() * self.as_inner().pw() * self.as_inner().px()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().dist() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().nz() * self.as_inner().px()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().dist() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().pw() * self.as_inner().pz()
                + T::TWO * operand.as_inner().ny() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.as_inner().ny() * self.as_inner().pw() * self.as_inner().py()
                + T::TWO * operand.as_inner().nz() * self.as_inner().nx() * self.as_inner().py()
                + T::TWO * operand.as_inner().nz() * self.as_inner().ny() * self.as_inner().px()
                + operand.as_inner().dist(),
            -T::TWO * operand.as_inner().nx() * self.as_inner().nx() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().nx() * self.as_inner().ny() * self.as_inner().pw()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().ny() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().pw() * self.as_inner().pw()
                + T::TWO * operand.as_inner().ny() * self.as_inner().nx() * self.as_inner().pw()
                + operand.as_inner().nz(),
            -T::TWO * operand.as_inner().nx() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().pw() * self.as_inner().pw()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().nx() * self.as_inner().pw()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.as_inner().nx() * self.as_inner().nz() * self.as_inner().pw()
                + operand.as_inner().ny(),
            -(operand.as_inner().nx())
                + -T::TWO * operand.as_inner().ny() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().nz() * self.as_inner().pw()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.as_inner().nx() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.as_inner().nx() * self.as_inner().nz() * self.as_inner().nz()
                + T::TWO * operand.as_inner().nz() * self.as_inner().ny() * self.as_inner().pw(),
        )
    }
}
#[doc = "Antisandwich product: [`Flector`] x [`Point`] x antirev([`Flector`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Flector<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.dist() * operand.w() * self.nx()) - self.nx() * operand.w() * self.dist()
                + self.nx() * operand.x() * self.nx()
                - self.nx() * operand.y() * self.ny()
                + self.nx() * operand.z() * self.nz()
                + self.ny() * operand.w() * self.pz()
                - self.ny() * operand.x() * self.ny()
                - self.ny() * operand.y() * self.nx()
                - self.ny() * operand.z() * self.pw()
                + self.nz() * operand.w() * self.py()
                - self.nz() * operand.x() * self.nz()
                - self.nz() * operand.y() * self.pw()
                + self.nz() * operand.z() * self.nx()
                - self.pw() * operand.w() * self.px()
                + self.pw() * operand.x() * self.pw()
                - self.pw() * operand.y() * self.nz()
                - self.pw() * operand.z() * self.ny()
                - self.px() * operand.w() * self.pw()
                + self.py() * operand.w() * self.nz()
                + self.pz() * operand.w() * self.ny(),
            self.dist() * operand.w() * self.ny() + self.nx() * operand.w() * self.pz()
                - self.nx() * operand.x() * self.ny()
                - self.nx() * operand.y() * self.nx()
                - self.nx() * operand.z() * self.pw()
                + self.ny() * operand.w() * self.dist()
                - self.ny() * operand.x() * self.nx()
                + self.ny() * operand.y() * self.ny()
                - self.ny() * operand.z() * self.nz()
                - self.nz() * operand.w() * self.px()
                + self.nz() * operand.x() * self.pw()
                - self.nz() * operand.y() * self.nz()
                - self.nz() * operand.z() * self.ny()
                - self.pw() * operand.w() * self.py()
                + self.pw() * operand.x() * self.nz()
                + self.pw() * operand.y() * self.pw()
                - self.pw() * operand.z() * self.nx()
                - self.px() * operand.w() * self.nz()
                - self.py() * operand.w() * self.pw()
                + self.pz() * operand.w() * self.nx(),
            -(self.dist() * operand.w() * self.nz()) - self.nx() * operand.w() * self.py()
                + self.nx() * operand.x() * self.nz()
                + self.nx() * operand.y() * self.pw()
                - self.nx() * operand.z() * self.nx()
                - self.ny() * operand.w() * self.px()
                + self.ny() * operand.x() * self.pw()
                - self.ny() * operand.y() * self.nz()
                - self.ny() * operand.z() * self.ny()
                - self.nz() * operand.w() * self.dist()
                + self.nz() * operand.x() * self.nx()
                - self.nz() * operand.y() * self.ny()
                + self.nz() * operand.z() * self.nz()
                - self.pw() * operand.w() * self.pz()
                + self.pw() * operand.x() * self.ny()
                + self.pw() * operand.y() * self.nx()
                + self.pw() * operand.z() * self.pw()
                - self.px() * operand.w() * self.ny()
                - self.py() * operand.w() * self.nx()
                - self.pz() * operand.w() * self.pw(),
            -(self.nx() * operand.w() * self.nx())
                - self.ny() * operand.w() * self.ny()
                - self.nz() * operand.w() * self.nz()
                - self.pw() * operand.w() * self.pw(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Unitized<Flector<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -T::TWO * operand.w() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.w() * self.as_inner().pw() * self.as_inner().px()
                + -T::TWO * operand.x() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.x() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.y() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.y() * self.as_inner().nz() * self.as_inner().pw()
                + -T::TWO * operand.z() * self.as_inner().ny() * self.as_inner().pw()
                + T::TWO * operand.w() * self.as_inner().ny() * self.as_inner().pz()
                + T::TWO * operand.w() * self.as_inner().nz() * self.as_inner().py()
                + T::TWO * operand.z() * self.as_inner().nx() * self.as_inner().nz()
                + operand.x(),
            -(operand.y())
                + -T::TWO * operand.w() * self.as_inner().nz() * self.as_inner().px()
                + -T::TWO * operand.w() * self.as_inner().pw() * self.as_inner().py()
                + -T::TWO * operand.x() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.z() * self.as_inner().nx() * self.as_inner().pw()
                + -T::TWO * operand.z() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.w() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.w() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.x() * self.as_inner().nz() * self.as_inner().pw()
                + T::TWO * operand.y() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.y() * self.as_inner().pw() * self.as_inner().pw(),
            -(operand.z())
                + -T::TWO * operand.w() * self.as_inner().dist() * self.as_inner().nz()
                + -T::TWO * operand.w() * self.as_inner().nx() * self.as_inner().py()
                + -T::TWO * operand.w() * self.as_inner().ny() * self.as_inner().px()
                + -T::TWO * operand.w() * self.as_inner().pw() * self.as_inner().pz()
                + -T::TWO * operand.y() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.x() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.x() * self.as_inner().ny() * self.as_inner().pw()
                + T::TWO * operand.y() * self.as_inner().nx() * self.as_inner().pw()
                + T::TWO * operand.z() * self.as_inner().nz() * self.as_inner().nz()
                + T::TWO * operand.z() * self.as_inner().pw() * self.as_inner().pw(),
            -(operand.w()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Point<T>>> for Flector<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x() * self.ny() * self.ny())
                + -(operand.as_inner().x() * self.nz() * self.nz())
                + -T::TWO * operand.as_inner().w() * self.dist() * self.nx()
                + -T::TWO * operand.as_inner().w() * self.pw() * self.px()
                + -T::TWO * operand.as_inner().y() * self.nx() * self.ny()
                + -T::TWO * operand.as_inner().y() * self.nz() * self.pw()
                + -T::TWO * operand.as_inner().z() * self.ny() * self.pw()
                + T::TWO * operand.as_inner().w() * self.ny() * self.pz()
                + T::TWO * operand.as_inner().w() * self.nz() * self.py()
                + T::TWO * operand.as_inner().z() * self.nx() * self.nz()
                + operand.as_inner().x() * self.nx() * self.nx()
                + operand.as_inner().x() * self.pw() * self.pw(),
            -(operand.as_inner().y() * self.nx() * self.nx())
                + -(operand.as_inner().y() * self.nz() * self.nz())
                + -T::TWO * operand.as_inner().w() * self.nz() * self.px()
                + -T::TWO * operand.as_inner().w() * self.pw() * self.py()
                + -T::TWO * operand.as_inner().x() * self.nx() * self.ny()
                + -T::TWO * operand.as_inner().z() * self.nx() * self.pw()
                + -T::TWO * operand.as_inner().z() * self.ny() * self.nz()
                + T::TWO * operand.as_inner().w() * self.dist() * self.ny()
                + T::TWO * operand.as_inner().w() * self.nx() * self.pz()
                + T::TWO * operand.as_inner().x() * self.nz() * self.pw()
                + operand.as_inner().y() * self.ny() * self.ny()
                + operand.as_inner().y() * self.pw() * self.pw(),
            -(operand.as_inner().z() * self.nx() * self.nx())
                + -(operand.as_inner().z() * self.ny() * self.ny())
                + -T::TWO * operand.as_inner().w() * self.dist() * self.nz()
                + -T::TWO * operand.as_inner().w() * self.nx() * self.py()
                + -T::TWO * operand.as_inner().w() * self.ny() * self.px()
                + -T::TWO * operand.as_inner().w() * self.pw() * self.pz()
                + -T::TWO * operand.as_inner().y() * self.ny() * self.nz()
                + T::TWO * operand.as_inner().x() * self.nx() * self.nz()
                + T::TWO * operand.as_inner().x() * self.ny() * self.pw()
                + T::TWO * operand.as_inner().y() * self.nx() * self.pw()
                + operand.as_inner().z() * self.nz() * self.nz()
                + operand.as_inner().z() * self.pw() * self.pw(),
            -(operand.as_inner().w() * self.nx() * self.nx())
                + -(operand.as_inner().w() * self.ny() * self.ny())
                + -(operand.as_inner().w() * self.nz() * self.nz())
                + -(operand.as_inner().w() * self.pw() * self.pw()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Point<T>>> for Unitized<Flector<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -T::TWO * operand.as_inner().w() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.as_inner().w() * self.as_inner().pw() * self.as_inner().px()
                + -T::TWO * operand.as_inner().x() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().x() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().y() * self.as_inner().nz() * self.as_inner().pw()
                + -T::TWO * operand.as_inner().z() * self.as_inner().ny() * self.as_inner().pw()
                + T::TWO * operand.as_inner().w() * self.as_inner().ny() * self.as_inner().pz()
                + T::TWO * operand.as_inner().w() * self.as_inner().nz() * self.as_inner().py()
                + T::TWO * operand.as_inner().z() * self.as_inner().nx() * self.as_inner().nz()
                + operand.as_inner().x(),
            -(operand.as_inner().y())
                + -T::TWO * operand.as_inner().w() * self.as_inner().nz() * self.as_inner().px()
                + -T::TWO * operand.as_inner().w() * self.as_inner().pw() * self.as_inner().py()
                + -T::TWO * operand.as_inner().x() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().z() * self.as_inner().nx() * self.as_inner().pw()
                + -T::TWO * operand.as_inner().z() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.as_inner().w() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.as_inner().w() * self.as_inner().nx() * self.as_inner().pz()
                + T::TWO * operand.as_inner().x() * self.as_inner().nz() * self.as_inner().pw()
                + T::TWO * operand.as_inner().y() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.as_inner().y() * self.as_inner().pw() * self.as_inner().pw(),
            -(operand.as_inner().z())
                + -T::TWO * operand.as_inner().w() * self.as_inner().dist() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().w() * self.as_inner().nx() * self.as_inner().py()
                + -T::TWO * operand.as_inner().w() * self.as_inner().ny() * self.as_inner().px()
                + -T::TWO * operand.as_inner().w() * self.as_inner().pw() * self.as_inner().pz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.as_inner().x() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.as_inner().x() * self.as_inner().ny() * self.as_inner().pw()
                + T::TWO * operand.as_inner().y() * self.as_inner().nx() * self.as_inner().pw()
                + T::TWO * operand.as_inner().z() * self.as_inner().nz() * self.as_inner().nz()
                + T::TWO * operand.as_inner().z() * self.as_inner().pw() * self.as_inner().pw(),
            -(operand.as_inner().w()),
        )
    }
}
#[doc = "Antisandwich product: [`Flector`] x [`Quadvector`] x antirev([`Flector`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Quadvector<T>> for Flector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(self.nx() * operand.ps() * self.nx())
                - self.ny() * operand.ps() * self.ny()
                - self.nz() * operand.ps() * self.nz()
                - self.pw() * operand.ps() * self.pw(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Quadvector<T>> for Unitized<Flector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(-(operand.ps()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Quadvector<T>>> for Flector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(operand.as_inner().ps() * self.nx() * self.nx())
                + -(operand.as_inner().ps() * self.ny() * self.ny())
                + -(operand.as_inner().ps() * self.nz() * self.nz())
                + -(operand.as_inner().ps() * self.pw() * self.pw()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Quadvector<T>>> for Unitized<Flector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(-(operand.as_inner().ps()))
    }
}
#[doc = "Antisandwich product: [`Flector`] x [`Scalar`] x antirev([`Flector`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Flector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.nx() * operand.s() * self.nx()
                + self.ny() * operand.s() * self.ny()
                + self.nz() * operand.s() * self.nz()
                + self.pw() * operand.s() * self.pw(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unitized<Flector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Flector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Unitized<Flector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Antisandwich product: [`Line`] x [`Flector`] x antirev([`Line`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Flector<T>> for Line<T> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            self.dir_x() * operand.nx() * self.moment_x()
                + self.dir_x() * operand.ny() * self.moment_y()
                + self.dir_x() * operand.nz() * self.moment_z()
                + self.dir_x() * operand.px() * self.dir_x()
                + self.dir_x() * operand.py() * self.dir_y()
                + self.dir_x() * operand.pz() * self.dir_z()
                + self.dir_y() * operand.dist() * self.dir_z()
                + self.dir_y() * operand.nx() * self.moment_y()
                - self.dir_y() * operand.ny() * self.moment_x()
                - self.dir_y() * operand.pw() * self.moment_z()
                - self.dir_y() * operand.px() * self.dir_y()
                + self.dir_y() * operand.py() * self.dir_x()
                - self.dir_z() * operand.dist() * self.dir_y()
                - self.dir_z() * operand.nx() * self.moment_z()
                + self.dir_z() * operand.nz() * self.moment_x()
                - self.dir_z() * operand.pw() * self.moment_y()
                - self.dir_z() * operand.px() * self.dir_z()
                + self.dir_z() * operand.pz() * self.dir_x()
                - self.moment_x() * operand.nx() * self.dir_x()
                + self.moment_x() * operand.ny() * self.dir_y()
                - self.moment_x() * operand.nz() * self.dir_z()
                - self.moment_y() * operand.nx() * self.dir_y()
                - self.moment_y() * operand.ny() * self.dir_x()
                - self.moment_y() * operand.pw() * self.dir_z()
                + self.moment_z() * operand.nx() * self.dir_z()
                - self.moment_z() * operand.nz() * self.dir_x()
                - self.moment_z() * operand.pw() * self.dir_y(),
            -(self.dir_x() * operand.dist() * self.dir_z())
                - self.dir_x() * operand.nx() * self.moment_y()
                + self.dir_x() * operand.ny() * self.moment_x()
                + self.dir_x() * operand.pw() * self.moment_z()
                + self.dir_x() * operand.px() * self.dir_y()
                - self.dir_x() * operand.py() * self.dir_x()
                + self.dir_y() * operand.nx() * self.moment_x()
                + self.dir_y() * operand.ny() * self.moment_y()
                + self.dir_y() * operand.nz() * self.moment_z()
                + self.dir_y() * operand.px() * self.dir_x()
                + self.dir_y() * operand.py() * self.dir_y()
                + self.dir_y() * operand.pz() * self.dir_z()
                + self.dir_z() * operand.dist() * self.dir_x()
                + self.dir_z() * operand.ny() * self.moment_z()
                - self.dir_z() * operand.nz() * self.moment_y()
                - self.dir_z() * operand.pw() * self.moment_x()
                - self.dir_z() * operand.py() * self.dir_z()
                + self.dir_z() * operand.pz() * self.dir_y()
                - self.moment_x() * operand.nx() * self.dir_y()
                - self.moment_x() * operand.ny() * self.dir_x()
                - self.moment_x() * operand.pw() * self.dir_z()
                + self.moment_y() * operand.nx() * self.dir_x()
                - self.moment_y() * operand.ny() * self.dir_y()
                + self.moment_y() * operand.nz() * self.dir_z()
                - self.moment_z() * operand.ny() * self.dir_z()
                - self.moment_z() * operand.nz() * self.dir_y()
                + self.moment_z() * operand.pw() * self.dir_x(),
            self.dir_x() * operand.dist() * self.dir_y()
                + self.dir_x() * operand.nx() * self.moment_z()
                - self.dir_x() * operand.nz() * self.moment_x()
                + self.dir_x() * operand.pw() * self.moment_y()
                + self.dir_x() * operand.px() * self.dir_z()
                - self.dir_x() * operand.pz() * self.dir_x()
                - self.dir_y() * operand.dist() * self.dir_x()
                - self.dir_y() * operand.ny() * self.moment_z()
                + self.dir_y() * operand.nz() * self.moment_y()
                + self.dir_y() * operand.pw() * self.moment_x()
                + self.dir_y() * operand.py() * self.dir_z()
                - self.dir_y() * operand.pz() * self.dir_y()
                + self.dir_z() * operand.nx() * self.moment_x()
                + self.dir_z() * operand.ny() * self.moment_y()
                + self.dir_z() * operand.nz() * self.moment_z()
                + self.dir_z() * operand.px() * self.dir_x()
                + self.dir_z() * operand.py() * self.dir_y()
                + self.dir_z() * operand.pz() * self.dir_z()
                - self.moment_x() * operand.nx() * self.dir_z()
                + self.moment_x() * operand.nz() * self.dir_x()
                + self.moment_x() * operand.pw() * self.dir_y()
                - self.moment_y() * operand.ny() * self.dir_z()
                - self.moment_y() * operand.nz() * self.dir_y()
                + self.moment_y() * operand.pw() * self.dir_x()
                - self.moment_z() * operand.nx() * self.dir_x()
                + self.moment_z() * operand.ny() * self.dir_y()
                - self.moment_z() * operand.nz() * self.dir_z(),
            -(self.dir_x() * operand.ny() * self.dir_z())
                - self.dir_x() * operand.nz() * self.dir_y()
                + self.dir_x() * operand.pw() * self.dir_x()
                - self.dir_y() * operand.nx() * self.dir_z()
                + self.dir_y() * operand.nz() * self.dir_x()
                + self.dir_y() * operand.pw() * self.dir_y()
                + self.dir_z() * operand.nx() * self.dir_y()
                + self.dir_z() * operand.ny() * self.dir_x()
                + self.dir_z() * operand.pw() * self.dir_z(),
            self.dir_x() * operand.dist() * self.dir_x()
                + self.dir_x() * operand.ny() * self.moment_z()
                - self.dir_x() * operand.nz() * self.moment_y()
                - self.dir_x() * operand.pw() * self.moment_x()
                - self.dir_x() * operand.py() * self.dir_z()
                + self.dir_x() * operand.pz() * self.dir_y()
                + self.dir_y() * operand.dist() * self.dir_y()
                + self.dir_y() * operand.nx() * self.moment_z()
                - self.dir_y() * operand.nz() * self.moment_x()
                + self.dir_y() * operand.pw() * self.moment_y()
                + self.dir_y() * operand.px() * self.dir_z()
                - self.dir_y() * operand.pz() * self.dir_x()
                + self.dir_z() * operand.dist() * self.dir_z()
                + self.dir_z() * operand.nx() * self.moment_y()
                - self.dir_z() * operand.ny() * self.moment_x()
                - self.dir_z() * operand.pw() * self.moment_z()
                - self.dir_z() * operand.px() * self.dir_y()
                + self.dir_z() * operand.py() * self.dir_x()
                - self.moment_x() * operand.ny() * self.dir_z()
                - self.moment_x() * operand.nz() * self.dir_y()
                + self.moment_x() * operand.pw() * self.dir_x()
                + self.moment_y() * operand.nx() * self.dir_z()
                - self.moment_y() * operand.nz() * self.dir_x()
                - self.moment_y() * operand.pw() * self.dir_y()
                + self.moment_z() * operand.nx() * self.dir_y()
                + self.moment_z() * operand.ny() * self.dir_x()
                + self.moment_z() * operand.pw() * self.dir_z(),
            self.dir_x() * operand.nx() * self.dir_z()
                - self.dir_x() * operand.nz() * self.dir_x()
                - self.dir_x() * operand.pw() * self.dir_y()
                - self.dir_y() * operand.ny() * self.dir_z()
                - self.dir_y() * operand.nz() * self.dir_y()
                + self.dir_y() * operand.pw() * self.dir_x()
                + self.dir_z() * operand.nx() * self.dir_x()
                - self.dir_z() * operand.ny() * self.dir_y()
                + self.dir_z() * operand.nz() * self.dir_z(),
            -(self.dir_x() * operand.nx() * self.dir_y())
                - self.dir_x() * operand.ny() * self.dir_x()
                - self.dir_x() * operand.pw() * self.dir_z()
                - self.dir_y() * operand.nx() * self.dir_x()
                + self.dir_y() * operand.ny() * self.dir_y()
                - self.dir_y() * operand.nz() * self.dir_z()
                - self.dir_z() * operand.ny() * self.dir_z()
                - self.dir_z() * operand.nz() * self.dir_y()
                + self.dir_z() * operand.pw() * self.dir_x(),
            self.dir_x() * operand.nx() * self.dir_x() - self.dir_x() * operand.ny() * self.dir_y()
                + self.dir_x() * operand.nz() * self.dir_z()
                - self.dir_y() * operand.nx() * self.dir_y()
                - self.dir_y() * operand.ny() * self.dir_x()
                - self.dir_y() * operand.pw() * self.dir_z()
                - self.dir_z() * operand.nx() * self.dir_z()
                + self.dir_z() * operand.nz() * self.dir_x()
                + self.dir_z() * operand.pw() * self.dir_y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Flector<T>> for Unitized<Line<T>> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            -(operand.px())
                + -T::TWO * operand.pw() * self.as_inner().dir_y() * self.as_inner().moment_z()
                + -T::TWO * operand.pw() * self.as_inner().dir_z() * self.as_inner().moment_y()
                + T::TWO * operand.px() * self.as_inner().dir_x() * self.as_inner().dir_x()
                + T::TWO * operand.py() * self.as_inner().dir_x() * self.as_inner().dir_y()
                + T::TWO * operand.pz() * self.as_inner().dir_x() * self.as_inner().dir_z(),
            -(operand.py())
                + -T::TWO * operand.pw() * self.as_inner().dir_z() * self.as_inner().moment_x()
                + T::TWO * operand.pw() * self.as_inner().dir_x() * self.as_inner().moment_z()
                + T::TWO * operand.px() * self.as_inner().dir_x() * self.as_inner().dir_y()
                + T::TWO * operand.py() * self.as_inner().dir_y() * self.as_inner().dir_y()
                + T::TWO * operand.pz() * self.as_inner().dir_y() * self.as_inner().dir_z(),
            -T::TWO * operand.pz() * self.as_inner().dir_x() * self.as_inner().dir_x()
                + -T::TWO * operand.pz() * self.as_inner().dir_y() * self.as_inner().dir_y()
                + T::TWO * operand.pw() * self.as_inner().dir_x() * self.as_inner().moment_y()
                + T::TWO * operand.pw() * self.as_inner().dir_y() * self.as_inner().moment_x()
                + T::TWO * operand.px() * self.as_inner().dir_x() * self.as_inner().dir_z()
                + T::TWO * operand.py() * self.as_inner().dir_y() * self.as_inner().dir_z()
                + operand.pz(),
            operand.pw(),
            -T::TWO * operand.ny() * self.as_inner().dir_z() * self.as_inner().moment_x()
                + -T::TWO * operand.nz() * self.as_inner().dir_x() * self.as_inner().moment_y()
                + -T::TWO * operand.nz() * self.as_inner().dir_y() * self.as_inner().moment_x()
                + T::TWO * operand.nx() * self.as_inner().dir_y() * self.as_inner().moment_z()
                + T::TWO * operand.nx() * self.as_inner().dir_z() * self.as_inner().moment_y()
                + T::TWO * operand.ny() * self.as_inner().dir_x() * self.as_inner().moment_z()
                + operand.dist(),
            -T::TWO * operand.ny() * self.as_inner().dir_y() * self.as_inner().dir_z()
                + -T::TWO * operand.nz() * self.as_inner().dir_x() * self.as_inner().dir_x()
                + -T::TWO * operand.nz() * self.as_inner().dir_y() * self.as_inner().dir_y()
                + T::TWO * operand.nx() * self.as_inner().dir_x() * self.as_inner().dir_z()
                + operand.nz(),
            -(operand.ny())
                + -T::TWO * operand.nx() * self.as_inner().dir_x() * self.as_inner().dir_y()
                + -T::TWO * operand.nz() * self.as_inner().dir_y() * self.as_inner().dir_z()
                + T::TWO * operand.ny() * self.as_inner().dir_y() * self.as_inner().dir_y(),
            -(operand.nx())
                + -T::TWO * operand.ny() * self.as_inner().dir_x() * self.as_inner().dir_y()
                + T::TWO * operand.nx() * self.as_inner().dir_x() * self.as_inner().dir_x()
                + T::TWO * operand.nz() * self.as_inner().dir_x() * self.as_inner().dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Flector<T>>> for Line<T> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            -(operand.as_inner().px() * self.dir_y() * self.dir_y())
                + -(operand.as_inner().px() * self.dir_z() * self.dir_z())
                + -T::TWO * operand.as_inner().pw() * self.dir_y() * self.moment_z()
                + -T::TWO * operand.as_inner().pw() * self.dir_z() * self.moment_y()
                + T::TWO * operand.as_inner().py() * self.dir_x() * self.dir_y()
                + T::TWO * operand.as_inner().pz() * self.dir_x() * self.dir_z()
                + operand.as_inner().px() * self.dir_x() * self.dir_x(),
            -(operand.as_inner().py() * self.dir_x() * self.dir_x())
                + -(operand.as_inner().py() * self.dir_z() * self.dir_z())
                + -T::TWO * operand.as_inner().pw() * self.dir_z() * self.moment_x()
                + T::TWO * operand.as_inner().pw() * self.dir_x() * self.moment_z()
                + T::TWO * operand.as_inner().px() * self.dir_x() * self.dir_y()
                + T::TWO * operand.as_inner().pz() * self.dir_y() * self.dir_z()
                + operand.as_inner().py() * self.dir_y() * self.dir_y(),
            -(operand.as_inner().pz() * self.dir_x() * self.dir_x())
                + -(operand.as_inner().pz() * self.dir_y() * self.dir_y())
                + T::TWO * operand.as_inner().pw() * self.dir_x() * self.moment_y()
                + T::TWO * operand.as_inner().pw() * self.dir_y() * self.moment_x()
                + T::TWO * operand.as_inner().px() * self.dir_x() * self.dir_z()
                + T::TWO * operand.as_inner().py() * self.dir_y() * self.dir_z()
                + operand.as_inner().pz() * self.dir_z() * self.dir_z(),
            operand.as_inner().pw() * self.dir_x() * self.dir_x()
                + operand.as_inner().pw() * self.dir_y() * self.dir_y()
                + operand.as_inner().pw() * self.dir_z() * self.dir_z(),
            -T::TWO * operand.as_inner().ny() * self.dir_z() * self.moment_x()
                + -T::TWO * operand.as_inner().nz() * self.dir_x() * self.moment_y()
                + -T::TWO * operand.as_inner().nz() * self.dir_y() * self.moment_x()
                + T::TWO * operand.as_inner().nx() * self.dir_y() * self.moment_z()
                + T::TWO * operand.as_inner().nx() * self.dir_z() * self.moment_y()
                + T::TWO * operand.as_inner().ny() * self.dir_x() * self.moment_z()
                + operand.as_inner().dist() * self.dir_x() * self.dir_x()
                + operand.as_inner().dist() * self.dir_y() * self.dir_y()
                + operand.as_inner().dist() * self.dir_z() * self.dir_z(),
            -(operand.as_inner().nz() * self.dir_x() * self.dir_x())
                + -(operand.as_inner().nz() * self.dir_y() * self.dir_y())
                + -T::TWO * operand.as_inner().ny() * self.dir_y() * self.dir_z()
                + T::TWO * operand.as_inner().nx() * self.dir_x() * self.dir_z()
                + operand.as_inner().nz() * self.dir_z() * self.dir_z(),
            -(operand.as_inner().ny() * self.dir_x() * self.dir_x())
                + -(operand.as_inner().ny() * self.dir_z() * self.dir_z())
                + -T::TWO * operand.as_inner().nx() * self.dir_x() * self.dir_y()
                + -T::TWO * operand.as_inner().nz() * self.dir_y() * self.dir_z()
                + operand.as_inner().ny() * self.dir_y() * self.dir_y(),
            -(operand.as_inner().nx() * self.dir_y() * self.dir_y())
                + -(operand.as_inner().nx() * self.dir_z() * self.dir_z())
                + -T::TWO * operand.as_inner().ny() * self.dir_x() * self.dir_y()
                + T::TWO * operand.as_inner().nz() * self.dir_x() * self.dir_z()
                + operand.as_inner().nx() * self.dir_x() * self.dir_x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Flector<T>>> for Unitized<Line<T>> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            -(operand.as_inner().px())
                + -T::TWO
                    * operand.as_inner().pw()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_z()
                + -T::TWO
                    * operand.as_inner().pw()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().px()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_x()
                + T::TWO
                    * operand.as_inner().py()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().pz()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_z(),
            -(operand.as_inner().py())
                + -T::TWO
                    * operand.as_inner().pw()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().pw()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().px()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().py()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().pz()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_z(),
            -T::TWO * operand.as_inner().pz() * self.as_inner().dir_x() * self.as_inner().dir_x()
                + -T::TWO
                    * operand.as_inner().pz()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().pw()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().pw()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().px()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_z()
                + T::TWO
                    * operand.as_inner().py()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_z()
                + operand.as_inner().pz(),
            operand.as_inner().pw(),
            -T::TWO
                * operand.as_inner().ny()
                * self.as_inner().dir_z()
                * self.as_inner().moment_x()
                + -T::TWO
                    * operand.as_inner().nz()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_y()
                + -T::TWO
                    * operand.as_inner().nz()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().nx()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().nx()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().ny()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_z()
                + operand.as_inner().dist(),
            -T::TWO * operand.as_inner().ny() * self.as_inner().dir_y() * self.as_inner().dir_z()
                + -T::TWO
                    * operand.as_inner().nz()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_x()
                + -T::TWO
                    * operand.as_inner().nz()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().nx()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_z()
                + operand.as_inner().nz(),
            -(operand.as_inner().ny())
                + -T::TWO
                    * operand.as_inner().nx()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_y()
                + -T::TWO
                    * operand.as_inner().nz()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_z()
                + T::TWO
                    * operand.as_inner().ny()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_y(),
            -(operand.as_inner().nx())
                + -T::TWO
                    * operand.as_inner().ny()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().nx()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_x()
                + T::TWO
                    * operand.as_inner().nz()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_z(),
        )
    }
}
#[doc = "Antisandwich product: [`Line`] x [`Line`] x antirev([`Line`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.dir_x() * operand.dir_x() * self.moment_z()
                - self.dir_x() * operand.dir_z() * self.moment_x()
                + self.dir_x() * operand.moment_x() * self.dir_z()
                - self.dir_x() * operand.moment_z() * self.dir_x()
                + self.dir_y() * operand.dir_y() * self.moment_z()
                + self.dir_y() * operand.dir_z() * self.moment_y()
                - self.dir_y() * operand.moment_y() * self.dir_z()
                - self.dir_y() * operand.moment_z() * self.dir_y()
                + self.dir_z() * operand.dir_x() * self.moment_x()
                - self.dir_z() * operand.dir_y() * self.moment_y()
                + self.dir_z() * operand.dir_z() * self.moment_z()
                + self.dir_z() * operand.moment_x() * self.dir_x()
                - self.dir_z() * operand.moment_y() * self.dir_y()
                + self.dir_z() * operand.moment_z() * self.dir_z()
                + self.moment_x() * operand.dir_x() * self.dir_z()
                - self.moment_x() * operand.dir_z() * self.dir_x()
                - self.moment_y() * operand.dir_y() * self.dir_z()
                + self.moment_y() * operand.dir_z() * self.dir_y()
                + self.moment_z() * operand.dir_x() * self.dir_x()
                + self.moment_z() * operand.dir_y() * self.dir_y()
                + self.moment_z() * operand.dir_z() * self.dir_z(),
            self.dir_x() * operand.dir_x() * self.moment_y()
                + self.dir_x() * operand.dir_y() * self.moment_x()
                - self.dir_x() * operand.moment_x() * self.dir_y()
                - self.dir_x() * operand.moment_y() * self.dir_x()
                - self.dir_y() * operand.dir_x() * self.moment_x()
                + self.dir_y() * operand.dir_y() * self.moment_y()
                - self.dir_y() * operand.dir_z() * self.moment_z()
                - self.dir_y() * operand.moment_x() * self.dir_x()
                + self.dir_y() * operand.moment_y() * self.dir_y()
                - self.dir_y() * operand.moment_z() * self.dir_z()
                + self.dir_z() * operand.dir_y() * self.moment_z()
                + self.dir_z() * operand.dir_z() * self.moment_y()
                - self.dir_z() * operand.moment_y() * self.dir_z()
                - self.dir_z() * operand.moment_z() * self.dir_y()
                - self.moment_x() * operand.dir_x() * self.dir_y()
                + self.moment_x() * operand.dir_y() * self.dir_x()
                + self.moment_y() * operand.dir_x() * self.dir_x()
                + self.moment_y() * operand.dir_y() * self.dir_y()
                + self.moment_y() * operand.dir_z() * self.dir_z()
                + self.moment_z() * operand.dir_y() * self.dir_z()
                - self.moment_z() * operand.dir_z() * self.dir_y(),
            self.dir_x() * operand.dir_x() * self.dir_x()
                + self.dir_x() * operand.dir_y() * self.dir_y()
                + self.dir_x() * operand.dir_z() * self.dir_z()
                - self.dir_y() * operand.dir_x() * self.dir_y()
                + self.dir_y() * operand.dir_y() * self.dir_x()
                - self.dir_z() * operand.dir_x() * self.dir_z()
                + self.dir_z() * operand.dir_z() * self.dir_x(),
            self.dir_x() * operand.dir_x() * self.moment_x()
                - self.dir_x() * operand.dir_y() * self.moment_y()
                + self.dir_x() * operand.dir_z() * self.moment_z()
                + self.dir_x() * operand.moment_x() * self.dir_x()
                - self.dir_x() * operand.moment_y() * self.dir_y()
                + self.dir_x() * operand.moment_z() * self.dir_z()
                + self.dir_y() * operand.dir_x() * self.moment_y()
                + self.dir_y() * operand.dir_y() * self.moment_x()
                - self.dir_y() * operand.moment_x() * self.dir_y()
                - self.dir_y() * operand.moment_y() * self.dir_x()
                - self.dir_z() * operand.dir_x() * self.moment_z()
                + self.dir_z() * operand.dir_z() * self.moment_x()
                - self.dir_z() * operand.moment_x() * self.dir_z()
                + self.dir_z() * operand.moment_z() * self.dir_x()
                + self.moment_x() * operand.dir_x() * self.dir_x()
                + self.moment_x() * operand.dir_y() * self.dir_y()
                + self.moment_x() * operand.dir_z() * self.dir_z()
                + self.moment_y() * operand.dir_x() * self.dir_y()
                - self.moment_y() * operand.dir_y() * self.dir_x()
                - self.moment_z() * operand.dir_x() * self.dir_z()
                + self.moment_z() * operand.dir_z() * self.dir_x(),
            self.dir_x() * operand.dir_x() * self.dir_y()
                - self.dir_x() * operand.dir_y() * self.dir_x()
                + self.dir_y() * operand.dir_x() * self.dir_x()
                + self.dir_y() * operand.dir_y() * self.dir_y()
                + self.dir_y() * operand.dir_z() * self.dir_z()
                - self.dir_z() * operand.dir_y() * self.dir_z()
                + self.dir_z() * operand.dir_z() * self.dir_y(),
            self.dir_x() * operand.dir_x() * self.dir_z()
                - self.dir_x() * operand.dir_z() * self.dir_x()
                + self.dir_y() * operand.dir_y() * self.dir_z()
                - self.dir_y() * operand.dir_z() * self.dir_y()
                + self.dir_z() * operand.dir_x() * self.dir_x()
                + self.dir_z() * operand.dir_y() * self.dir_y()
                + self.dir_z() * operand.dir_z() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            -T::TWO * operand.dir_y() * self.as_inner().dir_z() * self.as_inner().moment_y()
                + -T::TWO * operand.moment_y() * self.as_inner().dir_y() * self.as_inner().dir_z()
                + -T::TWO * operand.moment_z() * self.as_inner().dir_x() * self.as_inner().dir_x()
                + -T::TWO * operand.moment_z() * self.as_inner().dir_y() * self.as_inner().dir_y()
                + T::TWO * operand.dir_x() * self.as_inner().dir_x() * self.as_inner().moment_z()
                + T::TWO * operand.dir_x() * self.as_inner().dir_z() * self.as_inner().moment_x()
                + T::TWO * operand.dir_y() * self.as_inner().dir_y() * self.as_inner().moment_z()
                + T::TWO * operand.moment_x() * self.as_inner().dir_x() * self.as_inner().dir_z()
                + T::from_i8(-4i8)
                    * operand.dir_z()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_x()
                + T::from_i8(4i8)
                    * operand.dir_z()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_y()
                + operand.moment_z(),
            -(operand.moment_y())
                + -T::TWO * operand.dir_x() * self.as_inner().dir_y() * self.as_inner().moment_x()
                + -T::TWO * operand.dir_z() * self.as_inner().dir_y() * self.as_inner().moment_z()
                + -T::TWO * operand.moment_x() * self.as_inner().dir_x() * self.as_inner().dir_y()
                + -T::TWO * operand.moment_z() * self.as_inner().dir_y() * self.as_inner().dir_z()
                + T::TWO * operand.dir_x() * self.as_inner().dir_x() * self.as_inner().moment_y()
                + T::TWO * operand.dir_z() * self.as_inner().dir_z() * self.as_inner().moment_y()
                + T::TWO * operand.moment_y() * self.as_inner().dir_y() * self.as_inner().dir_y()
                + T::from_i8(4i8)
                    * operand.dir_y()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_y(),
            -(operand.dir_x())
                + T::TWO * operand.dir_x() * self.as_inner().dir_x() * self.as_inner().dir_x()
                + T::TWO * operand.dir_y() * self.as_inner().dir_x() * self.as_inner().dir_y()
                + T::TWO * operand.dir_z() * self.as_inner().dir_x() * self.as_inner().dir_z(),
            -(operand.moment_x())
                + -T::TWO * operand.dir_y() * self.as_inner().dir_x() * self.as_inner().moment_y()
                + -T::TWO * operand.moment_y() * self.as_inner().dir_x() * self.as_inner().dir_y()
                + T::TWO * operand.dir_y() * self.as_inner().dir_y() * self.as_inner().moment_x()
                + T::TWO * operand.dir_z() * self.as_inner().dir_x() * self.as_inner().moment_z()
                + T::TWO * operand.dir_z() * self.as_inner().dir_z() * self.as_inner().moment_x()
                + T::TWO * operand.moment_x() * self.as_inner().dir_x() * self.as_inner().dir_x()
                + T::TWO * operand.moment_z() * self.as_inner().dir_x() * self.as_inner().dir_z()
                + T::from_i8(4i8)
                    * operand.dir_x()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_x(),
            -(operand.dir_y())
                + T::TWO * operand.dir_x() * self.as_inner().dir_x() * self.as_inner().dir_y()
                + T::TWO * operand.dir_y() * self.as_inner().dir_y() * self.as_inner().dir_y()
                + T::TWO * operand.dir_z() * self.as_inner().dir_y() * self.as_inner().dir_z(),
            -T::TWO * operand.dir_z() * self.as_inner().dir_x() * self.as_inner().dir_x()
                + -T::TWO * operand.dir_z() * self.as_inner().dir_y() * self.as_inner().dir_y()
                + T::TWO * operand.dir_x() * self.as_inner().dir_x() * self.as_inner().dir_z()
                + T::TWO * operand.dir_y() * self.as_inner().dir_y() * self.as_inner().dir_z()
                + operand.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Line<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(operand.as_inner().moment_z() * self.dir_x() * self.dir_x())
                + -(operand.as_inner().moment_z() * self.dir_y() * self.dir_y())
                + -T::TWO * operand.as_inner().dir_y() * self.dir_z() * self.moment_y()
                + -T::TWO * operand.as_inner().moment_y() * self.dir_y() * self.dir_z()
                + T::TWO * operand.as_inner().dir_x() * self.dir_x() * self.moment_z()
                + T::TWO * operand.as_inner().dir_x() * self.dir_z() * self.moment_x()
                + T::TWO * operand.as_inner().dir_y() * self.dir_y() * self.moment_z()
                + T::TWO * operand.as_inner().moment_x() * self.dir_x() * self.dir_z()
                + T::from_i8(-4i8) * operand.as_inner().dir_z() * self.dir_x() * self.moment_x()
                + T::from_i8(4i8) * operand.as_inner().dir_z() * self.dir_y() * self.moment_y()
                + operand.as_inner().moment_z() * self.dir_z() * self.dir_z(),
            -(operand.as_inner().moment_y() * self.dir_x() * self.dir_x())
                + -(operand.as_inner().moment_y() * self.dir_z() * self.dir_z())
                + -T::TWO * operand.as_inner().dir_x() * self.dir_y() * self.moment_x()
                + -T::TWO * operand.as_inner().dir_z() * self.dir_y() * self.moment_z()
                + -T::TWO * operand.as_inner().moment_x() * self.dir_x() * self.dir_y()
                + -T::TWO * operand.as_inner().moment_z() * self.dir_y() * self.dir_z()
                + T::TWO * operand.as_inner().dir_x() * self.dir_x() * self.moment_y()
                + T::TWO * operand.as_inner().dir_z() * self.dir_z() * self.moment_y()
                + T::from_i8(4i8) * operand.as_inner().dir_y() * self.dir_y() * self.moment_y()
                + operand.as_inner().moment_y() * self.dir_y() * self.dir_y(),
            -(operand.as_inner().dir_x() * self.dir_y() * self.dir_y())
                + -(operand.as_inner().dir_x() * self.dir_z() * self.dir_z())
                + T::TWO * operand.as_inner().dir_y() * self.dir_x() * self.dir_y()
                + T::TWO * operand.as_inner().dir_z() * self.dir_x() * self.dir_z()
                + operand.as_inner().dir_x() * self.dir_x() * self.dir_x(),
            -(operand.as_inner().moment_x() * self.dir_y() * self.dir_y())
                + -(operand.as_inner().moment_x() * self.dir_z() * self.dir_z())
                + -T::TWO * operand.as_inner().dir_y() * self.dir_x() * self.moment_y()
                + -T::TWO * operand.as_inner().moment_y() * self.dir_x() * self.dir_y()
                + T::TWO * operand.as_inner().dir_y() * self.dir_y() * self.moment_x()
                + T::TWO * operand.as_inner().dir_z() * self.dir_x() * self.moment_z()
                + T::TWO * operand.as_inner().dir_z() * self.dir_z() * self.moment_x()
                + T::TWO * operand.as_inner().moment_z() * self.dir_x() * self.dir_z()
                + T::from_i8(4i8) * operand.as_inner().dir_x() * self.dir_x() * self.moment_x()
                + operand.as_inner().moment_x() * self.dir_x() * self.dir_x(),
            -(operand.as_inner().dir_y() * self.dir_x() * self.dir_x())
                + -(operand.as_inner().dir_y() * self.dir_z() * self.dir_z())
                + T::TWO * operand.as_inner().dir_x() * self.dir_x() * self.dir_y()
                + T::TWO * operand.as_inner().dir_z() * self.dir_y() * self.dir_z()
                + operand.as_inner().dir_y() * self.dir_y() * self.dir_y(),
            -(operand.as_inner().dir_z() * self.dir_x() * self.dir_x())
                + -(operand.as_inner().dir_z() * self.dir_y() * self.dir_y())
                + T::TWO * operand.as_inner().dir_x() * self.dir_x() * self.dir_z()
                + T::TWO * operand.as_inner().dir_y() * self.dir_y() * self.dir_z()
                + operand.as_inner().dir_z() * self.dir_z() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Line<T>>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -T::TWO
                * operand.as_inner().dir_y()
                * self.as_inner().dir_z()
                * self.as_inner().moment_y()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_z()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_x()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_z()
                + T::from_i8(-4i8)
                    * operand.as_inner().dir_z()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_x()
                + T::from_i8(4i8)
                    * operand.as_inner().dir_z()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_y()
                + operand.as_inner().moment_z(),
            -(operand.as_inner().moment_y())
                + -T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_x()
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_z()
                + -T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_y()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_z()
                + T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_y()
                + T::from_i8(4i8)
                    * operand.as_inner().dir_y()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_y(),
            -(operand.as_inner().dir_x())
                + T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_x()
                + T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_z(),
            -(operand.as_inner().moment_x())
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_y()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_x()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_z()
                + T::from_i8(4i8)
                    * operand.as_inner().dir_x()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_x(),
            -(operand.as_inner().dir_y())
                + T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_z(),
            -T::TWO
                * operand.as_inner().dir_z()
                * self.as_inner().dir_x()
                * self.as_inner().dir_x()
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_z()
                + T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_z()
                + operand.as_inner().dir_z(),
        )
    }
}
#[doc = "Antisandwich product: [`Line`] x [`Motor`] x antirev([`Line`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Motor<T>> for Line<T> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            -(self.dir_x() * operand.ps() * self.moment_x())
                + self.dir_x() * operand.ry() * self.moment_z()
                + self.dir_x() * operand.rz() * self.moment_y()
                + self.dir_x() * operand.s() * self.dir_x()
                - self.dir_x() * operand.ty() * self.dir_z()
                - self.dir_x() * operand.tz() * self.dir_y()
                + self.dir_y() * operand.ps() * self.moment_y()
                - self.dir_y() * operand.rx() * self.dir_z()
                + self.dir_y() * operand.rz() * self.moment_x()
                + self.dir_y() * operand.s() * self.dir_y()
                - self.dir_y() * operand.tx() * self.moment_z()
                + self.dir_y() * operand.tz() * self.dir_x()
                - self.dir_z() * operand.ps() * self.moment_z()
                + self.dir_z() * operand.rx() * self.dir_y()
                - self.dir_z() * operand.ry() * self.moment_x()
                + self.dir_z() * operand.s() * self.dir_z()
                - self.dir_z() * operand.tx() * self.moment_y()
                + self.dir_z() * operand.ty() * self.dir_x()
                - self.moment_x() * operand.ps() * self.dir_x()
                + self.moment_x() * operand.ry() * self.dir_z()
                - self.moment_x() * operand.rz() * self.dir_y()
                + self.moment_y() * operand.ps() * self.dir_y()
                - self.moment_y() * operand.rz() * self.dir_x()
                + self.moment_y() * operand.tx() * self.dir_z()
                - self.moment_z() * operand.ps() * self.dir_z()
                - self.moment_z() * operand.ry() * self.dir_x()
                + self.moment_z() * operand.tx() * self.dir_y(),
            -(self.dir_x() * operand.ps() * self.moment_y())
                + self.dir_x() * operand.rx() * self.dir_z()
                - self.dir_x() * operand.rz() * self.moment_x()
                - self.dir_x() * operand.s() * self.dir_y()
                + self.dir_x() * operand.tx() * self.moment_z()
                - self.dir_x() * operand.tz() * self.dir_x()
                - self.dir_y() * operand.ps() * self.moment_x()
                + self.dir_y() * operand.ry() * self.moment_z()
                + self.dir_y() * operand.rz() * self.moment_y()
                + self.dir_y() * operand.s() * self.dir_x()
                - self.dir_y() * operand.ty() * self.dir_z()
                - self.dir_y() * operand.tz() * self.dir_y()
                + self.dir_z() * operand.rx() * self.dir_x()
                - self.dir_z() * operand.ry() * self.moment_y()
                + self.dir_z() * operand.rz() * self.moment_z()
                + self.dir_z() * operand.tx() * self.moment_x()
                - self.dir_z() * operand.ty() * self.dir_y()
                + self.dir_z() * operand.tz() * self.dir_z()
                + self.moment_x() * operand.ps() * self.dir_y()
                - self.moment_x() * operand.rz() * self.dir_x()
                + self.moment_x() * operand.tx() * self.dir_z()
                + self.moment_y() * operand.ps() * self.dir_x()
                - self.moment_y() * operand.ry() * self.dir_z()
                + self.moment_y() * operand.rz() * self.dir_y()
                + self.moment_z() * operand.ry() * self.dir_y()
                + self.moment_z() * operand.rz() * self.dir_z()
                + self.moment_z() * operand.tx() * self.dir_x(),
            self.dir_x() * operand.ps() * self.moment_z()
                - self.dir_x() * operand.rx() * self.dir_y()
                + self.dir_x() * operand.ry() * self.moment_x()
                - self.dir_x() * operand.s() * self.dir_z()
                + self.dir_x() * operand.tx() * self.moment_y()
                - self.dir_x() * operand.ty() * self.dir_x()
                - self.dir_y() * operand.rx() * self.dir_x()
                + self.dir_y() * operand.ry() * self.moment_y()
                - self.dir_y() * operand.rz() * self.moment_z()
                - self.dir_y() * operand.tx() * self.moment_x()
                + self.dir_y() * operand.ty() * self.dir_y()
                - self.dir_y() * operand.tz() * self.dir_z()
                - self.dir_z() * operand.ps() * self.moment_x()
                + self.dir_z() * operand.ry() * self.moment_z()
                + self.dir_z() * operand.rz() * self.moment_y()
                + self.dir_z() * operand.s() * self.dir_x()
                - self.dir_z() * operand.ty() * self.dir_z()
                - self.dir_z() * operand.tz() * self.dir_y()
                + self.moment_x() * operand.ps() * self.dir_z()
                + self.moment_x() * operand.ry() * self.dir_x()
                - self.moment_x() * operand.tx() * self.dir_y()
                + self.moment_y() * operand.ry() * self.dir_y()
                + self.moment_y() * operand.rz() * self.dir_z()
                + self.moment_y() * operand.tx() * self.dir_x()
                - self.moment_z() * operand.ps() * self.dir_x()
                + self.moment_z() * operand.ry() * self.dir_z()
                - self.moment_z() * operand.rz() * self.dir_y(),
            self.dir_x() * operand.ry() * self.dir_y()
                + self.dir_x() * operand.rz() * self.dir_z()
                + self.dir_x() * operand.tx() * self.dir_x()
                + self.dir_y() * operand.ps() * self.dir_z()
                + self.dir_y() * operand.ry() * self.dir_x()
                - self.dir_y() * operand.tx() * self.dir_y()
                - self.dir_z() * operand.ps() * self.dir_y()
                + self.dir_z() * operand.rz() * self.dir_x()
                - self.dir_z() * operand.tx() * self.dir_z(),
            self.dir_x() * operand.rx() * self.dir_x()
                - self.dir_x() * operand.ry() * self.moment_y()
                + self.dir_x() * operand.rz() * self.moment_z()
                + self.dir_x() * operand.tx() * self.moment_x()
                - self.dir_x() * operand.ty() * self.dir_y()
                + self.dir_x() * operand.tz() * self.dir_z()
                + self.dir_y() * operand.ps() * self.moment_z()
                - self.dir_y() * operand.rx() * self.dir_y()
                + self.dir_y() * operand.ry() * self.moment_x()
                - self.dir_y() * operand.s() * self.dir_z()
                + self.dir_y() * operand.tx() * self.moment_y()
                - self.dir_y() * operand.ty() * self.dir_x()
                + self.dir_z() * operand.ps() * self.moment_y()
                - self.dir_z() * operand.rx() * self.dir_z()
                + self.dir_z() * operand.rz() * self.moment_x()
                + self.dir_z() * operand.s() * self.dir_y()
                - self.dir_z() * operand.tx() * self.moment_z()
                + self.dir_z() * operand.tz() * self.dir_x()
                + self.moment_x() * operand.ry() * self.dir_y()
                + self.moment_x() * operand.rz() * self.dir_z()
                + self.moment_x() * operand.tx() * self.dir_x()
                - self.moment_y() * operand.ps() * self.dir_z()
                - self.moment_y() * operand.ry() * self.dir_x()
                + self.moment_y() * operand.tx() * self.dir_y()
                - self.moment_z() * operand.ps() * self.dir_y()
                + self.moment_z() * operand.rz() * self.dir_x()
                - self.moment_z() * operand.tx() * self.dir_z(),
            -(self.dir_x() * operand.ps() * self.dir_z())
                - self.dir_x() * operand.ry() * self.dir_x()
                + self.dir_x() * operand.tx() * self.dir_y()
                + self.dir_y() * operand.ry() * self.dir_y()
                + self.dir_y() * operand.rz() * self.dir_z()
                + self.dir_y() * operand.tx() * self.dir_x()
                + self.dir_z() * operand.ps() * self.dir_x()
                - self.dir_z() * operand.ry() * self.dir_z()
                + self.dir_z() * operand.rz() * self.dir_y(),
            self.dir_x() * operand.ps() * self.dir_y() - self.dir_x() * operand.rz() * self.dir_x()
                + self.dir_x() * operand.tx() * self.dir_z()
                - self.dir_y() * operand.ps() * self.dir_x()
                + self.dir_y() * operand.ry() * self.dir_z()
                - self.dir_y() * operand.rz() * self.dir_y()
                + self.dir_z() * operand.ry() * self.dir_y()
                + self.dir_z() * operand.rz() * self.dir_z()
                + self.dir_z() * operand.tx() * self.dir_x(),
            self.dir_x() * operand.ps() * self.dir_x() - self.dir_x() * operand.ry() * self.dir_z()
                + self.dir_x() * operand.rz() * self.dir_y()
                + self.dir_y() * operand.ps() * self.dir_y()
                - self.dir_y() * operand.rz() * self.dir_x()
                + self.dir_y() * operand.tx() * self.dir_z()
                + self.dir_z() * operand.ps() * self.dir_z()
                + self.dir_z() * operand.ry() * self.dir_x()
                - self.dir_z() * operand.tx() * self.dir_y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Motor<T>> for Unitized<Line<T>> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            operand.s(),
            -T::TWO * operand.ry() * self.as_inner().dir_z() * self.as_inner().moment_y()
                + -T::TWO * operand.ty() * self.as_inner().dir_y() * self.as_inner().dir_z()
                + -T::TWO * operand.tz() * self.as_inner().dir_x() * self.as_inner().dir_x()
                + -T::TWO * operand.tz() * self.as_inner().dir_y() * self.as_inner().dir_y()
                + T::TWO * operand.rx() * self.as_inner().dir_x() * self.as_inner().dir_z()
                + T::TWO * operand.ry() * self.as_inner().dir_y() * self.as_inner().moment_z()
                + T::TWO * operand.tx() * self.as_inner().dir_x() * self.as_inner().moment_z()
                + T::TWO * operand.tx() * self.as_inner().dir_z() * self.as_inner().moment_x()
                + T::from_i8(-4i8)
                    * operand.rz()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_x()
                + T::from_i8(4i8)
                    * operand.rz()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_y()
                + operand.tz(),
            -(operand.ty())
                + -T::TWO * operand.rx() * self.as_inner().dir_x() * self.as_inner().dir_y()
                + -T::TWO * operand.rz() * self.as_inner().dir_y() * self.as_inner().moment_z()
                + -T::TWO * operand.tx() * self.as_inner().dir_y() * self.as_inner().moment_x()
                + -T::TWO * operand.tz() * self.as_inner().dir_y() * self.as_inner().dir_z()
                + T::TWO * operand.rz() * self.as_inner().dir_z() * self.as_inner().moment_y()
                + T::TWO * operand.tx() * self.as_inner().dir_x() * self.as_inner().moment_y()
                + T::TWO * operand.ty() * self.as_inner().dir_y() * self.as_inner().dir_y()
                + T::from_i8(4i8)
                    * operand.ry()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_y(),
            -(operand.tx())
                + T::TWO * operand.ry() * self.as_inner().dir_x() * self.as_inner().dir_y()
                + T::TWO * operand.rz() * self.as_inner().dir_x() * self.as_inner().dir_z()
                + T::TWO * operand.tx() * self.as_inner().dir_x() * self.as_inner().dir_x(),
            -(operand.rx())
                + -T::TWO * operand.ry() * self.as_inner().dir_x() * self.as_inner().moment_y()
                + -T::TWO * operand.ty() * self.as_inner().dir_x() * self.as_inner().dir_y()
                + T::TWO * operand.rx() * self.as_inner().dir_x() * self.as_inner().dir_x()
                + T::TWO * operand.ry() * self.as_inner().dir_y() * self.as_inner().moment_x()
                + T::TWO * operand.rz() * self.as_inner().dir_x() * self.as_inner().moment_z()
                + T::TWO * operand.rz() * self.as_inner().dir_z() * self.as_inner().moment_x()
                + T::TWO * operand.tz() * self.as_inner().dir_x() * self.as_inner().dir_z()
                + T::from_i8(4i8)
                    * operand.tx()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_x(),
            -(operand.ry())
                + T::TWO * operand.ry() * self.as_inner().dir_y() * self.as_inner().dir_y()
                + T::TWO * operand.rz() * self.as_inner().dir_y() * self.as_inner().dir_z()
                + T::TWO * operand.tx() * self.as_inner().dir_x() * self.as_inner().dir_y(),
            -T::TWO * operand.rz() * self.as_inner().dir_x() * self.as_inner().dir_x()
                + -T::TWO * operand.rz() * self.as_inner().dir_y() * self.as_inner().dir_y()
                + T::TWO * operand.ry() * self.as_inner().dir_y() * self.as_inner().dir_z()
                + T::TWO * operand.tx() * self.as_inner().dir_x() * self.as_inner().dir_z()
                + operand.rz(),
            operand.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Motor<T>>> for Line<T> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s() * self.dir_x() * self.dir_x()
                + operand.as_inner().s() * self.dir_y() * self.dir_y()
                + operand.as_inner().s() * self.dir_z() * self.dir_z(),
            -(operand.as_inner().tz() * self.dir_x() * self.dir_x())
                + -(operand.as_inner().tz() * self.dir_y() * self.dir_y())
                + -T::TWO * operand.as_inner().ry() * self.dir_z() * self.moment_y()
                + -T::TWO * operand.as_inner().ty() * self.dir_y() * self.dir_z()
                + T::TWO * operand.as_inner().rx() * self.dir_x() * self.dir_z()
                + T::TWO * operand.as_inner().ry() * self.dir_y() * self.moment_z()
                + T::TWO * operand.as_inner().tx() * self.dir_x() * self.moment_z()
                + T::TWO * operand.as_inner().tx() * self.dir_z() * self.moment_x()
                + T::from_i8(-4i8) * operand.as_inner().rz() * self.dir_x() * self.moment_x()
                + T::from_i8(4i8) * operand.as_inner().rz() * self.dir_y() * self.moment_y()
                + operand.as_inner().tz() * self.dir_z() * self.dir_z(),
            -(operand.as_inner().ty() * self.dir_x() * self.dir_x())
                + -(operand.as_inner().ty() * self.dir_z() * self.dir_z())
                + -T::TWO * operand.as_inner().rx() * self.dir_x() * self.dir_y()
                + -T::TWO * operand.as_inner().rz() * self.dir_y() * self.moment_z()
                + -T::TWO * operand.as_inner().tx() * self.dir_y() * self.moment_x()
                + -T::TWO * operand.as_inner().tz() * self.dir_y() * self.dir_z()
                + T::TWO * operand.as_inner().rz() * self.dir_z() * self.moment_y()
                + T::TWO * operand.as_inner().tx() * self.dir_x() * self.moment_y()
                + T::from_i8(4i8) * operand.as_inner().ry() * self.dir_y() * self.moment_y()
                + operand.as_inner().ty() * self.dir_y() * self.dir_y(),
            -(operand.as_inner().tx() * self.dir_y() * self.dir_y())
                + -(operand.as_inner().tx() * self.dir_z() * self.dir_z())
                + T::TWO * operand.as_inner().ry() * self.dir_x() * self.dir_y()
                + T::TWO * operand.as_inner().rz() * self.dir_x() * self.dir_z()
                + operand.as_inner().tx() * self.dir_x() * self.dir_x(),
            -(operand.as_inner().rx() * self.dir_y() * self.dir_y())
                + -(operand.as_inner().rx() * self.dir_z() * self.dir_z())
                + -T::TWO * operand.as_inner().ry() * self.dir_x() * self.moment_y()
                + -T::TWO * operand.as_inner().ty() * self.dir_x() * self.dir_y()
                + T::TWO * operand.as_inner().ry() * self.dir_y() * self.moment_x()
                + T::TWO * operand.as_inner().rz() * self.dir_x() * self.moment_z()
                + T::TWO * operand.as_inner().rz() * self.dir_z() * self.moment_x()
                + T::TWO * operand.as_inner().tz() * self.dir_x() * self.dir_z()
                + T::from_i8(4i8) * operand.as_inner().tx() * self.dir_x() * self.moment_x()
                + operand.as_inner().rx() * self.dir_x() * self.dir_x(),
            -(operand.as_inner().ry() * self.dir_x() * self.dir_x())
                + -(operand.as_inner().ry() * self.dir_z() * self.dir_z())
                + T::TWO * operand.as_inner().rz() * self.dir_y() * self.dir_z()
                + T::TWO * operand.as_inner().tx() * self.dir_x() * self.dir_y()
                + operand.as_inner().ry() * self.dir_y() * self.dir_y(),
            -(operand.as_inner().rz() * self.dir_x() * self.dir_x())
                + -(operand.as_inner().rz() * self.dir_y() * self.dir_y())
                + T::TWO * operand.as_inner().ry() * self.dir_y() * self.dir_z()
                + T::TWO * operand.as_inner().tx() * self.dir_x() * self.dir_z()
                + operand.as_inner().rz() * self.dir_z() * self.dir_z(),
            operand.as_inner().ps() * self.dir_x() * self.dir_x()
                + operand.as_inner().ps() * self.dir_y() * self.dir_y()
                + operand.as_inner().ps() * self.dir_z() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Motor<T>>> for Unitized<Line<T>> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s(),
            -T::TWO
                * operand.as_inner().ry()
                * self.as_inner().dir_z()
                * self.as_inner().moment_y()
                + -T::TWO
                    * operand.as_inner().ty()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_z()
                + -T::TWO
                    * operand.as_inner().tz()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_x()
                + -T::TWO
                    * operand.as_inner().tz()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().rx()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_z()
                + T::TWO
                    * operand.as_inner().ry()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().tx()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().tx()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_x()
                + T::from_i8(-4i8)
                    * operand.as_inner().rz()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_x()
                + T::from_i8(4i8)
                    * operand.as_inner().rz()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_y()
                + operand.as_inner().tz(),
            -(operand.as_inner().ty())
                + -T::TWO
                    * operand.as_inner().rx()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_y()
                + -T::TWO
                    * operand.as_inner().rz()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_z()
                + -T::TWO
                    * operand.as_inner().tx()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_x()
                + -T::TWO
                    * operand.as_inner().tz()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_z()
                + T::TWO
                    * operand.as_inner().rz()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().tx()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().ty()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_y()
                + T::from_i8(4i8)
                    * operand.as_inner().ry()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_y(),
            -(operand.as_inner().tx())
                + T::TWO
                    * operand.as_inner().ry()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().rz()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_z()
                + T::TWO
                    * operand.as_inner().tx()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_x(),
            -(operand.as_inner().rx())
                + -T::TWO
                    * operand.as_inner().ry()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_y()
                + -T::TWO
                    * operand.as_inner().ty()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().rx()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_x()
                + T::TWO
                    * operand.as_inner().ry()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().rz()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().rz()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().tz()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_z()
                + T::from_i8(4i8)
                    * operand.as_inner().tx()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_x(),
            -(operand.as_inner().ry())
                + T::TWO
                    * operand.as_inner().ry()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().rz()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_z()
                + T::TWO
                    * operand.as_inner().tx()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_y(),
            -T::TWO * operand.as_inner().rz() * self.as_inner().dir_x() * self.as_inner().dir_x()
                + -T::TWO
                    * operand.as_inner().rz()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().ry()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_z()
                + T::TWO
                    * operand.as_inner().tx()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_z()
                + operand.as_inner().rz(),
            operand.as_inner().ps(),
        )
    }
}
#[doc = "Antisandwich product: [`Line`] x [`Plane`] x antirev([`Line`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Plane<T>> for Line<T> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            self.dir_x() * operand.dist() * self.dir_x()
                + self.dir_x() * operand.ny() * self.moment_z()
                - self.dir_x() * operand.nz() * self.moment_y()
                + self.dir_y() * operand.dist() * self.dir_y()
                + self.dir_y() * operand.nx() * self.moment_z()
                - self.dir_y() * operand.nz() * self.moment_x()
                + self.dir_z() * operand.dist() * self.dir_z()
                + self.dir_z() * operand.nx() * self.moment_y()
                - self.dir_z() * operand.ny() * self.moment_x()
                - self.moment_x() * operand.ny() * self.dir_z()
                - self.moment_x() * operand.nz() * self.dir_y()
                + self.moment_y() * operand.nx() * self.dir_z()
                - self.moment_y() * operand.nz() * self.dir_x()
                + self.moment_z() * operand.nx() * self.dir_y()
                + self.moment_z() * operand.ny() * self.dir_x(),
            self.dir_x() * operand.nx() * self.dir_z()
                - self.dir_x() * operand.nz() * self.dir_x()
                - self.dir_y() * operand.ny() * self.dir_z()
                - self.dir_y() * operand.nz() * self.dir_y()
                + self.dir_z() * operand.nx() * self.dir_x()
                - self.dir_z() * operand.ny() * self.dir_y()
                + self.dir_z() * operand.nz() * self.dir_z(),
            -(self.dir_x() * operand.nx() * self.dir_y())
                - self.dir_x() * operand.ny() * self.dir_x()
                - self.dir_y() * operand.nx() * self.dir_x()
                + self.dir_y() * operand.ny() * self.dir_y()
                - self.dir_y() * operand.nz() * self.dir_z()
                - self.dir_z() * operand.ny() * self.dir_z()
                - self.dir_z() * operand.nz() * self.dir_y(),
            self.dir_x() * operand.nx() * self.dir_x() - self.dir_x() * operand.ny() * self.dir_y()
                + self.dir_x() * operand.nz() * self.dir_z()
                - self.dir_y() * operand.nx() * self.dir_y()
                - self.dir_y() * operand.ny() * self.dir_x()
                - self.dir_z() * operand.nx() * self.dir_z()
                + self.dir_z() * operand.nz() * self.dir_x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Plane<T>> for Unitized<Line<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            -T::TWO * operand.ny() * self.as_inner().dir_z() * self.as_inner().moment_x()
                + -T::TWO * operand.nz() * self.as_inner().dir_x() * self.as_inner().moment_y()
                + -T::TWO * operand.nz() * self.as_inner().dir_y() * self.as_inner().moment_x()
                + T::TWO * operand.nx() * self.as_inner().dir_y() * self.as_inner().moment_z()
                + T::TWO * operand.nx() * self.as_inner().dir_z() * self.as_inner().moment_y()
                + T::TWO * operand.ny() * self.as_inner().dir_x() * self.as_inner().moment_z()
                + operand.dist(),
            -T::TWO * operand.ny() * self.as_inner().dir_y() * self.as_inner().dir_z()
                + -T::TWO * operand.nz() * self.as_inner().dir_x() * self.as_inner().dir_x()
                + -T::TWO * operand.nz() * self.as_inner().dir_y() * self.as_inner().dir_y()
                + T::TWO * operand.nx() * self.as_inner().dir_x() * self.as_inner().dir_z()
                + operand.nz(),
            -(operand.ny())
                + -T::TWO * operand.nx() * self.as_inner().dir_x() * self.as_inner().dir_y()
                + -T::TWO * operand.nz() * self.as_inner().dir_y() * self.as_inner().dir_z()
                + T::TWO * operand.ny() * self.as_inner().dir_y() * self.as_inner().dir_y(),
            -(operand.nx())
                + -T::TWO * operand.ny() * self.as_inner().dir_x() * self.as_inner().dir_y()
                + T::TWO * operand.nx() * self.as_inner().dir_x() * self.as_inner().dir_x()
                + T::TWO * operand.nz() * self.as_inner().dir_x() * self.as_inner().dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Plane<T>>> for Line<T> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -T::TWO * operand.as_inner().ny() * self.dir_z() * self.moment_x()
                + -T::TWO * operand.as_inner().nz() * self.dir_x() * self.moment_y()
                + -T::TWO * operand.as_inner().nz() * self.dir_y() * self.moment_x()
                + T::TWO * operand.as_inner().nx() * self.dir_y() * self.moment_z()
                + T::TWO * operand.as_inner().nx() * self.dir_z() * self.moment_y()
                + T::TWO * operand.as_inner().ny() * self.dir_x() * self.moment_z()
                + operand.as_inner().dist() * self.dir_x() * self.dir_x()
                + operand.as_inner().dist() * self.dir_y() * self.dir_y()
                + operand.as_inner().dist() * self.dir_z() * self.dir_z(),
            -(operand.as_inner().nz() * self.dir_x() * self.dir_x())
                + -(operand.as_inner().nz() * self.dir_y() * self.dir_y())
                + -T::TWO * operand.as_inner().ny() * self.dir_y() * self.dir_z()
                + T::TWO * operand.as_inner().nx() * self.dir_x() * self.dir_z()
                + operand.as_inner().nz() * self.dir_z() * self.dir_z(),
            -(operand.as_inner().ny() * self.dir_x() * self.dir_x())
                + -(operand.as_inner().ny() * self.dir_z() * self.dir_z())
                + -T::TWO * operand.as_inner().nx() * self.dir_x() * self.dir_y()
                + -T::TWO * operand.as_inner().nz() * self.dir_y() * self.dir_z()
                + operand.as_inner().ny() * self.dir_y() * self.dir_y(),
            -(operand.as_inner().nx() * self.dir_y() * self.dir_y())
                + -(operand.as_inner().nx() * self.dir_z() * self.dir_z())
                + -T::TWO * operand.as_inner().ny() * self.dir_x() * self.dir_y()
                + T::TWO * operand.as_inner().nz() * self.dir_x() * self.dir_z()
                + operand.as_inner().nx() * self.dir_x() * self.dir_x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Plane<T>>> for Unitized<Line<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -T::TWO
                * operand.as_inner().ny()
                * self.as_inner().dir_z()
                * self.as_inner().moment_x()
                + -T::TWO
                    * operand.as_inner().nz()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_y()
                + -T::TWO
                    * operand.as_inner().nz()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().nx()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().nx()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().ny()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_z()
                + operand.as_inner().dist(),
            -T::TWO * operand.as_inner().ny() * self.as_inner().dir_y() * self.as_inner().dir_z()
                + -T::TWO
                    * operand.as_inner().nz()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_x()
                + -T::TWO
                    * operand.as_inner().nz()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().nx()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_z()
                + operand.as_inner().nz(),
            -(operand.as_inner().ny())
                + -T::TWO
                    * operand.as_inner().nx()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_y()
                + -T::TWO
                    * operand.as_inner().nz()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_z()
                + T::TWO
                    * operand.as_inner().ny()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_y(),
            -(operand.as_inner().nx())
                + -T::TWO
                    * operand.as_inner().ny()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().nx()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_x()
                + T::TWO
                    * operand.as_inner().nz()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_z(),
        )
    }
}
#[doc = "Antisandwich product: [`Line`] x [`Point`] x antirev([`Line`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.dir_x() * operand.x() * self.dir_x()
                + self.dir_x() * operand.y() * self.dir_y()
                + self.dir_x() * operand.z() * self.dir_z()
                - self.dir_y() * operand.w() * self.moment_z()
                - self.dir_y() * operand.x() * self.dir_y()
                + self.dir_y() * operand.y() * self.dir_x()
                - self.dir_z() * operand.w() * self.moment_y()
                - self.dir_z() * operand.x() * self.dir_z()
                + self.dir_z() * operand.z() * self.dir_x()
                - self.moment_y() * operand.w() * self.dir_z()
                - self.moment_z() * operand.w() * self.dir_y(),
            self.dir_x() * operand.w() * self.moment_z()
                + self.dir_x() * operand.x() * self.dir_y()
                - self.dir_x() * operand.y() * self.dir_x()
                + self.dir_y() * operand.x() * self.dir_x()
                + self.dir_y() * operand.y() * self.dir_y()
                + self.dir_y() * operand.z() * self.dir_z()
                - self.dir_z() * operand.w() * self.moment_x()
                - self.dir_z() * operand.y() * self.dir_z()
                + self.dir_z() * operand.z() * self.dir_y()
                - self.moment_x() * operand.w() * self.dir_z()
                + self.moment_z() * operand.w() * self.dir_x(),
            self.dir_x() * operand.w() * self.moment_y()
                + self.dir_x() * operand.x() * self.dir_z()
                - self.dir_x() * operand.z() * self.dir_x()
                + self.dir_y() * operand.w() * self.moment_x()
                + self.dir_y() * operand.y() * self.dir_z()
                - self.dir_y() * operand.z() * self.dir_y()
                + self.dir_z() * operand.x() * self.dir_x()
                + self.dir_z() * operand.y() * self.dir_y()
                + self.dir_z() * operand.z() * self.dir_z()
                + self.moment_x() * operand.w() * self.dir_y()
                + self.moment_y() * operand.w() * self.dir_x(),
            self.dir_x() * operand.w() * self.dir_x()
                + self.dir_y() * operand.w() * self.dir_y()
                + self.dir_z() * operand.w() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Unitized<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -(operand.x())
                + -T::TWO * operand.w() * self.as_inner().dir_y() * self.as_inner().moment_z()
                + -T::TWO * operand.w() * self.as_inner().dir_z() * self.as_inner().moment_y()
                + T::TWO * operand.x() * self.as_inner().dir_x() * self.as_inner().dir_x()
                + T::TWO * operand.y() * self.as_inner().dir_x() * self.as_inner().dir_y()
                + T::TWO * operand.z() * self.as_inner().dir_x() * self.as_inner().dir_z(),
            -(operand.y())
                + -T::TWO * operand.w() * self.as_inner().dir_z() * self.as_inner().moment_x()
                + T::TWO * operand.w() * self.as_inner().dir_x() * self.as_inner().moment_z()
                + T::TWO * operand.x() * self.as_inner().dir_x() * self.as_inner().dir_y()
                + T::TWO * operand.y() * self.as_inner().dir_y() * self.as_inner().dir_y()
                + T::TWO * operand.z() * self.as_inner().dir_y() * self.as_inner().dir_z(),
            -T::TWO * operand.z() * self.as_inner().dir_x() * self.as_inner().dir_x()
                + -T::TWO * operand.z() * self.as_inner().dir_y() * self.as_inner().dir_y()
                + T::TWO * operand.w() * self.as_inner().dir_x() * self.as_inner().moment_y()
                + T::TWO * operand.w() * self.as_inner().dir_y() * self.as_inner().moment_x()
                + T::TWO * operand.x() * self.as_inner().dir_x() * self.as_inner().dir_z()
                + T::TWO * operand.y() * self.as_inner().dir_y() * self.as_inner().dir_z()
                + operand.z(),
            operand.w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Point<T>>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x() * self.dir_y() * self.dir_y())
                + -(operand.as_inner().x() * self.dir_z() * self.dir_z())
                + -T::TWO * operand.as_inner().w() * self.dir_y() * self.moment_z()
                + -T::TWO * operand.as_inner().w() * self.dir_z() * self.moment_y()
                + T::TWO * operand.as_inner().y() * self.dir_x() * self.dir_y()
                + T::TWO * operand.as_inner().z() * self.dir_x() * self.dir_z()
                + operand.as_inner().x() * self.dir_x() * self.dir_x(),
            -(operand.as_inner().y() * self.dir_x() * self.dir_x())
                + -(operand.as_inner().y() * self.dir_z() * self.dir_z())
                + -T::TWO * operand.as_inner().w() * self.dir_z() * self.moment_x()
                + T::TWO * operand.as_inner().w() * self.dir_x() * self.moment_z()
                + T::TWO * operand.as_inner().x() * self.dir_x() * self.dir_y()
                + T::TWO * operand.as_inner().z() * self.dir_y() * self.dir_z()
                + operand.as_inner().y() * self.dir_y() * self.dir_y(),
            -(operand.as_inner().z() * self.dir_x() * self.dir_x())
                + -(operand.as_inner().z() * self.dir_y() * self.dir_y())
                + T::TWO * operand.as_inner().w() * self.dir_x() * self.moment_y()
                + T::TWO * operand.as_inner().w() * self.dir_y() * self.moment_x()
                + T::TWO * operand.as_inner().x() * self.dir_x() * self.dir_z()
                + T::TWO * operand.as_inner().y() * self.dir_y() * self.dir_z()
                + operand.as_inner().z() * self.dir_z() * self.dir_z(),
            operand.as_inner().w() * self.dir_x() * self.dir_x()
                + operand.as_inner().w() * self.dir_y() * self.dir_y()
                + operand.as_inner().w() * self.dir_z() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Point<T>>> for Unitized<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x())
                + -T::TWO
                    * operand.as_inner().w()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_z()
                + -T::TWO
                    * operand.as_inner().w()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().x()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_x()
                + T::TWO
                    * operand.as_inner().y()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().z()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_z(),
            -(operand.as_inner().y())
                + -T::TWO
                    * operand.as_inner().w()
                    * self.as_inner().dir_z()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().w()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_z()
                + T::TWO
                    * operand.as_inner().x()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().y()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().z()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_z(),
            -T::TWO * operand.as_inner().z() * self.as_inner().dir_x() * self.as_inner().dir_x()
                + -T::TWO
                    * operand.as_inner().z()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_y()
                + T::TWO
                    * operand.as_inner().w()
                    * self.as_inner().dir_x()
                    * self.as_inner().moment_y()
                + T::TWO
                    * operand.as_inner().w()
                    * self.as_inner().dir_y()
                    * self.as_inner().moment_x()
                + T::TWO
                    * operand.as_inner().x()
                    * self.as_inner().dir_x()
                    * self.as_inner().dir_z()
                + T::TWO
                    * operand.as_inner().y()
                    * self.as_inner().dir_y()
                    * self.as_inner().dir_z()
                + operand.as_inner().z(),
            operand.as_inner().w(),
        )
    }
}
#[doc = "Antisandwich product: [`Line`] x [`Quadvector`] x antirev([`Line`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Quadvector<T>> for Line<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            self.dir_x() * operand.ps() * self.dir_x()
                + self.dir_y() * operand.ps() * self.dir_y()
                + self.dir_z() * operand.ps() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Quadvector<T>> for Unitized<Line<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(operand.ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Quadvector<T>>> for Line<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            operand.as_inner().ps() * self.dir_x() * self.dir_x()
                + operand.as_inner().ps() * self.dir_y() * self.dir_y()
                + operand.as_inner().ps() * self.dir_z() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Quadvector<T>>> for Unitized<Line<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(operand.as_inner().ps())
    }
}
#[doc = "Antisandwich product: [`Line`] x [`Scalar`] x antirev([`Line`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.dir_x() * operand.s() * self.dir_x()
                + self.dir_y() * operand.s() * self.dir_y()
                + self.dir_z() * operand.s() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unitized<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Unitized<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Antisandwich product: [`Motor`] x [`Flector`] x antirev([`Motor`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Flector<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            -(self.ps() * operand.dist() * self.tx())
                - self.ps() * operand.nx() * self.s()
                - self.ps() * operand.ny() * self.tz()
                + self.ps() * operand.nz() * self.ty()
                + self.ps() * operand.pw() * self.rx()
                + self.ps() * operand.px() * self.ps()
                + self.ps() * operand.py() * self.rz()
                - self.ps() * operand.pz() * self.ry()
                - self.rx() * operand.nx() * self.tx()
                + self.rx() * operand.ny() * self.ry()
                - self.rx() * operand.nz() * self.rz()
                + self.rx() * operand.pw() * self.ps()
                + self.ry() * operand.dist() * self.rz()
                + self.ry() * operand.nx() * self.ty()
                - self.ry() * operand.ny() * self.rx()
                + self.ry() * operand.nz() * self.s()
                - self.ry() * operand.pw() * self.tz()
                - self.ry() * operand.px() * self.ry()
                + self.ry() * operand.py() * self.tx()
                - self.ry() * operand.pz() * self.ps()
                - self.rz() * operand.dist() * self.ry()
                - self.rz() * operand.nx() * self.tz()
                + self.rz() * operand.ny() * self.s()
                + self.rz() * operand.nz() * self.rx()
                - self.rz() * operand.pw() * self.ty()
                - self.rz() * operand.px() * self.rz()
                + self.rz() * operand.py() * self.ps()
                + self.rz() * operand.pz() * self.tx()
                + self.s() * operand.nx() * self.ps()
                - self.s() * operand.ny() * self.rz()
                - self.s() * operand.nz() * self.ry()
                + self.s() * operand.pw() * self.tx()
                + self.tx() * operand.dist() * self.ps()
                + self.tx() * operand.nx() * self.rx()
                + self.tx() * operand.ny() * self.ty()
                + self.tx() * operand.nz() * self.tz()
                + self.tx() * operand.pw() * self.s()
                + self.tx() * operand.px() * self.tx()
                + self.tx() * operand.py() * self.ry()
                + self.tx() * operand.pz() * self.rz()
                - self.ty() * operand.nx() * self.ry()
                - self.ty() * operand.ny() * self.tx()
                - self.ty() * operand.nz() * self.ps()
                - self.ty() * operand.pw() * self.rz()
                + self.tz() * operand.nx() * self.rz()
                + self.tz() * operand.ny() * self.ps()
                - self.tz() * operand.nz() * self.tx()
                - self.tz() * operand.pw() * self.ry(),
            -(self.ps() * operand.dist() * self.ry()) - self.ps() * operand.nx() * self.tz()
                + self.ps() * operand.ny() * self.s()
                + self.ps() * operand.nz() * self.rx()
                - self.ps() * operand.pw() * self.ty()
                - self.ps() * operand.px() * self.rz()
                + self.ps() * operand.py() * self.ps()
                + self.ps() * operand.pz() * self.tx()
                - self.rx() * operand.nx() * self.ry()
                - self.rx() * operand.ny() * self.tx()
                - self.rx() * operand.nz() * self.ps()
                - self.rx() * operand.pw() * self.rz()
                + self.ry() * operand.dist() * self.ps()
                + self.ry() * operand.nx() * self.rx()
                + self.ry() * operand.ny() * self.ty()
                + self.ry() * operand.nz() * self.tz()
                + self.ry() * operand.pw() * self.s()
                + self.ry() * operand.px() * self.tx()
                + self.ry() * operand.py() * self.ry()
                + self.ry() * operand.pz() * self.rz()
                + self.rz() * operand.dist() * self.tx()
                + self.rz() * operand.nx() * self.s()
                + self.rz() * operand.ny() * self.tz()
                - self.rz() * operand.nz() * self.ty()
                - self.rz() * operand.pw() * self.rx()
                - self.rz() * operand.px() * self.ps()
                - self.rz() * operand.py() * self.rz()
                + self.rz() * operand.pz() * self.ry()
                - self.s() * operand.nx() * self.rz()
                - self.s() * operand.ny() * self.ps()
                + self.s() * operand.nz() * self.tx()
                + self.s() * operand.pw() * self.ry()
                - self.tx() * operand.dist() * self.rz()
                - self.tx() * operand.nx() * self.ty()
                + self.tx() * operand.ny() * self.rx()
                - self.tx() * operand.nz() * self.s()
                + self.tx() * operand.pw() * self.tz()
                + self.tx() * operand.px() * self.ry()
                - self.tx() * operand.py() * self.tx()
                + self.tx() * operand.pz() * self.ps()
                + self.ty() * operand.nx() * self.tx()
                - self.ty() * operand.ny() * self.ry()
                + self.ty() * operand.nz() * self.rz()
                - self.ty() * operand.pw() * self.ps()
                + self.tz() * operand.nx() * self.ps()
                - self.tz() * operand.ny() * self.rz()
                - self.tz() * operand.nz() * self.ry()
                + self.tz() * operand.pw() * self.tx(),
            -(self.ps() * operand.dist() * self.rz()) - self.ps() * operand.nx() * self.ty()
                + self.ps() * operand.ny() * self.rx()
                - self.ps() * operand.nz() * self.s()
                + self.ps() * operand.pw() * self.tz()
                + self.ps() * operand.px() * self.ry()
                - self.ps() * operand.py() * self.tx()
                + self.ps() * operand.pz() * self.ps()
                - self.rx() * operand.nx() * self.rz()
                - self.rx() * operand.ny() * self.ps()
                + self.rx() * operand.nz() * self.tx()
                + self.rx() * operand.pw() * self.ry()
                - self.ry() * operand.dist() * self.tx()
                - self.ry() * operand.nx() * self.s()
                - self.ry() * operand.ny() * self.tz()
                + self.ry() * operand.nz() * self.ty()
                + self.ry() * operand.pw() * self.rx()
                + self.ry() * operand.px() * self.ps()
                + self.ry() * operand.py() * self.rz()
                - self.ry() * operand.pz() * self.ry()
                + self.rz() * operand.dist() * self.ps()
                + self.rz() * operand.nx() * self.rx()
                + self.rz() * operand.ny() * self.ty()
                + self.rz() * operand.nz() * self.tz()
                + self.rz() * operand.pw() * self.s()
                + self.rz() * operand.px() * self.tx()
                + self.rz() * operand.py() * self.ry()
                + self.rz() * operand.pz() * self.rz()
                + self.s() * operand.nx() * self.ry()
                + self.s() * operand.ny() * self.tx()
                + self.s() * operand.nz() * self.ps()
                + self.s() * operand.pw() * self.rz()
                + self.tx() * operand.dist() * self.ry()
                + self.tx() * operand.nx() * self.tz()
                - self.tx() * operand.ny() * self.s()
                - self.tx() * operand.nz() * self.rx()
                + self.tx() * operand.pw() * self.ty()
                + self.tx() * operand.px() * self.rz()
                - self.tx() * operand.py() * self.ps()
                - self.tx() * operand.pz() * self.tx()
                + self.ty() * operand.nx() * self.ps()
                - self.ty() * operand.ny() * self.rz()
                - self.ty() * operand.nz() * self.ry()
                + self.ty() * operand.pw() * self.tx()
                - self.tz() * operand.nx() * self.tx()
                + self.tz() * operand.ny() * self.ry()
                - self.tz() * operand.nz() * self.rz()
                + self.tz() * operand.pw() * self.ps(),
            -(self.ps() * operand.nx() * self.tx()) + self.ps() * operand.ny() * self.ry()
                - self.ps() * operand.nz() * self.rz()
                + self.ps() * operand.pw() * self.ps()
                - self.ry() * operand.nx() * self.rz()
                - self.ry() * operand.ny() * self.ps()
                + self.ry() * operand.nz() * self.tx()
                + self.ry() * operand.pw() * self.ry()
                + self.rz() * operand.nx() * self.ry()
                + self.rz() * operand.ny() * self.tx()
                + self.rz() * operand.nz() * self.ps()
                + self.rz() * operand.pw() * self.rz()
                + self.tx() * operand.nx() * self.ps()
                - self.tx() * operand.ny() * self.rz()
                - self.tx() * operand.nz() * self.ry()
                + self.tx() * operand.pw() * self.tx(),
            self.ps() * operand.dist() * self.ps()
                + self.ps() * operand.nx() * self.rx()
                + self.ps() * operand.ny() * self.ty()
                + self.ps() * operand.nz() * self.tz()
                + self.ps() * operand.pw() * self.s()
                + self.ps() * operand.px() * self.tx()
                + self.ps() * operand.py() * self.ry()
                + self.ps() * operand.pz() * self.rz()
                + self.rx() * operand.nx() * self.ps()
                - self.rx() * operand.ny() * self.rz()
                - self.rx() * operand.nz() * self.ry()
                + self.rx() * operand.pw() * self.tx()
                + self.ry() * operand.dist() * self.ry()
                + self.ry() * operand.nx() * self.tz()
                - self.ry() * operand.ny() * self.s()
                - self.ry() * operand.nz() * self.rx()
                + self.ry() * operand.pw() * self.ty()
                + self.ry() * operand.px() * self.rz()
                - self.ry() * operand.py() * self.ps()
                - self.ry() * operand.pz() * self.tx()
                + self.rz() * operand.dist() * self.rz()
                + self.rz() * operand.nx() * self.ty()
                - self.rz() * operand.ny() * self.rx()
                + self.rz() * operand.nz() * self.s()
                - self.rz() * operand.pw() * self.tz()
                - self.rz() * operand.px() * self.ry()
                + self.rz() * operand.py() * self.tx()
                - self.rz() * operand.pz() * self.ps()
                + self.s() * operand.nx() * self.tx()
                - self.s() * operand.ny() * self.ry()
                + self.s() * operand.nz() * self.rz()
                - self.s() * operand.pw() * self.ps()
                + self.tx() * operand.dist() * self.tx()
                + self.tx() * operand.nx() * self.s()
                + self.tx() * operand.ny() * self.tz()
                - self.tx() * operand.nz() * self.ty()
                - self.tx() * operand.pw() * self.rx()
                - self.tx() * operand.px() * self.ps()
                - self.tx() * operand.py() * self.rz()
                + self.tx() * operand.pz() * self.ry()
                + self.ty() * operand.nx() * self.rz()
                + self.ty() * operand.ny() * self.ps()
                - self.ty() * operand.nz() * self.tx()
                - self.ty() * operand.pw() * self.ry()
                + self.tz() * operand.nx() * self.ry()
                + self.tz() * operand.ny() * self.tx()
                + self.tz() * operand.nz() * self.ps()
                + self.tz() * operand.pw() * self.rz(),
            self.ps() * operand.nx() * self.ry()
                + self.ps() * operand.ny() * self.tx()
                + self.ps() * operand.nz() * self.ps()
                + self.ps() * operand.pw() * self.rz()
                + self.ry() * operand.nx() * self.ps()
                - self.ry() * operand.ny() * self.rz()
                - self.ry() * operand.nz() * self.ry()
                + self.ry() * operand.pw() * self.tx()
                + self.rz() * operand.nx() * self.tx()
                - self.rz() * operand.ny() * self.ry()
                + self.rz() * operand.nz() * self.rz()
                - self.rz() * operand.pw() * self.ps()
                + self.tx() * operand.nx() * self.rz()
                + self.tx() * operand.ny() * self.ps()
                - self.tx() * operand.nz() * self.tx()
                - self.tx() * operand.pw() * self.ry(),
            self.ps() * operand.nx() * self.rz() + self.ps() * operand.ny() * self.ps()
                - self.ps() * operand.nz() * self.tx()
                - self.ps() * operand.pw() * self.ry()
                - self.ry() * operand.nx() * self.tx()
                + self.ry() * operand.ny() * self.ry()
                - self.ry() * operand.nz() * self.rz()
                + self.ry() * operand.pw() * self.ps()
                + self.rz() * operand.nx() * self.ps()
                - self.rz() * operand.ny() * self.rz()
                - self.rz() * operand.nz() * self.ry()
                + self.rz() * operand.pw() * self.tx()
                - self.tx() * operand.nx() * self.ry()
                - self.tx() * operand.ny() * self.tx()
                - self.tx() * operand.nz() * self.ps()
                - self.tx() * operand.pw() * self.rz(),
            self.ps() * operand.nx() * self.ps()
                - self.ps() * operand.ny() * self.rz()
                - self.ps() * operand.nz() * self.ry()
                + self.ps() * operand.pw() * self.tx()
                - self.ry() * operand.nx() * self.ry()
                - self.ry() * operand.ny() * self.tx()
                - self.ry() * operand.nz() * self.ps()
                - self.ry() * operand.pw() * self.rz()
                - self.rz() * operand.nx() * self.rz()
                - self.rz() * operand.ny() * self.ps()
                + self.rz() * operand.nz() * self.tx()
                + self.rz() * operand.pw() * self.ry()
                + self.tx() * operand.nx() * self.tx()
                - self.tx() * operand.ny() * self.ry()
                + self.tx() * operand.nz() * self.rz()
                - self.tx() * operand.pw() * self.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Flector<T>> for Unitized<Motor<T>> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            -T::TWO * operand.pw() * self.as_inner().ry() * self.as_inner().tz()
                + -T::TWO * operand.pw() * self.as_inner().rz() * self.as_inner().ty()
                + -T::TWO * operand.px() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.px() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.pz() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.pw() * self.as_inner().ps() * self.as_inner().rx()
                + T::TWO * operand.pw() * self.as_inner().s() * self.as_inner().tx()
                + T::TWO * operand.py() * self.as_inner().ps() * self.as_inner().rz()
                + T::TWO * operand.py() * self.as_inner().ry() * self.as_inner().tx()
                + T::TWO * operand.pz() * self.as_inner().rz() * self.as_inner().tx()
                + operand.px(),
            -T::TWO * operand.pw() * self.as_inner().ps() * self.as_inner().ty()
                + -T::TWO * operand.pw() * self.as_inner().rx() * self.as_inner().rz()
                + -T::TWO * operand.px() * self.as_inner().ps() * self.as_inner().rz()
                + -T::TWO * operand.py() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.py() * self.as_inner().tx() * self.as_inner().tx()
                + T::TWO * operand.pw() * self.as_inner().ry() * self.as_inner().s()
                + T::TWO * operand.pw() * self.as_inner().tx() * self.as_inner().tz()
                + T::TWO * operand.px() * self.as_inner().ry() * self.as_inner().tx()
                + T::TWO * operand.pz() * self.as_inner().ps() * self.as_inner().tx()
                + T::TWO * operand.pz() * self.as_inner().ry() * self.as_inner().rz()
                + operand.py(),
            -T::TWO * operand.py() * self.as_inner().ps() * self.as_inner().tx()
                + -T::TWO * operand.pz() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.pz() * self.as_inner().tx() * self.as_inner().tx()
                + T::TWO * operand.pw() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.pw() * self.as_inner().rx() * self.as_inner().ry()
                + T::TWO * operand.pw() * self.as_inner().rz() * self.as_inner().s()
                + T::TWO * operand.pw() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.px() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.px() * self.as_inner().rz() * self.as_inner().tx()
                + T::TWO * operand.py() * self.as_inner().ry() * self.as_inner().rz()
                + operand.pz(),
            operand.pw(),
            -T::TWO * operand.ny() * self.as_inner().rx() * self.as_inner().rz()
                + -T::TWO * operand.ny() * self.as_inner().ry() * self.as_inner().s()
                + -T::TWO * operand.nz() * self.as_inner().rx() * self.as_inner().ry()
                + -T::TWO * operand.nz() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.nx() * self.as_inner().ps() * self.as_inner().rx()
                + T::TWO * operand.nx() * self.as_inner().ry() * self.as_inner().tz()
                + T::TWO * operand.nx() * self.as_inner().rz() * self.as_inner().ty()
                + T::TWO * operand.nx() * self.as_inner().s() * self.as_inner().tx()
                + T::TWO * operand.ny() * self.as_inner().ps() * self.as_inner().ty()
                + T::TWO * operand.ny() * self.as_inner().tx() * self.as_inner().tz()
                + T::TWO * operand.nz() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.nz() * self.as_inner().rz() * self.as_inner().s()
                + operand.dist(),
            -T::TWO * operand.ny() * self.as_inner().ry() * self.as_inner().rz()
                + -T::TWO * operand.nz() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.nz() * self.as_inner().tx() * self.as_inner().tx()
                + T::TWO * operand.nx() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.nx() * self.as_inner().rz() * self.as_inner().tx()
                + T::TWO * operand.ny() * self.as_inner().ps() * self.as_inner().tx()
                + operand.nz(),
            -T::TWO * operand.nx() * self.as_inner().ry() * self.as_inner().tx()
                + -T::TWO * operand.ny() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.ny() * self.as_inner().tx() * self.as_inner().tx()
                + -T::TWO * operand.nz() * self.as_inner().ps() * self.as_inner().tx()
                + -T::TWO * operand.nz() * self.as_inner().ry() * self.as_inner().rz()
                + T::TWO * operand.nx() * self.as_inner().ps() * self.as_inner().rz()
                + operand.ny(),
            -T::TWO * operand.nx() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.nx() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.ny() * self.as_inner().ps() * self.as_inner().rz()
                + -T::TWO * operand.ny() * self.as_inner().ry() * self.as_inner().tx()
                + -T::TWO * operand.nz() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.nz() * self.as_inner().rz() * self.as_inner().tx()
                + operand.nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Flector<T>>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            -(operand.as_inner().px() * self.ry() * self.ry())
                + -(operand.as_inner().px() * self.rz() * self.rz())
                + -T::TWO * operand.as_inner().pw() * self.ry() * self.tz()
                + -T::TWO * operand.as_inner().pw() * self.rz() * self.ty()
                + -T::TWO * operand.as_inner().pz() * self.ps() * self.ry()
                + T::TWO * operand.as_inner().pw() * self.ps() * self.rx()
                + T::TWO * operand.as_inner().pw() * self.s() * self.tx()
                + T::TWO * operand.as_inner().py() * self.ps() * self.rz()
                + T::TWO * operand.as_inner().py() * self.ry() * self.tx()
                + T::TWO * operand.as_inner().pz() * self.rz() * self.tx()
                + operand.as_inner().px() * self.ps() * self.ps()
                + operand.as_inner().px() * self.tx() * self.tx(),
            -(operand.as_inner().py() * self.rz() * self.rz())
                + -(operand.as_inner().py() * self.tx() * self.tx())
                + -T::TWO * operand.as_inner().pw() * self.ps() * self.ty()
                + -T::TWO * operand.as_inner().pw() * self.rx() * self.rz()
                + -T::TWO * operand.as_inner().px() * self.ps() * self.rz()
                + T::TWO * operand.as_inner().pw() * self.ry() * self.s()
                + T::TWO * operand.as_inner().pw() * self.tx() * self.tz()
                + T::TWO * operand.as_inner().px() * self.ry() * self.tx()
                + T::TWO * operand.as_inner().pz() * self.ps() * self.tx()
                + T::TWO * operand.as_inner().pz() * self.ry() * self.rz()
                + operand.as_inner().py() * self.ps() * self.ps()
                + operand.as_inner().py() * self.ry() * self.ry(),
            -(operand.as_inner().pz() * self.ry() * self.ry())
                + -(operand.as_inner().pz() * self.tx() * self.tx())
                + -T::TWO * operand.as_inner().py() * self.ps() * self.tx()
                + T::TWO * operand.as_inner().pw() * self.ps() * self.tz()
                + T::TWO * operand.as_inner().pw() * self.rx() * self.ry()
                + T::TWO * operand.as_inner().pw() * self.rz() * self.s()
                + T::TWO * operand.as_inner().pw() * self.tx() * self.ty()
                + T::TWO * operand.as_inner().px() * self.ps() * self.ry()
                + T::TWO * operand.as_inner().px() * self.rz() * self.tx()
                + T::TWO * operand.as_inner().py() * self.ry() * self.rz()
                + operand.as_inner().pz() * self.ps() * self.ps()
                + operand.as_inner().pz() * self.rz() * self.rz(),
            operand.as_inner().pw() * self.ps() * self.ps()
                + operand.as_inner().pw() * self.ry() * self.ry()
                + operand.as_inner().pw() * self.rz() * self.rz()
                + operand.as_inner().pw() * self.tx() * self.tx(),
            -T::TWO * operand.as_inner().ny() * self.rx() * self.rz()
                + -T::TWO * operand.as_inner().ny() * self.ry() * self.s()
                + -T::TWO * operand.as_inner().nz() * self.rx() * self.ry()
                + -T::TWO * operand.as_inner().nz() * self.tx() * self.ty()
                + T::TWO * operand.as_inner().nx() * self.ps() * self.rx()
                + T::TWO * operand.as_inner().nx() * self.ry() * self.tz()
                + T::TWO * operand.as_inner().nx() * self.rz() * self.ty()
                + T::TWO * operand.as_inner().nx() * self.s() * self.tx()
                + T::TWO * operand.as_inner().ny() * self.ps() * self.ty()
                + T::TWO * operand.as_inner().ny() * self.tx() * self.tz()
                + T::TWO * operand.as_inner().nz() * self.ps() * self.tz()
                + T::TWO * operand.as_inner().nz() * self.rz() * self.s()
                + operand.as_inner().dist() * self.ps() * self.ps()
                + operand.as_inner().dist() * self.ry() * self.ry()
                + operand.as_inner().dist() * self.rz() * self.rz()
                + operand.as_inner().dist() * self.tx() * self.tx(),
            -(operand.as_inner().nz() * self.ry() * self.ry())
                + -(operand.as_inner().nz() * self.tx() * self.tx())
                + -T::TWO * operand.as_inner().ny() * self.ry() * self.rz()
                + T::TWO * operand.as_inner().nx() * self.ps() * self.ry()
                + T::TWO * operand.as_inner().nx() * self.rz() * self.tx()
                + T::TWO * operand.as_inner().ny() * self.ps() * self.tx()
                + operand.as_inner().nz() * self.ps() * self.ps()
                + operand.as_inner().nz() * self.rz() * self.rz(),
            -(operand.as_inner().ny() * self.rz() * self.rz())
                + -(operand.as_inner().ny() * self.tx() * self.tx())
                + -T::TWO * operand.as_inner().nx() * self.ry() * self.tx()
                + -T::TWO * operand.as_inner().nz() * self.ps() * self.tx()
                + -T::TWO * operand.as_inner().nz() * self.ry() * self.rz()
                + T::TWO * operand.as_inner().nx() * self.ps() * self.rz()
                + operand.as_inner().ny() * self.ps() * self.ps()
                + operand.as_inner().ny() * self.ry() * self.ry(),
            -(operand.as_inner().nx() * self.ry() * self.ry())
                + -(operand.as_inner().nx() * self.rz() * self.rz())
                + -T::TWO * operand.as_inner().ny() * self.ps() * self.rz()
                + -T::TWO * operand.as_inner().ny() * self.ry() * self.tx()
                + -T::TWO * operand.as_inner().nz() * self.ps() * self.ry()
                + T::TWO * operand.as_inner().nz() * self.rz() * self.tx()
                + operand.as_inner().nx() * self.ps() * self.ps()
                + operand.as_inner().nx() * self.tx() * self.tx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Flector<T>>> for Unitized<Motor<T>> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            -T::TWO * operand.as_inner().pw() * self.as_inner().ry() * self.as_inner().tz()
                + -T::TWO * operand.as_inner().pw() * self.as_inner().rz() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().px() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().px() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().pz() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.as_inner().pw() * self.as_inner().ps() * self.as_inner().rx()
                + T::TWO * operand.as_inner().pw() * self.as_inner().s() * self.as_inner().tx()
                + T::TWO * operand.as_inner().py() * self.as_inner().ps() * self.as_inner().rz()
                + T::TWO * operand.as_inner().py() * self.as_inner().ry() * self.as_inner().tx()
                + T::TWO * operand.as_inner().pz() * self.as_inner().rz() * self.as_inner().tx()
                + operand.as_inner().px(),
            -T::TWO * operand.as_inner().pw() * self.as_inner().ps() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().pw() * self.as_inner().rx() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().px() * self.as_inner().ps() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().py() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().py() * self.as_inner().tx() * self.as_inner().tx()
                + T::TWO * operand.as_inner().pw() * self.as_inner().ry() * self.as_inner().s()
                + T::TWO * operand.as_inner().pw() * self.as_inner().tx() * self.as_inner().tz()
                + T::TWO * operand.as_inner().px() * self.as_inner().ry() * self.as_inner().tx()
                + T::TWO * operand.as_inner().pz() * self.as_inner().ps() * self.as_inner().tx()
                + T::TWO * operand.as_inner().pz() * self.as_inner().ry() * self.as_inner().rz()
                + operand.as_inner().py(),
            -T::TWO * operand.as_inner().py() * self.as_inner().ps() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().pz() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().pz() * self.as_inner().tx() * self.as_inner().tx()
                + T::TWO * operand.as_inner().pw() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.as_inner().pw() * self.as_inner().rx() * self.as_inner().ry()
                + T::TWO * operand.as_inner().pw() * self.as_inner().rz() * self.as_inner().s()
                + T::TWO * operand.as_inner().pw() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.as_inner().px() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.as_inner().px() * self.as_inner().rz() * self.as_inner().tx()
                + T::TWO * operand.as_inner().py() * self.as_inner().ry() * self.as_inner().rz()
                + operand.as_inner().pz(),
            operand.as_inner().pw(),
            -T::TWO * operand.as_inner().ny() * self.as_inner().rx() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().ry() * self.as_inner().s()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().rx() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.as_inner().nx() * self.as_inner().ps() * self.as_inner().rx()
                + T::TWO * operand.as_inner().nx() * self.as_inner().ry() * self.as_inner().tz()
                + T::TWO * operand.as_inner().nx() * self.as_inner().rz() * self.as_inner().ty()
                + T::TWO * operand.as_inner().nx() * self.as_inner().s() * self.as_inner().tx()
                + T::TWO * operand.as_inner().ny() * self.as_inner().ps() * self.as_inner().ty()
                + T::TWO * operand.as_inner().ny() * self.as_inner().tx() * self.as_inner().tz()
                + T::TWO * operand.as_inner().nz() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.as_inner().nz() * self.as_inner().rz() * self.as_inner().s()
                + operand.as_inner().dist(),
            -T::TWO * operand.as_inner().ny() * self.as_inner().ry() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().tx() * self.as_inner().tx()
                + T::TWO * operand.as_inner().nx() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.as_inner().nx() * self.as_inner().rz() * self.as_inner().tx()
                + T::TWO * operand.as_inner().ny() * self.as_inner().ps() * self.as_inner().tx()
                + operand.as_inner().nz(),
            -T::TWO * operand.as_inner().nx() * self.as_inner().ry() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().tx() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().ps() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().ry() * self.as_inner().rz()
                + T::TWO * operand.as_inner().nx() * self.as_inner().ps() * self.as_inner().rz()
                + operand.as_inner().ny(),
            -T::TWO * operand.as_inner().nx() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().nx() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().ps() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().ry() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.as_inner().nz() * self.as_inner().rz() * self.as_inner().tx()
                + operand.as_inner().nx(),
        )
    }
}
#[doc = "Antisandwich product: [`Motor`] x [`Line`] x antirev([`Motor`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Motor<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            -(self.ps() * operand.dir_x() * self.ty())
                - self.ps() * operand.dir_y() * self.rx()
                - self.ps() * operand.dir_z() * self.s()
                + self.ps() * operand.moment_x() * self.ry()
                + self.ps() * operand.moment_y() * self.tx()
                + self.ps() * operand.moment_z() * self.ps()
                + self.rx() * operand.dir_x() * self.rz()
                - self.rx() * operand.dir_y() * self.ps()
                - self.rx() * operand.dir_z() * self.tx()
                - self.ry() * operand.dir_x() * self.s()
                + self.ry() * operand.dir_y() * self.tz()
                + self.ry() * operand.dir_z() * self.ty()
                + self.ry() * operand.moment_x() * self.ps()
                - self.ry() * operand.moment_y() * self.rz()
                - self.ry() * operand.moment_z() * self.ry()
                + self.rz() * operand.dir_x() * self.rx()
                - self.rz() * operand.dir_y() * self.ty()
                + self.rz() * operand.dir_z() * self.tz()
                + self.rz() * operand.moment_x() * self.tx()
                - self.rz() * operand.moment_y() * self.ry()
                + self.rz() * operand.moment_z() * self.rz()
                - self.s() * operand.dir_x() * self.ry()
                + self.s() * operand.dir_y() * self.tx()
                - self.s() * operand.dir_z() * self.ps()
                + self.tx() * operand.dir_x() * self.tz()
                + self.tx() * operand.dir_y() * self.s()
                - self.tx() * operand.dir_z() * self.rx()
                + self.tx() * operand.moment_x() * self.rz()
                + self.tx() * operand.moment_y() * self.ps()
                - self.tx() * operand.moment_z() * self.tx()
                - self.ty() * operand.dir_x() * self.ps()
                - self.ty() * operand.dir_y() * self.rz()
                + self.ty() * operand.dir_z() * self.ry()
                + self.tz() * operand.dir_x() * self.tx()
                + self.tz() * operand.dir_y() * self.ry()
                + self.tz() * operand.dir_z() * self.rz(),
            self.ps() * operand.dir_x() * self.tz() + self.ps() * operand.dir_y() * self.s()
                - self.ps() * operand.dir_z() * self.rx()
                + self.ps() * operand.moment_x() * self.rz()
                + self.ps() * operand.moment_y() * self.ps()
                - self.ps() * operand.moment_z() * self.tx()
                - self.rx() * operand.dir_x() * self.ry()
                + self.rx() * operand.dir_y() * self.tx()
                - self.rx() * operand.dir_z() * self.ps()
                - self.ry() * operand.dir_x() * self.rx()
                + self.ry() * operand.dir_y() * self.ty()
                - self.ry() * operand.dir_z() * self.tz()
                - self.ry() * operand.moment_x() * self.tx()
                + self.ry() * operand.moment_y() * self.ry()
                - self.ry() * operand.moment_z() * self.rz()
                - self.rz() * operand.dir_x() * self.s()
                + self.rz() * operand.dir_y() * self.tz()
                + self.rz() * operand.dir_z() * self.ty()
                + self.rz() * operand.moment_x() * self.ps()
                - self.rz() * operand.moment_y() * self.rz()
                - self.rz() * operand.moment_z() * self.ry()
                - self.s() * operand.dir_x() * self.rz()
                + self.s() * operand.dir_y() * self.ps()
                + self.s() * operand.dir_z() * self.tx()
                + self.tx() * operand.dir_x() * self.ty()
                + self.tx() * operand.dir_y() * self.rx()
                + self.tx() * operand.dir_z() * self.s()
                - self.tx() * operand.moment_x() * self.ry()
                - self.tx() * operand.moment_y() * self.tx()
                - self.tx() * operand.moment_z() * self.ps()
                + self.ty() * operand.dir_x() * self.tx()
                + self.ty() * operand.dir_y() * self.ry()
                + self.ty() * operand.dir_z() * self.rz()
                + self.tz() * operand.dir_x() * self.ps()
                + self.tz() * operand.dir_y() * self.rz()
                - self.tz() * operand.dir_z() * self.ry(),
            self.ps() * operand.dir_x() * self.ps() + self.ps() * operand.dir_y() * self.rz()
                - self.ps() * operand.dir_z() * self.ry()
                - self.ry() * operand.dir_x() * self.ry()
                + self.ry() * operand.dir_y() * self.tx()
                - self.ry() * operand.dir_z() * self.ps()
                - self.rz() * operand.dir_x() * self.rz()
                + self.rz() * operand.dir_y() * self.ps()
                + self.rz() * operand.dir_z() * self.tx()
                + self.tx() * operand.dir_x() * self.tx()
                + self.tx() * operand.dir_y() * self.ry()
                + self.tx() * operand.dir_z() * self.rz(),
            -(self.ps() * operand.dir_x() * self.s())
                + self.ps() * operand.dir_y() * self.tz()
                + self.ps() * operand.dir_z() * self.ty()
                + self.ps() * operand.moment_x() * self.ps()
                - self.ps() * operand.moment_y() * self.rz()
                - self.ps() * operand.moment_z() * self.ry()
                + self.rx() * operand.dir_x() * self.tx()
                + self.rx() * operand.dir_y() * self.ry()
                + self.rx() * operand.dir_z() * self.rz()
                + self.ry() * operand.dir_x() * self.ty()
                + self.ry() * operand.dir_y() * self.rx()
                + self.ry() * operand.dir_z() * self.s()
                - self.ry() * operand.moment_x() * self.ry()
                - self.ry() * operand.moment_y() * self.tx()
                - self.ry() * operand.moment_z() * self.ps()
                - self.rz() * operand.dir_x() * self.tz()
                - self.rz() * operand.dir_y() * self.s()
                + self.rz() * operand.dir_z() * self.rx()
                - self.rz() * operand.moment_x() * self.rz()
                - self.rz() * operand.moment_y() * self.ps()
                + self.rz() * operand.moment_z() * self.tx()
                - self.s() * operand.dir_x() * self.ps()
                - self.s() * operand.dir_y() * self.rz()
                + self.s() * operand.dir_z() * self.ry()
                + self.tx() * operand.dir_x() * self.rx()
                - self.tx() * operand.dir_y() * self.ty()
                + self.tx() * operand.dir_z() * self.tz()
                + self.tx() * operand.moment_x() * self.tx()
                - self.tx() * operand.moment_y() * self.ry()
                + self.tx() * operand.moment_z() * self.rz()
                + self.ty() * operand.dir_x() * self.ry()
                - self.ty() * operand.dir_y() * self.tx()
                + self.ty() * operand.dir_z() * self.ps()
                - self.tz() * operand.dir_x() * self.rz()
                + self.tz() * operand.dir_y() * self.ps()
                + self.tz() * operand.dir_z() * self.tx(),
            -(self.ps() * operand.dir_x() * self.rz())
                + self.ps() * operand.dir_y() * self.ps()
                + self.ps() * operand.dir_z() * self.tx()
                + self.ry() * operand.dir_x() * self.tx()
                + self.ry() * operand.dir_y() * self.ry()
                + self.ry() * operand.dir_z() * self.rz()
                - self.rz() * operand.dir_x() * self.ps()
                - self.rz() * operand.dir_y() * self.rz()
                + self.rz() * operand.dir_z() * self.ry()
                + self.tx() * operand.dir_x() * self.ry()
                - self.tx() * operand.dir_y() * self.tx()
                + self.tx() * operand.dir_z() * self.ps(),
            self.ps() * operand.dir_x() * self.ry() - self.ps() * operand.dir_y() * self.tx()
                + self.ps() * operand.dir_z() * self.ps()
                + self.ry() * operand.dir_x() * self.ps()
                + self.ry() * operand.dir_y() * self.rz()
                - self.ry() * operand.dir_z() * self.ry()
                + self.rz() * operand.dir_x() * self.tx()
                + self.rz() * operand.dir_y() * self.ry()
                + self.rz() * operand.dir_z() * self.rz()
                + self.tx() * operand.dir_x() * self.rz()
                - self.tx() * operand.dir_y() * self.ps()
                - self.tx() * operand.dir_z() * self.tx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Unitized<Motor<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            -T::TWO * operand.dir_x() * self.as_inner().ps() * self.as_inner().ty()
                + -T::TWO * operand.dir_x() * self.as_inner().ry() * self.as_inner().s()
                + -T::TWO * operand.dir_y() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.dir_y() * self.as_inner().rz() * self.as_inner().ty()
                + -T::TWO * operand.moment_y() * self.as_inner().ry() * self.as_inner().rz()
                + -T::TWO * operand.moment_z() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.moment_z() * self.as_inner().tx() * self.as_inner().tx()
                + T::TWO * operand.dir_x() * self.as_inner().rx() * self.as_inner().rz()
                + T::TWO * operand.dir_x() * self.as_inner().tx() * self.as_inner().tz()
                + T::TWO * operand.dir_y() * self.as_inner().ry() * self.as_inner().tz()
                + T::TWO * operand.dir_y() * self.as_inner().s() * self.as_inner().tx()
                + T::TWO * operand.moment_x() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.moment_x() * self.as_inner().rz() * self.as_inner().tx()
                + T::TWO * operand.moment_y() * self.as_inner().ps() * self.as_inner().tx()
                + T::from_i8(-4i8) * operand.dir_z() * self.as_inner().rx() * self.as_inner().tx()
                + T::from_i8(4i8) * operand.dir_z() * self.as_inner().ry() * self.as_inner().ty()
                + operand.moment_z(),
            -T::TWO * operand.dir_x() * self.as_inner().rx() * self.as_inner().ry()
                + -T::TWO * operand.dir_x() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.dir_z() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.dir_z() * self.as_inner().ry() * self.as_inner().tz()
                + -T::TWO * operand.moment_x() * self.as_inner().ry() * self.as_inner().tx()
                + -T::TWO * operand.moment_y() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.moment_y() * self.as_inner().tx() * self.as_inner().tx()
                + -T::TWO * operand.moment_z() * self.as_inner().ps() * self.as_inner().tx()
                + -T::TWO * operand.moment_z() * self.as_inner().ry() * self.as_inner().rz()
                + T::TWO * operand.dir_x() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.dir_x() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.dir_z() * self.as_inner().rz() * self.as_inner().ty()
                + T::TWO * operand.dir_z() * self.as_inner().s() * self.as_inner().tx()
                + T::TWO * operand.moment_x() * self.as_inner().ps() * self.as_inner().rz()
                + T::from_i8(4i8) * operand.dir_y() * self.as_inner().rx() * self.as_inner().tx()
                + T::from_i8(4i8) * operand.dir_y() * self.as_inner().rz() * self.as_inner().tz()
                + operand.moment_y(),
            -T::TWO * operand.dir_x() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.dir_x() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.dir_z() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.dir_y() * self.as_inner().ps() * self.as_inner().rz()
                + T::TWO * operand.dir_y() * self.as_inner().ry() * self.as_inner().tx()
                + T::TWO * operand.dir_z() * self.as_inner().rz() * self.as_inner().tx()
                + operand.dir_x(),
            -T::TWO * operand.dir_y() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.dir_y() * self.as_inner().tx() * self.as_inner().ty()
                + -T::TWO * operand.moment_x() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.moment_x() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.moment_y() * self.as_inner().ps() * self.as_inner().rz()
                + -T::TWO * operand.moment_y() * self.as_inner().ry() * self.as_inner().tx()
                + -T::TWO * operand.moment_z() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.dir_y() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.dir_y() * self.as_inner().rx() * self.as_inner().ry()
                + T::TWO * operand.dir_z() * self.as_inner().ps() * self.as_inner().ty()
                + T::TWO * operand.dir_z() * self.as_inner().rx() * self.as_inner().rz()
                + T::TWO * operand.dir_z() * self.as_inner().ry() * self.as_inner().s()
                + T::TWO * operand.dir_z() * self.as_inner().tx() * self.as_inner().tz()
                + T::TWO * operand.moment_z() * self.as_inner().rz() * self.as_inner().tx()
                + T::from_i8(-4i8) * operand.dir_x() * self.as_inner().rz() * self.as_inner().tz()
                + T::from_i8(4i8) * operand.dir_x() * self.as_inner().ry() * self.as_inner().ty()
                + operand.moment_x(),
            -T::TWO * operand.dir_x() * self.as_inner().ps() * self.as_inner().rz()
                + -T::TWO * operand.dir_y() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.dir_y() * self.as_inner().tx() * self.as_inner().tx()
                + T::TWO * operand.dir_x() * self.as_inner().ry() * self.as_inner().tx()
                + T::TWO * operand.dir_z() * self.as_inner().ps() * self.as_inner().tx()
                + T::TWO * operand.dir_z() * self.as_inner().ry() * self.as_inner().rz()
                + operand.dir_y(),
            -T::TWO * operand.dir_y() * self.as_inner().ps() * self.as_inner().tx()
                + -T::TWO * operand.dir_z() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.dir_z() * self.as_inner().tx() * self.as_inner().tx()
                + T::TWO * operand.dir_x() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.dir_x() * self.as_inner().rz() * self.as_inner().tx()
                + T::TWO * operand.dir_y() * self.as_inner().ry() * self.as_inner().rz()
                + operand.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Line<T>>> for Motor<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(operand.as_inner().moment_z() * self.ry() * self.ry())
                + -(operand.as_inner().moment_z() * self.tx() * self.tx())
                + -T::TWO * operand.as_inner().dir_x() * self.ps() * self.ty()
                + -T::TWO * operand.as_inner().dir_x() * self.ry() * self.s()
                + -T::TWO * operand.as_inner().dir_y() * self.ps() * self.rx()
                + -T::TWO * operand.as_inner().dir_y() * self.rz() * self.ty()
                + -T::TWO * operand.as_inner().moment_y() * self.ry() * self.rz()
                + T::TWO * operand.as_inner().dir_x() * self.rx() * self.rz()
                + T::TWO * operand.as_inner().dir_x() * self.tx() * self.tz()
                + T::TWO * operand.as_inner().dir_y() * self.ry() * self.tz()
                + T::TWO * operand.as_inner().dir_y() * self.s() * self.tx()
                + T::TWO * operand.as_inner().moment_x() * self.ps() * self.ry()
                + T::TWO * operand.as_inner().moment_x() * self.rz() * self.tx()
                + T::TWO * operand.as_inner().moment_y() * self.ps() * self.tx()
                + T::from_i8(-4i8) * operand.as_inner().dir_z() * self.rx() * self.tx()
                + T::from_i8(4i8) * operand.as_inner().dir_z() * self.ry() * self.ty()
                + operand.as_inner().moment_z() * self.ps() * self.ps()
                + operand.as_inner().moment_z() * self.rz() * self.rz(),
            -(operand.as_inner().moment_y() * self.rz() * self.rz())
                + -(operand.as_inner().moment_y() * self.tx() * self.tx())
                + -T::TWO * operand.as_inner().dir_x() * self.rx() * self.ry()
                + -T::TWO * operand.as_inner().dir_x() * self.rz() * self.s()
                + -T::TWO * operand.as_inner().dir_z() * self.ps() * self.rx()
                + -T::TWO * operand.as_inner().dir_z() * self.ry() * self.tz()
                + -T::TWO * operand.as_inner().moment_x() * self.ry() * self.tx()
                + -T::TWO * operand.as_inner().moment_z() * self.ps() * self.tx()
                + -T::TWO * operand.as_inner().moment_z() * self.ry() * self.rz()
                + T::TWO * operand.as_inner().dir_x() * self.ps() * self.tz()
                + T::TWO * operand.as_inner().dir_x() * self.tx() * self.ty()
                + T::TWO * operand.as_inner().dir_z() * self.rz() * self.ty()
                + T::TWO * operand.as_inner().dir_z() * self.s() * self.tx()
                + T::TWO * operand.as_inner().moment_x() * self.ps() * self.rz()
                + T::from_i8(4i8) * operand.as_inner().dir_y() * self.rx() * self.tx()
                + T::from_i8(4i8) * operand.as_inner().dir_y() * self.rz() * self.tz()
                + operand.as_inner().moment_y() * self.ps() * self.ps()
                + operand.as_inner().moment_y() * self.ry() * self.ry(),
            -(operand.as_inner().dir_x() * self.ry() * self.ry())
                + -(operand.as_inner().dir_x() * self.rz() * self.rz())
                + -T::TWO * operand.as_inner().dir_z() * self.ps() * self.ry()
                + T::TWO * operand.as_inner().dir_y() * self.ps() * self.rz()
                + T::TWO * operand.as_inner().dir_y() * self.ry() * self.tx()
                + T::TWO * operand.as_inner().dir_z() * self.rz() * self.tx()
                + operand.as_inner().dir_x() * self.ps() * self.ps()
                + operand.as_inner().dir_x() * self.tx() * self.tx(),
            -(operand.as_inner().moment_x() * self.ry() * self.ry())
                + -(operand.as_inner().moment_x() * self.rz() * self.rz())
                + -T::TWO * operand.as_inner().dir_y() * self.rz() * self.s()
                + -T::TWO * operand.as_inner().dir_y() * self.tx() * self.ty()
                + -T::TWO * operand.as_inner().moment_y() * self.ps() * self.rz()
                + -T::TWO * operand.as_inner().moment_y() * self.ry() * self.tx()
                + -T::TWO * operand.as_inner().moment_z() * self.ps() * self.ry()
                + T::TWO * operand.as_inner().dir_y() * self.ps() * self.tz()
                + T::TWO * operand.as_inner().dir_y() * self.rx() * self.ry()
                + T::TWO * operand.as_inner().dir_z() * self.ps() * self.ty()
                + T::TWO * operand.as_inner().dir_z() * self.rx() * self.rz()
                + T::TWO * operand.as_inner().dir_z() * self.ry() * self.s()
                + T::TWO * operand.as_inner().dir_z() * self.tx() * self.tz()
                + T::TWO * operand.as_inner().moment_z() * self.rz() * self.tx()
                + T::from_i8(-4i8) * operand.as_inner().dir_x() * self.rz() * self.tz()
                + T::from_i8(4i8) * operand.as_inner().dir_x() * self.ry() * self.ty()
                + operand.as_inner().moment_x() * self.ps() * self.ps()
                + operand.as_inner().moment_x() * self.tx() * self.tx(),
            -(operand.as_inner().dir_y() * self.rz() * self.rz())
                + -(operand.as_inner().dir_y() * self.tx() * self.tx())
                + -T::TWO * operand.as_inner().dir_x() * self.ps() * self.rz()
                + T::TWO * operand.as_inner().dir_x() * self.ry() * self.tx()
                + T::TWO * operand.as_inner().dir_z() * self.ps() * self.tx()
                + T::TWO * operand.as_inner().dir_z() * self.ry() * self.rz()
                + operand.as_inner().dir_y() * self.ps() * self.ps()
                + operand.as_inner().dir_y() * self.ry() * self.ry(),
            -(operand.as_inner().dir_z() * self.ry() * self.ry())
                + -(operand.as_inner().dir_z() * self.tx() * self.tx())
                + -T::TWO * operand.as_inner().dir_y() * self.ps() * self.tx()
                + T::TWO * operand.as_inner().dir_x() * self.ps() * self.ry()
                + T::TWO * operand.as_inner().dir_x() * self.rz() * self.tx()
                + T::TWO * operand.as_inner().dir_y() * self.ry() * self.rz()
                + operand.as_inner().dir_z() * self.ps() * self.ps()
                + operand.as_inner().dir_z() * self.rz() * self.rz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Line<T>>> for Unitized<Motor<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -T::TWO * operand.as_inner().dir_x() * self.as_inner().ps() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().dir_x() * self.as_inner().ry() * self.as_inner().s()
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().ps()
                    * self.as_inner().rx()
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().rz()
                    * self.as_inner().ty()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().ry()
                    * self.as_inner().rz()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().ry()
                    * self.as_inner().ry()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().tx()
                    * self.as_inner().tx()
                + T::TWO * operand.as_inner().dir_x() * self.as_inner().rx() * self.as_inner().rz()
                + T::TWO * operand.as_inner().dir_x() * self.as_inner().tx() * self.as_inner().tz()
                + T::TWO * operand.as_inner().dir_y() * self.as_inner().ry() * self.as_inner().tz()
                + T::TWO * operand.as_inner().dir_y() * self.as_inner().s() * self.as_inner().tx()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().ps()
                    * self.as_inner().ry()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().rz()
                    * self.as_inner().tx()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().ps()
                    * self.as_inner().tx()
                + T::from_i8(-4i8)
                    * operand.as_inner().dir_z()
                    * self.as_inner().rx()
                    * self.as_inner().tx()
                + T::from_i8(4i8)
                    * operand.as_inner().dir_z()
                    * self.as_inner().ry()
                    * self.as_inner().ty()
                + operand.as_inner().moment_z(),
            -T::TWO * operand.as_inner().dir_x() * self.as_inner().rx() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().dir_x() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().ps()
                    * self.as_inner().rx()
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().ry()
                    * self.as_inner().tz()
                + -T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().ry()
                    * self.as_inner().tx()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().rz()
                    * self.as_inner().rz()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().tx()
                    * self.as_inner().tx()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().ps()
                    * self.as_inner().tx()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().ry()
                    * self.as_inner().rz()
                + T::TWO * operand.as_inner().dir_x() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.as_inner().dir_x() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().rz() * self.as_inner().ty()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().s() * self.as_inner().tx()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().ps()
                    * self.as_inner().rz()
                + T::from_i8(4i8)
                    * operand.as_inner().dir_y()
                    * self.as_inner().rx()
                    * self.as_inner().tx()
                + T::from_i8(4i8)
                    * operand.as_inner().dir_y()
                    * self.as_inner().rz()
                    * self.as_inner().tz()
                + operand.as_inner().moment_y(),
            -T::TWO * operand.as_inner().dir_x() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().rz()
                    * self.as_inner().rz()
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().ps()
                    * self.as_inner().ry()
                + T::TWO * operand.as_inner().dir_y() * self.as_inner().ps() * self.as_inner().rz()
                + T::TWO * operand.as_inner().dir_y() * self.as_inner().ry() * self.as_inner().tx()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().rz() * self.as_inner().tx()
                + operand.as_inner().dir_x(),
            -T::TWO * operand.as_inner().dir_y() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().tx()
                    * self.as_inner().ty()
                + -T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().ry()
                    * self.as_inner().ry()
                + -T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().rz()
                    * self.as_inner().rz()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().ps()
                    * self.as_inner().rz()
                + -T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().ry()
                    * self.as_inner().tx()
                + -T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().ps()
                    * self.as_inner().ry()
                + T::TWO * operand.as_inner().dir_y() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.as_inner().dir_y() * self.as_inner().rx() * self.as_inner().ry()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().ps() * self.as_inner().ty()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().rx() * self.as_inner().rz()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().ry() * self.as_inner().s()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().tx() * self.as_inner().tz()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().rz()
                    * self.as_inner().tx()
                + T::from_i8(-4i8)
                    * operand.as_inner().dir_x()
                    * self.as_inner().rz()
                    * self.as_inner().tz()
                + T::from_i8(4i8)
                    * operand.as_inner().dir_x()
                    * self.as_inner().ry()
                    * self.as_inner().ty()
                + operand.as_inner().moment_x(),
            -T::TWO * operand.as_inner().dir_x() * self.as_inner().ps() * self.as_inner().rz()
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().rz()
                    * self.as_inner().rz()
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().tx()
                    * self.as_inner().tx()
                + T::TWO * operand.as_inner().dir_x() * self.as_inner().ry() * self.as_inner().tx()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().ps() * self.as_inner().tx()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().ry() * self.as_inner().rz()
                + operand.as_inner().dir_y(),
            -T::TWO * operand.as_inner().dir_y() * self.as_inner().ps() * self.as_inner().tx()
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().ry()
                    * self.as_inner().ry()
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().tx()
                    * self.as_inner().tx()
                + T::TWO * operand.as_inner().dir_x() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.as_inner().dir_x() * self.as_inner().rz() * self.as_inner().tx()
                + T::TWO * operand.as_inner().dir_y() * self.as_inner().ry() * self.as_inner().rz()
                + operand.as_inner().dir_z(),
        )
    }
}
#[doc = "Antisandwich product: [`Motor`] x [`Motor`] x antirev([`Motor`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Motor<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            self.ps() * operand.ps() * self.s() - self.ps() * operand.rx() * self.tx()
                + self.ps() * operand.ry() * self.ty()
                - self.ps() * operand.rz() * self.tz()
                + self.ps() * operand.s() * self.ps()
                - self.ps() * operand.tx() * self.rx()
                + self.ps() * operand.ty() * self.ry()
                - self.ps() * operand.tz() * self.rz()
                - self.rx() * operand.ps() * self.tx()
                + self.rx() * operand.ry() * self.rz()
                - self.rx() * operand.rz() * self.ry()
                + self.rx() * operand.tx() * self.ps()
                + self.ry() * operand.ps() * self.ty()
                - self.ry() * operand.rx() * self.rz()
                - self.ry() * operand.ry() * self.s()
                + self.ry() * operand.rz() * self.rx()
                + self.ry() * operand.s() * self.ry()
                - self.ry() * operand.tx() * self.tz()
                - self.ry() * operand.ty() * self.ps()
                + self.ry() * operand.tz() * self.tx()
                - self.rz() * operand.ps() * self.tz()
                + self.rz() * operand.rx() * self.ry()
                - self.rz() * operand.ry() * self.rx()
                - self.rz() * operand.rz() * self.s()
                + self.rz() * operand.s() * self.rz()
                - self.rz() * operand.tx() * self.ty()
                + self.rz() * operand.ty() * self.tx()
                + self.rz() * operand.tz() * self.ps()
                + self.s() * operand.ps() * self.ps()
                + self.s() * operand.ry() * self.ry()
                + self.s() * operand.rz() * self.rz()
                + self.s() * operand.tx() * self.tx()
                - self.tx() * operand.ps() * self.rx()
                + self.tx() * operand.rx() * self.ps()
                + self.tx() * operand.ry() * self.tz()
                + self.tx() * operand.rz() * self.ty()
                + self.tx() * operand.s() * self.tx()
                - self.tx() * operand.tx() * self.s()
                - self.tx() * operand.ty() * self.rz()
                - self.tx() * operand.tz() * self.ry()
                + self.ty() * operand.ps() * self.ry()
                - self.ty() * operand.ry() * self.ps()
                - self.ty() * operand.rz() * self.tx()
                + self.ty() * operand.tx() * self.rz()
                - self.tz() * operand.ps() * self.rz()
                - self.tz() * operand.ry() * self.tx()
                + self.tz() * operand.rz() * self.ps()
                + self.tz() * operand.tx() * self.ry(),
            -(self.ps() * operand.ps() * self.tz()) + self.ps() * operand.rx() * self.ry()
                - self.ps() * operand.ry() * self.rx()
                - self.ps() * operand.rz() * self.s()
                + self.ps() * operand.s() * self.rz()
                - self.ps() * operand.tx() * self.ty()
                + self.ps() * operand.ty() * self.tx()
                + self.ps() * operand.tz() * self.ps()
                + self.rx() * operand.ps() * self.ry()
                - self.rx() * operand.ry() * self.ps()
                - self.rx() * operand.rz() * self.tx()
                + self.rx() * operand.tx() * self.rz()
                - self.ry() * operand.ps() * self.rx()
                + self.ry() * operand.rx() * self.ps()
                + self.ry() * operand.ry() * self.tz()
                + self.ry() * operand.rz() * self.ty()
                + self.ry() * operand.s() * self.tx()
                - self.ry() * operand.tx() * self.s()
                - self.ry() * operand.ty() * self.rz()
                - self.ry() * operand.tz() * self.ry()
                - self.rz() * operand.ps() * self.s()
                + self.rz() * operand.rx() * self.tx()
                - self.rz() * operand.ry() * self.ty()
                + self.rz() * operand.rz() * self.tz()
                - self.rz() * operand.s() * self.ps()
                + self.rz() * operand.tx() * self.rx()
                - self.rz() * operand.ty() * self.ry()
                + self.rz() * operand.tz() * self.rz()
                + self.s() * operand.ps() * self.rz()
                + self.s() * operand.ry() * self.tx()
                - self.s() * operand.rz() * self.ps()
                - self.s() * operand.tx() * self.ry()
                - self.tx() * operand.ps() * self.ty()
                + self.tx() * operand.rx() * self.rz()
                + self.tx() * operand.ry() * self.s()
                - self.tx() * operand.rz() * self.rx()
                - self.tx() * operand.s() * self.ry()
                + self.tx() * operand.tx() * self.tz()
                + self.tx() * operand.ty() * self.ps()
                - self.tx() * operand.tz() * self.tx()
                + self.ty() * operand.ps() * self.tx()
                - self.ty() * operand.ry() * self.rz()
                + self.ty() * operand.rz() * self.ry()
                - self.ty() * operand.tx() * self.ps()
                + self.tz() * operand.ps() * self.ps()
                + self.tz() * operand.ry() * self.ry()
                + self.tz() * operand.rz() * self.rz()
                + self.tz() * operand.tx() * self.tx(),
            -(self.ps() * operand.ps() * self.ty())
                + self.ps() * operand.rx() * self.rz()
                + self.ps() * operand.ry() * self.s()
                - self.ps() * operand.rz() * self.rx()
                - self.ps() * operand.s() * self.ry()
                + self.ps() * operand.tx() * self.tz()
                + self.ps() * operand.ty() * self.ps()
                - self.ps() * operand.tz() * self.tx()
                + self.rx() * operand.ps() * self.rz()
                + self.rx() * operand.ry() * self.tx()
                - self.rx() * operand.rz() * self.ps()
                - self.rx() * operand.tx() * self.ry()
                + self.ry() * operand.ps() * self.s()
                - self.ry() * operand.rx() * self.tx()
                + self.ry() * operand.ry() * self.ty()
                - self.ry() * operand.rz() * self.tz()
                + self.ry() * operand.s() * self.ps()
                - self.ry() * operand.tx() * self.rx()
                + self.ry() * operand.ty() * self.ry()
                - self.ry() * operand.tz() * self.rz()
                - self.rz() * operand.ps() * self.rx()
                + self.rz() * operand.rx() * self.ps()
                + self.rz() * operand.ry() * self.tz()
                + self.rz() * operand.rz() * self.ty()
                + self.rz() * operand.s() * self.tx()
                - self.rz() * operand.tx() * self.s()
                - self.rz() * operand.ty() * self.rz()
                - self.rz() * operand.tz() * self.ry()
                - self.s() * operand.ps() * self.ry()
                + self.s() * operand.ry() * self.ps()
                + self.s() * operand.rz() * self.tx()
                - self.s() * operand.tx() * self.rz()
                + self.tx() * operand.ps() * self.tz()
                - self.tx() * operand.rx() * self.ry()
                + self.tx() * operand.ry() * self.rx()
                + self.tx() * operand.rz() * self.s()
                - self.tx() * operand.s() * self.rz()
                + self.tx() * operand.tx() * self.ty()
                - self.tx() * operand.ty() * self.tx()
                - self.tx() * operand.tz() * self.ps()
                + self.ty() * operand.ps() * self.ps()
                + self.ty() * operand.ry() * self.ry()
                + self.ty() * operand.rz() * self.rz()
                + self.ty() * operand.tx() * self.tx()
                - self.tz() * operand.ps() * self.tx()
                + self.tz() * operand.ry() * self.rz()
                - self.tz() * operand.rz() * self.ry()
                + self.tz() * operand.tx() * self.ps(),
            -(self.ps() * operand.ps() * self.tx()) + self.ps() * operand.ry() * self.rz()
                - self.ps() * operand.rz() * self.ry()
                + self.ps() * operand.tx() * self.ps()
                + self.ry() * operand.ps() * self.rz()
                + self.ry() * operand.ry() * self.tx()
                - self.ry() * operand.rz() * self.ps()
                - self.ry() * operand.tx() * self.ry()
                - self.rz() * operand.ps() * self.ry()
                + self.rz() * operand.ry() * self.ps()
                + self.rz() * operand.rz() * self.tx()
                - self.rz() * operand.tx() * self.rz()
                + self.tx() * operand.ps() * self.ps()
                + self.tx() * operand.ry() * self.ry()
                + self.tx() * operand.rz() * self.rz()
                + self.tx() * operand.tx() * self.tx(),
            -(self.ps() * operand.ps() * self.rx())
                + self.ps() * operand.rx() * self.ps()
                + self.ps() * operand.ry() * self.tz()
                + self.ps() * operand.rz() * self.ty()
                + self.ps() * operand.s() * self.tx()
                - self.ps() * operand.tx() * self.s()
                - self.ps() * operand.ty() * self.rz()
                - self.ps() * operand.tz() * self.ry()
                + self.rx() * operand.ps() * self.ps()
                + self.rx() * operand.ry() * self.ry()
                + self.rx() * operand.rz() * self.rz()
                + self.rx() * operand.tx() * self.tx()
                + self.ry() * operand.ps() * self.tz()
                - self.ry() * operand.rx() * self.ry()
                + self.ry() * operand.ry() * self.rx()
                + self.ry() * operand.rz() * self.s()
                - self.ry() * operand.s() * self.rz()
                + self.ry() * operand.tx() * self.ty()
                - self.ry() * operand.ty() * self.tx()
                - self.ry() * operand.tz() * self.ps()
                + self.rz() * operand.ps() * self.ty()
                - self.rz() * operand.rx() * self.rz()
                - self.rz() * operand.ry() * self.s()
                + self.rz() * operand.rz() * self.rx()
                + self.rz() * operand.s() * self.ry()
                - self.rz() * operand.tx() * self.tz()
                - self.rz() * operand.ty() * self.ps()
                + self.rz() * operand.tz() * self.tx()
                + self.s() * operand.ps() * self.tx()
                - self.s() * operand.ry() * self.rz()
                + self.s() * operand.rz() * self.ry()
                - self.s() * operand.tx() * self.ps()
                - self.tx() * operand.ps() * self.s()
                + self.tx() * operand.rx() * self.tx()
                - self.tx() * operand.ry() * self.ty()
                + self.tx() * operand.rz() * self.tz()
                - self.tx() * operand.s() * self.ps()
                + self.tx() * operand.tx() * self.rx()
                - self.tx() * operand.ty() * self.ry()
                + self.tx() * operand.tz() * self.rz()
                - self.ty() * operand.ps() * self.rz()
                - self.ty() * operand.ry() * self.tx()
                + self.ty() * operand.rz() * self.ps()
                + self.ty() * operand.tx() * self.ry()
                - self.tz() * operand.ps() * self.ry()
                + self.tz() * operand.ry() * self.ps()
                + self.tz() * operand.rz() * self.tx()
                - self.tz() * operand.tx() * self.rz(),
            -(self.ps() * operand.ps() * self.ry())
                + self.ps() * operand.ry() * self.ps()
                + self.ps() * operand.rz() * self.tx()
                - self.ps() * operand.tx() * self.rz()
                + self.ry() * operand.ps() * self.ps()
                + self.ry() * operand.ry() * self.ry()
                + self.ry() * operand.rz() * self.rz()
                + self.ry() * operand.tx() * self.tx()
                + self.rz() * operand.ps() * self.tx()
                - self.rz() * operand.ry() * self.rz()
                + self.rz() * operand.rz() * self.ry()
                - self.rz() * operand.tx() * self.ps()
                - self.tx() * operand.ps() * self.rz()
                - self.tx() * operand.ry() * self.tx()
                + self.tx() * operand.rz() * self.ps()
                + self.tx() * operand.tx() * self.ry(),
            -(self.ps() * operand.ps() * self.rz()) - self.ps() * operand.ry() * self.tx()
                + self.ps() * operand.rz() * self.ps()
                + self.ps() * operand.tx() * self.ry()
                - self.ry() * operand.ps() * self.tx()
                + self.ry() * operand.ry() * self.rz()
                - self.ry() * operand.rz() * self.ry()
                + self.ry() * operand.tx() * self.ps()
                + self.rz() * operand.ps() * self.ps()
                + self.rz() * operand.ry() * self.ry()
                + self.rz() * operand.rz() * self.rz()
                + self.rz() * operand.tx() * self.tx()
                + self.tx() * operand.ps() * self.ry()
                - self.tx() * operand.ry() * self.ps()
                - self.tx() * operand.rz() * self.tx()
                + self.tx() * operand.tx() * self.rz(),
            self.ps() * operand.ps() * self.ps()
                + self.ps() * operand.ry() * self.ry()
                + self.ps() * operand.rz() * self.rz()
                + self.ps() * operand.tx() * self.tx()
                + self.ry() * operand.ps() * self.ry()
                - self.ry() * operand.ry() * self.ps()
                - self.ry() * operand.rz() * self.tx()
                + self.ry() * operand.tx() * self.rz()
                + self.rz() * operand.ps() * self.rz()
                + self.rz() * operand.ry() * self.tx()
                - self.rz() * operand.rz() * self.ps()
                - self.rz() * operand.tx() * self.ry()
                + self.tx() * operand.ps() * self.tx()
                - self.tx() * operand.ry() * self.rz()
                + self.tx() * operand.rz() * self.ry()
                - self.tx() * operand.tx() * self.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Motor<T>> for Unitized<Motor<T>> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            operand.s(),
            -T::TWO * operand.ry() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.ry() * self.as_inner().rz() * self.as_inner().ty()
                + -T::TWO * operand.tx() * self.as_inner().ps() * self.as_inner().ty()
                + -T::TWO * operand.tx() * self.as_inner().ry() * self.as_inner().s()
                + -T::TWO * operand.ty() * self.as_inner().ry() * self.as_inner().rz()
                + -T::TWO * operand.tz() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.tz() * self.as_inner().tx() * self.as_inner().tx()
                + T::TWO * operand.rx() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.rx() * self.as_inner().rz() * self.as_inner().tx()
                + T::TWO * operand.ry() * self.as_inner().ry() * self.as_inner().tz()
                + T::TWO * operand.ry() * self.as_inner().s() * self.as_inner().tx()
                + T::TWO * operand.tx() * self.as_inner().rx() * self.as_inner().rz()
                + T::TWO * operand.tx() * self.as_inner().tx() * self.as_inner().tz()
                + T::TWO * operand.ty() * self.as_inner().ps() * self.as_inner().tx()
                + T::from_i8(-4i8) * operand.rz() * self.as_inner().rx() * self.as_inner().tx()
                + T::from_i8(4i8) * operand.rz() * self.as_inner().ry() * self.as_inner().ty()
                + operand.tz(),
            -T::TWO * operand.rx() * self.as_inner().ry() * self.as_inner().tx()
                + -T::TWO * operand.rz() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.rz() * self.as_inner().ry() * self.as_inner().tz()
                + -T::TWO * operand.tx() * self.as_inner().rx() * self.as_inner().ry()
                + -T::TWO * operand.tx() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.ty() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.ty() * self.as_inner().tx() * self.as_inner().tx()
                + -T::TWO * operand.tz() * self.as_inner().ps() * self.as_inner().tx()
                + -T::TWO * operand.tz() * self.as_inner().ry() * self.as_inner().rz()
                + T::TWO * operand.rx() * self.as_inner().ps() * self.as_inner().rz()
                + T::TWO * operand.rz() * self.as_inner().rz() * self.as_inner().ty()
                + T::TWO * operand.rz() * self.as_inner().s() * self.as_inner().tx()
                + T::TWO * operand.tx() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.tx() * self.as_inner().tx() * self.as_inner().ty()
                + T::from_i8(4i8) * operand.ry() * self.as_inner().rx() * self.as_inner().tx()
                + T::from_i8(4i8) * operand.ry() * self.as_inner().rz() * self.as_inner().tz()
                + operand.ty(),
            -T::TWO * operand.rz() * self.as_inner().ps() * self.as_inner().ry()
                + -T::TWO * operand.tx() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.tx() * self.as_inner().rz() * self.as_inner().rz()
                + T::TWO * operand.ry() * self.as_inner().ps() * self.as_inner().rz()
                + T::TWO * operand.ry() * self.as_inner().ry() * self.as_inner().tx()
                + T::TWO * operand.rz() * self.as_inner().rz() * self.as_inner().tx()
                + operand.tx(),
            -T::TWO * operand.rx() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.rx() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.ry() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.ry() * self.as_inner().tx() * self.as_inner().ty()
                + -T::TWO * operand.ty() * self.as_inner().ps() * self.as_inner().rz()
                + -T::TWO * operand.ty() * self.as_inner().ry() * self.as_inner().tx()
                + -T::TWO * operand.tz() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.ry() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.ry() * self.as_inner().rx() * self.as_inner().ry()
                + T::TWO * operand.rz() * self.as_inner().ps() * self.as_inner().ty()
                + T::TWO * operand.rz() * self.as_inner().rx() * self.as_inner().rz()
                + T::TWO * operand.rz() * self.as_inner().ry() * self.as_inner().s()
                + T::TWO * operand.rz() * self.as_inner().tx() * self.as_inner().tz()
                + T::TWO * operand.tz() * self.as_inner().rz() * self.as_inner().tx()
                + T::from_i8(-4i8) * operand.tx() * self.as_inner().rz() * self.as_inner().tz()
                + T::from_i8(4i8) * operand.tx() * self.as_inner().ry() * self.as_inner().ty()
                + operand.rx(),
            -T::TWO * operand.ry() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.ry() * self.as_inner().tx() * self.as_inner().tx()
                + -T::TWO * operand.tx() * self.as_inner().ps() * self.as_inner().rz()
                + T::TWO * operand.rz() * self.as_inner().ps() * self.as_inner().tx()
                + T::TWO * operand.rz() * self.as_inner().ry() * self.as_inner().rz()
                + T::TWO * operand.tx() * self.as_inner().ry() * self.as_inner().tx()
                + operand.ry(),
            -T::TWO * operand.ry() * self.as_inner().ps() * self.as_inner().tx()
                + -T::TWO * operand.rz() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.rz() * self.as_inner().tx() * self.as_inner().tx()
                + T::TWO * operand.ry() * self.as_inner().ry() * self.as_inner().rz()
                + T::TWO * operand.tx() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.tx() * self.as_inner().rz() * self.as_inner().tx()
                + operand.rz(),
            operand.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Motor<T>>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s() * self.ps() * self.ps()
                + operand.as_inner().s() * self.ry() * self.ry()
                + operand.as_inner().s() * self.rz() * self.rz()
                + operand.as_inner().s() * self.tx() * self.tx(),
            -(operand.as_inner().tz() * self.ry() * self.ry())
                + -(operand.as_inner().tz() * self.tx() * self.tx())
                + -T::TWO * operand.as_inner().ry() * self.ps() * self.rx()
                + -T::TWO * operand.as_inner().ry() * self.rz() * self.ty()
                + -T::TWO * operand.as_inner().tx() * self.ps() * self.ty()
                + -T::TWO * operand.as_inner().tx() * self.ry() * self.s()
                + -T::TWO * operand.as_inner().ty() * self.ry() * self.rz()
                + T::TWO * operand.as_inner().rx() * self.ps() * self.ry()
                + T::TWO * operand.as_inner().rx() * self.rz() * self.tx()
                + T::TWO * operand.as_inner().ry() * self.ry() * self.tz()
                + T::TWO * operand.as_inner().ry() * self.s() * self.tx()
                + T::TWO * operand.as_inner().tx() * self.rx() * self.rz()
                + T::TWO * operand.as_inner().tx() * self.tx() * self.tz()
                + T::TWO * operand.as_inner().ty() * self.ps() * self.tx()
                + T::from_i8(-4i8) * operand.as_inner().rz() * self.rx() * self.tx()
                + T::from_i8(4i8) * operand.as_inner().rz() * self.ry() * self.ty()
                + operand.as_inner().tz() * self.ps() * self.ps()
                + operand.as_inner().tz() * self.rz() * self.rz(),
            -(operand.as_inner().ty() * self.rz() * self.rz())
                + -(operand.as_inner().ty() * self.tx() * self.tx())
                + -T::TWO * operand.as_inner().rx() * self.ry() * self.tx()
                + -T::TWO * operand.as_inner().rz() * self.ps() * self.rx()
                + -T::TWO * operand.as_inner().rz() * self.ry() * self.tz()
                + -T::TWO * operand.as_inner().tx() * self.rx() * self.ry()
                + -T::TWO * operand.as_inner().tx() * self.rz() * self.s()
                + -T::TWO * operand.as_inner().tz() * self.ps() * self.tx()
                + -T::TWO * operand.as_inner().tz() * self.ry() * self.rz()
                + T::TWO * operand.as_inner().rx() * self.ps() * self.rz()
                + T::TWO * operand.as_inner().rz() * self.rz() * self.ty()
                + T::TWO * operand.as_inner().rz() * self.s() * self.tx()
                + T::TWO * operand.as_inner().tx() * self.ps() * self.tz()
                + T::TWO * operand.as_inner().tx() * self.tx() * self.ty()
                + T::from_i8(4i8) * operand.as_inner().ry() * self.rx() * self.tx()
                + T::from_i8(4i8) * operand.as_inner().ry() * self.rz() * self.tz()
                + operand.as_inner().ty() * self.ps() * self.ps()
                + operand.as_inner().ty() * self.ry() * self.ry(),
            -(operand.as_inner().tx() * self.ry() * self.ry())
                + -(operand.as_inner().tx() * self.rz() * self.rz())
                + -T::TWO * operand.as_inner().rz() * self.ps() * self.ry()
                + T::TWO * operand.as_inner().ry() * self.ps() * self.rz()
                + T::TWO * operand.as_inner().ry() * self.ry() * self.tx()
                + T::TWO * operand.as_inner().rz() * self.rz() * self.tx()
                + operand.as_inner().tx() * self.ps() * self.ps()
                + operand.as_inner().tx() * self.tx() * self.tx(),
            -(operand.as_inner().rx() * self.ry() * self.ry())
                + -(operand.as_inner().rx() * self.rz() * self.rz())
                + -T::TWO * operand.as_inner().ry() * self.rz() * self.s()
                + -T::TWO * operand.as_inner().ry() * self.tx() * self.ty()
                + -T::TWO * operand.as_inner().ty() * self.ps() * self.rz()
                + -T::TWO * operand.as_inner().ty() * self.ry() * self.tx()
                + -T::TWO * operand.as_inner().tz() * self.ps() * self.ry()
                + T::TWO * operand.as_inner().ry() * self.ps() * self.tz()
                + T::TWO * operand.as_inner().ry() * self.rx() * self.ry()
                + T::TWO * operand.as_inner().rz() * self.ps() * self.ty()
                + T::TWO * operand.as_inner().rz() * self.rx() * self.rz()
                + T::TWO * operand.as_inner().rz() * self.ry() * self.s()
                + T::TWO * operand.as_inner().rz() * self.tx() * self.tz()
                + T::TWO * operand.as_inner().tz() * self.rz() * self.tx()
                + T::from_i8(-4i8) * operand.as_inner().tx() * self.rz() * self.tz()
                + T::from_i8(4i8) * operand.as_inner().tx() * self.ry() * self.ty()
                + operand.as_inner().rx() * self.ps() * self.ps()
                + operand.as_inner().rx() * self.tx() * self.tx(),
            -(operand.as_inner().ry() * self.rz() * self.rz())
                + -(operand.as_inner().ry() * self.tx() * self.tx())
                + -T::TWO * operand.as_inner().tx() * self.ps() * self.rz()
                + T::TWO * operand.as_inner().rz() * self.ps() * self.tx()
                + T::TWO * operand.as_inner().rz() * self.ry() * self.rz()
                + T::TWO * operand.as_inner().tx() * self.ry() * self.tx()
                + operand.as_inner().ry() * self.ps() * self.ps()
                + operand.as_inner().ry() * self.ry() * self.ry(),
            -(operand.as_inner().rz() * self.ry() * self.ry())
                + -(operand.as_inner().rz() * self.tx() * self.tx())
                + -T::TWO * operand.as_inner().ry() * self.ps() * self.tx()
                + T::TWO * operand.as_inner().ry() * self.ry() * self.rz()
                + T::TWO * operand.as_inner().tx() * self.ps() * self.ry()
                + T::TWO * operand.as_inner().tx() * self.rz() * self.tx()
                + operand.as_inner().rz() * self.ps() * self.ps()
                + operand.as_inner().rz() * self.rz() * self.rz(),
            operand.as_inner().ps() * self.ps() * self.ps()
                + operand.as_inner().ps() * self.ry() * self.ry()
                + operand.as_inner().ps() * self.rz() * self.rz()
                + operand.as_inner().ps() * self.tx() * self.tx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Motor<T>>> for Unitized<Motor<T>> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s(),
            -T::TWO * operand.as_inner().ry() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.as_inner().ry() * self.as_inner().rz() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().ps() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().ry() * self.as_inner().s()
                + -T::TWO * operand.as_inner().ty() * self.as_inner().ry() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().tz() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().tz() * self.as_inner().tx() * self.as_inner().tx()
                + T::TWO * operand.as_inner().rx() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.as_inner().rx() * self.as_inner().rz() * self.as_inner().tx()
                + T::TWO * operand.as_inner().ry() * self.as_inner().ry() * self.as_inner().tz()
                + T::TWO * operand.as_inner().ry() * self.as_inner().s() * self.as_inner().tx()
                + T::TWO * operand.as_inner().tx() * self.as_inner().rx() * self.as_inner().rz()
                + T::TWO * operand.as_inner().tx() * self.as_inner().tx() * self.as_inner().tz()
                + T::TWO * operand.as_inner().ty() * self.as_inner().ps() * self.as_inner().tx()
                + T::from_i8(-4i8)
                    * operand.as_inner().rz()
                    * self.as_inner().rx()
                    * self.as_inner().tx()
                + T::from_i8(4i8)
                    * operand.as_inner().rz()
                    * self.as_inner().ry()
                    * self.as_inner().ty()
                + operand.as_inner().tz(),
            -T::TWO * operand.as_inner().rx() * self.as_inner().ry() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().rz() * self.as_inner().ps() * self.as_inner().rx()
                + -T::TWO * operand.as_inner().rz() * self.as_inner().ry() * self.as_inner().tz()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().rx() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.as_inner().ty() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().ty() * self.as_inner().tx() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().tz() * self.as_inner().ps() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().tz() * self.as_inner().ry() * self.as_inner().rz()
                + T::TWO * operand.as_inner().rx() * self.as_inner().ps() * self.as_inner().rz()
                + T::TWO * operand.as_inner().rz() * self.as_inner().rz() * self.as_inner().ty()
                + T::TWO * operand.as_inner().rz() * self.as_inner().s() * self.as_inner().tx()
                + T::TWO * operand.as_inner().tx() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.as_inner().tx() * self.as_inner().tx() * self.as_inner().ty()
                + T::from_i8(4i8)
                    * operand.as_inner().ry()
                    * self.as_inner().rx()
                    * self.as_inner().tx()
                + T::from_i8(4i8)
                    * operand.as_inner().ry()
                    * self.as_inner().rz()
                    * self.as_inner().tz()
                + operand.as_inner().ty(),
            -T::TWO * operand.as_inner().rz() * self.as_inner().ps() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().rz() * self.as_inner().rz()
                + T::TWO * operand.as_inner().ry() * self.as_inner().ps() * self.as_inner().rz()
                + T::TWO * operand.as_inner().ry() * self.as_inner().ry() * self.as_inner().tx()
                + T::TWO * operand.as_inner().rz() * self.as_inner().rz() * self.as_inner().tx()
                + operand.as_inner().tx(),
            -T::TWO * operand.as_inner().rx() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().rx() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().ry() * self.as_inner().rz() * self.as_inner().s()
                + -T::TWO * operand.as_inner().ry() * self.as_inner().tx() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().ty() * self.as_inner().ps() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().ty() * self.as_inner().ry() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().tz() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.as_inner().ry() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.as_inner().ry() * self.as_inner().rx() * self.as_inner().ry()
                + T::TWO * operand.as_inner().rz() * self.as_inner().ps() * self.as_inner().ty()
                + T::TWO * operand.as_inner().rz() * self.as_inner().rx() * self.as_inner().rz()
                + T::TWO * operand.as_inner().rz() * self.as_inner().ry() * self.as_inner().s()
                + T::TWO * operand.as_inner().rz() * self.as_inner().tx() * self.as_inner().tz()
                + T::TWO * operand.as_inner().tz() * self.as_inner().rz() * self.as_inner().tx()
                + T::from_i8(-4i8)
                    * operand.as_inner().tx()
                    * self.as_inner().rz()
                    * self.as_inner().tz()
                + T::from_i8(4i8)
                    * operand.as_inner().tx()
                    * self.as_inner().ry()
                    * self.as_inner().ty()
                + operand.as_inner().rx(),
            -T::TWO * operand.as_inner().ry() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().ry() * self.as_inner().tx() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().ps() * self.as_inner().rz()
                + T::TWO * operand.as_inner().rz() * self.as_inner().ps() * self.as_inner().tx()
                + T::TWO * operand.as_inner().rz() * self.as_inner().ry() * self.as_inner().rz()
                + T::TWO * operand.as_inner().tx() * self.as_inner().ry() * self.as_inner().tx()
                + operand.as_inner().ry(),
            -T::TWO * operand.as_inner().ry() * self.as_inner().ps() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().rz() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().rz() * self.as_inner().tx() * self.as_inner().tx()
                + T::TWO * operand.as_inner().ry() * self.as_inner().ry() * self.as_inner().rz()
                + T::TWO * operand.as_inner().tx() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.as_inner().tx() * self.as_inner().rz() * self.as_inner().tx()
                + operand.as_inner().rz(),
            operand.as_inner().ps(),
        )
    }
}
#[doc = "Antisandwich product: [`Motor`] x [`Plane`] x antirev([`Motor`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Plane<T>> for Motor<T> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            self.ps() * operand.dist() * self.ps()
                + self.ps() * operand.nx() * self.rx()
                + self.ps() * operand.ny() * self.ty()
                + self.ps() * operand.nz() * self.tz()
                + self.rx() * operand.nx() * self.ps()
                - self.rx() * operand.ny() * self.rz()
                - self.rx() * operand.nz() * self.ry()
                + self.ry() * operand.dist() * self.ry()
                + self.ry() * operand.nx() * self.tz()
                - self.ry() * operand.ny() * self.s()
                - self.ry() * operand.nz() * self.rx()
                + self.rz() * operand.dist() * self.rz()
                + self.rz() * operand.nx() * self.ty()
                - self.rz() * operand.ny() * self.rx()
                + self.rz() * operand.nz() * self.s()
                + self.s() * operand.nx() * self.tx()
                - self.s() * operand.ny() * self.ry()
                + self.s() * operand.nz() * self.rz()
                + self.tx() * operand.dist() * self.tx()
                + self.tx() * operand.nx() * self.s()
                + self.tx() * operand.ny() * self.tz()
                - self.tx() * operand.nz() * self.ty()
                + self.ty() * operand.nx() * self.rz()
                + self.ty() * operand.ny() * self.ps()
                - self.ty() * operand.nz() * self.tx()
                + self.tz() * operand.nx() * self.ry()
                + self.tz() * operand.ny() * self.tx()
                + self.tz() * operand.nz() * self.ps(),
            self.ps() * operand.nx() * self.ry()
                + self.ps() * operand.ny() * self.tx()
                + self.ps() * operand.nz() * self.ps()
                + self.ry() * operand.nx() * self.ps()
                - self.ry() * operand.ny() * self.rz()
                - self.ry() * operand.nz() * self.ry()
                + self.rz() * operand.nx() * self.tx()
                - self.rz() * operand.ny() * self.ry()
                + self.rz() * operand.nz() * self.rz()
                + self.tx() * operand.nx() * self.rz()
                + self.tx() * operand.ny() * self.ps()
                - self.tx() * operand.nz() * self.tx(),
            self.ps() * operand.nx() * self.rz() + self.ps() * operand.ny() * self.ps()
                - self.ps() * operand.nz() * self.tx()
                - self.ry() * operand.nx() * self.tx()
                + self.ry() * operand.ny() * self.ry()
                - self.ry() * operand.nz() * self.rz()
                + self.rz() * operand.nx() * self.ps()
                - self.rz() * operand.ny() * self.rz()
                - self.rz() * operand.nz() * self.ry()
                - self.tx() * operand.nx() * self.ry()
                - self.tx() * operand.ny() * self.tx()
                - self.tx() * operand.nz() * self.ps(),
            self.ps() * operand.nx() * self.ps()
                - self.ps() * operand.ny() * self.rz()
                - self.ps() * operand.nz() * self.ry()
                - self.ry() * operand.nx() * self.ry()
                - self.ry() * operand.ny() * self.tx()
                - self.ry() * operand.nz() * self.ps()
                - self.rz() * operand.nx() * self.rz()
                - self.rz() * operand.ny() * self.ps()
                + self.rz() * operand.nz() * self.tx()
                + self.tx() * operand.nx() * self.tx()
                - self.tx() * operand.ny() * self.ry()
                + self.tx() * operand.nz() * self.rz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Plane<T>> for Unitized<Motor<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            -T::TWO * operand.ny() * self.as_inner().rx() * self.as_inner().rz()
                + -T::TWO * operand.ny() * self.as_inner().ry() * self.as_inner().s()
                + -T::TWO * operand.nz() * self.as_inner().rx() * self.as_inner().ry()
                + -T::TWO * operand.nz() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.nx() * self.as_inner().ps() * self.as_inner().rx()
                + T::TWO * operand.nx() * self.as_inner().ry() * self.as_inner().tz()
                + T::TWO * operand.nx() * self.as_inner().rz() * self.as_inner().ty()
                + T::TWO * operand.nx() * self.as_inner().s() * self.as_inner().tx()
                + T::TWO * operand.ny() * self.as_inner().ps() * self.as_inner().ty()
                + T::TWO * operand.ny() * self.as_inner().tx() * self.as_inner().tz()
                + T::TWO * operand.nz() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.nz() * self.as_inner().rz() * self.as_inner().s()
                + operand.dist(),
            -T::TWO * operand.ny() * self.as_inner().ry() * self.as_inner().rz()
                + -T::TWO * operand.nz() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.nz() * self.as_inner().tx() * self.as_inner().tx()
                + T::TWO * operand.nx() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.nx() * self.as_inner().rz() * self.as_inner().tx()
                + T::TWO * operand.ny() * self.as_inner().ps() * self.as_inner().tx()
                + operand.nz(),
            -T::TWO * operand.nx() * self.as_inner().ry() * self.as_inner().tx()
                + -T::TWO * operand.ny() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.ny() * self.as_inner().tx() * self.as_inner().tx()
                + -T::TWO * operand.nz() * self.as_inner().ps() * self.as_inner().tx()
                + -T::TWO * operand.nz() * self.as_inner().ry() * self.as_inner().rz()
                + T::TWO * operand.nx() * self.as_inner().ps() * self.as_inner().rz()
                + operand.ny(),
            -T::TWO * operand.nx() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.nx() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.ny() * self.as_inner().ps() * self.as_inner().rz()
                + -T::TWO * operand.ny() * self.as_inner().ry() * self.as_inner().tx()
                + -T::TWO * operand.nz() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.nz() * self.as_inner().rz() * self.as_inner().tx()
                + operand.nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Plane<T>>> for Motor<T> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -T::TWO * operand.as_inner().ny() * self.rx() * self.rz()
                + -T::TWO * operand.as_inner().ny() * self.ry() * self.s()
                + -T::TWO * operand.as_inner().nz() * self.rx() * self.ry()
                + -T::TWO * operand.as_inner().nz() * self.tx() * self.ty()
                + T::TWO * operand.as_inner().nx() * self.ps() * self.rx()
                + T::TWO * operand.as_inner().nx() * self.ry() * self.tz()
                + T::TWO * operand.as_inner().nx() * self.rz() * self.ty()
                + T::TWO * operand.as_inner().nx() * self.s() * self.tx()
                + T::TWO * operand.as_inner().ny() * self.ps() * self.ty()
                + T::TWO * operand.as_inner().ny() * self.tx() * self.tz()
                + T::TWO * operand.as_inner().nz() * self.ps() * self.tz()
                + T::TWO * operand.as_inner().nz() * self.rz() * self.s()
                + operand.as_inner().dist() * self.ps() * self.ps()
                + operand.as_inner().dist() * self.ry() * self.ry()
                + operand.as_inner().dist() * self.rz() * self.rz()
                + operand.as_inner().dist() * self.tx() * self.tx(),
            -(operand.as_inner().nz() * self.ry() * self.ry())
                + -(operand.as_inner().nz() * self.tx() * self.tx())
                + -T::TWO * operand.as_inner().ny() * self.ry() * self.rz()
                + T::TWO * operand.as_inner().nx() * self.ps() * self.ry()
                + T::TWO * operand.as_inner().nx() * self.rz() * self.tx()
                + T::TWO * operand.as_inner().ny() * self.ps() * self.tx()
                + operand.as_inner().nz() * self.ps() * self.ps()
                + operand.as_inner().nz() * self.rz() * self.rz(),
            -(operand.as_inner().ny() * self.rz() * self.rz())
                + -(operand.as_inner().ny() * self.tx() * self.tx())
                + -T::TWO * operand.as_inner().nx() * self.ry() * self.tx()
                + -T::TWO * operand.as_inner().nz() * self.ps() * self.tx()
                + -T::TWO * operand.as_inner().nz() * self.ry() * self.rz()
                + T::TWO * operand.as_inner().nx() * self.ps() * self.rz()
                + operand.as_inner().ny() * self.ps() * self.ps()
                + operand.as_inner().ny() * self.ry() * self.ry(),
            -(operand.as_inner().nx() * self.ry() * self.ry())
                + -(operand.as_inner().nx() * self.rz() * self.rz())
                + -T::TWO * operand.as_inner().ny() * self.ps() * self.rz()
                + -T::TWO * operand.as_inner().ny() * self.ry() * self.tx()
                + -T::TWO * operand.as_inner().nz() * self.ps() * self.ry()
                + T::TWO * operand.as_inner().nz() * self.rz() * self.tx()
                + operand.as_inner().nx() * self.ps() * self.ps()
                + operand.as_inner().nx() * self.tx() * self.tx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Plane<T>>> for Unitized<Motor<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -T::TWO * operand.as_inner().ny() * self.as_inner().rx() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().ry() * self.as_inner().s()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().rx() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.as_inner().nx() * self.as_inner().ps() * self.as_inner().rx()
                + T::TWO * operand.as_inner().nx() * self.as_inner().ry() * self.as_inner().tz()
                + T::TWO * operand.as_inner().nx() * self.as_inner().rz() * self.as_inner().ty()
                + T::TWO * operand.as_inner().nx() * self.as_inner().s() * self.as_inner().tx()
                + T::TWO * operand.as_inner().ny() * self.as_inner().ps() * self.as_inner().ty()
                + T::TWO * operand.as_inner().ny() * self.as_inner().tx() * self.as_inner().tz()
                + T::TWO * operand.as_inner().nz() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.as_inner().nz() * self.as_inner().rz() * self.as_inner().s()
                + operand.as_inner().dist(),
            -T::TWO * operand.as_inner().ny() * self.as_inner().ry() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().tx() * self.as_inner().tx()
                + T::TWO * operand.as_inner().nx() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.as_inner().nx() * self.as_inner().rz() * self.as_inner().tx()
                + T::TWO * operand.as_inner().ny() * self.as_inner().ps() * self.as_inner().tx()
                + operand.as_inner().nz(),
            -T::TWO * operand.as_inner().nx() * self.as_inner().ry() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().tx() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().ps() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().ry() * self.as_inner().rz()
                + T::TWO * operand.as_inner().nx() * self.as_inner().ps() * self.as_inner().rz()
                + operand.as_inner().ny(),
            -T::TWO * operand.as_inner().nx() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().nx() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().ps() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().ry() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.as_inner().nz() * self.as_inner().rz() * self.as_inner().tx()
                + operand.as_inner().nx(),
        )
    }
}
#[doc = "Antisandwich product: [`Motor`] x [`Point`] x antirev([`Motor`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Motor<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.ps() * operand.w() * self.rx()
                + self.ps() * operand.x() * self.ps()
                + self.ps() * operand.y() * self.rz()
                - self.ps() * operand.z() * self.ry()
                + self.rx() * operand.w() * self.ps()
                - self.ry() * operand.w() * self.tz()
                - self.ry() * operand.x() * self.ry()
                + self.ry() * operand.y() * self.tx()
                - self.ry() * operand.z() * self.ps()
                - self.rz() * operand.w() * self.ty()
                - self.rz() * operand.x() * self.rz()
                + self.rz() * operand.y() * self.ps()
                + self.rz() * operand.z() * self.tx()
                + self.s() * operand.w() * self.tx()
                + self.tx() * operand.w() * self.s()
                + self.tx() * operand.x() * self.tx()
                + self.tx() * operand.y() * self.ry()
                + self.tx() * operand.z() * self.rz()
                - self.ty() * operand.w() * self.rz()
                - self.tz() * operand.w() * self.ry(),
            -(self.ps() * operand.w() * self.ty()) - self.ps() * operand.x() * self.rz()
                + self.ps() * operand.y() * self.ps()
                + self.ps() * operand.z() * self.tx()
                - self.rx() * operand.w() * self.rz()
                + self.ry() * operand.w() * self.s()
                + self.ry() * operand.x() * self.tx()
                + self.ry() * operand.y() * self.ry()
                + self.ry() * operand.z() * self.rz()
                - self.rz() * operand.w() * self.rx()
                - self.rz() * operand.x() * self.ps()
                - self.rz() * operand.y() * self.rz()
                + self.rz() * operand.z() * self.ry()
                + self.s() * operand.w() * self.ry()
                + self.tx() * operand.w() * self.tz()
                + self.tx() * operand.x() * self.ry()
                - self.tx() * operand.y() * self.tx()
                + self.tx() * operand.z() * self.ps()
                - self.ty() * operand.w() * self.ps()
                + self.tz() * operand.w() * self.tx(),
            self.ps() * operand.w() * self.tz() + self.ps() * operand.x() * self.ry()
                - self.ps() * operand.y() * self.tx()
                + self.ps() * operand.z() * self.ps()
                + self.rx() * operand.w() * self.ry()
                + self.ry() * operand.w() * self.rx()
                + self.ry() * operand.x() * self.ps()
                + self.ry() * operand.y() * self.rz()
                - self.ry() * operand.z() * self.ry()
                + self.rz() * operand.w() * self.s()
                + self.rz() * operand.x() * self.tx()
                + self.rz() * operand.y() * self.ry()
                + self.rz() * operand.z() * self.rz()
                + self.s() * operand.w() * self.rz()
                + self.tx() * operand.w() * self.ty()
                + self.tx() * operand.x() * self.rz()
                - self.tx() * operand.y() * self.ps()
                - self.tx() * operand.z() * self.tx()
                + self.ty() * operand.w() * self.tx()
                + self.tz() * operand.w() * self.ps(),
            self.ps() * operand.w() * self.ps()
                + self.ry() * operand.w() * self.ry()
                + self.rz() * operand.w() * self.rz()
                + self.tx() * operand.w() * self.tx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Unitized<Motor<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -T::TWO * operand.w() * self.as_inner().ry() * self.as_inner().tz()
                + -T::TWO * operand.w() * self.as_inner().rz() * self.as_inner().ty()
                + -T::TWO * operand.x() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.x() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.z() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.w() * self.as_inner().ps() * self.as_inner().rx()
                + T::TWO * operand.w() * self.as_inner().s() * self.as_inner().tx()
                + T::TWO * operand.y() * self.as_inner().ps() * self.as_inner().rz()
                + T::TWO * operand.y() * self.as_inner().ry() * self.as_inner().tx()
                + T::TWO * operand.z() * self.as_inner().rz() * self.as_inner().tx()
                + operand.x(),
            -T::TWO * operand.w() * self.as_inner().ps() * self.as_inner().ty()
                + -T::TWO * operand.w() * self.as_inner().rx() * self.as_inner().rz()
                + -T::TWO * operand.x() * self.as_inner().ps() * self.as_inner().rz()
                + -T::TWO * operand.y() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.y() * self.as_inner().tx() * self.as_inner().tx()
                + T::TWO * operand.w() * self.as_inner().ry() * self.as_inner().s()
                + T::TWO * operand.w() * self.as_inner().tx() * self.as_inner().tz()
                + T::TWO * operand.x() * self.as_inner().ry() * self.as_inner().tx()
                + T::TWO * operand.z() * self.as_inner().ps() * self.as_inner().tx()
                + T::TWO * operand.z() * self.as_inner().ry() * self.as_inner().rz()
                + operand.y(),
            -T::TWO * operand.y() * self.as_inner().ps() * self.as_inner().tx()
                + -T::TWO * operand.z() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.z() * self.as_inner().tx() * self.as_inner().tx()
                + T::TWO * operand.w() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.w() * self.as_inner().rx() * self.as_inner().ry()
                + T::TWO * operand.w() * self.as_inner().rz() * self.as_inner().s()
                + T::TWO * operand.w() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.x() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.x() * self.as_inner().rz() * self.as_inner().tx()
                + T::TWO * operand.y() * self.as_inner().ry() * self.as_inner().rz()
                + operand.z(),
            operand.w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Point<T>>> for Motor<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x() * self.ry() * self.ry())
                + -(operand.as_inner().x() * self.rz() * self.rz())
                + -T::TWO * operand.as_inner().w() * self.ry() * self.tz()
                + -T::TWO * operand.as_inner().w() * self.rz() * self.ty()
                + -T::TWO * operand.as_inner().z() * self.ps() * self.ry()
                + T::TWO * operand.as_inner().w() * self.ps() * self.rx()
                + T::TWO * operand.as_inner().w() * self.s() * self.tx()
                + T::TWO * operand.as_inner().y() * self.ps() * self.rz()
                + T::TWO * operand.as_inner().y() * self.ry() * self.tx()
                + T::TWO * operand.as_inner().z() * self.rz() * self.tx()
                + operand.as_inner().x() * self.ps() * self.ps()
                + operand.as_inner().x() * self.tx() * self.tx(),
            -(operand.as_inner().y() * self.rz() * self.rz())
                + -(operand.as_inner().y() * self.tx() * self.tx())
                + -T::TWO * operand.as_inner().w() * self.ps() * self.ty()
                + -T::TWO * operand.as_inner().w() * self.rx() * self.rz()
                + -T::TWO * operand.as_inner().x() * self.ps() * self.rz()
                + T::TWO * operand.as_inner().w() * self.ry() * self.s()
                + T::TWO * operand.as_inner().w() * self.tx() * self.tz()
                + T::TWO * operand.as_inner().x() * self.ry() * self.tx()
                + T::TWO * operand.as_inner().z() * self.ps() * self.tx()
                + T::TWO * operand.as_inner().z() * self.ry() * self.rz()
                + operand.as_inner().y() * self.ps() * self.ps()
                + operand.as_inner().y() * self.ry() * self.ry(),
            -(operand.as_inner().z() * self.ry() * self.ry())
                + -(operand.as_inner().z() * self.tx() * self.tx())
                + -T::TWO * operand.as_inner().y() * self.ps() * self.tx()
                + T::TWO * operand.as_inner().w() * self.ps() * self.tz()
                + T::TWO * operand.as_inner().w() * self.rx() * self.ry()
                + T::TWO * operand.as_inner().w() * self.rz() * self.s()
                + T::TWO * operand.as_inner().w() * self.tx() * self.ty()
                + T::TWO * operand.as_inner().x() * self.ps() * self.ry()
                + T::TWO * operand.as_inner().x() * self.rz() * self.tx()
                + T::TWO * operand.as_inner().y() * self.ry() * self.rz()
                + operand.as_inner().z() * self.ps() * self.ps()
                + operand.as_inner().z() * self.rz() * self.rz(),
            operand.as_inner().w() * self.ps() * self.ps()
                + operand.as_inner().w() * self.ry() * self.ry()
                + operand.as_inner().w() * self.rz() * self.rz()
                + operand.as_inner().w() * self.tx() * self.tx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Point<T>>> for Unitized<Motor<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -T::TWO * operand.as_inner().w() * self.as_inner().ry() * self.as_inner().tz()
                + -T::TWO * operand.as_inner().w() * self.as_inner().rz() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().x() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().x() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.as_inner().w() * self.as_inner().ps() * self.as_inner().rx()
                + T::TWO * operand.as_inner().w() * self.as_inner().s() * self.as_inner().tx()
                + T::TWO * operand.as_inner().y() * self.as_inner().ps() * self.as_inner().rz()
                + T::TWO * operand.as_inner().y() * self.as_inner().ry() * self.as_inner().tx()
                + T::TWO * operand.as_inner().z() * self.as_inner().rz() * self.as_inner().tx()
                + operand.as_inner().x(),
            -T::TWO * operand.as_inner().w() * self.as_inner().ps() * self.as_inner().ty()
                + -T::TWO * operand.as_inner().w() * self.as_inner().rx() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().x() * self.as_inner().ps() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().rz() * self.as_inner().rz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().tx() * self.as_inner().tx()
                + T::TWO * operand.as_inner().w() * self.as_inner().ry() * self.as_inner().s()
                + T::TWO * operand.as_inner().w() * self.as_inner().tx() * self.as_inner().tz()
                + T::TWO * operand.as_inner().x() * self.as_inner().ry() * self.as_inner().tx()
                + T::TWO * operand.as_inner().z() * self.as_inner().ps() * self.as_inner().tx()
                + T::TWO * operand.as_inner().z() * self.as_inner().ry() * self.as_inner().rz()
                + operand.as_inner().y(),
            -T::TWO * operand.as_inner().y() * self.as_inner().ps() * self.as_inner().tx()
                + -T::TWO * operand.as_inner().z() * self.as_inner().ry() * self.as_inner().ry()
                + -T::TWO * operand.as_inner().z() * self.as_inner().tx() * self.as_inner().tx()
                + T::TWO * operand.as_inner().w() * self.as_inner().ps() * self.as_inner().tz()
                + T::TWO * operand.as_inner().w() * self.as_inner().rx() * self.as_inner().ry()
                + T::TWO * operand.as_inner().w() * self.as_inner().rz() * self.as_inner().s()
                + T::TWO * operand.as_inner().w() * self.as_inner().tx() * self.as_inner().ty()
                + T::TWO * operand.as_inner().x() * self.as_inner().ps() * self.as_inner().ry()
                + T::TWO * operand.as_inner().x() * self.as_inner().rz() * self.as_inner().tx()
                + T::TWO * operand.as_inner().y() * self.as_inner().ry() * self.as_inner().rz()
                + operand.as_inner().z(),
            operand.as_inner().w(),
        )
    }
}
#[doc = "Antisandwich product: [`Motor`] x [`Quadvector`] x antirev([`Motor`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Quadvector<T>> for Motor<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            self.ps() * operand.ps() * self.ps()
                + self.ry() * operand.ps() * self.ry()
                + self.rz() * operand.ps() * self.rz()
                + self.tx() * operand.ps() * self.tx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Quadvector<T>> for Unitized<Motor<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(operand.ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Quadvector<T>>> for Motor<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            operand.as_inner().ps() * self.ps() * self.ps()
                + operand.as_inner().ps() * self.ry() * self.ry()
                + operand.as_inner().ps() * self.rz() * self.rz()
                + operand.as_inner().ps() * self.tx() * self.tx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Quadvector<T>>> for Unitized<Motor<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(operand.as_inner().ps())
    }
}
#[doc = "Antisandwich product: [`Motor`] x [`Scalar`] x antirev([`Motor`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Motor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.ps() * operand.s() * self.ps()
                + self.ry() * operand.s() * self.ry()
                + self.rz() * operand.s() * self.rz()
                + self.tx() * operand.s() * self.tx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unitized<Motor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Motor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Unitized<Motor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Antisandwich product: [`Plane`] x [`Flector`] x antirev([`Plane`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Flector<T>> for Plane<T> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            self.dist() * operand.ny() * self.nz()
                - self.dist() * operand.nz() * self.ny()
                - self.dist() * operand.pw() * self.nx()
                - self.nx() * operand.pw() * self.dist()
                + self.nx() * operand.px() * self.nx()
                - self.nx() * operand.py() * self.ny()
                + self.nx() * operand.pz() * self.nz()
                - self.ny() * operand.dist() * self.nz()
                + self.ny() * operand.nz() * self.dist()
                - self.ny() * operand.px() * self.ny()
                - self.ny() * operand.py() * self.nx()
                + self.nz() * operand.dist() * self.ny()
                - self.nz() * operand.ny() * self.dist()
                - self.nz() * operand.px() * self.nz()
                + self.nz() * operand.pz() * self.nx(),
            self.dist() * operand.nx() * self.nz() - self.dist() * operand.nz() * self.nx()
                + self.dist() * operand.pw() * self.ny()
                - self.nx() * operand.dist() * self.nz()
                + self.nx() * operand.nz() * self.dist()
                - self.nx() * operand.px() * self.ny()
                - self.nx() * operand.py() * self.nx()
                + self.ny() * operand.pw() * self.dist()
                - self.ny() * operand.px() * self.nx()
                + self.ny() * operand.py() * self.ny()
                - self.ny() * operand.pz() * self.nz()
                + self.nz() * operand.dist() * self.nx()
                - self.nz() * operand.nx() * self.dist()
                - self.nz() * operand.py() * self.nz()
                - self.nz() * operand.pz() * self.ny(),
            self.dist() * operand.nx() * self.ny()
                - self.dist() * operand.ny() * self.nx()
                - self.dist() * operand.pw() * self.nz()
                - self.nx() * operand.dist() * self.ny()
                + self.nx() * operand.ny() * self.dist()
                + self.nx() * operand.px() * self.nz()
                - self.nx() * operand.pz() * self.nx()
                + self.ny() * operand.dist() * self.nx()
                - self.ny() * operand.nx() * self.dist()
                - self.ny() * operand.py() * self.nz()
                - self.ny() * operand.pz() * self.ny()
                - self.nz() * operand.pw() * self.dist()
                + self.nz() * operand.px() * self.nx()
                - self.nz() * operand.py() * self.ny()
                + self.nz() * operand.pz() * self.nz(),
            self.nx() * operand.ny() * self.nz()
                - self.nx() * operand.nz() * self.ny()
                - self.nx() * operand.pw() * self.nx()
                - self.ny() * operand.nx() * self.nz()
                + self.ny() * operand.nz() * self.nx()
                - self.ny() * operand.pw() * self.ny()
                + self.nz() * operand.nx() * self.ny()
                - self.nz() * operand.ny() * self.nx()
                - self.nz() * operand.pw() * self.nz(),
            -(self.dist() * operand.nx() * self.nx())
                - self.dist() * operand.ny() * self.ny()
                - self.dist() * operand.nz() * self.nz()
                + self.nx() * operand.dist() * self.nx()
                - self.nx() * operand.nx() * self.dist()
                - self.nx() * operand.py() * self.nz()
                - self.nx() * operand.pz() * self.ny()
                + self.ny() * operand.dist() * self.ny()
                - self.ny() * operand.ny() * self.dist()
                - self.ny() * operand.px() * self.nz()
                + self.ny() * operand.pz() * self.nx()
                + self.nz() * operand.dist() * self.nz()
                - self.nz() * operand.nz() * self.dist()
                + self.nz() * operand.px() * self.ny()
                + self.nz() * operand.py() * self.nx(),
            -(self.nx() * operand.nx() * self.nz()) + self.nx() * operand.nz() * self.nx()
                - self.nx() * operand.pw() * self.ny()
                - self.ny() * operand.ny() * self.nz()
                + self.ny() * operand.nz() * self.ny()
                + self.ny() * operand.pw() * self.nx()
                - self.nz() * operand.nx() * self.nx()
                - self.nz() * operand.ny() * self.ny()
                - self.nz() * operand.nz() * self.nz(),
            -(self.nx() * operand.nx() * self.ny())
                + self.nx() * operand.ny() * self.nx()
                + self.nx() * operand.pw() * self.nz()
                - self.ny() * operand.nx() * self.nx()
                - self.ny() * operand.ny() * self.ny()
                - self.ny() * operand.nz() * self.nz()
                + self.nz() * operand.ny() * self.nz()
                - self.nz() * operand.nz() * self.ny()
                - self.nz() * operand.pw() * self.nx(),
            -(self.nx() * operand.nx() * self.nx())
                - self.nx() * operand.ny() * self.ny()
                - self.nx() * operand.nz() * self.nz()
                + self.ny() * operand.nx() * self.ny()
                - self.ny() * operand.ny() * self.nx()
                - self.ny() * operand.pw() * self.nz()
                + self.nz() * operand.nx() * self.nz()
                - self.nz() * operand.nz() * self.nx()
                + self.nz() * operand.pw() * self.ny(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Flector<T>> for Unitized<Plane<T>> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            -T::TWO * operand.pw() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.px() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.px() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.py() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.pz() * self.as_inner().nx() * self.as_inner().nz()
                + operand.px(),
            -(operand.py())
                + -T::TWO * operand.px() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.pz() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.pw() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.py() * self.as_inner().ny() * self.as_inner().ny(),
            -(operand.pz())
                + -T::TWO * operand.pw() * self.as_inner().dist() * self.as_inner().nz()
                + -T::TWO * operand.py() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.px() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.pz() * self.as_inner().nz() * self.as_inner().nz(),
            -(operand.pw()),
            -T::TWO * operand.nx() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.ny() * self.as_inner().dist() * self.as_inner().ny()
                + -T::TWO * operand.nz() * self.as_inner().dist() * self.as_inner().nz()
                + operand.dist(),
            -T::TWO * operand.nx() * self.as_inner().nx() * self.as_inner().nz()
                + -T::TWO * operand.ny() * self.as_inner().ny() * self.as_inner().nz()
                + -T::TWO * operand.nz() * self.as_inner().nz() * self.as_inner().nz()
                + operand.nz(),
            -T::TWO * operand.nx() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.ny() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.nz() * self.as_inner().ny() * self.as_inner().nz()
                + operand.ny(),
            -(operand.nx())
                + -T::TWO * operand.ny() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.nz() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.nx() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.nx() * self.as_inner().nz() * self.as_inner().nz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Flector<T>>> for Plane<T> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            -(operand.as_inner().px() * self.ny() * self.ny())
                + -(operand.as_inner().px() * self.nz() * self.nz())
                + -T::TWO * operand.as_inner().pw() * self.dist() * self.nx()
                + -T::TWO * operand.as_inner().py() * self.nx() * self.ny()
                + T::TWO * operand.as_inner().pz() * self.nx() * self.nz()
                + operand.as_inner().px() * self.nx() * self.nx(),
            -(operand.as_inner().py() * self.nx() * self.nx())
                + -(operand.as_inner().py() * self.nz() * self.nz())
                + -T::TWO * operand.as_inner().px() * self.nx() * self.ny()
                + -T::TWO * operand.as_inner().pz() * self.ny() * self.nz()
                + T::TWO * operand.as_inner().pw() * self.dist() * self.ny()
                + operand.as_inner().py() * self.ny() * self.ny(),
            -(operand.as_inner().pz() * self.nx() * self.nx())
                + -(operand.as_inner().pz() * self.ny() * self.ny())
                + -T::TWO * operand.as_inner().pw() * self.dist() * self.nz()
                + -T::TWO * operand.as_inner().py() * self.ny() * self.nz()
                + T::TWO * operand.as_inner().px() * self.nx() * self.nz()
                + operand.as_inner().pz() * self.nz() * self.nz(),
            -(operand.as_inner().pw() * self.nx() * self.nx())
                + -(operand.as_inner().pw() * self.ny() * self.ny())
                + -(operand.as_inner().pw() * self.nz() * self.nz()),
            -T::TWO * operand.as_inner().nx() * self.dist() * self.nx()
                + -T::TWO * operand.as_inner().ny() * self.dist() * self.ny()
                + -T::TWO * operand.as_inner().nz() * self.dist() * self.nz()
                + operand.as_inner().dist() * self.nx() * self.nx()
                + operand.as_inner().dist() * self.ny() * self.ny()
                + operand.as_inner().dist() * self.nz() * self.nz(),
            -(operand.as_inner().nz() * self.nz() * self.nz())
                + -T::TWO * operand.as_inner().nx() * self.nx() * self.nz()
                + -T::TWO * operand.as_inner().ny() * self.ny() * self.nz()
                + operand.as_inner().nz() * self.nx() * self.nx()
                + operand.as_inner().nz() * self.ny() * self.ny(),
            -(operand.as_inner().ny() * self.ny() * self.ny())
                + -T::TWO * operand.as_inner().nx() * self.nx() * self.ny()
                + -T::TWO * operand.as_inner().nz() * self.ny() * self.nz()
                + operand.as_inner().ny() * self.nx() * self.nx()
                + operand.as_inner().ny() * self.nz() * self.nz(),
            -(operand.as_inner().nx() * self.nx() * self.nx())
                + -T::TWO * operand.as_inner().ny() * self.nx() * self.ny()
                + -T::TWO * operand.as_inner().nz() * self.nx() * self.nz()
                + operand.as_inner().nx() * self.ny() * self.ny()
                + operand.as_inner().nx() * self.nz() * self.nz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Flector<T>>> for Unitized<Plane<T>> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            -T::TWO * operand.as_inner().pw() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.as_inner().px() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().px() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().py() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.as_inner().pz() * self.as_inner().nx() * self.as_inner().nz()
                + operand.as_inner().px(),
            -(operand.as_inner().py())
                + -T::TWO * operand.as_inner().px() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().pz() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.as_inner().pw() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.as_inner().py() * self.as_inner().ny() * self.as_inner().ny(),
            -(operand.as_inner().pz())
                + -T::TWO * operand.as_inner().pw() * self.as_inner().dist() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().py() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.as_inner().px() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.as_inner().pz() * self.as_inner().nz() * self.as_inner().nz(),
            -(operand.as_inner().pw()),
            -T::TWO * operand.as_inner().nx() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().dist() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().dist() * self.as_inner().nz()
                + operand.as_inner().dist(),
            -T::TWO * operand.as_inner().nx() * self.as_inner().nx() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().ny() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().nz() * self.as_inner().nz()
                + operand.as_inner().nz(),
            -T::TWO * operand.as_inner().nx() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().ny() * self.as_inner().nz()
                + operand.as_inner().ny(),
            -(operand.as_inner().nx())
                + -T::TWO * operand.as_inner().ny() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.as_inner().nx() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.as_inner().nx() * self.as_inner().nz() * self.as_inner().nz(),
        )
    }
}
#[doc = "Antisandwich product: [`Plane`] x [`Line`] x antirev([`Plane`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Plane<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            -(self.dist() * operand.dir_x() * self.ny())
                - self.dist() * operand.dir_y() * self.nx()
                - self.nx() * operand.dir_y() * self.dist()
                + self.nx() * operand.moment_x() * self.nz()
                - self.nx() * operand.moment_z() * self.nx()
                - self.ny() * operand.dir_x() * self.dist()
                + self.ny() * operand.moment_y() * self.nz()
                - self.ny() * operand.moment_z() * self.ny()
                + self.nz() * operand.moment_x() * self.nx()
                + self.nz() * operand.moment_y() * self.ny()
                + self.nz() * operand.moment_z() * self.nz(),
            self.dist() * operand.dir_x() * self.nz()
                - self.dist() * operand.dir_z() * self.nx()
                - self.nx() * operand.dir_z() * self.dist()
                + self.nx() * operand.moment_x() * self.ny()
                - self.nx() * operand.moment_y() * self.nx()
                + self.ny() * operand.moment_x() * self.nx()
                + self.ny() * operand.moment_y() * self.ny()
                + self.ny() * operand.moment_z() * self.nz()
                + self.nz() * operand.dir_x() * self.dist()
                - self.nz() * operand.moment_y() * self.nz()
                + self.nz() * operand.moment_z() * self.ny(),
            -(self.nx() * operand.dir_x() * self.nx()) + self.nx() * operand.dir_y() * self.ny()
                - self.nx() * operand.dir_z() * self.nz()
                + self.ny() * operand.dir_x() * self.ny()
                + self.ny() * operand.dir_y() * self.nx()
                + self.nz() * operand.dir_x() * self.nz()
                - self.nz() * operand.dir_z() * self.nx(),
            self.dist() * operand.dir_y() * self.nz()
                + self.dist() * operand.dir_z() * self.ny()
                + self.nx() * operand.moment_x() * self.nx()
                + self.nx() * operand.moment_y() * self.ny()
                + self.nx() * operand.moment_z() * self.nz()
                + self.ny() * operand.dir_z() * self.dist()
                - self.ny() * operand.moment_x() * self.ny()
                + self.ny() * operand.moment_y() * self.nx()
                + self.nz() * operand.dir_y() * self.dist()
                - self.nz() * operand.moment_x() * self.nz()
                + self.nz() * operand.moment_z() * self.nx(),
            self.nx() * operand.dir_x() * self.ny()
                + self.nx() * operand.dir_y() * self.nx()
                + self.ny() * operand.dir_x() * self.nx()
                - self.ny() * operand.dir_y() * self.ny()
                + self.ny() * operand.dir_z() * self.nz()
                + self.nz() * operand.dir_y() * self.nz()
                + self.nz() * operand.dir_z() * self.ny(),
            -(self.nx() * operand.dir_x() * self.nz())
                + self.nx() * operand.dir_z() * self.nx()
                + self.ny() * operand.dir_y() * self.nz()
                + self.ny() * operand.dir_z() * self.ny()
                - self.nz() * operand.dir_x() * self.nx()
                + self.nz() * operand.dir_y() * self.ny()
                - self.nz() * operand.dir_z() * self.nz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Unitized<Plane<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            -(operand.moment_z())
                + -T::TWO * operand.dir_x() * self.as_inner().dist() * self.as_inner().ny()
                + -T::TWO * operand.dir_y() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.moment_x() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.moment_y() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.moment_z() * self.as_inner().nz() * self.as_inner().nz(),
            -(operand.moment_y())
                + -T::TWO * operand.dir_z() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.dir_x() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.moment_x() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.moment_y() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.moment_z() * self.as_inner().ny() * self.as_inner().nz(),
            -(operand.dir_x())
                + -T::TWO * operand.dir_z() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.dir_x() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.dir_x() * self.as_inner().nz() * self.as_inner().nz()
                + T::TWO * operand.dir_y() * self.as_inner().nx() * self.as_inner().ny(),
            -T::TWO * operand.moment_x() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.moment_x() * self.as_inner().nz() * self.as_inner().nz()
                + T::TWO * operand.dir_y() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.dir_z() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.moment_y() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.moment_z() * self.as_inner().nx() * self.as_inner().nz()
                + operand.moment_x(),
            -T::TWO * operand.dir_y() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.dir_x() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.dir_z() * self.as_inner().ny() * self.as_inner().nz()
                + operand.dir_y(),
            -T::TWO * operand.dir_x() * self.as_inner().nx() * self.as_inner().nz()
                + -T::TWO * operand.dir_z() * self.as_inner().nz() * self.as_inner().nz()
                + T::TWO * operand.dir_y() * self.as_inner().ny() * self.as_inner().nz()
                + operand.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Line<T>>> for Plane<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(operand.as_inner().moment_z() * self.nx() * self.nx())
                + -(operand.as_inner().moment_z() * self.ny() * self.ny())
                + -T::TWO * operand.as_inner().dir_x() * self.dist() * self.ny()
                + -T::TWO * operand.as_inner().dir_y() * self.dist() * self.nx()
                + T::TWO * operand.as_inner().moment_x() * self.nx() * self.nz()
                + T::TWO * operand.as_inner().moment_y() * self.ny() * self.nz()
                + operand.as_inner().moment_z() * self.nz() * self.nz(),
            -(operand.as_inner().moment_y() * self.nx() * self.nx())
                + -(operand.as_inner().moment_y() * self.nz() * self.nz())
                + -T::TWO * operand.as_inner().dir_z() * self.dist() * self.nx()
                + T::TWO * operand.as_inner().dir_x() * self.dist() * self.nz()
                + T::TWO * operand.as_inner().moment_x() * self.nx() * self.ny()
                + T::TWO * operand.as_inner().moment_z() * self.ny() * self.nz()
                + operand.as_inner().moment_y() * self.ny() * self.ny(),
            -(operand.as_inner().dir_x() * self.nx() * self.nx())
                + -T::TWO * operand.as_inner().dir_z() * self.nx() * self.nz()
                + T::TWO * operand.as_inner().dir_y() * self.nx() * self.ny()
                + operand.as_inner().dir_x() * self.ny() * self.ny()
                + operand.as_inner().dir_x() * self.nz() * self.nz(),
            -(operand.as_inner().moment_x() * self.ny() * self.ny())
                + -(operand.as_inner().moment_x() * self.nz() * self.nz())
                + T::TWO * operand.as_inner().dir_y() * self.dist() * self.nz()
                + T::TWO * operand.as_inner().dir_z() * self.dist() * self.ny()
                + T::TWO * operand.as_inner().moment_y() * self.nx() * self.ny()
                + T::TWO * operand.as_inner().moment_z() * self.nx() * self.nz()
                + operand.as_inner().moment_x() * self.nx() * self.nx(),
            -(operand.as_inner().dir_y() * self.ny() * self.ny())
                + T::TWO * operand.as_inner().dir_x() * self.nx() * self.ny()
                + T::TWO * operand.as_inner().dir_z() * self.ny() * self.nz()
                + operand.as_inner().dir_y() * self.nx() * self.nx()
                + operand.as_inner().dir_y() * self.nz() * self.nz(),
            -(operand.as_inner().dir_z() * self.nz() * self.nz())
                + -T::TWO * operand.as_inner().dir_x() * self.nx() * self.nz()
                + T::TWO * operand.as_inner().dir_y() * self.ny() * self.nz()
                + operand.as_inner().dir_z() * self.nx() * self.nx()
                + operand.as_inner().dir_z() * self.ny() * self.ny(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Line<T>>> for Unitized<Plane<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(operand.as_inner().moment_z())
                + -T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().dist()
                    * self.as_inner().ny()
                + -T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().dist()
                    * self.as_inner().nx()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().nx()
                    * self.as_inner().nz()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().ny()
                    * self.as_inner().nz()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().nz()
                    * self.as_inner().nz(),
            -(operand.as_inner().moment_y())
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().dist()
                    * self.as_inner().nx()
                + T::TWO
                    * operand.as_inner().dir_x()
                    * self.as_inner().dist()
                    * self.as_inner().nz()
                + T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().nx()
                    * self.as_inner().ny()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().ny()
                    * self.as_inner().ny()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().ny()
                    * self.as_inner().nz(),
            -(operand.as_inner().dir_x())
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().nx()
                    * self.as_inner().nz()
                + T::TWO * operand.as_inner().dir_x() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.as_inner().dir_x() * self.as_inner().nz() * self.as_inner().nz()
                + T::TWO * operand.as_inner().dir_y() * self.as_inner().nx() * self.as_inner().ny(),
            -T::TWO * operand.as_inner().moment_x() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO
                    * operand.as_inner().moment_x()
                    * self.as_inner().nz()
                    * self.as_inner().nz()
                + T::TWO
                    * operand.as_inner().dir_y()
                    * self.as_inner().dist()
                    * self.as_inner().nz()
                + T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().dist()
                    * self.as_inner().ny()
                + T::TWO
                    * operand.as_inner().moment_y()
                    * self.as_inner().nx()
                    * self.as_inner().ny()
                + T::TWO
                    * operand.as_inner().moment_z()
                    * self.as_inner().nx()
                    * self.as_inner().nz()
                + operand.as_inner().moment_x(),
            -T::TWO * operand.as_inner().dir_y() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.as_inner().dir_x() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().ny() * self.as_inner().nz()
                + operand.as_inner().dir_y(),
            -T::TWO * operand.as_inner().dir_x() * self.as_inner().nx() * self.as_inner().nz()
                + -T::TWO
                    * operand.as_inner().dir_z()
                    * self.as_inner().nz()
                    * self.as_inner().nz()
                + T::TWO * operand.as_inner().dir_y() * self.as_inner().ny() * self.as_inner().nz()
                + operand.as_inner().dir_z(),
        )
    }
}
#[doc = "Antisandwich product: [`Plane`] x [`Motor`] x antirev([`Plane`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Motor<T>> for Plane<T> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            self.dist() * operand.ry() * self.ny()
                - self.dist() * operand.rz() * self.nz()
                - self.dist() * operand.tx() * self.nx()
                + self.nx() * operand.s() * self.nx()
                + self.nx() * operand.tx() * self.dist()
                - self.nx() * operand.ty() * self.nz()
                + self.nx() * operand.tz() * self.ny()
                + self.ny() * operand.rx() * self.nz()
                - self.ny() * operand.ry() * self.dist()
                + self.ny() * operand.s() * self.ny()
                - self.ny() * operand.tz() * self.nx()
                - self.nz() * operand.rx() * self.ny()
                + self.nz() * operand.rz() * self.dist()
                + self.nz() * operand.s() * self.nz()
                + self.nz() * operand.ty() * self.nx(),
            -(self.dist() * operand.ps() * self.nz())
                - self.dist() * operand.ry() * self.nx()
                - self.dist() * operand.tx() * self.ny()
                + self.nx() * operand.rx() * self.nz()
                - self.nx() * operand.ry() * self.dist()
                + self.nx() * operand.s() * self.ny()
                - self.nx() * operand.tz() * self.nx()
                - self.ny() * operand.s() * self.nx()
                - self.ny() * operand.tx() * self.dist()
                + self.ny() * operand.ty() * self.nz()
                - self.ny() * operand.tz() * self.ny()
                + self.nz() * operand.ps() * self.dist()
                + self.nz() * operand.rx() * self.nx()
                + self.nz() * operand.ty() * self.ny()
                + self.nz() * operand.tz() * self.nz(),
            -(self.dist() * operand.ps() * self.ny()) - self.dist() * operand.rz() * self.nx()
                + self.dist() * operand.tx() * self.nz()
                + self.nx() * operand.rx() * self.ny()
                - self.nx() * operand.rz() * self.dist()
                - self.nx() * operand.s() * self.nz()
                - self.nx() * operand.ty() * self.nx()
                + self.ny() * operand.ps() * self.dist()
                + self.ny() * operand.rx() * self.nx()
                + self.ny() * operand.ty() * self.ny()
                + self.ny() * operand.tz() * self.nz()
                + self.nz() * operand.s() * self.nx()
                + self.nz() * operand.tx() * self.dist()
                - self.nz() * operand.ty() * self.nz()
                + self.nz() * operand.tz() * self.ny(),
            self.nx() * operand.ry() * self.ny()
                - self.nx() * operand.rz() * self.nz()
                - self.nx() * operand.tx() * self.nx()
                + self.ny() * operand.ps() * self.nz()
                + self.ny() * operand.ry() * self.nx()
                + self.ny() * operand.tx() * self.ny()
                - self.nz() * operand.ps() * self.ny()
                - self.nz() * operand.rz() * self.nx()
                + self.nz() * operand.tx() * self.nz(),
            -(self.dist() * operand.ps() * self.nx())
                + self.dist() * operand.ry() * self.nz()
                + self.dist() * operand.rz() * self.ny()
                + self.nx() * operand.ps() * self.dist()
                + self.nx() * operand.rx() * self.nx()
                + self.nx() * operand.ty() * self.ny()
                + self.nx() * operand.tz() * self.nz()
                - self.ny() * operand.rx() * self.ny()
                + self.ny() * operand.rz() * self.dist()
                + self.ny() * operand.s() * self.nz()
                + self.ny() * operand.ty() * self.nx()
                - self.nz() * operand.rx() * self.nz()
                + self.nz() * operand.ry() * self.dist()
                - self.nz() * operand.s() * self.ny()
                + self.nz() * operand.tz() * self.nx(),
            self.nx() * operand.ps() * self.nz()
                + self.nx() * operand.ry() * self.nx()
                + self.nx() * operand.tx() * self.ny()
                - self.ny() * operand.ry() * self.ny()
                + self.ny() * operand.rz() * self.nz()
                + self.ny() * operand.tx() * self.nx()
                - self.nz() * operand.ps() * self.nx()
                + self.nz() * operand.ry() * self.nz()
                + self.nz() * operand.rz() * self.ny(),
            self.nx() * operand.ps() * self.ny() + self.nx() * operand.rz() * self.nx()
                - self.nx() * operand.tx() * self.nz()
                - self.ny() * operand.ps() * self.nx()
                + self.ny() * operand.ry() * self.nz()
                + self.ny() * operand.rz() * self.ny()
                + self.nz() * operand.ry() * self.ny()
                - self.nz() * operand.rz() * self.nz()
                - self.nz() * operand.tx() * self.nx(),
            -(self.nx() * operand.ps() * self.nx())
                + self.nx() * operand.ry() * self.nz()
                + self.nx() * operand.rz() * self.ny()
                - self.ny() * operand.ps() * self.ny()
                - self.ny() * operand.rz() * self.nx()
                + self.ny() * operand.tx() * self.nz()
                - self.nz() * operand.ps() * self.nz()
                - self.nz() * operand.ry() * self.nx()
                - self.nz() * operand.tx() * self.ny(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Motor<T>> for Unitized<Plane<T>> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            operand.s(),
            -(operand.tz())
                + -T::TWO * operand.ry() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.tx() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.rx() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.ty() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.tz() * self.as_inner().nz() * self.as_inner().nz(),
            -(operand.ty())
                + -T::TWO * operand.rz() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.rx() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.tx() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.ty() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.tz() * self.as_inner().ny() * self.as_inner().nz(),
            -(operand.tx())
                + -T::TWO * operand.rz() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.ry() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.tx() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.tx() * self.as_inner().nz() * self.as_inner().nz(),
            -T::TWO * operand.rx() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.rx() * self.as_inner().nz() * self.as_inner().nz()
                + T::TWO * operand.ry() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.rz() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.ty() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.tz() * self.as_inner().nx() * self.as_inner().nz()
                + operand.rx(),
            -T::TWO * operand.ry() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.rz() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.tx() * self.as_inner().nx() * self.as_inner().ny()
                + operand.ry(),
            -T::TWO * operand.rz() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.tx() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.ry() * self.as_inner().ny() * self.as_inner().nz()
                + operand.rz(),
            -(operand.ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Motor<T>>> for Plane<T> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s() * self.nx() * self.nx()
                + operand.as_inner().s() * self.ny() * self.ny()
                + operand.as_inner().s() * self.nz() * self.nz(),
            -(operand.as_inner().tz() * self.nx() * self.nx())
                + -(operand.as_inner().tz() * self.ny() * self.ny())
                + -T::TWO * operand.as_inner().ry() * self.dist() * self.nx()
                + -T::TWO * operand.as_inner().tx() * self.dist() * self.ny()
                + T::TWO * operand.as_inner().rx() * self.nx() * self.nz()
                + T::TWO * operand.as_inner().ty() * self.ny() * self.nz()
                + operand.as_inner().tz() * self.nz() * self.nz(),
            -(operand.as_inner().ty() * self.nx() * self.nx())
                + -(operand.as_inner().ty() * self.nz() * self.nz())
                + -T::TWO * operand.as_inner().rz() * self.dist() * self.nx()
                + T::TWO * operand.as_inner().rx() * self.nx() * self.ny()
                + T::TWO * operand.as_inner().tx() * self.dist() * self.nz()
                + T::TWO * operand.as_inner().tz() * self.ny() * self.nz()
                + operand.as_inner().ty() * self.ny() * self.ny(),
            -(operand.as_inner().tx() * self.nx() * self.nx())
                + -T::TWO * operand.as_inner().rz() * self.nx() * self.nz()
                + T::TWO * operand.as_inner().ry() * self.nx() * self.ny()
                + operand.as_inner().tx() * self.ny() * self.ny()
                + operand.as_inner().tx() * self.nz() * self.nz(),
            -(operand.as_inner().rx() * self.ny() * self.ny())
                + -(operand.as_inner().rx() * self.nz() * self.nz())
                + T::TWO * operand.as_inner().ry() * self.dist() * self.nz()
                + T::TWO * operand.as_inner().rz() * self.dist() * self.ny()
                + T::TWO * operand.as_inner().ty() * self.nx() * self.ny()
                + T::TWO * operand.as_inner().tz() * self.nx() * self.nz()
                + operand.as_inner().rx() * self.nx() * self.nx(),
            -(operand.as_inner().ry() * self.ny() * self.ny())
                + T::TWO * operand.as_inner().rz() * self.ny() * self.nz()
                + T::TWO * operand.as_inner().tx() * self.nx() * self.ny()
                + operand.as_inner().ry() * self.nx() * self.nx()
                + operand.as_inner().ry() * self.nz() * self.nz(),
            -(operand.as_inner().rz() * self.nz() * self.nz())
                + -T::TWO * operand.as_inner().tx() * self.nx() * self.nz()
                + T::TWO * operand.as_inner().ry() * self.ny() * self.nz()
                + operand.as_inner().rz() * self.nx() * self.nx()
                + operand.as_inner().rz() * self.ny() * self.ny(),
            -(operand.as_inner().ps() * self.nx() * self.nx())
                + -(operand.as_inner().ps() * self.ny() * self.ny())
                + -(operand.as_inner().ps() * self.nz() * self.nz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Motor<T>>> for Unitized<Plane<T>> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s(),
            -(operand.as_inner().tz())
                + -T::TWO * operand.as_inner().ry() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.as_inner().rx() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.as_inner().ty() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.as_inner().tz() * self.as_inner().nz() * self.as_inner().nz(),
            -(operand.as_inner().ty())
                + -T::TWO * operand.as_inner().rz() * self.as_inner().dist() * self.as_inner().nx()
                + T::TWO * operand.as_inner().rx() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.as_inner().tx() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.as_inner().ty() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.as_inner().tz() * self.as_inner().ny() * self.as_inner().nz(),
            -(operand.as_inner().tx())
                + -T::TWO * operand.as_inner().rz() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.as_inner().ry() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.as_inner().tx() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.as_inner().tx() * self.as_inner().nz() * self.as_inner().nz(),
            -T::TWO * operand.as_inner().rx() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().rx() * self.as_inner().nz() * self.as_inner().nz()
                + T::TWO * operand.as_inner().ry() * self.as_inner().dist() * self.as_inner().nz()
                + T::TWO * operand.as_inner().rz() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.as_inner().ty() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.as_inner().tz() * self.as_inner().nx() * self.as_inner().nz()
                + operand.as_inner().rx(),
            -T::TWO * operand.as_inner().ry() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.as_inner().rz() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.as_inner().tx() * self.as_inner().nx() * self.as_inner().ny()
                + operand.as_inner().ry(),
            -T::TWO * operand.as_inner().rz() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().tx() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.as_inner().ry() * self.as_inner().ny() * self.as_inner().nz()
                + operand.as_inner().rz(),
            -(operand.as_inner().ps()),
        )
    }
}
#[doc = "Antisandwich product: [`Plane`] x [`Plane`] x antirev([`Plane`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Plane<T>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            -(self.dist() * operand.nx() * self.nx())
                - self.dist() * operand.ny() * self.ny()
                - self.dist() * operand.nz() * self.nz()
                + self.nx() * operand.dist() * self.nx()
                - self.nx() * operand.nx() * self.dist()
                + self.ny() * operand.dist() * self.ny()
                - self.ny() * operand.ny() * self.dist()
                + self.nz() * operand.dist() * self.nz()
                - self.nz() * operand.nz() * self.dist(),
            -(self.nx() * operand.nx() * self.nz()) + self.nx() * operand.nz() * self.nx()
                - self.ny() * operand.ny() * self.nz()
                + self.ny() * operand.nz() * self.ny()
                - self.nz() * operand.nx() * self.nx()
                - self.nz() * operand.ny() * self.ny()
                - self.nz() * operand.nz() * self.nz(),
            -(self.nx() * operand.nx() * self.ny()) + self.nx() * operand.ny() * self.nx()
                - self.ny() * operand.nx() * self.nx()
                - self.ny() * operand.ny() * self.ny()
                - self.ny() * operand.nz() * self.nz()
                + self.nz() * operand.ny() * self.nz()
                - self.nz() * operand.nz() * self.ny(),
            -(self.nx() * operand.nx() * self.nx())
                - self.nx() * operand.ny() * self.ny()
                - self.nx() * operand.nz() * self.nz()
                + self.ny() * operand.nx() * self.ny()
                - self.ny() * operand.ny() * self.nx()
                + self.nz() * operand.nx() * self.nz()
                - self.nz() * operand.nz() * self.nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Plane<T>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            -T::TWO * operand.nx() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.ny() * self.as_inner().dist() * self.as_inner().ny()
                + -T::TWO * operand.nz() * self.as_inner().dist() * self.as_inner().nz()
                + operand.dist(),
            -T::TWO * operand.nx() * self.as_inner().nx() * self.as_inner().nz()
                + -T::TWO * operand.ny() * self.as_inner().ny() * self.as_inner().nz()
                + -T::TWO * operand.nz() * self.as_inner().nz() * self.as_inner().nz()
                + operand.nz(),
            -T::TWO * operand.nx() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.ny() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.nz() * self.as_inner().ny() * self.as_inner().nz()
                + operand.ny(),
            -(operand.nx())
                + -T::TWO * operand.ny() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.nz() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.nx() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.nx() * self.as_inner().nz() * self.as_inner().nz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Plane<T>>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -T::TWO * operand.as_inner().nx() * self.dist() * self.nx()
                + -T::TWO * operand.as_inner().ny() * self.dist() * self.ny()
                + -T::TWO * operand.as_inner().nz() * self.dist() * self.nz()
                + operand.as_inner().dist() * self.nx() * self.nx()
                + operand.as_inner().dist() * self.ny() * self.ny()
                + operand.as_inner().dist() * self.nz() * self.nz(),
            -(operand.as_inner().nz() * self.nz() * self.nz())
                + -T::TWO * operand.as_inner().nx() * self.nx() * self.nz()
                + -T::TWO * operand.as_inner().ny() * self.ny() * self.nz()
                + operand.as_inner().nz() * self.nx() * self.nx()
                + operand.as_inner().nz() * self.ny() * self.ny(),
            -(operand.as_inner().ny() * self.ny() * self.ny())
                + -T::TWO * operand.as_inner().nx() * self.nx() * self.ny()
                + -T::TWO * operand.as_inner().nz() * self.ny() * self.nz()
                + operand.as_inner().ny() * self.nx() * self.nx()
                + operand.as_inner().ny() * self.nz() * self.nz(),
            -(operand.as_inner().nx() * self.nx() * self.nx())
                + -T::TWO * operand.as_inner().ny() * self.nx() * self.ny()
                + -T::TWO * operand.as_inner().nz() * self.nx() * self.nz()
                + operand.as_inner().nx() * self.ny() * self.ny()
                + operand.as_inner().nx() * self.nz() * self.nz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Plane<T>>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -T::TWO * operand.as_inner().nx() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().dist() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().dist() * self.as_inner().nz()
                + operand.as_inner().dist(),
            -T::TWO * operand.as_inner().nx() * self.as_inner().nx() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().ny() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().nz() * self.as_inner().nz()
                + operand.as_inner().nz(),
            -T::TWO * operand.as_inner().nx() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().ny() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().ny() * self.as_inner().nz()
                + operand.as_inner().ny(),
            -(operand.as_inner().nx())
                + -T::TWO * operand.as_inner().ny() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.as_inner().nx() * self.as_inner().ny() * self.as_inner().ny()
                + T::TWO * operand.as_inner().nx() * self.as_inner().nz() * self.as_inner().nz(),
        )
    }
}
#[doc = "Antisandwich product: [`Plane`] x [`Point`] x antirev([`Plane`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.dist() * operand.w() * self.nx()) - self.nx() * operand.w() * self.dist()
                + self.nx() * operand.x() * self.nx()
                - self.nx() * operand.y() * self.ny()
                + self.nx() * operand.z() * self.nz()
                - self.ny() * operand.x() * self.ny()
                - self.ny() * operand.y() * self.nx()
                - self.nz() * operand.x() * self.nz()
                + self.nz() * operand.z() * self.nx(),
            self.dist() * operand.w() * self.ny()
                - self.nx() * operand.x() * self.ny()
                - self.nx() * operand.y() * self.nx()
                + self.ny() * operand.w() * self.dist()
                - self.ny() * operand.x() * self.nx()
                + self.ny() * operand.y() * self.ny()
                - self.ny() * operand.z() * self.nz()
                - self.nz() * operand.y() * self.nz()
                - self.nz() * operand.z() * self.ny(),
            -(self.dist() * operand.w() * self.nz()) + self.nx() * operand.x() * self.nz()
                - self.nx() * operand.z() * self.nx()
                - self.ny() * operand.y() * self.nz()
                - self.ny() * operand.z() * self.ny()
                - self.nz() * operand.w() * self.dist()
                + self.nz() * operand.x() * self.nx()
                - self.nz() * operand.y() * self.ny()
                + self.nz() * operand.z() * self.nz(),
            -(self.nx() * operand.w() * self.nx())
                - self.ny() * operand.w() * self.ny()
                - self.nz() * operand.w() * self.nz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Unitized<Plane<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -T::TWO * operand.w() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.x() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.x() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.y() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.z() * self.as_inner().nx() * self.as_inner().nz()
                + operand.x(),
            -(operand.y())
                + -T::TWO * operand.x() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.z() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.w() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.y() * self.as_inner().ny() * self.as_inner().ny(),
            -(operand.z())
                + -T::TWO * operand.w() * self.as_inner().dist() * self.as_inner().nz()
                + -T::TWO * operand.y() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.x() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.z() * self.as_inner().nz() * self.as_inner().nz(),
            -(operand.w()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Point<T>>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x() * self.ny() * self.ny())
                + -(operand.as_inner().x() * self.nz() * self.nz())
                + -T::TWO * operand.as_inner().w() * self.dist() * self.nx()
                + -T::TWO * operand.as_inner().y() * self.nx() * self.ny()
                + T::TWO * operand.as_inner().z() * self.nx() * self.nz()
                + operand.as_inner().x() * self.nx() * self.nx(),
            -(operand.as_inner().y() * self.nx() * self.nx())
                + -(operand.as_inner().y() * self.nz() * self.nz())
                + -T::TWO * operand.as_inner().x() * self.nx() * self.ny()
                + -T::TWO * operand.as_inner().z() * self.ny() * self.nz()
                + T::TWO * operand.as_inner().w() * self.dist() * self.ny()
                + operand.as_inner().y() * self.ny() * self.ny(),
            -(operand.as_inner().z() * self.nx() * self.nx())
                + -(operand.as_inner().z() * self.ny() * self.ny())
                + -T::TWO * operand.as_inner().w() * self.dist() * self.nz()
                + -T::TWO * operand.as_inner().y() * self.ny() * self.nz()
                + T::TWO * operand.as_inner().x() * self.nx() * self.nz()
                + operand.as_inner().z() * self.nz() * self.nz(),
            -(operand.as_inner().w() * self.nx() * self.nx())
                + -(operand.as_inner().w() * self.ny() * self.ny())
                + -(operand.as_inner().w() * self.nz() * self.nz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Point<T>>> for Unitized<Plane<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -T::TWO * operand.as_inner().w() * self.as_inner().dist() * self.as_inner().nx()
                + -T::TWO * operand.as_inner().x() * self.as_inner().ny() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().x() * self.as_inner().nz() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().nx() * self.as_inner().ny()
                + T::TWO * operand.as_inner().z() * self.as_inner().nx() * self.as_inner().nz()
                + operand.as_inner().x(),
            -(operand.as_inner().y())
                + -T::TWO * operand.as_inner().x() * self.as_inner().nx() * self.as_inner().ny()
                + -T::TWO * operand.as_inner().z() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.as_inner().w() * self.as_inner().dist() * self.as_inner().ny()
                + T::TWO * operand.as_inner().y() * self.as_inner().ny() * self.as_inner().ny(),
            -(operand.as_inner().z())
                + -T::TWO * operand.as_inner().w() * self.as_inner().dist() * self.as_inner().nz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().ny() * self.as_inner().nz()
                + T::TWO * operand.as_inner().x() * self.as_inner().nx() * self.as_inner().nz()
                + T::TWO * operand.as_inner().z() * self.as_inner().nz() * self.as_inner().nz(),
            -(operand.as_inner().w()),
        )
    }
}
#[doc = "Antisandwich product: [`Plane`] x [`Quadvector`] x antirev([`Plane`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Quadvector<T>> for Plane<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(self.nx() * operand.ps() * self.nx())
                - self.ny() * operand.ps() * self.ny()
                - self.nz() * operand.ps() * self.nz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Quadvector<T>> for Unitized<Plane<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(-(operand.ps()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Quadvector<T>>> for Plane<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(operand.as_inner().ps() * self.nx() * self.nx())
                + -(operand.as_inner().ps() * self.ny() * self.ny())
                + -(operand.as_inner().ps() * self.nz() * self.nz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Quadvector<T>>> for Unitized<Plane<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(-(operand.as_inner().ps()))
    }
}
#[doc = "Antisandwich product: [`Plane`] x [`Scalar`] x antirev([`Plane`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Plane<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.nx() * operand.s() * self.nx()
                + self.ny() * operand.s() * self.ny()
                + self.nz() * operand.s() * self.nz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unitized<Plane<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Plane<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Unitized<Plane<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Antisandwich product: [`Point`] x [`Flector`] x antirev([`Point`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Flector<T>> for Point<T> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            self.w() * operand.ny() * self.z() + self.w() * operand.nz() * self.y()
                - self.w() * operand.pw() * self.x()
                + self.w() * operand.px() * self.w()
                - self.x() * operand.pw() * self.w()
                - self.y() * operand.nz() * self.w()
                - self.z() * operand.ny() * self.w(),
            self.w() * operand.nx() * self.z()
                - self.w() * operand.nz() * self.x()
                - self.w() * operand.pw() * self.y()
                + self.w() * operand.py() * self.w()
                + self.x() * operand.nz() * self.w()
                - self.y() * operand.pw() * self.w()
                - self.z() * operand.nx() * self.w(),
            -(self.w() * operand.nx() * self.y())
                - self.w() * operand.ny() * self.x()
                - self.w() * operand.pw() * self.z()
                + self.w() * operand.pz() * self.w()
                + self.x() * operand.ny() * self.w()
                + self.y() * operand.nx() * self.w()
                - self.z() * operand.pw() * self.w(),
            -(self.w() * operand.pw() * self.w()),
            self.w() * operand.dist() * self.w() - self.w() * operand.nx() * self.x()
                + self.w() * operand.ny() * self.y()
                - self.w() * operand.nz() * self.z()
                - self.x() * operand.nx() * self.w()
                + self.y() * operand.ny() * self.w()
                - self.z() * operand.nz() * self.w(),
            -(self.w() * operand.nz() * self.w()),
            -(self.w() * operand.ny() * self.w()),
            -(self.w() * operand.nx() * self.w()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Flector<T>> for Unitized<Point<T>> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            -T::TWO * operand.pw() * self.as_inner().w() * self.as_inner().x() + operand.px(),
            -T::TWO * operand.pw() * self.as_inner().w() * self.as_inner().y() + operand.py(),
            -T::TWO * operand.pw() * self.as_inner().w() * self.as_inner().z() + operand.pz(),
            -(operand.pw()),
            -T::TWO * operand.nx() * self.as_inner().w() * self.as_inner().x()
                + -T::TWO * operand.nz() * self.as_inner().w() * self.as_inner().z()
                + T::TWO * operand.ny() * self.as_inner().w() * self.as_inner().y()
                + operand.dist(),
            -(operand.nz()),
            -(operand.ny()),
            -(operand.nx()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Flector<T>>> for Point<T> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            -T::TWO * operand.as_inner().pw() * self.w() * self.x()
                + operand.as_inner().px() * self.w() * self.w(),
            -T::TWO * operand.as_inner().pw() * self.w() * self.y()
                + operand.as_inner().py() * self.w() * self.w(),
            -T::TWO * operand.as_inner().pw() * self.w() * self.z()
                + operand.as_inner().pz() * self.w() * self.w(),
            -(operand.as_inner().pw() * self.w() * self.w()),
            -T::TWO * operand.as_inner().nx() * self.w() * self.x()
                + -T::TWO * operand.as_inner().nz() * self.w() * self.z()
                + T::TWO * operand.as_inner().ny() * self.w() * self.y()
                + operand.as_inner().dist() * self.w() * self.w(),
            -(operand.as_inner().nz() * self.w() * self.w()),
            -(operand.as_inner().ny() * self.w() * self.w()),
            -(operand.as_inner().nx() * self.w() * self.w()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Flector<T>>> for Unitized<Point<T>> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            -T::TWO * operand.as_inner().pw() * self.as_inner().w() * self.as_inner().x()
                + operand.as_inner().px(),
            -T::TWO * operand.as_inner().pw() * self.as_inner().w() * self.as_inner().y()
                + operand.as_inner().py(),
            -T::TWO * operand.as_inner().pw() * self.as_inner().w() * self.as_inner().z()
                + operand.as_inner().pz(),
            -(operand.as_inner().pw()),
            -T::TWO * operand.as_inner().nx() * self.as_inner().w() * self.as_inner().x()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().w() * self.as_inner().z()
                + T::TWO * operand.as_inner().ny() * self.as_inner().w() * self.as_inner().y()
                + operand.as_inner().dist(),
            -(operand.as_inner().nz()),
            -(operand.as_inner().ny()),
            -(operand.as_inner().nx()),
        )
    }
}
#[doc = "Antisandwich product: [`Point`] x [`Line`] x antirev([`Point`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            -(self.w() * operand.dir_x() * self.y())
                + self.w() * operand.dir_y() * self.x()
                + self.w() * operand.moment_z() * self.w()
                + self.x() * operand.dir_y() * self.w()
                - self.y() * operand.dir_x() * self.w(),
            -(self.w() * operand.dir_x() * self.z())
                + self.w() * operand.dir_z() * self.x()
                + self.w() * operand.moment_y() * self.w()
                + self.x() * operand.dir_z() * self.w()
                - self.z() * operand.dir_x() * self.w(),
            -(self.w() * operand.dir_x() * self.w()),
            -(self.w() * operand.dir_y() * self.z())
                + self.w() * operand.dir_z() * self.y()
                + self.w() * operand.moment_x() * self.w()
                + self.y() * operand.dir_z() * self.w()
                - self.z() * operand.dir_y() * self.w(),
            -(self.w() * operand.dir_y() * self.w()),
            -(self.w() * operand.dir_z() * self.w()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Unitized<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            -T::TWO * operand.dir_x() * self.as_inner().w() * self.as_inner().y()
                + T::TWO * operand.dir_y() * self.as_inner().w() * self.as_inner().x()
                + operand.moment_z(),
            -T::TWO * operand.dir_x() * self.as_inner().w() * self.as_inner().z()
                + T::TWO * operand.dir_z() * self.as_inner().w() * self.as_inner().x()
                + operand.moment_y(),
            -(operand.dir_x()),
            -T::TWO * operand.dir_y() * self.as_inner().w() * self.as_inner().z()
                + T::TWO * operand.dir_z() * self.as_inner().w() * self.as_inner().y()
                + operand.moment_x(),
            -(operand.dir_y()),
            -(operand.dir_z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Line<T>>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -T::TWO * operand.as_inner().dir_x() * self.w() * self.y()
                + T::TWO * operand.as_inner().dir_y() * self.w() * self.x()
                + operand.as_inner().moment_z() * self.w() * self.w(),
            -T::TWO * operand.as_inner().dir_x() * self.w() * self.z()
                + T::TWO * operand.as_inner().dir_z() * self.w() * self.x()
                + operand.as_inner().moment_y() * self.w() * self.w(),
            -(operand.as_inner().dir_x() * self.w() * self.w()),
            -T::TWO * operand.as_inner().dir_y() * self.w() * self.z()
                + T::TWO * operand.as_inner().dir_z() * self.w() * self.y()
                + operand.as_inner().moment_x() * self.w() * self.w(),
            -(operand.as_inner().dir_y() * self.w() * self.w()),
            -(operand.as_inner().dir_z() * self.w() * self.w()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Line<T>>> for Unitized<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -T::TWO * operand.as_inner().dir_x() * self.as_inner().w() * self.as_inner().y()
                + T::TWO * operand.as_inner().dir_y() * self.as_inner().w() * self.as_inner().x()
                + operand.as_inner().moment_z(),
            -T::TWO * operand.as_inner().dir_x() * self.as_inner().w() * self.as_inner().z()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().w() * self.as_inner().x()
                + operand.as_inner().moment_y(),
            -(operand.as_inner().dir_x()),
            -T::TWO * operand.as_inner().dir_y() * self.as_inner().w() * self.as_inner().z()
                + T::TWO * operand.as_inner().dir_z() * self.as_inner().w() * self.as_inner().y()
                + operand.as_inner().moment_x(),
            -(operand.as_inner().dir_y()),
            -(operand.as_inner().dir_z()),
        )
    }
}
#[doc = "Antisandwich product: [`Point`] x [`Motor`] x antirev([`Point`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Motor<T>> for Point<T> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            self.w() * operand.ry() * self.y()
                + self.w() * operand.rz() * self.z()
                + self.w() * operand.s() * self.w()
                + self.w() * operand.tx() * self.x()
                - self.x() * operand.tx() * self.w()
                - self.y() * operand.ry() * self.w()
                - self.z() * operand.rz() * self.w(),
            self.w() * operand.ps() * self.z() + self.w() * operand.ry() * self.x()
                - self.w() * operand.tx() * self.y()
                + self.w() * operand.tz() * self.w()
                + self.x() * operand.ry() * self.w()
                - self.y() * operand.tx() * self.w()
                - self.z() * operand.ps() * self.w(),
            -(self.w() * operand.ps() * self.y()) + self.w() * operand.rz() * self.x()
                - self.w() * operand.tx() * self.z()
                + self.w() * operand.ty() * self.w()
                + self.x() * operand.rz() * self.w()
                + self.y() * operand.ps() * self.w()
                - self.z() * operand.tx() * self.w(),
            -(self.w() * operand.tx() * self.w()),
            self.w() * operand.ps() * self.x() + self.w() * operand.rx() * self.w()
                - self.w() * operand.ry() * self.z()
                + self.w() * operand.rz() * self.y()
                - self.x() * operand.ps() * self.w()
                + self.y() * operand.rz() * self.w()
                - self.z() * operand.ry() * self.w(),
            -(self.w() * operand.ry() * self.w()),
            -(self.w() * operand.rz() * self.w()),
            -(self.w() * operand.ps() * self.w()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Motor<T>> for Unitized<Point<T>> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            operand.s(),
            -T::TWO * operand.tx() * self.as_inner().w() * self.as_inner().y()
                + T::TWO * operand.ry() * self.as_inner().w() * self.as_inner().x()
                + operand.tz(),
            -T::TWO * operand.tx() * self.as_inner().w() * self.as_inner().z()
                + T::TWO * operand.rz() * self.as_inner().w() * self.as_inner().x()
                + operand.ty(),
            -(operand.tx()),
            -T::TWO * operand.ry() * self.as_inner().w() * self.as_inner().z()
                + T::TWO * operand.rz() * self.as_inner().w() * self.as_inner().y()
                + operand.rx(),
            -(operand.ry()),
            -(operand.rz()),
            -(operand.ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Motor<T>>> for Point<T> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s() * self.w() * self.w(),
            -T::TWO * operand.as_inner().tx() * self.w() * self.y()
                + T::TWO * operand.as_inner().ry() * self.w() * self.x()
                + operand.as_inner().tz() * self.w() * self.w(),
            -T::TWO * operand.as_inner().tx() * self.w() * self.z()
                + T::TWO * operand.as_inner().rz() * self.w() * self.x()
                + operand.as_inner().ty() * self.w() * self.w(),
            -(operand.as_inner().tx() * self.w() * self.w()),
            -T::TWO * operand.as_inner().ry() * self.w() * self.z()
                + T::TWO * operand.as_inner().rz() * self.w() * self.y()
                + operand.as_inner().rx() * self.w() * self.w(),
            -(operand.as_inner().ry() * self.w() * self.w()),
            -(operand.as_inner().rz() * self.w() * self.w()),
            -(operand.as_inner().ps() * self.w() * self.w()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Motor<T>>> for Unitized<Point<T>> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s(),
            -T::TWO * operand.as_inner().tx() * self.as_inner().w() * self.as_inner().y()
                + T::TWO * operand.as_inner().ry() * self.as_inner().w() * self.as_inner().x()
                + operand.as_inner().tz(),
            -T::TWO * operand.as_inner().tx() * self.as_inner().w() * self.as_inner().z()
                + T::TWO * operand.as_inner().rz() * self.as_inner().w() * self.as_inner().x()
                + operand.as_inner().ty(),
            -(operand.as_inner().tx()),
            -T::TWO * operand.as_inner().ry() * self.as_inner().w() * self.as_inner().z()
                + T::TWO * operand.as_inner().rz() * self.as_inner().w() * self.as_inner().y()
                + operand.as_inner().rx(),
            -(operand.as_inner().ry()),
            -(operand.as_inner().rz()),
            -(operand.as_inner().ps()),
        )
    }
}
#[doc = "Antisandwich product: [`Point`] x [`Plane`] x antirev([`Point`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Plane<T>> for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            self.w() * operand.dist() * self.w() - self.w() * operand.nx() * self.x()
                + self.w() * operand.ny() * self.y()
                - self.w() * operand.nz() * self.z()
                - self.x() * operand.nx() * self.w()
                + self.y() * operand.ny() * self.w()
                - self.z() * operand.nz() * self.w(),
            -(self.w() * operand.nz() * self.w()),
            -(self.w() * operand.ny() * self.w()),
            -(self.w() * operand.nx() * self.w()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Plane<T>> for Unitized<Point<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            -T::TWO * operand.nx() * self.as_inner().w() * self.as_inner().x()
                + -T::TWO * operand.nz() * self.as_inner().w() * self.as_inner().z()
                + T::TWO * operand.ny() * self.as_inner().w() * self.as_inner().y()
                + operand.dist(),
            -(operand.nz()),
            -(operand.ny()),
            -(operand.nx()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Plane<T>>> for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -T::TWO * operand.as_inner().nx() * self.w() * self.x()
                + -T::TWO * operand.as_inner().nz() * self.w() * self.z()
                + T::TWO * operand.as_inner().ny() * self.w() * self.y()
                + operand.as_inner().dist() * self.w() * self.w(),
            -(operand.as_inner().nz() * self.w() * self.w()),
            -(operand.as_inner().ny() * self.w() * self.w()),
            -(operand.as_inner().nx() * self.w() * self.w()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Plane<T>>> for Unitized<Point<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -T::TWO * operand.as_inner().nx() * self.as_inner().w() * self.as_inner().x()
                + -T::TWO * operand.as_inner().nz() * self.as_inner().w() * self.as_inner().z()
                + T::TWO * operand.as_inner().ny() * self.as_inner().w() * self.as_inner().y()
                + operand.as_inner().dist(),
            -(operand.as_inner().nz()),
            -(operand.as_inner().ny()),
            -(operand.as_inner().nx()),
        )
    }
}
#[doc = "Antisandwich product: [`Point`] x [`Point`] x antirev([`Point`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.w() * operand.w() * self.x()) + self.w() * operand.x() * self.w()
                - self.x() * operand.w() * self.w(),
            -(self.w() * operand.w() * self.y()) + self.w() * operand.y() * self.w()
                - self.y() * operand.w() * self.w(),
            -(self.w() * operand.w() * self.z()) + self.w() * operand.z() * self.w()
                - self.z() * operand.w() * self.w(),
            -(self.w() * operand.w() * self.w()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -T::TWO * operand.w() * self.as_inner().w() * self.as_inner().x() + operand.x(),
            -T::TWO * operand.w() * self.as_inner().w() * self.as_inner().y() + operand.y(),
            -T::TWO * operand.w() * self.as_inner().w() * self.as_inner().z() + operand.z(),
            -(operand.w()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Point<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -T::TWO * operand.as_inner().w() * self.w() * self.x()
                + operand.as_inner().x() * self.w() * self.w(),
            -T::TWO * operand.as_inner().w() * self.w() * self.y()
                + operand.as_inner().y() * self.w() * self.w(),
            -T::TWO * operand.as_inner().w() * self.w() * self.z()
                + operand.as_inner().z() * self.w() * self.w(),
            -(operand.as_inner().w() * self.w() * self.w()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Point<T>>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -T::TWO * operand.as_inner().w() * self.as_inner().w() * self.as_inner().x()
                + operand.as_inner().x(),
            -T::TWO * operand.as_inner().w() * self.as_inner().w() * self.as_inner().y()
                + operand.as_inner().y(),
            -T::TWO * operand.as_inner().w() * self.as_inner().w() * self.as_inner().z()
                + operand.as_inner().z(),
            -(operand.as_inner().w()),
        )
    }
}
#[doc = "Antisandwich product: [`Point`] x [`Quadvector`] x antirev([`Point`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Quadvector<T>> for Point<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(-(self.w() * operand.ps() * self.w()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Quadvector<T>> for Unitized<Point<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(-(operand.ps()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Quadvector<T>>> for Point<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(-(operand.as_inner().ps() * self.w() * self.w()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Quadvector<T>>> for Unitized<Point<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(-(operand.as_inner().ps()))
    }
}
#[doc = "Antisandwich product: [`Point`] x [`Scalar`] x antirev([`Point`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.w() * operand.s() * self.w())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unitized<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Unitized<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Antisandwich product: [`Quadvector`] x [`Flector`] x antirev([`Quadvector`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Flector<T>> for Quadvector<T> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            self.ps() * operand.px() * self.ps(),
            self.ps() * operand.py() * self.ps(),
            self.ps() * operand.pz() * self.ps(),
            self.ps() * operand.pw() * self.ps(),
            self.ps() * operand.dist() * self.ps(),
            self.ps() * operand.nz() * self.ps(),
            self.ps() * operand.ny() * self.ps(),
            self.ps() * operand.nx() * self.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Flector<T>> for Unitized<Quadvector<T>> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            operand.px(),
            operand.py(),
            operand.pz(),
            operand.pw(),
            operand.dist(),
            operand.nz(),
            operand.ny(),
            operand.nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Flector<T>>> for Quadvector<T> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            operand.as_inner().px() * self.ps() * self.ps(),
            operand.as_inner().py() * self.ps() * self.ps(),
            operand.as_inner().pz() * self.ps() * self.ps(),
            operand.as_inner().pw() * self.ps() * self.ps(),
            operand.as_inner().dist() * self.ps() * self.ps(),
            operand.as_inner().nz() * self.ps() * self.ps(),
            operand.as_inner().ny() * self.ps() * self.ps(),
            operand.as_inner().nx() * self.ps() * self.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Flector<T>>> for Unitized<Quadvector<T>> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            operand.as_inner().px(),
            operand.as_inner().py(),
            operand.as_inner().pz(),
            operand.as_inner().pw(),
            operand.as_inner().dist(),
            operand.as_inner().nz(),
            operand.as_inner().ny(),
            operand.as_inner().nx(),
        )
    }
}
#[doc = "Antisandwich product: [`Quadvector`] x [`Line`] x antirev([`Quadvector`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Quadvector<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.ps() * operand.moment_z() * self.ps(),
            self.ps() * operand.moment_y() * self.ps(),
            self.ps() * operand.dir_x() * self.ps(),
            self.ps() * operand.moment_x() * self.ps(),
            self.ps() * operand.dir_y() * self.ps(),
            self.ps() * operand.dir_z() * self.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Unitized<Quadvector<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            operand.moment_z(),
            operand.moment_y(),
            operand.dir_x(),
            operand.moment_x(),
            operand.dir_y(),
            operand.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Line<T>>> for Quadvector<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            operand.as_inner().moment_z() * self.ps() * self.ps(),
            operand.as_inner().moment_y() * self.ps() * self.ps(),
            operand.as_inner().dir_x() * self.ps() * self.ps(),
            operand.as_inner().moment_x() * self.ps() * self.ps(),
            operand.as_inner().dir_y() * self.ps() * self.ps(),
            operand.as_inner().dir_z() * self.ps() * self.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Line<T>>> for Unitized<Quadvector<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            operand.as_inner().moment_z(),
            operand.as_inner().moment_y(),
            operand.as_inner().dir_x(),
            operand.as_inner().moment_x(),
            operand.as_inner().dir_y(),
            operand.as_inner().dir_z(),
        )
    }
}
#[doc = "Antisandwich product: [`Quadvector`] x [`Motor`] x antirev([`Quadvector`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Motor<T>> for Quadvector<T> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            self.ps() * operand.s() * self.ps(),
            self.ps() * operand.tz() * self.ps(),
            self.ps() * operand.ty() * self.ps(),
            self.ps() * operand.tx() * self.ps(),
            self.ps() * operand.rx() * self.ps(),
            self.ps() * operand.ry() * self.ps(),
            self.ps() * operand.rz() * self.ps(),
            self.ps() * operand.ps() * self.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Motor<T>> for Unitized<Quadvector<T>> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            operand.s(),
            operand.tz(),
            operand.ty(),
            operand.tx(),
            operand.rx(),
            operand.ry(),
            operand.rz(),
            operand.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Motor<T>>> for Quadvector<T> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s() * self.ps() * self.ps(),
            operand.as_inner().tz() * self.ps() * self.ps(),
            operand.as_inner().ty() * self.ps() * self.ps(),
            operand.as_inner().tx() * self.ps() * self.ps(),
            operand.as_inner().rx() * self.ps() * self.ps(),
            operand.as_inner().ry() * self.ps() * self.ps(),
            operand.as_inner().rz() * self.ps() * self.ps(),
            operand.as_inner().ps() * self.ps() * self.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Motor<T>>> for Unitized<Quadvector<T>> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            operand.as_inner().s(),
            operand.as_inner().tz(),
            operand.as_inner().ty(),
            operand.as_inner().tx(),
            operand.as_inner().rx(),
            operand.as_inner().ry(),
            operand.as_inner().rz(),
            operand.as_inner().ps(),
        )
    }
}
#[doc = "Antisandwich product: [`Quadvector`] x [`Plane`] x antirev([`Quadvector`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Plane<T>> for Quadvector<T> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            self.ps() * operand.dist() * self.ps(),
            self.ps() * operand.nz() * self.ps(),
            self.ps() * operand.ny() * self.ps(),
            self.ps() * operand.nx() * self.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Plane<T>> for Unitized<Quadvector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(operand.dist(), operand.nz(), operand.ny(), operand.nx())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Plane<T>>> for Quadvector<T> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            operand.as_inner().dist() * self.ps() * self.ps(),
            operand.as_inner().nz() * self.ps() * self.ps(),
            operand.as_inner().ny() * self.ps() * self.ps(),
            operand.as_inner().nx() * self.ps() * self.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Plane<T>>> for Unitized<Quadvector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            operand.as_inner().dist(),
            operand.as_inner().nz(),
            operand.as_inner().ny(),
            operand.as_inner().nx(),
        )
    }
}
#[doc = "Antisandwich product: [`Quadvector`] x [`Point`] x antirev([`Quadvector`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Quadvector<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.ps() * operand.x() * self.ps(),
            self.ps() * operand.y() * self.ps(),
            self.ps() * operand.z() * self.ps(),
            self.ps() * operand.w() * self.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Unitized<Quadvector<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(operand.x(), operand.y(), operand.z(), operand.w())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Point<T>>> for Quadvector<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            operand.as_inner().x() * self.ps() * self.ps(),
            operand.as_inner().y() * self.ps() * self.ps(),
            operand.as_inner().z() * self.ps() * self.ps(),
            operand.as_inner().w() * self.ps() * self.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Point<T>>> for Unitized<Quadvector<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            operand.as_inner().x(),
            operand.as_inner().y(),
            operand.as_inner().z(),
            operand.as_inner().w(),
        )
    }
}
#[doc = "Antisandwich product: [`Quadvector`] x [`Quadvector`] x antirev([`Quadvector`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Quadvector<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(self.ps() * operand.ps() * self.ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Quadvector<T>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(operand.ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Quadvector<T>>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(operand.as_inner().ps() * self.ps() * self.ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Quadvector<T>>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(operand.as_inner().ps())
    }
}
#[doc = "Antisandwich product: [`Quadvector`] x [`Scalar`] x antirev([`Quadvector`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Quadvector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.ps() * operand.s() * self.ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unitized<Quadvector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Quadvector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Unitized<Quadvector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Antisandwich product: [`Scalar`] x [`Flector`] x antirev([`Scalar`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Flector<T>> for Scalar<T> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Flector<T>> for Unitized<Scalar<T>> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Flector<T>) -> Flector<T> {
        Flector::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Flector<T>>> for Scalar<T> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Flector<T>>> for Unitized<Scalar<T>> {
    type Output = Flector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        Flector::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[doc = "Antisandwich product: [`Scalar`] x [`Line`] x antirev([`Scalar`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Unitized<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Line<T>>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Line<T>>> for Unitized<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[doc = "Antisandwich product: [`Scalar`] x [`Motor`] x antirev([`Scalar`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Motor<T>> for Scalar<T> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Motor<T>> for Unitized<Scalar<T>> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Motor<T>) -> Motor<T> {
        Motor::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Motor<T>>> for Scalar<T> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Motor<T>>> for Unitized<Scalar<T>> {
    type Output = Motor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        Motor::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[doc = "Antisandwich product: [`Scalar`] x [`Plane`] x antirev([`Scalar`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Plane<T>> for Scalar<T> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Plane<T>> for Unitized<Scalar<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Plane<T>>> for Scalar<T> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Plane<T>>> for Unitized<Scalar<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Antisandwich product: [`Scalar`] x [`Point`] x antirev([`Scalar`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Unitized<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Point<T>>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Point<T>>> for Unitized<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Antisandwich product: [`Scalar`] x [`Quadvector`] x antirev([`Scalar`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Quadvector<T>> for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Quadvector<T>> for Unitized<Scalar<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Quadvector<T>>> for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Quadvector<T>>> for Unitized<Scalar<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[doc = "Antisandwich product: [`Scalar`] x [`Scalar`] x antirev([`Scalar`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Transform a [`Flector`] using this [`Flector`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Flector<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Flector<T>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Flector<T>> for Unitized<Flector<T>> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Flector<T>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Flector<T>>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Flector<T>>> for Unitized<Flector<T>> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Line`] using this [`Flector`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Line<T>> for Flector<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Line<T>> for Unitized<Flector<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Line<T>>> for Flector<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Line<T>>> for Unitized<Flector<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Motor`] using this [`Flector`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Motor<T>> for Flector<T> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Motor<T>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Motor<T>> for Unitized<Flector<T>> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Motor<T>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Motor<T>>> for Flector<T> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Motor<T>>> for Unitized<Flector<T>> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Plane`] using this [`Flector`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Plane<T>> for Flector<T> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Plane<T>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Plane<T>> for Unitized<Flector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Plane<T>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Plane<T>>> for Flector<T> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Plane<T>>> for Unitized<Flector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Point`] using this [`Flector`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Point<T>> for Flector<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Point<T>> for Unitized<Flector<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Point<T>>> for Flector<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Point<T>>> for Unitized<Flector<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Quadvector`] using this [`Flector`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Quadvector<T>> for Flector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Quadvector<T>> for Unitized<Flector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Quadvector<T>>> for Flector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Quadvector<T>>> for Unitized<Flector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Scalar`] using this [`Flector`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Scalar<T>> for Flector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unitized<Flector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Flector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Unitized<Flector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Flector`] using this [`Line`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Flector<T>> for Line<T> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Flector<T>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Flector<T>> for Unitized<Line<T>> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Flector<T>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Flector<T>>> for Line<T> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Flector<T>>> for Unitized<Line<T>> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Line`] using this [`Line`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Line<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Line<T>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Line<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Line<T>>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Motor`] using this [`Line`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Motor<T>> for Line<T> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Motor<T>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Motor<T>> for Unitized<Line<T>> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Motor<T>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Motor<T>>> for Line<T> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Motor<T>>> for Unitized<Line<T>> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Plane`] using this [`Line`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Plane<T>> for Line<T> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Plane<T>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Plane<T>> for Unitized<Line<T>> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Plane<T>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Plane<T>>> for Line<T> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Plane<T>>> for Unitized<Line<T>> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Point`] using this [`Line`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Point<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Point<T>> for Unitized<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Point<T>>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Point<T>>> for Unitized<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Quadvector`] using this [`Line`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Quadvector<T>> for Line<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Quadvector<T>> for Unitized<Line<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Quadvector<T>>> for Line<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Quadvector<T>>> for Unitized<Line<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Scalar`] using this [`Line`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Scalar<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unitized<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Unitized<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Flector`] using this [`Motor`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Flector<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Flector<T>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Flector<T>> for Unitized<Motor<T>> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Flector<T>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Flector<T>>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Flector<T>>> for Unitized<Motor<T>> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Line`] using this [`Motor`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Line<T>> for Motor<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Line<T>> for Unitized<Motor<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Line<T>>> for Motor<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Line<T>>> for Unitized<Motor<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Motor`] using this [`Motor`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Motor<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Motor<T>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Motor<T>> for Unitized<Motor<T>> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Motor<T>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Motor<T>>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Motor<T>>> for Unitized<Motor<T>> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Plane`] using this [`Motor`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Plane<T>> for Motor<T> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Plane<T>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Plane<T>> for Unitized<Motor<T>> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Plane<T>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Plane<T>>> for Motor<T> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Plane<T>>> for Unitized<Motor<T>> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Point`] using this [`Motor`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Point<T>> for Motor<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Point<T>> for Unitized<Motor<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Point<T>>> for Motor<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Point<T>>> for Unitized<Motor<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Quadvector`] using this [`Motor`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Quadvector<T>> for Motor<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Quadvector<T>> for Unitized<Motor<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Quadvector<T>>> for Motor<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Quadvector<T>>> for Unitized<Motor<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Scalar`] using this [`Motor`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Scalar<T>> for Motor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unitized<Motor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Motor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Unitized<Motor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Flector`] using this [`Plane`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Flector<T>> for Plane<T> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Flector<T>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Flector<T>> for Unitized<Plane<T>> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Flector<T>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Flector<T>>> for Plane<T> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Flector<T>>> for Unitized<Plane<T>> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Line`] using this [`Plane`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Line<T>> for Plane<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Line<T>> for Unitized<Plane<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Line<T>>> for Plane<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Line<T>>> for Unitized<Plane<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Motor`] using this [`Plane`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Motor<T>> for Plane<T> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Motor<T>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Motor<T>> for Unitized<Plane<T>> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Motor<T>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Motor<T>>> for Plane<T> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Motor<T>>> for Unitized<Plane<T>> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Plane`] using this [`Plane`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Plane<T>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Plane<T>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Plane<T>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Plane<T>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Plane<T>>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Plane<T>>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Point`] using this [`Plane`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Point<T>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Point<T>> for Unitized<Plane<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Point<T>>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Point<T>>> for Unitized<Plane<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Quadvector`] using this [`Plane`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Quadvector<T>> for Plane<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Quadvector<T>> for Unitized<Plane<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Quadvector<T>>> for Plane<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Quadvector<T>>> for Unitized<Plane<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Scalar`] using this [`Plane`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Scalar<T>> for Plane<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unitized<Plane<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Plane<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Unitized<Plane<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Flector`] using this [`Point`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Flector<T>> for Point<T> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Flector<T>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Flector<T>> for Unitized<Point<T>> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Flector<T>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Flector<T>>> for Point<T> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Flector<T>>> for Unitized<Point<T>> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Line`] using this [`Point`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Line<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Line<T>> for Unitized<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Line<T>>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Line<T>>> for Unitized<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Motor`] using this [`Point`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Motor<T>> for Point<T> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Motor<T>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Motor<T>> for Unitized<Point<T>> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Motor<T>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Motor<T>>> for Point<T> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Motor<T>>> for Unitized<Point<T>> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Plane`] using this [`Point`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Plane<T>> for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Plane<T>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Plane<T>> for Unitized<Point<T>> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Plane<T>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Plane<T>>> for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Plane<T>>> for Unitized<Point<T>> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Point`] using this [`Point`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Point<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Point<T>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Point<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Point<T>>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Quadvector`] using this [`Point`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Quadvector<T>> for Point<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Quadvector<T>> for Unitized<Point<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Quadvector<T>>> for Point<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Quadvector<T>>> for Unitized<Point<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Scalar`] using this [`Point`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Scalar<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unitized<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Unitized<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Flector`] using this [`Quadvector`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Flector<T>> for Quadvector<T> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Flector<T>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Flector<T>> for Unitized<Quadvector<T>> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Flector<T>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Flector<T>>> for Quadvector<T> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Flector<T>>> for Unitized<Quadvector<T>> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Line`] using this [`Quadvector`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Line<T>> for Quadvector<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Line<T>> for Unitized<Quadvector<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Line<T>>> for Quadvector<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Line<T>>> for Unitized<Quadvector<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Motor`] using this [`Quadvector`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Motor<T>> for Quadvector<T> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Motor<T>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Motor<T>> for Unitized<Quadvector<T>> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Motor<T>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Motor<T>>> for Quadvector<T> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Motor<T>>> for Unitized<Quadvector<T>> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Plane`] using this [`Quadvector`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Plane<T>> for Quadvector<T> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Plane<T>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Plane<T>> for Unitized<Quadvector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Plane<T>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Plane<T>>> for Quadvector<T> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Plane<T>>> for Unitized<Quadvector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Point`] using this [`Quadvector`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Point<T>> for Quadvector<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Point<T>> for Unitized<Quadvector<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Point<T>>> for Quadvector<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Point<T>>> for Unitized<Quadvector<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Quadvector`] using this [`Quadvector`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Quadvector<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Quadvector<T>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Quadvector<T>>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Quadvector<T>>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Scalar`] using this [`Quadvector`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Scalar<T>> for Quadvector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unitized<Quadvector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Quadvector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Unitized<Quadvector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Flector`] using this [`Scalar`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Flector<T>> for Scalar<T> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Flector<T>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Flector<T>> for Unitized<Scalar<T>> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Flector<T>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Flector<T>>> for Scalar<T> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Flector<T>>> for Unitized<Scalar<T>> {
    type Output = Flector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Flector<T>>) -> Flector<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Line`] using this [`Scalar`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Line<T>> for Unitized<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Line<T>>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Line<T>>> for Unitized<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Line<T>>) -> Line<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Motor`] using this [`Scalar`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Motor<T>> for Scalar<T> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Motor<T>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Motor<T>> for Unitized<Scalar<T>> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Motor<T>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Motor<T>>> for Scalar<T> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Motor<T>>> for Unitized<Scalar<T>> {
    type Output = Motor<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Motor<T>>) -> Motor<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Plane`] using this [`Scalar`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Plane<T>> for Scalar<T> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Plane<T>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Plane<T>> for Unitized<Scalar<T>> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Plane<T>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Plane<T>>> for Scalar<T> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Plane<T>>> for Unitized<Scalar<T>> {
    type Output = Plane<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Plane<T>>) -> Plane<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Point`] using this [`Scalar`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Point<T>> for Unitized<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Point<T>>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Point<T>>> for Unitized<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Point<T>>) -> Point<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Quadvector`] using this [`Scalar`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Quadvector<T>> for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Quadvector<T>> for Unitized<Scalar<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Quadvector<T>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Quadvector<T>>> for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Quadvector<T>>> for Unitized<Scalar<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Scalar`] using this [`Scalar`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Flector<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Flector<T>) -> Option<Flector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Flector::new_unchecked(
            (-(self.dist() * operand.dist() * self.px())
                + self.dist() * operand.px() * self.dist()
                - self.dist() * operand.py() * self.pz()
                + self.dist() * operand.pz() * self.py()
                + self.px() * operand.dist() * self.dist()
                + self.px() * operand.px() * self.px()
                + self.px() * operand.py() * self.py()
                + self.px() * operand.pz() * self.pz()
                - self.py() * operand.dist() * self.pz()
                - self.py() * operand.px() * self.py()
                + self.py() * operand.py() * self.px()
                + self.py() * operand.pz() * self.dist()
                + self.pz() * operand.dist() * self.py()
                - self.pz() * operand.px() * self.pz()
                - self.pz() * operand.py() * self.dist()
                + self.pz() * operand.pz() * self.px())
                * inv_norm_sq,
            (-(self.dist() * operand.dist() * self.py())
                + self.dist() * operand.px() * self.pz()
                + self.dist() * operand.py() * self.dist()
                - self.dist() * operand.pz() * self.px()
                + self.px() * operand.dist() * self.pz()
                + self.px() * operand.px() * self.py()
                - self.px() * operand.py() * self.px()
                - self.px() * operand.pz() * self.dist()
                + self.py() * operand.dist() * self.dist()
                + self.py() * operand.px() * self.px()
                + self.py() * operand.py() * self.py()
                + self.py() * operand.pz() * self.pz()
                - self.pz() * operand.dist() * self.px()
                + self.pz() * operand.px() * self.dist()
                - self.pz() * operand.py() * self.pz()
                + self.pz() * operand.pz() * self.py())
                * inv_norm_sq,
            (-(self.dist() * operand.dist() * self.pz()) - self.dist() * operand.px() * self.py()
                + self.dist() * operand.py() * self.px()
                + self.dist() * operand.pz() * self.dist()
                - self.px() * operand.dist() * self.py()
                + self.px() * operand.px() * self.pz()
                + self.px() * operand.py() * self.dist()
                - self.px() * operand.pz() * self.px()
                + self.py() * operand.dist() * self.px()
                - self.py() * operand.px() * self.dist()
                + self.py() * operand.py() * self.pz()
                - self.py() * operand.pz() * self.py()
                + self.pz() * operand.dist() * self.dist()
                + self.pz() * operand.px() * self.px()
                + self.pz() * operand.py() * self.py()
                + self.pz() * operand.pz() * self.pz())
                * inv_norm_sq,
            (-(self.dist() * operand.dist() * self.pw()) + self.dist() * operand.nx() * self.px()
                - self.dist() * operand.ny() * self.py()
                + self.dist() * operand.nz() * self.pz()
                - self.dist() * operand.pw() * self.dist()
                + self.dist() * operand.px() * self.nx()
                - self.dist() * operand.py() * self.ny()
                + self.dist() * operand.pz() * self.nz()
                - self.nx() * operand.dist() * self.px()
                + self.nx() * operand.px() * self.dist()
                - self.nx() * operand.py() * self.pz()
                + self.nx() * operand.pz() * self.py()
                + self.ny() * operand.dist() * self.py()
                - self.ny() * operand.px() * self.pz()
                - self.ny() * operand.py() * self.dist()
                + self.ny() * operand.pz() * self.px()
                - self.nz() * operand.dist() * self.pz()
                - self.nz() * operand.px() * self.py()
                + self.nz() * operand.py() * self.px()
                + self.nz() * operand.pz() * self.dist()
                + self.pw() * operand.dist() * self.dist()
                + self.pw() * operand.px() * self.px()
                + self.pw() * operand.py() * self.py()
                + self.pw() * operand.pz() * self.pz()
                + self.px() * operand.dist() * self.nx()
                - self.px() * operand.nx() * self.dist()
                - self.px() * operand.ny() * self.pz()
                - self.px() * operand.nz() * self.py()
                - self.px() * operand.pw() * self.px()
                + self.px() * operand.px() * self.pw()
                + self.px() * operand.py() * self.nz()
                + self.px() * operand.pz() * self.ny()
                - self.py() * operand.dist() * self.ny()
                - self.py() * operand.nx() * self.pz()
                + self.py() * operand.ny() * self.dist()
                + self.py() * operand.nz() * self.px()
                - self.py() * operand.pw() * self.py()
                - self.py() * operand.px() * self.nz()
                + self.py() * operand.py() * self.pw()
                + self.py() * operand.pz() * self.nx()
                + self.pz() * operand.dist() * self.nz()
                + self.pz() * operand.nx() * self.py()
                + self.pz() * operand.ny() * self.px()
                - self.pz() * operand.nz() * self.dist()
                - self.pz() * operand.pw() * self.pz()
                - self.pz() * operand.px() * self.ny()
                - self.pz() * operand.py() * self.nx()
                + self.pz() * operand.pz() * self.pw())
                * inv_norm_sq,
            (self.dist() * operand.dist() * self.dist()
                + self.dist() * operand.px() * self.px()
                + self.dist() * operand.py() * self.py()
                + self.dist() * operand.pz() * self.pz()
                + self.px() * operand.dist() * self.px()
                - self.px() * operand.px() * self.dist()
                + self.px() * operand.py() * self.pz()
                - self.px() * operand.pz() * self.py()
                + self.py() * operand.dist() * self.py()
                - self.py() * operand.px() * self.pz()
                - self.py() * operand.py() * self.dist()
                + self.py() * operand.pz() * self.px()
                + self.pz() * operand.dist() * self.pz()
                + self.pz() * operand.px() * self.py()
                - self.pz() * operand.py() * self.px()
                - self.pz() * operand.pz() * self.dist())
                * inv_norm_sq,
            (self.dist() * operand.dist() * self.nz()
                + self.dist() * operand.nx() * self.py()
                + self.dist() * operand.ny() * self.px()
                - self.dist() * operand.nz() * self.dist()
                - self.dist() * operand.pw() * self.pz()
                - self.dist() * operand.px() * self.ny()
                - self.dist() * operand.py() * self.nx()
                + self.dist() * operand.pz() * self.pw()
                - self.nx() * operand.dist() * self.py()
                + self.nx() * operand.px() * self.pz()
                + self.nx() * operand.py() * self.dist()
                - self.nx() * operand.pz() * self.px()
                - self.ny() * operand.dist() * self.px()
                + self.ny() * operand.px() * self.dist()
                - self.ny() * operand.py() * self.pz()
                + self.ny() * operand.pz() * self.py()
                + self.nz() * operand.dist() * self.dist()
                + self.nz() * operand.px() * self.px()
                + self.nz() * operand.py() * self.py()
                + self.nz() * operand.pz() * self.pz()
                + self.pw() * operand.dist() * self.pz()
                + self.pw() * operand.px() * self.py()
                - self.pw() * operand.py() * self.px()
                - self.pw() * operand.pz() * self.dist()
                - self.px() * operand.dist() * self.ny()
                - self.px() * operand.nx() * self.pz()
                + self.px() * operand.ny() * self.dist()
                + self.px() * operand.nz() * self.px()
                - self.px() * operand.pw() * self.py()
                - self.px() * operand.px() * self.nz()
                + self.px() * operand.py() * self.pw()
                + self.px() * operand.pz() * self.nx()
                - self.py() * operand.dist() * self.nx()
                + self.py() * operand.nx() * self.dist()
                + self.py() * operand.ny() * self.pz()
                + self.py() * operand.nz() * self.py()
                + self.py() * operand.pw() * self.px()
                - self.py() * operand.px() * self.pw()
                - self.py() * operand.py() * self.nz()
                - self.py() * operand.pz() * self.ny()
                + self.pz() * operand.dist() * self.pw()
                - self.pz() * operand.nx() * self.px()
                + self.pz() * operand.ny() * self.py()
                - self.pz() * operand.nz() * self.pz()
                + self.pz() * operand.pw() * self.dist()
                - self.pz() * operand.px() * self.nx()
                + self.pz() * operand.py() * self.ny()
                - self.pz() * operand.pz() * self.nz())
                * inv_norm_sq,
            (self.dist() * operand.dist() * self.ny() + self.dist() * operand.nx() * self.pz()
                - self.dist() * operand.ny() * self.dist()
                - self.dist() * operand.nz() * self.px()
                + self.dist() * operand.pw() * self.py()
                + self.dist() * operand.px() * self.nz()
                - self.dist() * operand.py() * self.pw()
                - self.dist() * operand.pz() * self.nx()
                - self.nx() * operand.dist() * self.pz()
                - self.nx() * operand.px() * self.py()
                + self.nx() * operand.py() * self.px()
                + self.nx() * operand.pz() * self.dist()
                + self.ny() * operand.dist() * self.dist()
                + self.ny() * operand.px() * self.px()
                + self.ny() * operand.py() * self.py()
                + self.ny() * operand.pz() * self.pz()
                + self.nz() * operand.dist() * self.px()
                - self.nz() * operand.px() * self.dist()
                + self.nz() * operand.py() * self.pz()
                - self.nz() * operand.pz() * self.py()
                - self.pw() * operand.dist() * self.py()
                + self.pw() * operand.px() * self.pz()
                + self.pw() * operand.py() * self.dist()
                - self.pw() * operand.pz() * self.px()
                + self.px() * operand.dist() * self.nz()
                + self.px() * operand.nx() * self.py()
                + self.px() * operand.ny() * self.px()
                - self.px() * operand.nz() * self.dist()
                - self.px() * operand.pw() * self.pz()
                - self.px() * operand.px() * self.ny()
                - self.px() * operand.py() * self.nx()
                + self.px() * operand.pz() * self.pw()
                - self.py() * operand.dist() * self.pw()
                + self.py() * operand.nx() * self.px()
                - self.py() * operand.ny() * self.py()
                + self.py() * operand.nz() * self.pz()
                - self.py() * operand.pw() * self.dist()
                + self.py() * operand.px() * self.nx()
                - self.py() * operand.py() * self.ny()
                + self.py() * operand.pz() * self.nz()
                - self.pz() * operand.dist() * self.nx()
                + self.pz() * operand.nx() * self.dist()
                + self.pz() * operand.ny() * self.pz()
                + self.pz() * operand.nz() * self.py()
                + self.pz() * operand.pw() * self.px()
                - self.pz() * operand.px() * self.pw()
                - self.pz() * operand.py() * self.nz()
                - self.pz() * operand.pz() * self.ny())
                * inv_norm_sq,
            (self.dist() * operand.dist() * self.nx()
                - self.dist() * operand.nx() * self.dist()
                - self.dist() * operand.ny() * self.pz()
                - self.dist() * operand.nz() * self.py()
                - self.dist() * operand.pw() * self.px()
                + self.dist() * operand.px() * self.pw()
                + self.dist() * operand.py() * self.nz()
                + self.dist() * operand.pz() * self.ny()
                + self.nx() * operand.dist() * self.dist()
                + self.nx() * operand.px() * self.px()
                + self.nx() * operand.py() * self.py()
                + self.nx() * operand.pz() * self.pz()
                + self.ny() * operand.dist() * self.pz()
                + self.ny() * operand.px() * self.py()
                - self.ny() * operand.py() * self.px()
                - self.ny() * operand.pz() * self.dist()
                + self.nz() * operand.dist() * self.py()
                - self.nz() * operand.px() * self.pz()
                - self.nz() * operand.py() * self.dist()
                + self.nz() * operand.pz() * self.px()
                + self.pw() * operand.dist() * self.px()
                - self.pw() * operand.px() * self.dist()
                + self.pw() * operand.py() * self.pz()
                - self.pw() * operand.pz() * self.py()
                + self.px() * operand.dist() * self.pw()
                - self.px() * operand.nx() * self.px()
                + self.px() * operand.ny() * self.py()
                - self.px() * operand.nz() * self.pz()
                + self.px() * operand.pw() * self.dist()
                - self.px() * operand.px() * self.nx()
                + self.px() * operand.py() * self.ny()
                - self.px() * operand.pz() * self.nz()
                + self.py() * operand.dist() * self.nz()
                + self.py() * operand.nx() * self.py()
                + self.py() * operand.ny() * self.px()
                - self.py() * operand.nz() * self.dist()
                - self.py() * operand.pw() * self.pz()
                - self.py() * operand.px() * self.ny()
                - self.py() * operand.py() * self.nx()
                + self.py() * operand.pz() * self.pw()
                + self.pz() * operand.dist() * self.ny()
                + self.pz() * operand.nx() * self.pz()
                - self.pz() * operand.ny() * self.dist()
                - self.pz() * operand.nz() * self.px()
                + self.pz() * operand.pw() * self.py()
                + self.pz() * operand.px() * self.nz()
                - self.pz() * operand.py() * self.pw()
                - self.pz() * operand.pz() * self.nx())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Line<T>> for Flector<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (-(self.dist() * operand.moment_x() * self.py())
                - self.dist() * operand.moment_y() * self.px()
                + self.dist() * operand.moment_z() * self.dist()
                + self.px() * operand.moment_x() * self.pz()
                - self.px() * operand.moment_y() * self.dist()
                - self.px() * operand.moment_z() * self.px()
                - self.py() * operand.moment_x() * self.dist()
                - self.py() * operand.moment_y() * self.pz()
                - self.py() * operand.moment_z() * self.py()
                + self.pz() * operand.moment_x() * self.px()
                - self.pz() * operand.moment_y() * self.py()
                + self.pz() * operand.moment_z() * self.pz())
                * inv_norm_sq,
            (-(self.dist() * operand.moment_x() * self.pz())
                + self.dist() * operand.moment_y() * self.dist()
                + self.dist() * operand.moment_z() * self.px()
                - self.px() * operand.moment_x() * self.py()
                - self.px() * operand.moment_y() * self.px()
                + self.px() * operand.moment_z() * self.dist()
                - self.py() * operand.moment_x() * self.px()
                + self.py() * operand.moment_y() * self.py()
                - self.py() * operand.moment_z() * self.pz()
                - self.pz() * operand.moment_x() * self.dist()
                - self.pz() * operand.moment_y() * self.pz()
                - self.pz() * operand.moment_z() * self.py())
                * inv_norm_sq,
            (-(self.dist() * operand.dir_x() * self.dist())
                + self.dist() * operand.dir_y() * self.pz()
                - self.dist() * operand.dir_z() * self.py()
                - self.dist() * operand.moment_x() * self.pw()
                + self.dist() * operand.moment_y() * self.nz()
                - self.dist() * operand.moment_z() * self.ny()
                + self.nx() * operand.moment_x() * self.px()
                - self.nx() * operand.moment_y() * self.py()
                + self.nx() * operand.moment_z() * self.pz()
                + self.ny() * operand.moment_x() * self.py()
                + self.ny() * operand.moment_y() * self.px()
                - self.ny() * operand.moment_z() * self.dist()
                - self.nz() * operand.moment_x() * self.pz()
                + self.nz() * operand.moment_y() * self.dist()
                + self.nz() * operand.moment_z() * self.px()
                - self.pw() * operand.moment_x() * self.dist()
                - self.pw() * operand.moment_y() * self.pz()
                - self.pw() * operand.moment_z() * self.py()
                - self.px() * operand.dir_x() * self.px()
                - self.px() * operand.dir_y() * self.py()
                - self.px() * operand.dir_z() * self.pz()
                + self.px() * operand.moment_x() * self.nx()
                + self.px() * operand.moment_y() * self.ny()
                + self.px() * operand.moment_z() * self.nz()
                + self.py() * operand.dir_x() * self.py()
                - self.py() * operand.dir_y() * self.px()
                - self.py() * operand.dir_z() * self.dist()
                + self.py() * operand.moment_x() * self.ny()
                - self.py() * operand.moment_y() * self.nx()
                - self.py() * operand.moment_z() * self.pw()
                + self.pz() * operand.dir_x() * self.pz()
                + self.pz() * operand.dir_y() * self.dist()
                - self.pz() * operand.dir_z() * self.px()
                - self.pz() * operand.moment_x() * self.nz()
                - self.pz() * operand.moment_y() * self.pw()
                + self.pz() * operand.moment_z() * self.nx())
                * inv_norm_sq,
            (self.dist() * operand.moment_x() * self.dist()
                + self.dist() * operand.moment_y() * self.pz()
                + self.dist() * operand.moment_z() * self.py()
                + self.px() * operand.moment_x() * self.px()
                - self.px() * operand.moment_y() * self.py()
                + self.px() * operand.moment_z() * self.pz()
                - self.py() * operand.moment_x() * self.py()
                - self.py() * operand.moment_y() * self.px()
                + self.py() * operand.moment_z() * self.dist()
                - self.pz() * operand.moment_x() * self.pz()
                + self.pz() * operand.moment_y() * self.dist()
                + self.pz() * operand.moment_z() * self.px())
                * inv_norm_sq,
            (-(self.dist() * operand.dir_x() * self.pz())
                - self.dist() * operand.dir_y() * self.dist()
                + self.dist() * operand.dir_z() * self.px()
                + self.dist() * operand.moment_x() * self.nz()
                + self.dist() * operand.moment_y() * self.pw()
                - self.dist() * operand.moment_z() * self.nx()
                + self.nx() * operand.moment_x() * self.py()
                + self.nx() * operand.moment_y() * self.px()
                - self.nx() * operand.moment_z() * self.dist()
                - self.ny() * operand.moment_x() * self.px()
                + self.ny() * operand.moment_y() * self.py()
                - self.ny() * operand.moment_z() * self.pz()
                + self.nz() * operand.moment_x() * self.dist()
                + self.nz() * operand.moment_y() * self.pz()
                + self.nz() * operand.moment_z() * self.py()
                - self.pw() * operand.moment_x() * self.pz()
                + self.pw() * operand.moment_y() * self.dist()
                + self.pw() * operand.moment_z() * self.px()
                - self.px() * operand.dir_x() * self.py()
                + self.px() * operand.dir_y() * self.px()
                + self.px() * operand.dir_z() * self.dist()
                - self.px() * operand.moment_x() * self.ny()
                + self.px() * operand.moment_y() * self.nx()
                + self.px() * operand.moment_z() * self.pw()
                - self.py() * operand.dir_x() * self.px()
                - self.py() * operand.dir_y() * self.py()
                - self.py() * operand.dir_z() * self.pz()
                + self.py() * operand.moment_x() * self.nx()
                + self.py() * operand.moment_y() * self.ny()
                + self.py() * operand.moment_z() * self.nz()
                - self.pz() * operand.dir_x() * self.dist()
                + self.pz() * operand.dir_y() * self.pz()
                - self.pz() * operand.dir_z() * self.py()
                - self.pz() * operand.moment_x() * self.pw()
                + self.pz() * operand.moment_y() * self.nz()
                - self.pz() * operand.moment_z() * self.ny())
                * inv_norm_sq,
            (self.dist() * operand.dir_x() * self.py()
                - self.dist() * operand.dir_y() * self.px()
                - self.dist() * operand.dir_z() * self.dist()
                + self.dist() * operand.moment_x() * self.ny()
                - self.dist() * operand.moment_y() * self.nx()
                - self.dist() * operand.moment_z() * self.pw()
                + self.nx() * operand.moment_x() * self.pz()
                - self.nx() * operand.moment_y() * self.dist()
                - self.nx() * operand.moment_z() * self.px()
                + self.ny() * operand.moment_x() * self.dist()
                + self.ny() * operand.moment_y() * self.pz()
                + self.ny() * operand.moment_z() * self.py()
                + self.nz() * operand.moment_x() * self.px()
                - self.nz() * operand.moment_y() * self.py()
                + self.nz() * operand.moment_z() * self.pz()
                + self.pw() * operand.moment_x() * self.py()
                + self.pw() * operand.moment_y() * self.px()
                - self.pw() * operand.moment_z() * self.dist()
                - self.px() * operand.dir_x() * self.pz()
                - self.px() * operand.dir_y() * self.dist()
                + self.px() * operand.dir_z() * self.px()
                + self.px() * operand.moment_x() * self.nz()
                + self.px() * operand.moment_y() * self.pw()
                - self.px() * operand.moment_z() * self.nx()
                + self.py() * operand.dir_x() * self.dist()
                - self.py() * operand.dir_y() * self.pz()
                + self.py() * operand.dir_z() * self.py()
                + self.py() * operand.moment_x() * self.pw()
                - self.py() * operand.moment_y() * self.nz()
                + self.py() * operand.moment_z() * self.ny()
                - self.pz() * operand.dir_x() * self.px()
                - self.pz() * operand.dir_y() * self.py()
                - self.pz() * operand.dir_z() * self.pz()
                + self.pz() * operand.moment_x() * self.nx()
                + self.pz() * operand.moment_y() * self.ny()
                + self.pz() * operand.moment_z() * self.nz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Motor<T>> for Flector<T> {
    type Output = Motor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Motor<T>) -> Option<Motor<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Motor::new_unchecked(
            (-(self.dist() * operand.rx() * self.px())
                + self.dist() * operand.s() * self.dist()
                + self.dist() * operand.ty() * self.py()
                - self.dist() * operand.tz() * self.pz()
                + self.px() * operand.rx() * self.dist()
                + self.px() * operand.s() * self.px()
                + self.px() * operand.ty() * self.pz()
                + self.px() * operand.tz() * self.py()
                + self.py() * operand.rx() * self.pz()
                + self.py() * operand.s() * self.py()
                - self.py() * operand.ty() * self.dist()
                - self.py() * operand.tz() * self.px()
                - self.pz() * operand.rx() * self.py()
                + self.pz() * operand.s() * self.pz()
                - self.pz() * operand.ty() * self.px()
                + self.pz() * operand.tz() * self.dist())
                * inv_norm_sq,
            (-(self.dist() * operand.rx() * self.py()) + self.dist() * operand.s() * self.pz()
                - self.dist() * operand.ty() * self.px()
                + self.dist() * operand.tz() * self.dist()
                + self.px() * operand.rx() * self.pz()
                + self.px() * operand.s() * self.py()
                - self.px() * operand.ty() * self.dist()
                - self.px() * operand.tz() * self.px()
                - self.py() * operand.rx() * self.dist()
                - self.py() * operand.s() * self.px()
                - self.py() * operand.ty() * self.pz()
                - self.py() * operand.tz() * self.py()
                + self.pz() * operand.rx() * self.px()
                - self.pz() * operand.s() * self.dist()
                - self.pz() * operand.ty() * self.py()
                + self.pz() * operand.tz() * self.pz())
                * inv_norm_sq,
            (-(self.dist() * operand.rx() * self.pz()) - self.dist() * operand.s() * self.py()
                + self.dist() * operand.ty() * self.dist()
                + self.dist() * operand.tz() * self.px()
                - self.px() * operand.rx() * self.py()
                + self.px() * operand.s() * self.pz()
                - self.px() * operand.ty() * self.px()
                + self.px() * operand.tz() * self.dist()
                - self.py() * operand.rx() * self.px()
                + self.py() * operand.s() * self.dist()
                + self.py() * operand.ty() * self.py()
                - self.py() * operand.tz() * self.pz()
                - self.pz() * operand.rx() * self.dist()
                - self.pz() * operand.s() * self.px()
                - self.pz() * operand.ty() * self.pz()
                - self.pz() * operand.tz() * self.py())
                * inv_norm_sq,
            (self.dist() * operand.ps() * self.px() - self.dist() * operand.rx() * self.pw()
                + self.dist() * operand.ry() * self.pz()
                - self.dist() * operand.rz() * self.py()
                + self.dist() * operand.s() * self.nx()
                - self.dist() * operand.tx() * self.dist()
                + self.dist() * operand.ty() * self.nz()
                - self.dist() * operand.tz() * self.ny()
                + self.nx() * operand.rx() * self.px()
                - self.nx() * operand.s() * self.dist()
                - self.nx() * operand.ty() * self.py()
                + self.nx() * operand.tz() * self.pz()
                + self.ny() * operand.rx() * self.py()
                - self.ny() * operand.s() * self.pz()
                + self.ny() * operand.ty() * self.px()
                - self.ny() * operand.tz() * self.dist()
                - self.nz() * operand.rx() * self.pz()
                - self.nz() * operand.s() * self.py()
                + self.nz() * operand.ty() * self.dist()
                + self.nz() * operand.tz() * self.px()
                - self.pw() * operand.rx() * self.dist()
                - self.pw() * operand.s() * self.px()
                - self.pw() * operand.ty() * self.pz()
                - self.pw() * operand.tz() * self.py()
                - self.px() * operand.ps() * self.dist()
                + self.px() * operand.rx() * self.nx()
                - self.px() * operand.ry() * self.py()
                - self.px() * operand.rz() * self.pz()
                + self.px() * operand.s() * self.pw()
                - self.px() * operand.tx() * self.px()
                + self.px() * operand.ty() * self.ny()
                + self.px() * operand.tz() * self.nz()
                + self.py() * operand.ps() * self.pz()
                + self.py() * operand.rx() * self.ny()
                - self.py() * operand.ry() * self.px()
                - self.py() * operand.rz() * self.dist()
                + self.py() * operand.s() * self.nz()
                + self.py() * operand.tx() * self.py()
                - self.py() * operand.ty() * self.nx()
                - self.py() * operand.tz() * self.pw()
                - self.pz() * operand.ps() * self.py()
                - self.pz() * operand.rx() * self.nz()
                + self.pz() * operand.ry() * self.dist()
                - self.pz() * operand.rz() * self.px()
                + self.pz() * operand.s() * self.ny()
                + self.pz() * operand.tx() * self.pz()
                - self.pz() * operand.ty() * self.pw()
                + self.pz() * operand.tz() * self.nx())
                * inv_norm_sq,
            (self.dist() * operand.rx() * self.dist()
                + self.dist() * operand.s() * self.px()
                + self.dist() * operand.ty() * self.pz()
                + self.dist() * operand.tz() * self.py()
                + self.px() * operand.rx() * self.px()
                - self.px() * operand.s() * self.dist()
                - self.px() * operand.ty() * self.py()
                + self.px() * operand.tz() * self.pz()
                - self.py() * operand.rx() * self.py()
                + self.py() * operand.s() * self.pz()
                - self.py() * operand.ty() * self.px()
                + self.py() * operand.tz() * self.dist()
                - self.pz() * operand.rx() * self.pz()
                - self.pz() * operand.s() * self.py()
                + self.pz() * operand.ty() * self.dist()
                + self.pz() * operand.tz() * self.px())
                * inv_norm_sq,
            (self.dist() * operand.ps() * self.py() + self.dist() * operand.rx() * self.nz()
                - self.dist() * operand.ry() * self.dist()
                + self.dist() * operand.rz() * self.px()
                - self.dist() * operand.s() * self.ny()
                - self.dist() * operand.tx() * self.pz()
                + self.dist() * operand.ty() * self.pw()
                - self.dist() * operand.tz() * self.nx()
                + self.nx() * operand.rx() * self.py()
                - self.nx() * operand.s() * self.pz()
                + self.nx() * operand.ty() * self.px()
                - self.nx() * operand.tz() * self.dist()
                - self.ny() * operand.rx() * self.px()
                + self.ny() * operand.s() * self.dist()
                + self.ny() * operand.ty() * self.py()
                - self.ny() * operand.tz() * self.pz()
                + self.nz() * operand.rx() * self.dist()
                + self.nz() * operand.s() * self.px()
                + self.nz() * operand.ty() * self.pz()
                + self.nz() * operand.tz() * self.py()
                - self.pw() * operand.rx() * self.pz()
                - self.pw() * operand.s() * self.py()
                + self.pw() * operand.ty() * self.dist()
                + self.pw() * operand.tz() * self.px()
                - self.px() * operand.ps() * self.pz()
                - self.px() * operand.rx() * self.ny()
                + self.px() * operand.ry() * self.px()
                + self.px() * operand.rz() * self.dist()
                - self.px() * operand.s() * self.nz()
                - self.px() * operand.tx() * self.py()
                + self.px() * operand.ty() * self.nx()
                + self.px() * operand.tz() * self.pw()
                - self.py() * operand.ps() * self.dist()
                + self.py() * operand.rx() * self.nx()
                - self.py() * operand.ry() * self.py()
                - self.py() * operand.rz() * self.pz()
                + self.py() * operand.s() * self.pw()
                - self.py() * operand.tx() * self.px()
                + self.py() * operand.ty() * self.ny()
                + self.py() * operand.tz() * self.nz()
                + self.pz() * operand.ps() * self.px()
                - self.pz() * operand.rx() * self.pw()
                + self.pz() * operand.ry() * self.pz()
                - self.pz() * operand.rz() * self.py()
                + self.pz() * operand.s() * self.nx()
                - self.pz() * operand.tx() * self.dist()
                + self.pz() * operand.ty() * self.nz()
                - self.pz() * operand.tz() * self.ny())
                * inv_norm_sq,
            (self.dist() * operand.ps() * self.pz() + self.dist() * operand.rx() * self.ny()
                - self.dist() * operand.ry() * self.px()
                - self.dist() * operand.rz() * self.dist()
                + self.dist() * operand.s() * self.nz()
                + self.dist() * operand.tx() * self.py()
                - self.dist() * operand.ty() * self.nx()
                - self.dist() * operand.tz() * self.pw()
                + self.nx() * operand.rx() * self.pz()
                + self.nx() * operand.s() * self.py()
                - self.nx() * operand.ty() * self.dist()
                - self.nx() * operand.tz() * self.px()
                + self.ny() * operand.rx() * self.dist()
                + self.ny() * operand.s() * self.px()
                + self.ny() * operand.ty() * self.pz()
                + self.ny() * operand.tz() * self.py()
                + self.nz() * operand.rx() * self.px()
                - self.nz() * operand.s() * self.dist()
                - self.nz() * operand.ty() * self.py()
                + self.nz() * operand.tz() * self.pz()
                + self.pw() * operand.rx() * self.py()
                - self.pw() * operand.s() * self.pz()
                + self.pw() * operand.ty() * self.px()
                - self.pw() * operand.tz() * self.dist()
                + self.px() * operand.ps() * self.py()
                + self.px() * operand.rx() * self.nz()
                - self.px() * operand.ry() * self.dist()
                + self.px() * operand.rz() * self.px()
                - self.px() * operand.s() * self.ny()
                - self.px() * operand.tx() * self.pz()
                + self.px() * operand.ty() * self.pw()
                - self.px() * operand.tz() * self.nx()
                - self.py() * operand.ps() * self.px()
                + self.py() * operand.rx() * self.pw()
                - self.py() * operand.ry() * self.pz()
                + self.py() * operand.rz() * self.py()
                - self.py() * operand.s() * self.nx()
                + self.py() * operand.tx() * self.dist()
                - self.py() * operand.ty() * self.nz()
                + self.py() * operand.tz() * self.ny()
                - self.pz() * operand.ps() * self.dist()
                + self.pz() * operand.rx() * self.nx()
                - self.pz() * operand.ry() * self.py()
                - self.pz() * operand.rz() * self.pz()
                + self.pz() * operand.s() * self.pw()
                - self.pz() * operand.tx() * self.px()
                + self.pz() * operand.ty() * self.ny()
                + self.pz() * operand.tz() * self.nz())
                * inv_norm_sq,
            (-(self.dist() * operand.ps() * self.dist()) + self.dist() * operand.rx() * self.nx()
                - self.dist() * operand.ry() * self.py()
                - self.dist() * operand.rz() * self.pz()
                + self.dist() * operand.s() * self.pw()
                - self.dist() * operand.tx() * self.px()
                + self.dist() * operand.ty() * self.ny()
                + self.dist() * operand.tz() * self.nz()
                - self.nx() * operand.rx() * self.dist()
                - self.nx() * operand.s() * self.px()
                - self.nx() * operand.ty() * self.pz()
                - self.nx() * operand.tz() * self.py()
                + self.ny() * operand.rx() * self.pz()
                + self.ny() * operand.s() * self.py()
                - self.ny() * operand.ty() * self.dist()
                - self.ny() * operand.tz() * self.px()
                + self.nz() * operand.rx() * self.py()
                - self.nz() * operand.s() * self.pz()
                + self.nz() * operand.ty() * self.px()
                - self.nz() * operand.tz() * self.dist()
                - self.pw() * operand.rx() * self.px()
                + self.pw() * operand.s() * self.dist()
                + self.pw() * operand.ty() * self.py()
                - self.pw() * operand.tz() * self.pz()
                - self.px() * operand.ps() * self.px()
                + self.px() * operand.rx() * self.pw()
                - self.px() * operand.ry() * self.pz()
                + self.px() * operand.rz() * self.py()
                - self.px() * operand.s() * self.nx()
                + self.px() * operand.tx() * self.dist()
                - self.px() * operand.ty() * self.nz()
                + self.px() * operand.tz() * self.ny()
                - self.py() * operand.ps() * self.py()
                - self.py() * operand.rx() * self.nz()
                + self.py() * operand.ry() * self.dist()
                - self.py() * operand.rz() * self.px()
                + self.py() * operand.s() * self.ny()
                + self.py() * operand.tx() * self.pz()
                - self.py() * operand.ty() * self.pw()
                + self.py() * operand.tz() * self.nx()
                - self.pz() * operand.ps() * self.pz()
                - self.pz() * operand.rx() * self.ny()
                + self.pz() * operand.ry() * self.px()
                + self.pz() * operand.rz() * self.dist()
                - self.pz() * operand.s() * self.nz()
                - self.pz() * operand.tx() * self.py()
                + self.pz() * operand.ty() * self.nx()
                + self.pz() * operand.tz() * self.pw())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Plane<T>> for Flector<T> {
    type Output = Plane<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Plane<T>) -> Option<Plane<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Plane::new_unchecked(
            (self.dist() * operand.dist() * self.dist()
                + self.px() * operand.dist() * self.px()
                + self.py() * operand.dist() * self.py()
                + self.pz() * operand.dist() * self.pz())
                * inv_norm_sq,
            (self.dist() * operand.dist() * self.nz()
                + self.dist() * operand.nx() * self.py()
                + self.dist() * operand.ny() * self.px()
                - self.dist() * operand.nz() * self.dist()
                - self.nx() * operand.dist() * self.py()
                - self.ny() * operand.dist() * self.px()
                + self.nz() * operand.dist() * self.dist()
                + self.pw() * operand.dist() * self.pz()
                - self.px() * operand.dist() * self.ny()
                - self.px() * operand.nx() * self.pz()
                + self.px() * operand.ny() * self.dist()
                + self.px() * operand.nz() * self.px()
                - self.py() * operand.dist() * self.nx()
                + self.py() * operand.nx() * self.dist()
                + self.py() * operand.ny() * self.pz()
                + self.py() * operand.nz() * self.py()
                + self.pz() * operand.dist() * self.pw()
                - self.pz() * operand.nx() * self.px()
                + self.pz() * operand.ny() * self.py()
                - self.pz() * operand.nz() * self.pz())
                * inv_norm_sq,
            (self.dist() * operand.dist() * self.ny() + self.dist() * operand.nx() * self.pz()
                - self.dist() * operand.ny() * self.dist()
                - self.dist() * operand.nz() * self.px()
                - self.nx() * operand.dist() * self.pz()
                + self.ny() * operand.dist() * self.dist()
                + self.nz() * operand.dist() * self.px()
                - self.pw() * operand.dist() * self.py()
                + self.px() * operand.dist() * self.nz()
                + self.px() * operand.nx() * self.py()
                + self.px() * operand.ny() * self.px()
                - self.px() * operand.nz() * self.dist()
                - self.py() * operand.dist() * self.pw()
                + self.py() * operand.nx() * self.px()
                - self.py() * operand.ny() * self.py()
                + self.py() * operand.nz() * self.pz()
                - self.pz() * operand.dist() * self.nx()
                + self.pz() * operand.nx() * self.dist()
                + self.pz() * operand.ny() * self.pz()
                + self.pz() * operand.nz() * self.py())
                * inv_norm_sq,
            (self.dist() * operand.dist() * self.nx()
                - self.dist() * operand.nx() * self.dist()
                - self.dist() * operand.ny() * self.pz()
                - self.dist() * operand.nz() * self.py()
                + self.nx() * operand.dist() * self.dist()
                + self.ny() * operand.dist() * self.pz()
                + self.nz() * operand.dist() * self.py()
                + self.pw() * operand.dist() * self.px()
                + self.px() * operand.dist() * self.pw()
                - self.px() * operand.nx() * self.px()
                + self.px() * operand.ny() * self.py()
                - self.px() * operand.nz() * self.pz()
                + self.py() * operand.dist() * self.nz()
                + self.py() * operand.nx() * self.py()
                + self.py() * operand.ny() * self.px()
                - self.py() * operand.nz() * self.dist()
                + self.pz() * operand.dist() * self.ny()
                + self.pz() * operand.nx() * self.pz()
                - self.pz() * operand.ny() * self.dist()
                - self.pz() * operand.nz() * self.px())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Point<T>> for Flector<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (self.dist() * operand.x() * self.dist() - self.dist() * operand.y() * self.pz()
                + self.dist() * operand.z() * self.py()
                + self.px() * operand.x() * self.px()
                + self.px() * operand.y() * self.py()
                + self.px() * operand.z() * self.pz()
                - self.py() * operand.x() * self.py()
                + self.py() * operand.y() * self.px()
                + self.py() * operand.z() * self.dist()
                - self.pz() * operand.x() * self.pz()
                - self.pz() * operand.y() * self.dist()
                + self.pz() * operand.z() * self.px())
                * inv_norm_sq,
            (self.dist() * operand.x() * self.pz() + self.dist() * operand.y() * self.dist()
                - self.dist() * operand.z() * self.px()
                + self.px() * operand.x() * self.py()
                - self.px() * operand.y() * self.px()
                - self.px() * operand.z() * self.dist()
                + self.py() * operand.x() * self.px()
                + self.py() * operand.y() * self.py()
                + self.py() * operand.z() * self.pz()
                + self.pz() * operand.x() * self.dist()
                - self.pz() * operand.y() * self.pz()
                + self.pz() * operand.z() * self.py())
                * inv_norm_sq,
            (-(self.dist() * operand.x() * self.py())
                + self.dist() * operand.y() * self.px()
                + self.dist() * operand.z() * self.dist()
                + self.px() * operand.x() * self.pz()
                + self.px() * operand.y() * self.dist()
                - self.px() * operand.z() * self.px()
                - self.py() * operand.x() * self.dist()
                + self.py() * operand.y() * self.pz()
                - self.py() * operand.z() * self.py()
                + self.pz() * operand.x() * self.px()
                + self.pz() * operand.y() * self.py()
                + self.pz() * operand.z() * self.pz())
                * inv_norm_sq,
            (-(self.dist() * operand.w() * self.dist()) + self.dist() * operand.x() * self.nx()
                - self.dist() * operand.y() * self.ny()
                + self.dist() * operand.z() * self.nz()
                + self.nx() * operand.x() * self.dist()
                - self.nx() * operand.y() * self.pz()
                + self.nx() * operand.z() * self.py()
                - self.ny() * operand.x() * self.pz()
                - self.ny() * operand.y() * self.dist()
                + self.ny() * operand.z() * self.px()
                - self.nz() * operand.x() * self.py()
                + self.nz() * operand.y() * self.px()
                + self.nz() * operand.z() * self.dist()
                + self.pw() * operand.x() * self.px()
                + self.pw() * operand.y() * self.py()
                + self.pw() * operand.z() * self.pz()
                - self.px() * operand.w() * self.px()
                + self.px() * operand.x() * self.pw()
                + self.px() * operand.y() * self.nz()
                + self.px() * operand.z() * self.ny()
                - self.py() * operand.w() * self.py()
                - self.py() * operand.x() * self.nz()
                + self.py() * operand.y() * self.pw()
                + self.py() * operand.z() * self.nx()
                - self.pz() * operand.w() * self.pz()
                - self.pz() * operand.x() * self.ny()
                - self.pz() * operand.y() * self.nx()
                + self.pz() * operand.z() * self.pw())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Quadvector<T>> for Flector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Quadvector<T>) -> Option<Quadvector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Quadvector::new_unchecked(
            (-(self.dist() * operand.ps() * self.dist())
                - self.px() * operand.ps() * self.px()
                - self.py() * operand.ps() * self.py()
                - self.pz() * operand.ps() * self.pz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Flector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.dist() * operand.s() * self.dist()
                + self.px() * operand.s() * self.px()
                + self.py() * operand.s() * self.py()
                + self.pz() * operand.s() * self.pz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Flector<T>> for Line<T> {
    type Output = Flector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Flector<T>) -> Option<Flector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Flector::new_unchecked(
            (self.moment_x() * operand.px() * self.moment_x()
                - self.moment_x() * operand.py() * self.moment_y()
                + self.moment_x() * operand.pz() * self.moment_z()
                + self.moment_y() * operand.dist() * self.moment_z()
                - self.moment_y() * operand.px() * self.moment_y()
                - self.moment_y() * operand.py() * self.moment_x()
                - self.moment_z() * operand.dist() * self.moment_y()
                - self.moment_z() * operand.px() * self.moment_z()
                + self.moment_z() * operand.pz() * self.moment_x())
                * inv_norm_sq,
            (self.moment_x() * operand.dist() * self.moment_z()
                - self.moment_x() * operand.px() * self.moment_y()
                - self.moment_x() * operand.py() * self.moment_x()
                - self.moment_y() * operand.px() * self.moment_x()
                + self.moment_y() * operand.py() * self.moment_y()
                - self.moment_y() * operand.pz() * self.moment_z()
                - self.moment_z() * operand.dist() * self.moment_x()
                - self.moment_z() * operand.py() * self.moment_z()
                - self.moment_z() * operand.pz() * self.moment_y())
                * inv_norm_sq,
            (self.moment_x() * operand.dist() * self.moment_y()
                + self.moment_x() * operand.px() * self.moment_z()
                - self.moment_x() * operand.pz() * self.moment_x()
                - self.moment_y() * operand.dist() * self.moment_x()
                - self.moment_y() * operand.py() * self.moment_z()
                - self.moment_y() * operand.pz() * self.moment_y()
                + self.moment_z() * operand.px() * self.moment_x()
                - self.moment_z() * operand.py() * self.moment_y()
                + self.moment_z() * operand.pz() * self.moment_z())
                * inv_norm_sq,
            (-(self.dir_x() * operand.dist() * self.moment_x())
                - self.dir_x() * operand.py() * self.moment_z()
                - self.dir_x() * operand.pz() * self.moment_y()
                + self.dir_y() * operand.dist() * self.moment_y()
                + self.dir_y() * operand.px() * self.moment_z()
                - self.dir_y() * operand.pz() * self.moment_x()
                - self.dir_z() * operand.dist() * self.moment_z()
                + self.dir_z() * operand.px() * self.moment_y()
                + self.dir_z() * operand.py() * self.moment_x()
                + self.moment_x() * operand.dist() * self.dir_x()
                + self.moment_x() * operand.ny() * self.moment_z()
                - self.moment_x() * operand.nz() * self.moment_y()
                + self.moment_x() * operand.pw() * self.moment_x()
                + self.moment_x() * operand.py() * self.dir_z()
                - self.moment_x() * operand.pz() * self.dir_y()
                - self.moment_y() * operand.dist() * self.dir_y()
                - self.moment_y() * operand.nx() * self.moment_z()
                + self.moment_y() * operand.nz() * self.moment_x()
                + self.moment_y() * operand.pw() * self.moment_y()
                + self.moment_y() * operand.px() * self.dir_z()
                - self.moment_y() * operand.pz() * self.dir_x()
                + self.moment_z() * operand.dist() * self.dir_z()
                + self.moment_z() * operand.nx() * self.moment_y()
                - self.moment_z() * operand.ny() * self.moment_x()
                + self.moment_z() * operand.pw() * self.moment_z()
                + self.moment_z() * operand.px() * self.dir_y()
                - self.moment_z() * operand.py() * self.dir_x())
                * inv_norm_sq,
            (self.moment_x() * operand.dist() * self.moment_x()
                + self.moment_x() * operand.py() * self.moment_z()
                + self.moment_x() * operand.pz() * self.moment_y()
                + self.moment_y() * operand.dist() * self.moment_y()
                + self.moment_y() * operand.px() * self.moment_z()
                - self.moment_y() * operand.pz() * self.moment_x()
                + self.moment_z() * operand.dist() * self.moment_z()
                - self.moment_z() * operand.px() * self.moment_y()
                - self.moment_z() * operand.py() * self.moment_x())
                * inv_norm_sq,
            (self.dir_x() * operand.dist() * self.moment_y()
                + self.dir_x() * operand.px() * self.moment_z()
                - self.dir_x() * operand.pz() * self.moment_x()
                + self.dir_y() * operand.dist() * self.moment_x()
                + self.dir_y() * operand.py() * self.moment_z()
                + self.dir_y() * operand.pz() * self.moment_y()
                + self.dir_z() * operand.px() * self.moment_x()
                - self.dir_z() * operand.py() * self.moment_y()
                + self.dir_z() * operand.pz() * self.moment_z()
                + self.moment_x() * operand.dist() * self.dir_y()
                + self.moment_x() * operand.nx() * self.moment_z()
                - self.moment_x() * operand.nz() * self.moment_x()
                - self.moment_x() * operand.pw() * self.moment_y()
                - self.moment_x() * operand.px() * self.dir_z()
                + self.moment_x() * operand.pz() * self.dir_x()
                + self.moment_y() * operand.dist() * self.dir_x()
                + self.moment_y() * operand.ny() * self.moment_z()
                - self.moment_y() * operand.nz() * self.moment_y()
                + self.moment_y() * operand.pw() * self.moment_x()
                + self.moment_y() * operand.py() * self.dir_z()
                - self.moment_y() * operand.pz() * self.dir_y()
                + self.moment_z() * operand.nx() * self.moment_x()
                + self.moment_z() * operand.ny() * self.moment_y()
                + self.moment_z() * operand.nz() * self.moment_z()
                - self.moment_z() * operand.px() * self.dir_x()
                - self.moment_z() * operand.py() * self.dir_y()
                - self.moment_z() * operand.pz() * self.dir_z())
                * inv_norm_sq,
            (-(self.dir_x() * operand.dist() * self.moment_z())
                + self.dir_x() * operand.px() * self.moment_y()
                + self.dir_x() * operand.py() * self.moment_x()
                - self.dir_y() * operand.px() * self.moment_x()
                + self.dir_y() * operand.py() * self.moment_y()
                - self.dir_y() * operand.pz() * self.moment_z()
                + self.dir_z() * operand.dist() * self.moment_x()
                + self.dir_z() * operand.py() * self.moment_z()
                + self.dir_z() * operand.pz() * self.moment_y()
                + self.moment_x() * operand.dist() * self.dir_z()
                + self.moment_x() * operand.nx() * self.moment_y()
                - self.moment_x() * operand.ny() * self.moment_x()
                + self.moment_x() * operand.pw() * self.moment_z()
                + self.moment_x() * operand.px() * self.dir_y()
                - self.moment_x() * operand.py() * self.dir_x()
                + self.moment_y() * operand.nx() * self.moment_x()
                + self.moment_y() * operand.ny() * self.moment_y()
                + self.moment_y() * operand.nz() * self.moment_z()
                - self.moment_y() * operand.px() * self.dir_x()
                - self.moment_y() * operand.py() * self.dir_y()
                - self.moment_y() * operand.pz() * self.dir_z()
                - self.moment_z() * operand.dist() * self.dir_x()
                - self.moment_z() * operand.ny() * self.moment_z()
                + self.moment_z() * operand.nz() * self.moment_y()
                - self.moment_z() * operand.pw() * self.moment_x()
                - self.moment_z() * operand.py() * self.dir_z()
                + self.moment_z() * operand.pz() * self.dir_y())
                * inv_norm_sq,
            (self.dir_x() * operand.px() * self.moment_x()
                - self.dir_x() * operand.py() * self.moment_y()
                + self.dir_x() * operand.pz() * self.moment_z()
                - self.dir_y() * operand.dist() * self.moment_z()
                + self.dir_y() * operand.px() * self.moment_y()
                + self.dir_y() * operand.py() * self.moment_x()
                - self.dir_z() * operand.dist() * self.moment_y()
                - self.dir_z() * operand.px() * self.moment_z()
                + self.dir_z() * operand.pz() * self.moment_x()
                + self.moment_x() * operand.nx() * self.moment_x()
                + self.moment_x() * operand.ny() * self.moment_y()
                + self.moment_x() * operand.nz() * self.moment_z()
                - self.moment_x() * operand.px() * self.dir_x()
                - self.moment_x() * operand.py() * self.dir_y()
                - self.moment_x() * operand.pz() * self.dir_z()
                - self.moment_y() * operand.dist() * self.dir_z()
                - self.moment_y() * operand.nx() * self.moment_y()
                + self.moment_y() * operand.ny() * self.moment_x()
                - self.moment_y() * operand.pw() * self.moment_z()
                - self.moment_y() * operand.px() * self.dir_y()
                + self.moment_y() * operand.py() * self.dir_x()
                - self.moment_z() * operand.dist() * self.dir_y()
                - self.moment_z() * operand.nx() * self.moment_z()
                + self.moment_z() * operand.nz() * self.moment_x()
                + self.moment_z() * operand.pw() * self.moment_y()
                + self.moment_z() * operand.px() * self.dir_z()
                - self.moment_z() * operand.pz() * self.dir_x())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Line<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (self.moment_x() * operand.moment_x() * self.moment_z()
                - self.moment_x() * operand.moment_z() * self.moment_x()
                + self.moment_y() * operand.moment_y() * self.moment_z()
                - self.moment_y() * operand.moment_z() * self.moment_y()
                + self.moment_z() * operand.moment_x() * self.moment_x()
                + self.moment_z() * operand.moment_y() * self.moment_y()
                + self.moment_z() * operand.moment_z() * self.moment_z())
                * inv_norm_sq,
            (self.moment_x() * operand.moment_x() * self.moment_y()
                - self.moment_x() * operand.moment_y() * self.moment_x()
                + self.moment_y() * operand.moment_x() * self.moment_x()
                + self.moment_y() * operand.moment_y() * self.moment_y()
                + self.moment_y() * operand.moment_z() * self.moment_z()
                - self.moment_z() * operand.moment_y() * self.moment_z()
                + self.moment_z() * operand.moment_z() * self.moment_y())
                * inv_norm_sq,
            (self.dir_x() * operand.moment_x() * self.moment_x()
                + self.dir_x() * operand.moment_y() * self.moment_y()
                + self.dir_x() * operand.moment_z() * self.moment_z()
                + self.dir_y() * operand.moment_x() * self.moment_y()
                - self.dir_y() * operand.moment_y() * self.moment_x()
                - self.dir_z() * operand.moment_x() * self.moment_z()
                + self.dir_z() * operand.moment_z() * self.moment_x()
                + self.moment_x() * operand.dir_x() * self.moment_x()
                - self.moment_x() * operand.dir_y() * self.moment_y()
                + self.moment_x() * operand.dir_z() * self.moment_z()
                + self.moment_x() * operand.moment_x() * self.dir_x()
                - self.moment_x() * operand.moment_y() * self.dir_y()
                + self.moment_x() * operand.moment_z() * self.dir_z()
                - self.moment_y() * operand.dir_x() * self.moment_y()
                - self.moment_y() * operand.dir_y() * self.moment_x()
                + self.moment_y() * operand.moment_x() * self.dir_y()
                + self.moment_y() * operand.moment_y() * self.dir_x()
                - self.moment_z() * operand.dir_x() * self.moment_z()
                + self.moment_z() * operand.dir_z() * self.moment_x()
                - self.moment_z() * operand.moment_x() * self.dir_z()
                + self.moment_z() * operand.moment_z() * self.dir_x())
                * inv_norm_sq,
            (self.moment_x() * operand.moment_x() * self.moment_x()
                + self.moment_x() * operand.moment_y() * self.moment_y()
                + self.moment_x() * operand.moment_z() * self.moment_z()
                - self.moment_y() * operand.moment_x() * self.moment_y()
                + self.moment_y() * operand.moment_y() * self.moment_x()
                - self.moment_z() * operand.moment_x() * self.moment_z()
                + self.moment_z() * operand.moment_z() * self.moment_x())
                * inv_norm_sq,
            (-(self.dir_x() * operand.moment_x() * self.moment_y())
                + self.dir_x() * operand.moment_y() * self.moment_x()
                + self.dir_y() * operand.moment_x() * self.moment_x()
                + self.dir_y() * operand.moment_y() * self.moment_y()
                + self.dir_y() * operand.moment_z() * self.moment_z()
                + self.dir_z() * operand.moment_y() * self.moment_z()
                - self.dir_z() * operand.moment_z() * self.moment_y()
                - self.moment_x() * operand.dir_x() * self.moment_y()
                - self.moment_x() * operand.dir_y() * self.moment_x()
                + self.moment_x() * operand.moment_x() * self.dir_y()
                + self.moment_x() * operand.moment_y() * self.dir_x()
                - self.moment_y() * operand.dir_x() * self.moment_x()
                + self.moment_y() * operand.dir_y() * self.moment_y()
                - self.moment_y() * operand.dir_z() * self.moment_z()
                - self.moment_y() * operand.moment_x() * self.dir_x()
                + self.moment_y() * operand.moment_y() * self.dir_y()
                - self.moment_y() * operand.moment_z() * self.dir_z()
                - self.moment_z() * operand.dir_y() * self.moment_z()
                - self.moment_z() * operand.dir_z() * self.moment_y()
                + self.moment_z() * operand.moment_y() * self.dir_z()
                + self.moment_z() * operand.moment_z() * self.dir_y())
                * inv_norm_sq,
            (self.dir_x() * operand.moment_x() * self.moment_z()
                - self.dir_x() * operand.moment_z() * self.moment_x()
                - self.dir_y() * operand.moment_y() * self.moment_z()
                + self.dir_y() * operand.moment_z() * self.moment_y()
                + self.dir_z() * operand.moment_x() * self.moment_x()
                + self.dir_z() * operand.moment_y() * self.moment_y()
                + self.dir_z() * operand.moment_z() * self.moment_z()
                + self.moment_x() * operand.dir_x() * self.moment_z()
                - self.moment_x() * operand.dir_z() * self.moment_x()
                + self.moment_x() * operand.moment_x() * self.dir_z()
                - self.moment_x() * operand.moment_z() * self.dir_x()
                - self.moment_y() * operand.dir_y() * self.moment_z()
                - self.moment_y() * operand.dir_z() * self.moment_y()
                + self.moment_y() * operand.moment_y() * self.dir_z()
                + self.moment_y() * operand.moment_z() * self.dir_y()
                + self.moment_z() * operand.dir_x() * self.moment_x()
                - self.moment_z() * operand.dir_y() * self.moment_y()
                + self.moment_z() * operand.dir_z() * self.moment_z()
                + self.moment_z() * operand.moment_x() * self.dir_x()
                - self.moment_z() * operand.moment_y() * self.dir_y()
                + self.moment_z() * operand.moment_z() * self.dir_z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Motor<T>> for Line<T> {
    type Output = Motor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Motor<T>) -> Option<Motor<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Motor::new_unchecked(
            (self.moment_x() * operand.s() * self.moment_x()
                + self.moment_x() * operand.ty() * self.moment_z()
                - self.moment_x() * operand.tz() * self.moment_y()
                - self.moment_y() * operand.rx() * self.moment_z()
                + self.moment_y() * operand.s() * self.moment_y()
                + self.moment_y() * operand.tz() * self.moment_x()
                + self.moment_z() * operand.rx() * self.moment_y()
                + self.moment_z() * operand.s() * self.moment_z()
                - self.moment_z() * operand.ty() * self.moment_x())
                * inv_norm_sq,
            (self.moment_x() * operand.rx() * self.moment_z()
                - self.moment_x() * operand.s() * self.moment_y()
                - self.moment_x() * operand.tz() * self.moment_x()
                + self.moment_y() * operand.s() * self.moment_x()
                + self.moment_y() * operand.ty() * self.moment_z()
                - self.moment_y() * operand.tz() * self.moment_y()
                + self.moment_z() * operand.rx() * self.moment_x()
                + self.moment_z() * operand.ty() * self.moment_y()
                + self.moment_z() * operand.tz() * self.moment_z())
                * inv_norm_sq,
            (self.moment_x() * operand.rx() * self.moment_y()
                + self.moment_x() * operand.s() * self.moment_z()
                - self.moment_x() * operand.ty() * self.moment_x()
                + self.moment_y() * operand.rx() * self.moment_x()
                + self.moment_y() * operand.ty() * self.moment_y()
                + self.moment_y() * operand.tz() * self.moment_z()
                - self.moment_z() * operand.s() * self.moment_x()
                - self.moment_z() * operand.ty() * self.moment_z()
                + self.moment_z() * operand.tz() * self.moment_y())
                * inv_norm_sq,
            (self.dir_x() * operand.rx() * self.moment_x()
                + self.dir_x() * operand.ty() * self.moment_y()
                + self.dir_x() * operand.tz() * self.moment_z()
                + self.dir_y() * operand.rx() * self.moment_y()
                + self.dir_y() * operand.s() * self.moment_z()
                - self.dir_y() * operand.ty() * self.moment_x()
                - self.dir_z() * operand.rx() * self.moment_z()
                + self.dir_z() * operand.s() * self.moment_y()
                + self.dir_z() * operand.tz() * self.moment_x()
                + self.moment_x() * operand.rx() * self.dir_x()
                - self.moment_x() * operand.ry() * self.moment_y()
                + self.moment_x() * operand.rz() * self.moment_z()
                + self.moment_x() * operand.tx() * self.moment_x()
                - self.moment_x() * operand.ty() * self.dir_y()
                + self.moment_x() * operand.tz() * self.dir_z()
                + self.moment_y() * operand.ps() * self.moment_z()
                + self.moment_y() * operand.rx() * self.dir_y()
                - self.moment_y() * operand.ry() * self.moment_x()
                - self.moment_y() * operand.s() * self.dir_z()
                - self.moment_y() * operand.tx() * self.moment_y()
                + self.moment_y() * operand.ty() * self.dir_x()
                - self.moment_z() * operand.ps() * self.moment_y()
                - self.moment_z() * operand.rx() * self.dir_z()
                + self.moment_z() * operand.rz() * self.moment_x()
                - self.moment_z() * operand.s() * self.dir_y()
                - self.moment_z() * operand.tx() * self.moment_z()
                + self.moment_z() * operand.tz() * self.dir_x())
                * inv_norm_sq,
            (self.moment_x() * operand.rx() * self.moment_x()
                + self.moment_x() * operand.ty() * self.moment_y()
                + self.moment_x() * operand.tz() * self.moment_z()
                - self.moment_y() * operand.rx() * self.moment_y()
                - self.moment_y() * operand.s() * self.moment_z()
                + self.moment_y() * operand.ty() * self.moment_x()
                - self.moment_z() * operand.rx() * self.moment_z()
                + self.moment_z() * operand.s() * self.moment_y()
                + self.moment_z() * operand.tz() * self.moment_x())
                * inv_norm_sq,
            (-(self.dir_x() * operand.rx() * self.moment_y())
                - self.dir_x() * operand.s() * self.moment_z()
                + self.dir_x() * operand.ty() * self.moment_x()
                + self.dir_y() * operand.rx() * self.moment_x()
                + self.dir_y() * operand.ty() * self.moment_y()
                + self.dir_y() * operand.tz() * self.moment_z()
                + self.dir_z() * operand.s() * self.moment_x()
                + self.dir_z() * operand.ty() * self.moment_z()
                - self.dir_z() * operand.tz() * self.moment_y()
                + self.moment_x() * operand.ps() * self.moment_z()
                + self.moment_x() * operand.rx() * self.dir_y()
                - self.moment_x() * operand.ry() * self.moment_x()
                - self.moment_x() * operand.s() * self.dir_z()
                - self.moment_x() * operand.tx() * self.moment_y()
                + self.moment_x() * operand.ty() * self.dir_x()
                - self.moment_y() * operand.rx() * self.dir_x()
                + self.moment_y() * operand.ry() * self.moment_y()
                - self.moment_y() * operand.rz() * self.moment_z()
                - self.moment_y() * operand.tx() * self.moment_x()
                + self.moment_y() * operand.ty() * self.dir_y()
                - self.moment_y() * operand.tz() * self.dir_z()
                - self.moment_z() * operand.ps() * self.moment_x()
                - self.moment_z() * operand.ry() * self.moment_z()
                - self.moment_z() * operand.rz() * self.moment_y()
                + self.moment_z() * operand.s() * self.dir_x()
                + self.moment_z() * operand.ty() * self.dir_z()
                + self.moment_z() * operand.tz() * self.dir_y())
                * inv_norm_sq,
            (self.dir_x() * operand.rx() * self.moment_z()
                - self.dir_x() * operand.s() * self.moment_y()
                - self.dir_x() * operand.tz() * self.moment_x()
                - self.dir_y() * operand.s() * self.moment_x()
                - self.dir_y() * operand.ty() * self.moment_z()
                + self.dir_y() * operand.tz() * self.moment_y()
                + self.dir_z() * operand.rx() * self.moment_x()
                + self.dir_z() * operand.ty() * self.moment_y()
                + self.dir_z() * operand.tz() * self.moment_z()
                + self.moment_x() * operand.ps() * self.moment_y()
                + self.moment_x() * operand.rx() * self.dir_z()
                - self.moment_x() * operand.rz() * self.moment_x()
                + self.moment_x() * operand.s() * self.dir_y()
                + self.moment_x() * operand.tx() * self.moment_z()
                - self.moment_x() * operand.tz() * self.dir_x()
                - self.moment_y() * operand.ps() * self.moment_x()
                - self.moment_y() * operand.ry() * self.moment_z()
                - self.moment_y() * operand.rz() * self.moment_y()
                + self.moment_y() * operand.s() * self.dir_x()
                + self.moment_y() * operand.ty() * self.dir_z()
                + self.moment_y() * operand.tz() * self.dir_y()
                + self.moment_z() * operand.rx() * self.dir_x()
                - self.moment_z() * operand.ry() * self.moment_y()
                + self.moment_z() * operand.rz() * self.moment_z()
                + self.moment_z() * operand.tx() * self.moment_x()
                - self.moment_z() * operand.ty() * self.dir_y()
                + self.moment_z() * operand.tz() * self.dir_z())
                * inv_norm_sq,
            (-(self.dir_x() * operand.s() * self.moment_x())
                - self.dir_x() * operand.ty() * self.moment_z()
                + self.dir_x() * operand.tz() * self.moment_y()
                - self.dir_y() * operand.rx() * self.moment_z()
                + self.dir_y() * operand.s() * self.moment_y()
                + self.dir_y() * operand.tz() * self.moment_x()
                - self.dir_z() * operand.rx() * self.moment_y()
                - self.dir_z() * operand.s() * self.moment_z()
                + self.dir_z() * operand.ty() * self.moment_x()
                + self.moment_x() * operand.ps() * self.moment_x()
                + self.moment_x() * operand.ry() * self.moment_z()
                + self.moment_x() * operand.rz() * self.moment_y()
                - self.moment_x() * operand.s() * self.dir_x()
                - self.moment_x() * operand.ty() * self.dir_z()
                - self.moment_x() * operand.tz() * self.dir_y()
                + self.moment_y() * operand.ps() * self.moment_y()
                + self.moment_y() * operand.rx() * self.dir_z()
                - self.moment_y() * operand.rz() * self.moment_x()
                + self.moment_y() * operand.s() * self.dir_y()
                + self.moment_y() * operand.tx() * self.moment_z()
                - self.moment_y() * operand.tz() * self.dir_x()
                + self.moment_z() * operand.ps() * self.moment_z()
                + self.moment_z() * operand.rx() * self.dir_y()
                - self.moment_z() * operand.ry() * self.moment_x()
                - self.moment_z() * operand.s() * self.dir_z()
                - self.moment_z() * operand.tx() * self.moment_y()
                + self.moment_z() * operand.ty() * self.dir_x())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Plane<T>> for Line<T> {
    type Output = Plane<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Plane<T>) -> Option<Plane<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Plane::new_unchecked(
            (self.moment_x() * operand.dist() * self.moment_x()
                + self.moment_y() * operand.dist() * self.moment_y()
                + self.moment_z() * operand.dist() * self.moment_z())
                * inv_norm_sq,
            (self.dir_x() * operand.dist() * self.moment_y()
                + self.dir_y() * operand.dist() * self.moment_x()
                + self.moment_x() * operand.dist() * self.dir_y()
                + self.moment_x() * operand.nx() * self.moment_z()
                - self.moment_x() * operand.nz() * self.moment_x()
                + self.moment_y() * operand.dist() * self.dir_x()
                + self.moment_y() * operand.ny() * self.moment_z()
                - self.moment_y() * operand.nz() * self.moment_y()
                + self.moment_z() * operand.nx() * self.moment_x()
                + self.moment_z() * operand.ny() * self.moment_y()
                + self.moment_z() * operand.nz() * self.moment_z())
                * inv_norm_sq,
            (-(self.dir_x() * operand.dist() * self.moment_z())
                + self.dir_z() * operand.dist() * self.moment_x()
                + self.moment_x() * operand.dist() * self.dir_z()
                + self.moment_x() * operand.nx() * self.moment_y()
                - self.moment_x() * operand.ny() * self.moment_x()
                + self.moment_y() * operand.nx() * self.moment_x()
                + self.moment_y() * operand.ny() * self.moment_y()
                + self.moment_y() * operand.nz() * self.moment_z()
                - self.moment_z() * operand.dist() * self.dir_x()
                - self.moment_z() * operand.ny() * self.moment_z()
                + self.moment_z() * operand.nz() * self.moment_y())
                * inv_norm_sq,
            (-(self.dir_y() * operand.dist() * self.moment_z())
                - self.dir_z() * operand.dist() * self.moment_y()
                + self.moment_x() * operand.nx() * self.moment_x()
                + self.moment_x() * operand.ny() * self.moment_y()
                + self.moment_x() * operand.nz() * self.moment_z()
                - self.moment_y() * operand.dist() * self.dir_z()
                - self.moment_y() * operand.nx() * self.moment_y()
                + self.moment_y() * operand.ny() * self.moment_x()
                - self.moment_z() * operand.dist() * self.dir_y()
                - self.moment_z() * operand.nx() * self.moment_z()
                + self.moment_z() * operand.nz() * self.moment_x())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Point<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (self.moment_x() * operand.x() * self.moment_x()
                - self.moment_x() * operand.y() * self.moment_y()
                + self.moment_x() * operand.z() * self.moment_z()
                - self.moment_y() * operand.x() * self.moment_y()
                - self.moment_y() * operand.y() * self.moment_x()
                - self.moment_z() * operand.x() * self.moment_z()
                + self.moment_z() * operand.z() * self.moment_x())
                * inv_norm_sq,
            (-(self.moment_x() * operand.x() * self.moment_y())
                - self.moment_x() * operand.y() * self.moment_x()
                - self.moment_y() * operand.x() * self.moment_x()
                + self.moment_y() * operand.y() * self.moment_y()
                - self.moment_y() * operand.z() * self.moment_z()
                - self.moment_z() * operand.y() * self.moment_z()
                - self.moment_z() * operand.z() * self.moment_y())
                * inv_norm_sq,
            (self.moment_x() * operand.x() * self.moment_z()
                - self.moment_x() * operand.z() * self.moment_x()
                - self.moment_y() * operand.y() * self.moment_z()
                - self.moment_y() * operand.z() * self.moment_y()
                + self.moment_z() * operand.x() * self.moment_x()
                - self.moment_z() * operand.y() * self.moment_y()
                + self.moment_z() * operand.z() * self.moment_z())
                * inv_norm_sq,
            (-(self.dir_x() * operand.y() * self.moment_z())
                - self.dir_x() * operand.z() * self.moment_y()
                + self.dir_y() * operand.x() * self.moment_z()
                - self.dir_y() * operand.z() * self.moment_x()
                + self.dir_z() * operand.x() * self.moment_y()
                + self.dir_z() * operand.y() * self.moment_x()
                + self.moment_x() * operand.w() * self.moment_x()
                + self.moment_x() * operand.y() * self.dir_z()
                - self.moment_x() * operand.z() * self.dir_y()
                + self.moment_y() * operand.w() * self.moment_y()
                + self.moment_y() * operand.x() * self.dir_z()
                - self.moment_y() * operand.z() * self.dir_x()
                + self.moment_z() * operand.w() * self.moment_z()
                + self.moment_z() * operand.x() * self.dir_y()
                - self.moment_z() * operand.y() * self.dir_x())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Quadvector<T>> for Line<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Quadvector<T>) -> Option<Quadvector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Quadvector::new_unchecked(
            (self.moment_x() * operand.ps() * self.moment_x()
                + self.moment_y() * operand.ps() * self.moment_y()
                + self.moment_z() * operand.ps() * self.moment_z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.moment_x() * operand.s() * self.moment_x()
                + self.moment_y() * operand.s() * self.moment_y()
                + self.moment_z() * operand.s() * self.moment_z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Flector<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Flector<T>) -> Option<Flector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Flector::new_unchecked(
            (-(self.rx() * operand.dist() * self.s()) + self.rx() * operand.px() * self.rx()
                - self.rx() * operand.py() * self.ty()
                + self.rx() * operand.pz() * self.tz()
                + self.s() * operand.dist() * self.rx()
                + self.s() * operand.px() * self.s()
                + self.s() * operand.py() * self.tz()
                + self.s() * operand.pz() * self.ty()
                + self.ty() * operand.dist() * self.tz()
                - self.ty() * operand.px() * self.ty()
                - self.ty() * operand.py() * self.rx()
                + self.ty() * operand.pz() * self.s()
                - self.tz() * operand.dist() * self.ty()
                - self.tz() * operand.px() * self.tz()
                + self.tz() * operand.py() * self.s()
                + self.tz() * operand.pz() * self.rx())
                * inv_norm_sq,
            (self.rx() * operand.dist() * self.tz()
                - self.rx() * operand.px() * self.ty()
                - self.rx() * operand.py() * self.rx()
                + self.rx() * operand.pz() * self.s()
                - self.s() * operand.dist() * self.ty()
                - self.s() * operand.px() * self.tz()
                + self.s() * operand.py() * self.s()
                + self.s() * operand.pz() * self.rx()
                + self.ty() * operand.dist() * self.s()
                - self.ty() * operand.px() * self.rx()
                + self.ty() * operand.py() * self.ty()
                - self.ty() * operand.pz() * self.tz()
                - self.tz() * operand.dist() * self.rx()
                - self.tz() * operand.px() * self.s()
                - self.tz() * operand.py() * self.tz()
                - self.tz() * operand.pz() * self.ty())
                * inv_norm_sq,
            (self.rx() * operand.dist() * self.ty() + self.rx() * operand.px() * self.tz()
                - self.rx() * operand.py() * self.s()
                - self.rx() * operand.pz() * self.rx()
                + self.s() * operand.dist() * self.tz()
                - self.s() * operand.px() * self.ty()
                - self.s() * operand.py() * self.rx()
                + self.s() * operand.pz() * self.s()
                - self.ty() * operand.dist() * self.rx()
                - self.ty() * operand.px() * self.s()
                - self.ty() * operand.py() * self.tz()
                - self.ty() * operand.pz() * self.ty()
                - self.tz() * operand.dist() * self.s()
                + self.tz() * operand.px() * self.rx()
                - self.tz() * operand.py() * self.ty()
                + self.tz() * operand.pz() * self.tz())
                * inv_norm_sq,
            (self.ps() * operand.dist() * self.s() - self.ps() * operand.px() * self.rx()
                + self.ps() * operand.py() * self.ty()
                - self.ps() * operand.pz() * self.tz()
                + self.rx() * operand.dist() * self.tx()
                - self.rx() * operand.nx() * self.s()
                + self.rx() * operand.ny() * self.tz()
                - self.rx() * operand.nz() * self.ty()
                + self.rx() * operand.pw() * self.rx()
                - self.rx() * operand.px() * self.ps()
                + self.rx() * operand.py() * self.rz()
                - self.rx() * operand.pz() * self.ry()
                + self.ry() * operand.dist() * self.ty()
                + self.ry() * operand.px() * self.tz()
                - self.ry() * operand.py() * self.s()
                - self.ry() * operand.pz() * self.rx()
                - self.rz() * operand.dist() * self.tz()
                + self.rz() * operand.px() * self.ty()
                + self.rz() * operand.py() * self.rx()
                - self.rz() * operand.pz() * self.s()
                - self.s() * operand.dist() * self.ps()
                + self.s() * operand.nx() * self.rx()
                + self.s() * operand.ny() * self.ty()
                + self.s() * operand.nz() * self.tz()
                + self.s() * operand.pw() * self.s()
                - self.s() * operand.px() * self.tx()
                - self.s() * operand.py() * self.ry()
                - self.s() * operand.pz() * self.rz()
                - self.tx() * operand.dist() * self.rx()
                - self.tx() * operand.px() * self.s()
                - self.tx() * operand.py() * self.tz()
                - self.tx() * operand.pz() * self.ty()
                - self.ty() * operand.dist() * self.ry()
                - self.ty() * operand.nx() * self.tz()
                - self.ty() * operand.ny() * self.s()
                + self.ty() * operand.nz() * self.rx()
                + self.ty() * operand.pw() * self.ty()
                + self.ty() * operand.px() * self.rz()
                + self.ty() * operand.py() * self.ps()
                - self.ty() * operand.pz() * self.tx()
                + self.tz() * operand.dist() * self.rz()
                + self.tz() * operand.nx() * self.ty()
                - self.tz() * operand.ny() * self.rx()
                - self.tz() * operand.nz() * self.s()
                + self.tz() * operand.pw() * self.tz()
                + self.tz() * operand.px() * self.ry()
                - self.tz() * operand.py() * self.tx()
                - self.tz() * operand.pz() * self.ps())
                * inv_norm_sq,
            (self.rx() * operand.dist() * self.rx()
                + self.rx() * operand.px() * self.s()
                + self.rx() * operand.py() * self.tz()
                + self.rx() * operand.pz() * self.ty()
                + self.s() * operand.dist() * self.s()
                - self.s() * operand.px() * self.rx()
                + self.s() * operand.py() * self.ty()
                - self.s() * operand.pz() * self.tz()
                + self.ty() * operand.dist() * self.ty()
                + self.ty() * operand.px() * self.tz()
                - self.ty() * operand.py() * self.s()
                - self.ty() * operand.pz() * self.rx()
                + self.tz() * operand.dist() * self.tz()
                - self.tz() * operand.px() * self.ty()
                - self.tz() * operand.py() * self.rx()
                + self.tz() * operand.pz() * self.s())
                * inv_norm_sq,
            (-(self.ps() * operand.dist() * self.tz())
                + self.ps() * operand.px() * self.ty()
                + self.ps() * operand.py() * self.rx()
                - self.ps() * operand.pz() * self.s()
                + self.rx() * operand.dist() * self.ry()
                + self.rx() * operand.nx() * self.tz()
                + self.rx() * operand.ny() * self.s()
                - self.rx() * operand.nz() * self.rx()
                - self.rx() * operand.pw() * self.ty()
                - self.rx() * operand.px() * self.rz()
                - self.rx() * operand.py() * self.ps()
                + self.rx() * operand.pz() * self.tx()
                + self.ry() * operand.dist() * self.rx()
                + self.ry() * operand.px() * self.s()
                + self.ry() * operand.py() * self.tz()
                + self.ry() * operand.pz() * self.ty()
                - self.rz() * operand.dist() * self.s()
                + self.rz() * operand.px() * self.rx()
                - self.rz() * operand.py() * self.ty()
                + self.rz() * operand.pz() * self.tz()
                - self.s() * operand.dist() * self.rz()
                - self.s() * operand.nx() * self.ty()
                + self.s() * operand.ny() * self.rx()
                + self.s() * operand.nz() * self.s()
                - self.s() * operand.pw() * self.tz()
                - self.s() * operand.px() * self.ry()
                + self.s() * operand.py() * self.tx()
                + self.s() * operand.pz() * self.ps()
                + self.tx() * operand.dist() * self.ty()
                + self.tx() * operand.px() * self.tz()
                - self.tx() * operand.py() * self.s()
                - self.tx() * operand.pz() * self.rx()
                + self.ty() * operand.dist() * self.tx()
                - self.ty() * operand.nx() * self.s()
                + self.ty() * operand.ny() * self.tz()
                - self.ty() * operand.nz() * self.ty()
                + self.ty() * operand.pw() * self.rx()
                - self.ty() * operand.px() * self.ps()
                + self.ty() * operand.py() * self.rz()
                - self.ty() * operand.pz() * self.ry()
                - self.tz() * operand.dist() * self.ps()
                + self.tz() * operand.nx() * self.rx()
                + self.tz() * operand.ny() * self.ty()
                + self.tz() * operand.nz() * self.tz()
                + self.tz() * operand.pw() * self.s()
                - self.tz() * operand.px() * self.tx()
                - self.tz() * operand.py() * self.ry()
                - self.tz() * operand.pz() * self.rz())
                * inv_norm_sq,
            (-(self.ps() * operand.dist() * self.ty()) - self.ps() * operand.px() * self.tz()
                + self.ps() * operand.py() * self.s()
                + self.ps() * operand.pz() * self.rx()
                + self.rx() * operand.dist() * self.rz()
                + self.rx() * operand.nx() * self.ty()
                - self.rx() * operand.ny() * self.rx()
                - self.rx() * operand.nz() * self.s()
                + self.rx() * operand.pw() * self.tz()
                + self.rx() * operand.px() * self.ry()
                - self.rx() * operand.py() * self.tx()
                - self.rx() * operand.pz() * self.ps()
                + self.ry() * operand.dist() * self.s()
                - self.ry() * operand.px() * self.rx()
                + self.ry() * operand.py() * self.ty()
                - self.ry() * operand.pz() * self.tz()
                + self.rz() * operand.dist() * self.rx()
                + self.rz() * operand.px() * self.s()
                + self.rz() * operand.py() * self.tz()
                + self.rz() * operand.pz() * self.ty()
                + self.s() * operand.dist() * self.ry()
                + self.s() * operand.nx() * self.tz()
                + self.s() * operand.ny() * self.s()
                - self.s() * operand.nz() * self.rx()
                - self.s() * operand.pw() * self.ty()
                - self.s() * operand.px() * self.rz()
                - self.s() * operand.py() * self.ps()
                + self.s() * operand.pz() * self.tx()
                - self.tx() * operand.dist() * self.tz()
                + self.tx() * operand.px() * self.ty()
                + self.tx() * operand.py() * self.rx()
                - self.tx() * operand.pz() * self.s()
                - self.ty() * operand.dist() * self.ps()
                + self.ty() * operand.nx() * self.rx()
                + self.ty() * operand.ny() * self.ty()
                + self.ty() * operand.nz() * self.tz()
                + self.ty() * operand.pw() * self.s()
                - self.ty() * operand.px() * self.tx()
                - self.ty() * operand.py() * self.ry()
                - self.ty() * operand.pz() * self.rz()
                - self.tz() * operand.dist() * self.tx()
                + self.tz() * operand.nx() * self.s()
                - self.tz() * operand.ny() * self.tz()
                + self.tz() * operand.nz() * self.ty()
                - self.tz() * operand.pw() * self.rx()
                + self.tz() * operand.px() * self.ps()
                - self.tz() * operand.py() * self.rz()
                + self.tz() * operand.pz() * self.ry())
                * inv_norm_sq,
            (-(self.ps() * operand.dist() * self.rx())
                - self.ps() * operand.px() * self.s()
                - self.ps() * operand.py() * self.tz()
                - self.ps() * operand.pz() * self.ty()
                - self.rx() * operand.dist() * self.ps()
                + self.rx() * operand.nx() * self.rx()
                + self.rx() * operand.ny() * self.ty()
                + self.rx() * operand.nz() * self.tz()
                + self.rx() * operand.pw() * self.s()
                - self.rx() * operand.px() * self.tx()
                - self.rx() * operand.py() * self.ry()
                - self.rx() * operand.pz() * self.rz()
                - self.ry() * operand.dist() * self.tz()
                + self.ry() * operand.px() * self.ty()
                + self.ry() * operand.py() * self.rx()
                - self.ry() * operand.pz() * self.s()
                - self.rz() * operand.dist() * self.ty()
                - self.rz() * operand.px() * self.tz()
                + self.rz() * operand.py() * self.s()
                + self.rz() * operand.pz() * self.rx()
                - self.s() * operand.dist() * self.tx()
                + self.s() * operand.nx() * self.s()
                - self.s() * operand.ny() * self.tz()
                + self.s() * operand.nz() * self.ty()
                - self.s() * operand.pw() * self.rx()
                + self.s() * operand.px() * self.ps()
                - self.s() * operand.py() * self.rz()
                + self.s() * operand.pz() * self.ry()
                - self.tx() * operand.dist() * self.s()
                + self.tx() * operand.px() * self.rx()
                - self.tx() * operand.py() * self.ty()
                + self.tx() * operand.pz() * self.tz()
                - self.ty() * operand.dist() * self.rz()
                - self.ty() * operand.nx() * self.ty()
                + self.ty() * operand.ny() * self.rx()
                + self.ty() * operand.nz() * self.s()
                - self.ty() * operand.pw() * self.tz()
                - self.ty() * operand.px() * self.ry()
                + self.ty() * operand.py() * self.tx()
                + self.ty() * operand.pz() * self.ps()
                - self.tz() * operand.dist() * self.ry()
                - self.tz() * operand.nx() * self.tz()
                - self.tz() * operand.ny() * self.s()
                + self.tz() * operand.nz() * self.rx()
                + self.tz() * operand.pw() * self.ty()
                + self.tz() * operand.px() * self.rz()
                + self.tz() * operand.py() * self.ps()
                - self.tz() * operand.pz() * self.tx())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Line<T>> for Motor<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (self.rx() * operand.moment_x() * self.tz()
                + self.rx() * operand.moment_y() * self.s()
                - self.rx() * operand.moment_z() * self.rx()
                - self.s() * operand.moment_x() * self.ty()
                + self.s() * operand.moment_y() * self.rx()
                + self.s() * operand.moment_z() * self.s()
                - self.ty() * operand.moment_x() * self.s()
                + self.ty() * operand.moment_y() * self.tz()
                - self.ty() * operand.moment_z() * self.ty()
                + self.tz() * operand.moment_x() * self.rx()
                + self.tz() * operand.moment_y() * self.ty()
                + self.tz() * operand.moment_z() * self.tz())
                * inv_norm_sq,
            (self.rx() * operand.moment_x() * self.ty()
                - self.rx() * operand.moment_y() * self.rx()
                - self.rx() * operand.moment_z() * self.s()
                + self.s() * operand.moment_x() * self.tz()
                + self.s() * operand.moment_y() * self.s()
                - self.s() * operand.moment_z() * self.rx()
                + self.ty() * operand.moment_x() * self.rx()
                + self.ty() * operand.moment_y() * self.ty()
                + self.ty() * operand.moment_z() * self.tz()
                + self.tz() * operand.moment_x() * self.s()
                - self.tz() * operand.moment_y() * self.tz()
                + self.tz() * operand.moment_z() * self.ty())
                * inv_norm_sq,
            (-(self.ps() * operand.moment_x() * self.s())
                + self.ps() * operand.moment_y() * self.tz()
                - self.ps() * operand.moment_z() * self.ty()
                + self.rx() * operand.dir_x() * self.rx()
                - self.rx() * operand.dir_y() * self.ty()
                + self.rx() * operand.dir_z() * self.tz()
                + self.rx() * operand.moment_x() * self.tx()
                - self.rx() * operand.moment_y() * self.ry()
                + self.rx() * operand.moment_z() * self.rz()
                + self.ry() * operand.moment_x() * self.ty()
                - self.ry() * operand.moment_y() * self.rx()
                - self.ry() * operand.moment_z() * self.s()
                - self.rz() * operand.moment_x() * self.tz()
                - self.rz() * operand.moment_y() * self.s()
                + self.rz() * operand.moment_z() * self.rx()
                + self.s() * operand.dir_x() * self.s()
                + self.s() * operand.dir_y() * self.tz()
                + self.s() * operand.dir_z() * self.ty()
                - self.s() * operand.moment_x() * self.ps()
                - self.s() * operand.moment_y() * self.rz()
                - self.s() * operand.moment_z() * self.ry()
                + self.tx() * operand.moment_x() * self.rx()
                + self.tx() * operand.moment_y() * self.ty()
                + self.tx() * operand.moment_z() * self.tz()
                - self.ty() * operand.dir_x() * self.ty()
                - self.ty() * operand.dir_y() * self.rx()
                + self.ty() * operand.dir_z() * self.s()
                + self.ty() * operand.moment_x() * self.ry()
                + self.ty() * operand.moment_y() * self.tx()
                - self.ty() * operand.moment_z() * self.ps()
                - self.tz() * operand.dir_x() * self.tz()
                + self.tz() * operand.dir_y() * self.s()
                + self.tz() * operand.dir_z() * self.rx()
                - self.tz() * operand.moment_x() * self.rz()
                + self.tz() * operand.moment_y() * self.ps()
                + self.tz() * operand.moment_z() * self.tx())
                * inv_norm_sq,
            (self.rx() * operand.moment_x() * self.rx()
                + self.rx() * operand.moment_y() * self.ty()
                + self.rx() * operand.moment_z() * self.tz()
                + self.s() * operand.moment_x() * self.s()
                - self.s() * operand.moment_y() * self.tz()
                + self.s() * operand.moment_z() * self.ty()
                - self.ty() * operand.moment_x() * self.ty()
                + self.ty() * operand.moment_y() * self.rx()
                + self.ty() * operand.moment_z() * self.s()
                - self.tz() * operand.moment_x() * self.tz()
                - self.tz() * operand.moment_y() * self.s()
                + self.tz() * operand.moment_z() * self.rx())
                * inv_norm_sq,
            (self.ps() * operand.moment_x() * self.tz()
                + self.ps() * operand.moment_y() * self.s()
                - self.ps() * operand.moment_z() * self.rx()
                - self.rx() * operand.dir_x() * self.ty()
                - self.rx() * operand.dir_y() * self.rx()
                + self.rx() * operand.dir_z() * self.s()
                + self.rx() * operand.moment_x() * self.ry()
                + self.rx() * operand.moment_y() * self.tx()
                - self.rx() * operand.moment_z() * self.ps()
                + self.ry() * operand.moment_x() * self.rx()
                + self.ry() * operand.moment_y() * self.ty()
                + self.ry() * operand.moment_z() * self.tz()
                - self.rz() * operand.moment_x() * self.s()
                + self.rz() * operand.moment_y() * self.tz()
                - self.rz() * operand.moment_z() * self.ty()
                - self.s() * operand.dir_x() * self.tz()
                + self.s() * operand.dir_y() * self.s()
                + self.s() * operand.dir_z() * self.rx()
                - self.s() * operand.moment_x() * self.rz()
                + self.s() * operand.moment_y() * self.ps()
                + self.s() * operand.moment_z() * self.tx()
                - self.tx() * operand.moment_x() * self.ty()
                + self.tx() * operand.moment_y() * self.rx()
                + self.tx() * operand.moment_z() * self.s()
                - self.ty() * operand.dir_x() * self.rx()
                + self.ty() * operand.dir_y() * self.ty()
                - self.ty() * operand.dir_z() * self.tz()
                - self.ty() * operand.moment_x() * self.tx()
                + self.ty() * operand.moment_y() * self.ry()
                - self.ty() * operand.moment_z() * self.rz()
                - self.tz() * operand.dir_x() * self.s()
                - self.tz() * operand.dir_y() * self.tz()
                - self.tz() * operand.dir_z() * self.ty()
                + self.tz() * operand.moment_x() * self.ps()
                + self.tz() * operand.moment_y() * self.rz()
                + self.tz() * operand.moment_z() * self.ry())
                * inv_norm_sq,
            (self.ps() * operand.moment_x() * self.ty()
                - self.ps() * operand.moment_y() * self.rx()
                - self.ps() * operand.moment_z() * self.s()
                + self.rx() * operand.dir_x() * self.tz()
                - self.rx() * operand.dir_y() * self.s()
                - self.rx() * operand.dir_z() * self.rx()
                + self.rx() * operand.moment_x() * self.rz()
                - self.rx() * operand.moment_y() * self.ps()
                - self.rx() * operand.moment_z() * self.tx()
                + self.ry() * operand.moment_x() * self.s()
                - self.ry() * operand.moment_y() * self.tz()
                + self.ry() * operand.moment_z() * self.ty()
                + self.rz() * operand.moment_x() * self.rx()
                + self.rz() * operand.moment_y() * self.ty()
                + self.rz() * operand.moment_z() * self.tz()
                - self.s() * operand.dir_x() * self.ty()
                - self.s() * operand.dir_y() * self.rx()
                + self.s() * operand.dir_z() * self.s()
                + self.s() * operand.moment_x() * self.ry()
                + self.s() * operand.moment_y() * self.tx()
                - self.s() * operand.moment_z() * self.ps()
                + self.tx() * operand.moment_x() * self.tz()
                + self.tx() * operand.moment_y() * self.s()
                - self.tx() * operand.moment_z() * self.rx()
                - self.ty() * operand.dir_x() * self.s()
                - self.ty() * operand.dir_y() * self.tz()
                - self.ty() * operand.dir_z() * self.ty()
                + self.ty() * operand.moment_x() * self.ps()
                + self.ty() * operand.moment_y() * self.rz()
                + self.ty() * operand.moment_z() * self.ry()
                + self.tz() * operand.dir_x() * self.rx()
                - self.tz() * operand.dir_y() * self.ty()
                + self.tz() * operand.dir_z() * self.tz()
                + self.tz() * operand.moment_x() * self.tx()
                - self.tz() * operand.moment_y() * self.ry()
                + self.tz() * operand.moment_z() * self.rz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Motor<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Motor<T>) -> Option<Motor<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Motor::new_unchecked(
            (-(self.rx() * operand.rx() * self.s())
                + self.rx() * operand.s() * self.rx()
                + self.rx() * operand.ty() * self.tz()
                - self.rx() * operand.tz() * self.ty()
                + self.s() * operand.rx() * self.rx()
                + self.s() * operand.s() * self.s()
                + self.s() * operand.ty() * self.ty()
                + self.s() * operand.tz() * self.tz()
                - self.ty() * operand.rx() * self.tz()
                + self.ty() * operand.s() * self.ty()
                - self.ty() * operand.ty() * self.s()
                + self.ty() * operand.tz() * self.rx()
                + self.tz() * operand.rx() * self.ty()
                + self.tz() * operand.s() * self.tz()
                - self.tz() * operand.ty() * self.rx()
                - self.tz() * operand.tz() * self.s())
                * inv_norm_sq,
            (self.rx() * operand.rx() * self.tz() - self.rx() * operand.s() * self.ty()
                + self.rx() * operand.ty() * self.s()
                - self.rx() * operand.tz() * self.rx()
                - self.s() * operand.rx() * self.ty()
                - self.s() * operand.s() * self.tz()
                + self.s() * operand.ty() * self.rx()
                + self.s() * operand.tz() * self.s()
                - self.ty() * operand.rx() * self.s()
                + self.ty() * operand.s() * self.rx()
                + self.ty() * operand.ty() * self.tz()
                - self.ty() * operand.tz() * self.ty()
                + self.tz() * operand.rx() * self.rx()
                + self.tz() * operand.s() * self.s()
                + self.tz() * operand.ty() * self.ty()
                + self.tz() * operand.tz() * self.tz())
                * inv_norm_sq,
            (self.rx() * operand.rx() * self.ty() + self.rx() * operand.s() * self.tz()
                - self.rx() * operand.ty() * self.rx()
                - self.rx() * operand.tz() * self.s()
                + self.s() * operand.rx() * self.tz()
                - self.s() * operand.s() * self.ty()
                + self.s() * operand.ty() * self.s()
                - self.s() * operand.tz() * self.rx()
                + self.ty() * operand.rx() * self.rx()
                + self.ty() * operand.s() * self.s()
                + self.ty() * operand.ty() * self.ty()
                + self.ty() * operand.tz() * self.tz()
                + self.tz() * operand.rx() * self.s()
                - self.tz() * operand.s() * self.rx()
                - self.tz() * operand.ty() * self.tz()
                + self.tz() * operand.tz() * self.ty())
                * inv_norm_sq,
            (-(self.ps() * operand.rx() * self.s())
                + self.ps() * operand.s() * self.rx()
                + self.ps() * operand.ty() * self.tz()
                - self.ps() * operand.tz() * self.ty()
                - self.rx() * operand.ps() * self.s()
                + self.rx() * operand.rx() * self.tx()
                - self.rx() * operand.ry() * self.ty()
                + self.rx() * operand.rz() * self.tz()
                - self.rx() * operand.s() * self.ps()
                + self.rx() * operand.tx() * self.rx()
                - self.rx() * operand.ty() * self.ry()
                + self.rx() * operand.tz() * self.rz()
                + self.ry() * operand.rx() * self.ty()
                + self.ry() * operand.s() * self.tz()
                - self.ry() * operand.ty() * self.rx()
                - self.ry() * operand.tz() * self.s()
                - self.rz() * operand.rx() * self.tz()
                + self.rz() * operand.s() * self.ty()
                - self.rz() * operand.ty() * self.s()
                + self.rz() * operand.tz() * self.rx()
                + self.s() * operand.ps() * self.rx()
                - self.s() * operand.rx() * self.ps()
                + self.s() * operand.ry() * self.tz()
                + self.s() * operand.rz() * self.ty()
                - self.s() * operand.s() * self.tx()
                + self.s() * operand.tx() * self.s()
                - self.s() * operand.ty() * self.rz()
                - self.s() * operand.tz() * self.ry()
                + self.tx() * operand.rx() * self.rx()
                + self.tx() * operand.s() * self.s()
                + self.tx() * operand.ty() * self.ty()
                + self.tx() * operand.tz() * self.tz()
                + self.ty() * operand.ps() * self.tz()
                + self.ty() * operand.rx() * self.ry()
                - self.ty() * operand.ry() * self.rx()
                + self.ty() * operand.rz() * self.s()
                - self.ty() * operand.s() * self.rz()
                - self.ty() * operand.tx() * self.ty()
                + self.ty() * operand.ty() * self.tx()
                - self.ty() * operand.tz() * self.ps()
                - self.tz() * operand.ps() * self.ty()
                - self.tz() * operand.rx() * self.rz()
                + self.tz() * operand.ry() * self.s()
                + self.tz() * operand.rz() * self.rx()
                - self.tz() * operand.s() * self.ry()
                - self.tz() * operand.tx() * self.tz()
                + self.tz() * operand.ty() * self.ps()
                + self.tz() * operand.tz() * self.tx())
                * inv_norm_sq,
            (self.rx() * operand.rx() * self.rx()
                + self.rx() * operand.s() * self.s()
                + self.rx() * operand.ty() * self.ty()
                + self.rx() * operand.tz() * self.tz()
                + self.s() * operand.rx() * self.s()
                - self.s() * operand.s() * self.rx()
                - self.s() * operand.ty() * self.tz()
                + self.s() * operand.tz() * self.ty()
                - self.ty() * operand.rx() * self.ty()
                - self.ty() * operand.s() * self.tz()
                + self.ty() * operand.ty() * self.rx()
                + self.ty() * operand.tz() * self.s()
                - self.tz() * operand.rx() * self.tz()
                + self.tz() * operand.s() * self.ty()
                - self.tz() * operand.ty() * self.s()
                + self.tz() * operand.tz() * self.rx())
                * inv_norm_sq,
            (self.ps() * operand.rx() * self.tz() - self.ps() * operand.s() * self.ty()
                + self.ps() * operand.ty() * self.s()
                - self.ps() * operand.tz() * self.rx()
                + self.rx() * operand.ps() * self.tz()
                + self.rx() * operand.rx() * self.ry()
                - self.rx() * operand.ry() * self.rx()
                + self.rx() * operand.rz() * self.s()
                - self.rx() * operand.s() * self.rz()
                - self.rx() * operand.tx() * self.ty()
                + self.rx() * operand.ty() * self.tx()
                - self.rx() * operand.tz() * self.ps()
                + self.ry() * operand.rx() * self.rx()
                + self.ry() * operand.s() * self.s()
                + self.ry() * operand.ty() * self.ty()
                + self.ry() * operand.tz() * self.tz()
                - self.rz() * operand.rx() * self.s()
                + self.rz() * operand.s() * self.rx()
                + self.rz() * operand.ty() * self.tz()
                - self.rz() * operand.tz() * self.ty()
                - self.s() * operand.ps() * self.ty()
                - self.s() * operand.rx() * self.rz()
                + self.s() * operand.ry() * self.s()
                + self.s() * operand.rz() * self.rx()
                - self.s() * operand.s() * self.ry()
                - self.s() * operand.tx() * self.tz()
                + self.s() * operand.ty() * self.ps()
                + self.s() * operand.tz() * self.tx()
                - self.tx() * operand.rx() * self.ty()
                - self.tx() * operand.s() * self.tz()
                + self.tx() * operand.ty() * self.rx()
                + self.tx() * operand.tz() * self.s()
                + self.ty() * operand.ps() * self.s()
                - self.ty() * operand.rx() * self.tx()
                + self.ty() * operand.ry() * self.ty()
                - self.ty() * operand.rz() * self.tz()
                + self.ty() * operand.s() * self.ps()
                - self.ty() * operand.tx() * self.rx()
                + self.ty() * operand.ty() * self.ry()
                - self.ty() * operand.tz() * self.rz()
                - self.tz() * operand.ps() * self.rx()
                + self.tz() * operand.rx() * self.ps()
                - self.tz() * operand.ry() * self.tz()
                - self.tz() * operand.rz() * self.ty()
                + self.tz() * operand.s() * self.tx()
                - self.tz() * operand.tx() * self.s()
                + self.tz() * operand.ty() * self.rz()
                + self.tz() * operand.tz() * self.ry())
                * inv_norm_sq,
            (self.ps() * operand.rx() * self.ty() + self.ps() * operand.s() * self.tz()
                - self.ps() * operand.ty() * self.rx()
                - self.ps() * operand.tz() * self.s()
                + self.rx() * operand.ps() * self.ty()
                + self.rx() * operand.rx() * self.rz()
                - self.rx() * operand.ry() * self.s()
                - self.rx() * operand.rz() * self.rx()
                + self.rx() * operand.s() * self.ry()
                + self.rx() * operand.tx() * self.tz()
                - self.rx() * operand.ty() * self.ps()
                - self.rx() * operand.tz() * self.tx()
                + self.ry() * operand.rx() * self.s()
                - self.ry() * operand.s() * self.rx()
                - self.ry() * operand.ty() * self.tz()
                + self.ry() * operand.tz() * self.ty()
                + self.rz() * operand.rx() * self.rx()
                + self.rz() * operand.s() * self.s()
                + self.rz() * operand.ty() * self.ty()
                + self.rz() * operand.tz() * self.tz()
                + self.s() * operand.ps() * self.tz()
                + self.s() * operand.rx() * self.ry()
                - self.s() * operand.ry() * self.rx()
                + self.s() * operand.rz() * self.s()
                - self.s() * operand.s() * self.rz()
                - self.s() * operand.tx() * self.ty()
                + self.s() * operand.ty() * self.tx()
                - self.s() * operand.tz() * self.ps()
                + self.tx() * operand.rx() * self.tz()
                - self.tx() * operand.s() * self.ty()
                + self.tx() * operand.ty() * self.s()
                - self.tx() * operand.tz() * self.rx()
                - self.ty() * operand.ps() * self.rx()
                + self.ty() * operand.rx() * self.ps()
                - self.ty() * operand.ry() * self.tz()
                - self.ty() * operand.rz() * self.ty()
                + self.ty() * operand.s() * self.tx()
                - self.ty() * operand.tx() * self.s()
                + self.ty() * operand.ty() * self.rz()
                + self.ty() * operand.tz() * self.ry()
                - self.tz() * operand.ps() * self.s()
                + self.tz() * operand.rx() * self.tx()
                - self.tz() * operand.ry() * self.ty()
                + self.tz() * operand.rz() * self.tz()
                - self.tz() * operand.s() * self.ps()
                + self.tz() * operand.tx() * self.rx()
                - self.tz() * operand.ty() * self.ry()
                + self.tz() * operand.tz() * self.rz())
                * inv_norm_sq,
            (self.ps() * operand.rx() * self.rx()
                + self.ps() * operand.s() * self.s()
                + self.ps() * operand.ty() * self.ty()
                + self.ps() * operand.tz() * self.tz()
                + self.rx() * operand.ps() * self.rx()
                - self.rx() * operand.rx() * self.ps()
                + self.rx() * operand.ry() * self.tz()
                + self.rx() * operand.rz() * self.ty()
                - self.rx() * operand.s() * self.tx()
                + self.rx() * operand.tx() * self.s()
                - self.rx() * operand.ty() * self.rz()
                - self.rx() * operand.tz() * self.ry()
                - self.ry() * operand.rx() * self.tz()
                + self.ry() * operand.s() * self.ty()
                - self.ry() * operand.ty() * self.s()
                + self.ry() * operand.tz() * self.rx()
                - self.rz() * operand.rx() * self.ty()
                - self.rz() * operand.s() * self.tz()
                + self.rz() * operand.ty() * self.rx()
                + self.rz() * operand.tz() * self.s()
                + self.s() * operand.ps() * self.s()
                - self.s() * operand.rx() * self.tx()
                + self.s() * operand.ry() * self.ty()
                - self.s() * operand.rz() * self.tz()
                + self.s() * operand.s() * self.ps()
                - self.s() * operand.tx() * self.rx()
                + self.s() * operand.ty() * self.ry()
                - self.s() * operand.tz() * self.rz()
                + self.tx() * operand.rx() * self.s()
                - self.tx() * operand.s() * self.rx()
                - self.tx() * operand.ty() * self.tz()
                + self.tx() * operand.tz() * self.ty()
                + self.ty() * operand.ps() * self.ty()
                + self.ty() * operand.rx() * self.rz()
                - self.ty() * operand.ry() * self.s()
                - self.ty() * operand.rz() * self.rx()
                + self.ty() * operand.s() * self.ry()
                + self.ty() * operand.tx() * self.tz()
                - self.ty() * operand.ty() * self.ps()
                - self.ty() * operand.tz() * self.tx()
                + self.tz() * operand.ps() * self.tz()
                + self.tz() * operand.rx() * self.ry()
                - self.tz() * operand.ry() * self.rx()
                + self.tz() * operand.rz() * self.s()
                - self.tz() * operand.s() * self.rz()
                - self.tz() * operand.tx() * self.ty()
                + self.tz() * operand.ty() * self.tx()
                - self.tz() * operand.tz() * self.ps())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Plane<T>> for Motor<T> {
    type Output = Plane<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Plane<T>) -> Option<Plane<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Plane::new_unchecked(
            (self.rx() * operand.dist() * self.rx()
                + self.s() * operand.dist() * self.s()
                + self.ty() * operand.dist() * self.ty()
                + self.tz() * operand.dist() * self.tz())
                * inv_norm_sq,
            (-(self.ps() * operand.dist() * self.tz())
                + self.rx() * operand.dist() * self.ry()
                + self.rx() * operand.nx() * self.tz()
                + self.rx() * operand.ny() * self.s()
                - self.rx() * operand.nz() * self.rx()
                + self.ry() * operand.dist() * self.rx()
                - self.rz() * operand.dist() * self.s()
                - self.s() * operand.dist() * self.rz()
                - self.s() * operand.nx() * self.ty()
                + self.s() * operand.ny() * self.rx()
                + self.s() * operand.nz() * self.s()
                + self.tx() * operand.dist() * self.ty()
                + self.ty() * operand.dist() * self.tx()
                - self.ty() * operand.nx() * self.s()
                + self.ty() * operand.ny() * self.tz()
                - self.ty() * operand.nz() * self.ty()
                - self.tz() * operand.dist() * self.ps()
                + self.tz() * operand.nx() * self.rx()
                + self.tz() * operand.ny() * self.ty()
                + self.tz() * operand.nz() * self.tz())
                * inv_norm_sq,
            (-(self.ps() * operand.dist() * self.ty())
                + self.rx() * operand.dist() * self.rz()
                + self.rx() * operand.nx() * self.ty()
                - self.rx() * operand.ny() * self.rx()
                - self.rx() * operand.nz() * self.s()
                + self.ry() * operand.dist() * self.s()
                + self.rz() * operand.dist() * self.rx()
                + self.s() * operand.dist() * self.ry()
                + self.s() * operand.nx() * self.tz()
                + self.s() * operand.ny() * self.s()
                - self.s() * operand.nz() * self.rx()
                - self.tx() * operand.dist() * self.tz()
                - self.ty() * operand.dist() * self.ps()
                + self.ty() * operand.nx() * self.rx()
                + self.ty() * operand.ny() * self.ty()
                + self.ty() * operand.nz() * self.tz()
                - self.tz() * operand.dist() * self.tx()
                + self.tz() * operand.nx() * self.s()
                - self.tz() * operand.ny() * self.tz()
                + self.tz() * operand.nz() * self.ty())
                * inv_norm_sq,
            (-(self.ps() * operand.dist() * self.rx()) - self.rx() * operand.dist() * self.ps()
                + self.rx() * operand.nx() * self.rx()
                + self.rx() * operand.ny() * self.ty()
                + self.rx() * operand.nz() * self.tz()
                - self.ry() * operand.dist() * self.tz()
                - self.rz() * operand.dist() * self.ty()
                - self.s() * operand.dist() * self.tx()
                + self.s() * operand.nx() * self.s()
                - self.s() * operand.ny() * self.tz()
                + self.s() * operand.nz() * self.ty()
                - self.tx() * operand.dist() * self.s()
                - self.ty() * operand.dist() * self.rz()
                - self.ty() * operand.nx() * self.ty()
                + self.ty() * operand.ny() * self.rx()
                + self.ty() * operand.nz() * self.s()
                - self.tz() * operand.dist() * self.ry()
                - self.tz() * operand.nx() * self.tz()
                - self.tz() * operand.ny() * self.s()
                + self.tz() * operand.nz() * self.rx())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Point<T>> for Motor<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (self.rx() * operand.x() * self.rx() - self.rx() * operand.y() * self.ty()
                + self.rx() * operand.z() * self.tz()
                + self.s() * operand.x() * self.s()
                + self.s() * operand.y() * self.tz()
                + self.s() * operand.z() * self.ty()
                - self.ty() * operand.x() * self.ty()
                - self.ty() * operand.y() * self.rx()
                + self.ty() * operand.z() * self.s()
                - self.tz() * operand.x() * self.tz()
                + self.tz() * operand.y() * self.s()
                + self.tz() * operand.z() * self.rx())
                * inv_norm_sq,
            (-(self.rx() * operand.x() * self.ty()) - self.rx() * operand.y() * self.rx()
                + self.rx() * operand.z() * self.s()
                - self.s() * operand.x() * self.tz()
                + self.s() * operand.y() * self.s()
                + self.s() * operand.z() * self.rx()
                - self.ty() * operand.x() * self.rx()
                + self.ty() * operand.y() * self.ty()
                - self.ty() * operand.z() * self.tz()
                - self.tz() * operand.x() * self.s()
                - self.tz() * operand.y() * self.tz()
                - self.tz() * operand.z() * self.ty())
                * inv_norm_sq,
            (self.rx() * operand.x() * self.tz()
                - self.rx() * operand.y() * self.s()
                - self.rx() * operand.z() * self.rx()
                - self.s() * operand.x() * self.ty()
                - self.s() * operand.y() * self.rx()
                + self.s() * operand.z() * self.s()
                - self.ty() * operand.x() * self.s()
                - self.ty() * operand.y() * self.tz()
                - self.ty() * operand.z() * self.ty()
                + self.tz() * operand.x() * self.rx()
                - self.tz() * operand.y() * self.ty()
                + self.tz() * operand.z() * self.tz())
                * inv_norm_sq,
            (-(self.ps() * operand.x() * self.rx()) + self.ps() * operand.y() * self.ty()
                - self.ps() * operand.z() * self.tz()
                + self.rx() * operand.w() * self.rx()
                - self.rx() * operand.x() * self.ps()
                + self.rx() * operand.y() * self.rz()
                - self.rx() * operand.z() * self.ry()
                + self.ry() * operand.x() * self.tz()
                - self.ry() * operand.y() * self.s()
                - self.ry() * operand.z() * self.rx()
                + self.rz() * operand.x() * self.ty()
                + self.rz() * operand.y() * self.rx()
                - self.rz() * operand.z() * self.s()
                + self.s() * operand.w() * self.s()
                - self.s() * operand.x() * self.tx()
                - self.s() * operand.y() * self.ry()
                - self.s() * operand.z() * self.rz()
                - self.tx() * operand.x() * self.s()
                - self.tx() * operand.y() * self.tz()
                - self.tx() * operand.z() * self.ty()
                + self.ty() * operand.w() * self.ty()
                + self.ty() * operand.x() * self.rz()
                + self.ty() * operand.y() * self.ps()
                - self.ty() * operand.z() * self.tx()
                + self.tz() * operand.w() * self.tz()
                + self.tz() * operand.x() * self.ry()
                - self.tz() * operand.y() * self.tx()
                - self.tz() * operand.z() * self.ps())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Quadvector<T>> for Motor<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Quadvector<T>) -> Option<Quadvector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Quadvector::new_unchecked(
            (self.rx() * operand.ps() * self.rx()
                + self.s() * operand.ps() * self.s()
                + self.ty() * operand.ps() * self.ty()
                + self.tz() * operand.ps() * self.tz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Motor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.rx() * operand.s() * self.rx()
                + self.s() * operand.s() * self.s()
                + self.ty() * operand.s() * self.ty()
                + self.tz() * operand.s() * self.tz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Flector<T>> for Plane<T> {
    type Output = Flector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Flector<T>) -> Option<Flector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Flector::new_unchecked(
            (self.dist() * operand.px() * self.dist()) * inv_norm_sq,
            (self.dist() * operand.py() * self.dist()) * inv_norm_sq,
            (self.dist() * operand.pz() * self.dist()) * inv_norm_sq,
            (-(self.dist() * operand.pw() * self.dist()) + self.dist() * operand.px() * self.nx()
                - self.dist() * operand.py() * self.ny()
                + self.dist() * operand.pz() * self.nz()
                + self.nx() * operand.px() * self.dist()
                - self.ny() * operand.py() * self.dist()
                + self.nz() * operand.pz() * self.dist())
                * inv_norm_sq,
            (self.dist() * operand.dist() * self.dist()) * inv_norm_sq,
            (self.dist() * operand.dist() * self.nz()
                - self.dist() * operand.nz() * self.dist()
                - self.dist() * operand.px() * self.ny()
                - self.dist() * operand.py() * self.nx()
                + self.nx() * operand.py() * self.dist()
                + self.ny() * operand.px() * self.dist()
                + self.nz() * operand.dist() * self.dist())
                * inv_norm_sq,
            (self.dist() * operand.dist() * self.ny() - self.dist() * operand.ny() * self.dist()
                + self.dist() * operand.px() * self.nz()
                - self.dist() * operand.pz() * self.nx()
                + self.nx() * operand.pz() * self.dist()
                + self.ny() * operand.dist() * self.dist()
                - self.nz() * operand.px() * self.dist())
                * inv_norm_sq,
            (self.dist() * operand.dist() * self.nx() - self.dist() * operand.nx() * self.dist()
                + self.dist() * operand.py() * self.nz()
                + self.dist() * operand.pz() * self.ny()
                + self.nx() * operand.dist() * self.dist()
                - self.ny() * operand.pz() * self.dist()
                - self.nz() * operand.py() * self.dist())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Line<T>> for Plane<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (self.dist() * operand.moment_z() * self.dist()) * inv_norm_sq,
            (self.dist() * operand.moment_y() * self.dist()) * inv_norm_sq,
            (-(self.dist() * operand.dir_x() * self.dist())
                + self.dist() * operand.moment_y() * self.nz()
                - self.dist() * operand.moment_z() * self.ny()
                - self.ny() * operand.moment_z() * self.dist()
                + self.nz() * operand.moment_y() * self.dist())
                * inv_norm_sq,
            (self.dist() * operand.moment_x() * self.dist()) * inv_norm_sq,
            (-(self.dist() * operand.dir_y() * self.dist())
                + self.dist() * operand.moment_x() * self.nz()
                - self.dist() * operand.moment_z() * self.nx()
                - self.nx() * operand.moment_z() * self.dist()
                + self.nz() * operand.moment_x() * self.dist())
                * inv_norm_sq,
            (-(self.dist() * operand.dir_z() * self.dist())
                + self.dist() * operand.moment_x() * self.ny()
                - self.dist() * operand.moment_y() * self.nx()
                - self.nx() * operand.moment_y() * self.dist()
                + self.ny() * operand.moment_x() * self.dist())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Motor<T>> for Plane<T> {
    type Output = Motor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Motor<T>) -> Option<Motor<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Motor::new_unchecked(
            (self.dist() * operand.s() * self.dist()) * inv_norm_sq,
            (self.dist() * operand.tz() * self.dist()) * inv_norm_sq,
            (self.dist() * operand.ty() * self.dist()) * inv_norm_sq,
            (self.dist() * operand.s() * self.nx() - self.dist() * operand.tx() * self.dist()
                + self.dist() * operand.ty() * self.nz()
                - self.dist() * operand.tz() * self.ny()
                - self.nx() * operand.s() * self.dist()
                - self.ny() * operand.tz() * self.dist()
                + self.nz() * operand.ty() * self.dist())
                * inv_norm_sq,
            (self.dist() * operand.rx() * self.dist()) * inv_norm_sq,
            (self.dist() * operand.rx() * self.nz()
                - self.dist() * operand.ry() * self.dist()
                - self.dist() * operand.s() * self.ny()
                - self.dist() * operand.tz() * self.nx()
                - self.nx() * operand.tz() * self.dist()
                + self.ny() * operand.s() * self.dist()
                + self.nz() * operand.rx() * self.dist())
                * inv_norm_sq,
            (self.dist() * operand.rx() * self.ny() - self.dist() * operand.rz() * self.dist()
                + self.dist() * operand.s() * self.nz()
                - self.dist() * operand.ty() * self.nx()
                - self.nx() * operand.ty() * self.dist()
                + self.ny() * operand.rx() * self.dist()
                - self.nz() * operand.s() * self.dist())
                * inv_norm_sq,
            (-(self.dist() * operand.ps() * self.dist())
                + self.dist() * operand.rx() * self.nx()
                + self.dist() * operand.ty() * self.ny()
                + self.dist() * operand.tz() * self.nz()
                - self.nx() * operand.rx() * self.dist()
                - self.ny() * operand.ty() * self.dist()
                - self.nz() * operand.tz() * self.dist())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Plane<T>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Plane<T>) -> Option<Plane<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Plane::new_unchecked(
            (self.dist() * operand.dist() * self.dist()) * inv_norm_sq,
            (self.dist() * operand.dist() * self.nz() - self.dist() * operand.nz() * self.dist()
                + self.nz() * operand.dist() * self.dist())
                * inv_norm_sq,
            (self.dist() * operand.dist() * self.ny() - self.dist() * operand.ny() * self.dist()
                + self.ny() * operand.dist() * self.dist())
                * inv_norm_sq,
            (self.dist() * operand.dist() * self.nx() - self.dist() * operand.nx() * self.dist()
                + self.nx() * operand.dist() * self.dist())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Point<T>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (self.dist() * operand.x() * self.dist()) * inv_norm_sq,
            (self.dist() * operand.y() * self.dist()) * inv_norm_sq,
            (self.dist() * operand.z() * self.dist()) * inv_norm_sq,
            (-(self.dist() * operand.w() * self.dist()) + self.dist() * operand.x() * self.nx()
                - self.dist() * operand.y() * self.ny()
                + self.dist() * operand.z() * self.nz()
                + self.nx() * operand.x() * self.dist()
                - self.ny() * operand.y() * self.dist()
                + self.nz() * operand.z() * self.dist())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Quadvector<T>> for Plane<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Quadvector<T>) -> Option<Quadvector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Quadvector::new_unchecked(
            (-(self.dist() * operand.ps() * self.dist())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Plane<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.dist() * operand.s() * self.dist()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Flector<T>> for Point<T> {
    type Output = Flector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Flector<T>) -> Option<Flector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Flector::new_unchecked(
            (self.x() * operand.px() * self.x()
                + self.x() * operand.py() * self.y()
                + self.x() * operand.pz() * self.z()
                - self.y() * operand.dist() * self.z()
                - self.y() * operand.px() * self.y()
                + self.y() * operand.py() * self.x()
                + self.z() * operand.dist() * self.y()
                - self.z() * operand.px() * self.z()
                + self.z() * operand.pz() * self.x())
                * inv_norm_sq,
            (self.x() * operand.dist() * self.z() + self.x() * operand.px() * self.y()
                - self.x() * operand.py() * self.x()
                + self.y() * operand.px() * self.x()
                + self.y() * operand.py() * self.y()
                + self.y() * operand.pz() * self.z()
                - self.z() * operand.dist() * self.x()
                - self.z() * operand.py() * self.z()
                + self.z() * operand.pz() * self.y())
                * inv_norm_sq,
            (-(self.x() * operand.dist() * self.y()) + self.x() * operand.px() * self.z()
                - self.x() * operand.pz() * self.x()
                + self.y() * operand.dist() * self.x()
                + self.y() * operand.py() * self.z()
                - self.y() * operand.pz() * self.y()
                + self.z() * operand.px() * self.x()
                + self.z() * operand.py() * self.y()
                + self.z() * operand.pz() * self.z())
                * inv_norm_sq,
            (self.w() * operand.px() * self.x()
                + self.w() * operand.py() * self.y()
                + self.w() * operand.pz() * self.z()
                - self.x() * operand.ny() * self.z()
                - self.x() * operand.nz() * self.y()
                - self.x() * operand.pw() * self.x()
                + self.x() * operand.px() * self.w()
                - self.y() * operand.nx() * self.z()
                + self.y() * operand.nz() * self.x()
                - self.y() * operand.pw() * self.y()
                + self.y() * operand.py() * self.w()
                + self.z() * operand.nx() * self.y()
                + self.z() * operand.ny() * self.x()
                - self.z() * operand.pw() * self.z()
                + self.z() * operand.pz() * self.w())
                * inv_norm_sq,
            (self.x() * operand.dist() * self.x() + self.x() * operand.py() * self.z()
                - self.x() * operand.pz() * self.y()
                + self.y() * operand.dist() * self.y()
                - self.y() * operand.px() * self.z()
                + self.y() * operand.pz() * self.x()
                + self.z() * operand.dist() * self.z()
                + self.z() * operand.px() * self.y()
                - self.z() * operand.py() * self.x())
                * inv_norm_sq,
            (self.w() * operand.dist() * self.z() + self.w() * operand.px() * self.y()
                - self.w() * operand.py() * self.x()
                - self.x() * operand.nx() * self.z()
                + self.x() * operand.nz() * self.x()
                - self.x() * operand.pw() * self.y()
                + self.x() * operand.py() * self.w()
                + self.y() * operand.ny() * self.z()
                + self.y() * operand.nz() * self.y()
                + self.y() * operand.pw() * self.x()
                - self.y() * operand.px() * self.w()
                + self.z() * operand.dist() * self.w()
                - self.z() * operand.nx() * self.x()
                + self.z() * operand.ny() * self.y()
                - self.z() * operand.nz() * self.z())
                * inv_norm_sq,
            (-(self.w() * operand.dist() * self.y()) + self.w() * operand.px() * self.z()
                - self.w() * operand.pz() * self.x()
                + self.x() * operand.nx() * self.y()
                + self.x() * operand.ny() * self.x()
                - self.x() * operand.pw() * self.z()
                + self.x() * operand.pz() * self.w()
                - self.y() * operand.dist() * self.w()
                + self.y() * operand.nx() * self.x()
                - self.y() * operand.ny() * self.y()
                + self.y() * operand.nz() * self.z()
                + self.z() * operand.ny() * self.z()
                + self.z() * operand.nz() * self.y()
                + self.z() * operand.pw() * self.x()
                - self.z() * operand.px() * self.w())
                * inv_norm_sq,
            (self.w() * operand.dist() * self.x() + self.w() * operand.py() * self.z()
                - self.w() * operand.pz() * self.y()
                + self.x() * operand.dist() * self.w()
                - self.x() * operand.nx() * self.x()
                + self.x() * operand.ny() * self.y()
                - self.x() * operand.nz() * self.z()
                + self.y() * operand.nx() * self.y()
                + self.y() * operand.ny() * self.x()
                - self.y() * operand.pw() * self.z()
                + self.y() * operand.pz() * self.w()
                + self.z() * operand.nx() * self.z()
                - self.z() * operand.nz() * self.x()
                + self.z() * operand.pw() * self.y()
                - self.z() * operand.py() * self.w())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Line<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (self.x() * operand.moment_x() * self.z()
                - self.x() * operand.moment_z() * self.x()
                - self.y() * operand.moment_y() * self.z()
                - self.y() * operand.moment_z() * self.y()
                + self.z() * operand.moment_x() * self.x()
                - self.z() * operand.moment_y() * self.y()
                + self.z() * operand.moment_z() * self.z())
                * inv_norm_sq,
            (-(self.x() * operand.moment_x() * self.y())
                - self.x() * operand.moment_y() * self.x()
                - self.y() * operand.moment_x() * self.x()
                + self.y() * operand.moment_y() * self.y()
                - self.y() * operand.moment_z() * self.z()
                - self.z() * operand.moment_y() * self.z()
                - self.z() * operand.moment_z() * self.y())
                * inv_norm_sq,
            (-(self.w() * operand.moment_y() * self.z())
                - self.w() * operand.moment_z() * self.y()
                - self.x() * operand.dir_x() * self.x()
                - self.x() * operand.dir_y() * self.y()
                - self.x() * operand.dir_z() * self.z()
                + self.y() * operand.dir_x() * self.y()
                - self.y() * operand.dir_y() * self.x()
                - self.y() * operand.moment_z() * self.w()
                + self.z() * operand.dir_x() * self.z()
                - self.z() * operand.dir_z() * self.x()
                - self.z() * operand.moment_y() * self.w())
                * inv_norm_sq,
            (self.x() * operand.moment_x() * self.x() - self.x() * operand.moment_y() * self.y()
                + self.x() * operand.moment_z() * self.z()
                - self.y() * operand.moment_x() * self.y()
                - self.y() * operand.moment_y() * self.x()
                - self.z() * operand.moment_x() * self.z()
                + self.z() * operand.moment_z() * self.x())
                * inv_norm_sq,
            (-(self.w() * operand.moment_x() * self.z())
                + self.w() * operand.moment_z() * self.x()
                - self.x() * operand.dir_x() * self.y()
                + self.x() * operand.dir_y() * self.x()
                + self.x() * operand.moment_z() * self.w()
                - self.y() * operand.dir_x() * self.x()
                - self.y() * operand.dir_y() * self.y()
                - self.y() * operand.dir_z() * self.z()
                + self.z() * operand.dir_y() * self.z()
                - self.z() * operand.dir_z() * self.y()
                - self.z() * operand.moment_x() * self.w())
                * inv_norm_sq,
            (self.w() * operand.moment_x() * self.y() + self.w() * operand.moment_y() * self.x()
                - self.x() * operand.dir_x() * self.z()
                + self.x() * operand.dir_z() * self.x()
                + self.x() * operand.moment_y() * self.w()
                - self.y() * operand.dir_y() * self.z()
                + self.y() * operand.dir_z() * self.y()
                + self.y() * operand.moment_x() * self.w()
                - self.z() * operand.dir_x() * self.x()
                - self.z() * operand.dir_y() * self.y()
                - self.z() * operand.dir_z() * self.z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Motor<T>> for Point<T> {
    type Output = Motor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Motor<T>) -> Option<Motor<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Motor::new_unchecked(
            (self.x() * operand.s() * self.x()
                + self.x() * operand.ty() * self.z()
                + self.x() * operand.tz() * self.y()
                + self.y() * operand.rx() * self.z()
                + self.y() * operand.s() * self.y()
                - self.y() * operand.tz() * self.x()
                - self.z() * operand.rx() * self.y()
                + self.z() * operand.s() * self.z()
                - self.z() * operand.ty() * self.x())
                * inv_norm_sq,
            (self.x() * operand.rx() * self.z() + self.x() * operand.s() * self.y()
                - self.x() * operand.tz() * self.x()
                - self.y() * operand.s() * self.x()
                - self.y() * operand.ty() * self.z()
                - self.y() * operand.tz() * self.y()
                + self.z() * operand.rx() * self.x()
                - self.z() * operand.ty() * self.y()
                + self.z() * operand.tz() * self.z())
                * inv_norm_sq,
            (-(self.x() * operand.rx() * self.y()) + self.x() * operand.s() * self.z()
                - self.x() * operand.ty() * self.x()
                - self.y() * operand.rx() * self.x()
                + self.y() * operand.ty() * self.y()
                - self.y() * operand.tz() * self.z()
                - self.z() * operand.s() * self.x()
                - self.z() * operand.ty() * self.z()
                - self.z() * operand.tz() * self.y())
                * inv_norm_sq,
            (-(self.w() * operand.s() * self.x())
                - self.w() * operand.ty() * self.z()
                - self.w() * operand.tz() * self.y()
                - self.x() * operand.ry() * self.y()
                - self.x() * operand.rz() * self.z()
                + self.x() * operand.s() * self.w()
                - self.x() * operand.tx() * self.x()
                + self.y() * operand.ps() * self.z()
                - self.y() * operand.ry() * self.x()
                + self.y() * operand.tx() * self.y()
                - self.y() * operand.tz() * self.w()
                - self.z() * operand.ps() * self.y()
                - self.z() * operand.rz() * self.x()
                + self.z() * operand.tx() * self.z()
                - self.z() * operand.ty() * self.w())
                * inv_norm_sq,
            (self.x() * operand.rx() * self.x() - self.x() * operand.ty() * self.y()
                + self.x() * operand.tz() * self.z()
                - self.y() * operand.rx() * self.y()
                + self.y() * operand.s() * self.z()
                - self.y() * operand.ty() * self.x()
                - self.z() * operand.rx() * self.z()
                - self.z() * operand.s() * self.y()
                + self.z() * operand.tz() * self.x())
                * inv_norm_sq,
            (-(self.w() * operand.rx() * self.z()) - self.w() * operand.s() * self.y()
                + self.w() * operand.tz() * self.x()
                - self.x() * operand.ps() * self.z()
                + self.x() * operand.ry() * self.x()
                - self.x() * operand.tx() * self.y()
                + self.x() * operand.tz() * self.w()
                - self.y() * operand.ry() * self.y()
                - self.y() * operand.rz() * self.z()
                + self.y() * operand.s() * self.w()
                - self.y() * operand.tx() * self.x()
                + self.z() * operand.ps() * self.x()
                - self.z() * operand.rx() * self.w()
                + self.z() * operand.ry() * self.z()
                - self.z() * operand.rz() * self.y())
                * inv_norm_sq,
            (self.w() * operand.rx() * self.y() - self.w() * operand.s() * self.z()
                + self.w() * operand.ty() * self.x()
                + self.x() * operand.ps() * self.y()
                + self.x() * operand.rz() * self.x()
                - self.x() * operand.tx() * self.z()
                + self.x() * operand.ty() * self.w()
                - self.y() * operand.ps() * self.x()
                + self.y() * operand.rx() * self.w()
                - self.y() * operand.ry() * self.z()
                + self.y() * operand.rz() * self.y()
                - self.z() * operand.ry() * self.y()
                - self.z() * operand.rz() * self.z()
                + self.z() * operand.s() * self.w()
                - self.z() * operand.tx() * self.x())
                * inv_norm_sq,
            (-(self.w() * operand.rx() * self.x()) + self.w() * operand.ty() * self.y()
                - self.w() * operand.tz() * self.z()
                - self.x() * operand.ps() * self.x()
                + self.x() * operand.rx() * self.w()
                - self.x() * operand.ry() * self.z()
                + self.x() * operand.rz() * self.y()
                - self.y() * operand.ps() * self.y()
                - self.y() * operand.rz() * self.x()
                + self.y() * operand.tx() * self.z()
                - self.y() * operand.ty() * self.w()
                - self.z() * operand.ps() * self.z()
                + self.z() * operand.ry() * self.x()
                - self.z() * operand.tx() * self.y()
                + self.z() * operand.tz() * self.w())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Plane<T>> for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Plane<T>) -> Option<Plane<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Plane::new_unchecked(
            (self.x() * operand.dist() * self.x()
                + self.y() * operand.dist() * self.y()
                + self.z() * operand.dist() * self.z())
                * inv_norm_sq,
            (self.w() * operand.dist() * self.z() - self.x() * operand.nx() * self.z()
                + self.x() * operand.nz() * self.x()
                + self.y() * operand.ny() * self.z()
                + self.y() * operand.nz() * self.y()
                + self.z() * operand.dist() * self.w()
                - self.z() * operand.nx() * self.x()
                + self.z() * operand.ny() * self.y()
                - self.z() * operand.nz() * self.z())
                * inv_norm_sq,
            (-(self.w() * operand.dist() * self.y())
                + self.x() * operand.nx() * self.y()
                + self.x() * operand.ny() * self.x()
                - self.y() * operand.dist() * self.w()
                + self.y() * operand.nx() * self.x()
                - self.y() * operand.ny() * self.y()
                + self.y() * operand.nz() * self.z()
                + self.z() * operand.ny() * self.z()
                + self.z() * operand.nz() * self.y())
                * inv_norm_sq,
            (self.w() * operand.dist() * self.x() + self.x() * operand.dist() * self.w()
                - self.x() * operand.nx() * self.x()
                + self.x() * operand.ny() * self.y()
                - self.x() * operand.nz() * self.z()
                + self.y() * operand.nx() * self.y()
                + self.y() * operand.ny() * self.x()
                + self.z() * operand.nx() * self.z()
                - self.z() * operand.nz() * self.x())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Point<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (self.x() * operand.x() * self.x()
                + self.x() * operand.y() * self.y()
                + self.x() * operand.z() * self.z()
                - self.y() * operand.x() * self.y()
                + self.y() * operand.y() * self.x()
                - self.z() * operand.x() * self.z()
                + self.z() * operand.z() * self.x())
                * inv_norm_sq,
            (self.x() * operand.x() * self.y() - self.x() * operand.y() * self.x()
                + self.y() * operand.x() * self.x()
                + self.y() * operand.y() * self.y()
                + self.y() * operand.z() * self.z()
                - self.z() * operand.y() * self.z()
                + self.z() * operand.z() * self.y())
                * inv_norm_sq,
            (self.x() * operand.x() * self.z() - self.x() * operand.z() * self.x()
                + self.y() * operand.y() * self.z()
                - self.y() * operand.z() * self.y()
                + self.z() * operand.x() * self.x()
                + self.z() * operand.y() * self.y()
                + self.z() * operand.z() * self.z())
                * inv_norm_sq,
            (self.w() * operand.x() * self.x()
                + self.w() * operand.y() * self.y()
                + self.w() * operand.z() * self.z()
                - self.x() * operand.w() * self.x()
                + self.x() * operand.x() * self.w()
                - self.y() * operand.w() * self.y()
                + self.y() * operand.y() * self.w()
                - self.z() * operand.w() * self.z()
                + self.z() * operand.z() * self.w())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Quadvector<T>> for Point<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Quadvector<T>) -> Option<Quadvector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Quadvector::new_unchecked(
            (-(self.x() * operand.ps() * self.x())
                - self.y() * operand.ps() * self.y()
                - self.z() * operand.ps() * self.z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.x() * operand.s() * self.x()
                + self.y() * operand.s() * self.y()
                + self.z() * operand.s() * self.z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Flector<T>> for Quadvector<T> {
    type Output = Flector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Flector<T>) -> Option<Flector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Flector::new_unchecked(
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Line<T>> for Quadvector<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Motor<T>> for Quadvector<T> {
    type Output = Motor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Motor<T>) -> Option<Motor<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Motor::new_unchecked(
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Plane<T>> for Quadvector<T> {
    type Output = Plane<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Plane<T>) -> Option<Plane<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Plane::new_unchecked(
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Point<T>> for Quadvector<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Quadvector<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Quadvector<T>) -> Option<Quadvector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Quadvector::new_unchecked((T::zero()) * inv_norm_sq))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Quadvector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked((T::zero()) * inv_norm_sq))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Flector<T>> for Scalar<T> {
    type Output = Flector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Flector<T>) -> Option<Flector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Flector::new_unchecked(
            (self.s() * operand.px() * self.s()) * inv_norm_sq,
            (self.s() * operand.py() * self.s()) * inv_norm_sq,
            (self.s() * operand.pz() * self.s()) * inv_norm_sq,
            (self.s() * operand.pw() * self.s()) * inv_norm_sq,
            (self.s() * operand.dist() * self.s()) * inv_norm_sq,
            (self.s() * operand.nz() * self.s()) * inv_norm_sq,
            (self.s() * operand.ny() * self.s()) * inv_norm_sq,
            (self.s() * operand.nx() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (self.s() * operand.moment_z() * self.s()) * inv_norm_sq,
            (self.s() * operand.moment_y() * self.s()) * inv_norm_sq,
            (self.s() * operand.dir_x() * self.s()) * inv_norm_sq,
            (self.s() * operand.moment_x() * self.s()) * inv_norm_sq,
            (self.s() * operand.dir_y() * self.s()) * inv_norm_sq,
            (self.s() * operand.dir_z() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Motor<T>> for Scalar<T> {
    type Output = Motor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Motor<T>) -> Option<Motor<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Motor::new_unchecked(
            (self.s() * operand.s() * self.s()) * inv_norm_sq,
            (self.s() * operand.tz() * self.s()) * inv_norm_sq,
            (self.s() * operand.ty() * self.s()) * inv_norm_sq,
            (self.s() * operand.tx() * self.s()) * inv_norm_sq,
            (self.s() * operand.rx() * self.s()) * inv_norm_sq,
            (self.s() * operand.ry() * self.s()) * inv_norm_sq,
            (self.s() * operand.rz() * self.s()) * inv_norm_sq,
            (self.s() * operand.ps() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Plane<T>> for Scalar<T> {
    type Output = Plane<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Plane<T>) -> Option<Plane<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Plane::new_unchecked(
            (self.s() * operand.dist() * self.s()) * inv_norm_sq,
            (self.s() * operand.nz() * self.s()) * inv_norm_sq,
            (self.s() * operand.ny() * self.s()) * inv_norm_sq,
            (self.s() * operand.nx() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (self.s() * operand.x() * self.s()) * inv_norm_sq,
            (self.s() * operand.y() * self.s()) * inv_norm_sq,
            (self.s() * operand.z() * self.s()) * inv_norm_sq,
            (self.s() * operand.w() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Quadvector<T>> for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Quadvector<T>) -> Option<Quadvector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Quadvector::new_unchecked(
            (self.s() * operand.ps() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.s() * operand.s() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Flector<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Flector<T>) -> Option<Flector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Flector::new_unchecked(
            (self.dist() * operand.nx() * self.pw() + self.dist() * operand.ny() * self.nz()
                - self.dist() * operand.nz() * self.ny()
                - self.dist() * operand.pw() * self.nx()
                - self.nx() * operand.dist() * self.pw()
                + self.nx() * operand.nx() * self.px()
                - self.nx() * operand.ny() * self.py()
                + self.nx() * operand.nz() * self.pz()
                - self.nx() * operand.pw() * self.dist()
                + self.nx() * operand.px() * self.nx()
                - self.nx() * operand.py() * self.ny()
                + self.nx() * operand.pz() * self.nz()
                - self.ny() * operand.dist() * self.nz()
                + self.ny() * operand.nx() * self.py()
                + self.ny() * operand.ny() * self.px()
                + self.ny() * operand.nz() * self.dist()
                + self.ny() * operand.pw() * self.pz()
                - self.ny() * operand.px() * self.ny()
                - self.ny() * operand.py() * self.nx()
                - self.ny() * operand.pz() * self.pw()
                + self.nz() * operand.dist() * self.ny()
                - self.nz() * operand.nx() * self.pz()
                - self.nz() * operand.ny() * self.dist()
                + self.nz() * operand.nz() * self.px()
                + self.nz() * operand.pw() * self.py()
                - self.nz() * operand.px() * self.nz()
                - self.nz() * operand.py() * self.pw()
                + self.nz() * operand.pz() * self.nx()
                + self.pw() * operand.dist() * self.nx()
                - self.pw() * operand.nx() * self.dist()
                + self.pw() * operand.ny() * self.pz()
                + self.pw() * operand.nz() * self.py()
                - self.pw() * operand.pw() * self.px()
                + self.pw() * operand.px() * self.pw()
                - self.pw() * operand.py() * self.nz()
                - self.pw() * operand.pz() * self.ny()
                - self.px() * operand.nx() * self.nx()
                - self.px() * operand.ny() * self.ny()
                - self.px() * operand.nz() * self.nz()
                - self.px() * operand.pw() * self.pw()
                - self.py() * operand.nx() * self.ny()
                + self.py() * operand.ny() * self.nx()
                - self.py() * operand.nz() * self.pw()
                + self.py() * operand.pw() * self.nz()
                + self.pz() * operand.nx() * self.nz()
                - self.pz() * operand.ny() * self.pw()
                - self.pz() * operand.nz() * self.nx()
                + self.pz() * operand.pw() * self.ny())
                * inv_norm_sq,
            (self.dist() * operand.nx() * self.nz()
                - self.dist() * operand.ny() * self.pw()
                - self.dist() * operand.nz() * self.nx()
                + self.dist() * operand.pw() * self.ny()
                - self.nx() * operand.dist() * self.nz()
                + self.nx() * operand.nx() * self.py()
                + self.nx() * operand.ny() * self.px()
                + self.nx() * operand.nz() * self.dist()
                + self.nx() * operand.pw() * self.pz()
                - self.nx() * operand.px() * self.ny()
                - self.nx() * operand.py() * self.nx()
                - self.nx() * operand.pz() * self.pw()
                + self.ny() * operand.dist() * self.pw()
                - self.ny() * operand.nx() * self.px()
                + self.ny() * operand.ny() * self.py()
                - self.ny() * operand.nz() * self.pz()
                + self.ny() * operand.pw() * self.dist()
                - self.ny() * operand.px() * self.nx()
                + self.ny() * operand.py() * self.ny()
                - self.ny() * operand.pz() * self.nz()
                + self.nz() * operand.dist() * self.nx()
                - self.nz() * operand.nx() * self.dist()
                + self.nz() * operand.ny() * self.pz()
                + self.nz() * operand.nz() * self.py()
                - self.nz() * operand.pw() * self.px()
                + self.nz() * operand.px() * self.pw()
                - self.nz() * operand.py() * self.nz()
                - self.nz() * operand.pz() * self.ny()
                - self.pw() * operand.dist() * self.ny()
                + self.pw() * operand.nx() * self.pz()
                + self.pw() * operand.ny() * self.dist()
                - self.pw() * operand.nz() * self.px()
                - self.pw() * operand.pw() * self.py()
                + self.pw() * operand.px() * self.nz()
                + self.pw() * operand.py() * self.pw()
                - self.pw() * operand.pz() * self.nx()
                + self.px() * operand.nx() * self.ny()
                - self.px() * operand.ny() * self.nx()
                + self.px() * operand.nz() * self.pw()
                - self.px() * operand.pw() * self.nz()
                - self.py() * operand.nx() * self.nx()
                - self.py() * operand.ny() * self.ny()
                - self.py() * operand.nz() * self.nz()
                - self.py() * operand.pw() * self.pw()
                - self.pz() * operand.nx() * self.pw()
                - self.pz() * operand.ny() * self.nz()
                + self.pz() * operand.nz() * self.ny()
                + self.pz() * operand.pw() * self.nx())
                * inv_norm_sq,
            (self.dist() * operand.nx() * self.ny() - self.dist() * operand.ny() * self.nx()
                + self.dist() * operand.nz() * self.pw()
                - self.dist() * operand.pw() * self.nz()
                - self.nx() * operand.dist() * self.ny()
                + self.nx() * operand.nx() * self.pz()
                + self.nx() * operand.ny() * self.dist()
                - self.nx() * operand.nz() * self.px()
                - self.nx() * operand.pw() * self.py()
                + self.nx() * operand.px() * self.nz()
                + self.nx() * operand.py() * self.pw()
                - self.nx() * operand.pz() * self.nx()
                + self.ny() * operand.dist() * self.nx()
                - self.ny() * operand.nx() * self.dist()
                + self.ny() * operand.ny() * self.pz()
                + self.ny() * operand.nz() * self.py()
                - self.ny() * operand.pw() * self.px()
                + self.ny() * operand.px() * self.pw()
                - self.ny() * operand.py() * self.nz()
                - self.ny() * operand.pz() * self.ny()
                - self.nz() * operand.dist() * self.pw()
                + self.nz() * operand.nx() * self.px()
                - self.nz() * operand.ny() * self.py()
                + self.nz() * operand.nz() * self.pz()
                - self.nz() * operand.pw() * self.dist()
                + self.nz() * operand.px() * self.nx()
                - self.nz() * operand.py() * self.ny()
                + self.nz() * operand.pz() * self.nz()
                + self.pw() * operand.dist() * self.nz()
                - self.pw() * operand.nx() * self.py()
                - self.pw() * operand.ny() * self.px()
                - self.pw() * operand.nz() * self.dist()
                - self.pw() * operand.pw() * self.pz()
                + self.pw() * operand.px() * self.ny()
                + self.pw() * operand.py() * self.nx()
                + self.pw() * operand.pz() * self.pw()
                - self.px() * operand.nx() * self.nz()
                + self.px() * operand.ny() * self.pw()
                + self.px() * operand.nz() * self.nx()
                - self.px() * operand.pw() * self.ny()
                + self.py() * operand.nx() * self.pw()
                + self.py() * operand.ny() * self.nz()
                - self.py() * operand.nz() * self.ny()
                - self.py() * operand.pw() * self.nx()
                - self.pz() * operand.nx() * self.nx()
                - self.pz() * operand.ny() * self.ny()
                - self.pz() * operand.nz() * self.nz()
                - self.pz() * operand.pw() * self.pw())
                * inv_norm_sq,
            (self.nx() * operand.nx() * self.pw() + self.nx() * operand.ny() * self.nz()
                - self.nx() * operand.nz() * self.ny()
                - self.nx() * operand.pw() * self.nx()
                - self.ny() * operand.nx() * self.nz()
                + self.ny() * operand.ny() * self.pw()
                + self.ny() * operand.nz() * self.nx()
                - self.ny() * operand.pw() * self.ny()
                + self.nz() * operand.nx() * self.ny()
                - self.nz() * operand.ny() * self.nx()
                + self.nz() * operand.nz() * self.pw()
                - self.nz() * operand.pw() * self.nz()
                - self.pw() * operand.nx() * self.nx()
                - self.pw() * operand.ny() * self.ny()
                - self.pw() * operand.nz() * self.nz()
                - self.pw() * operand.pw() * self.pw())
                * inv_norm_sq,
            (-(self.dist() * operand.nx() * self.nx())
                - self.dist() * operand.ny() * self.ny()
                - self.dist() * operand.nz() * self.nz()
                - self.dist() * operand.pw() * self.pw()
                + self.nx() * operand.dist() * self.nx()
                - self.nx() * operand.nx() * self.dist()
                + self.nx() * operand.ny() * self.pz()
                + self.nx() * operand.nz() * self.py()
                - self.nx() * operand.pw() * self.px()
                + self.nx() * operand.px() * self.pw()
                - self.nx() * operand.py() * self.nz()
                - self.nx() * operand.pz() * self.ny()
                + self.ny() * operand.dist() * self.ny()
                - self.ny() * operand.nx() * self.pz()
                - self.ny() * operand.ny() * self.dist()
                + self.ny() * operand.nz() * self.px()
                + self.ny() * operand.pw() * self.py()
                - self.ny() * operand.px() * self.nz()
                - self.ny() * operand.py() * self.pw()
                + self.ny() * operand.pz() * self.nx()
                + self.nz() * operand.dist() * self.nz()
                - self.nz() * operand.nx() * self.py()
                - self.nz() * operand.ny() * self.px()
                - self.nz() * operand.nz() * self.dist()
                - self.nz() * operand.pw() * self.pz()
                + self.nz() * operand.px() * self.ny()
                + self.nz() * operand.py() * self.nx()
                + self.nz() * operand.pz() * self.pw()
                + self.pw() * operand.dist() * self.pw()
                - self.pw() * operand.nx() * self.px()
                + self.pw() * operand.ny() * self.py()
                - self.pw() * operand.nz() * self.pz()
                + self.pw() * operand.pw() * self.dist()
                - self.pw() * operand.px() * self.nx()
                + self.pw() * operand.py() * self.ny()
                - self.pw() * operand.pz() * self.nz()
                - self.px() * operand.nx() * self.pw()
                - self.px() * operand.ny() * self.nz()
                + self.px() * operand.nz() * self.ny()
                + self.px() * operand.pw() * self.nx()
                - self.py() * operand.nx() * self.nz()
                + self.py() * operand.ny() * self.pw()
                + self.py() * operand.nz() * self.nx()
                - self.py() * operand.pw() * self.ny()
                - self.pz() * operand.nx() * self.ny()
                + self.pz() * operand.ny() * self.nx()
                - self.pz() * operand.nz() * self.pw()
                + self.pz() * operand.pw() * self.nz())
                * inv_norm_sq,
            (-(self.nx() * operand.nx() * self.nz())
                + self.nx() * operand.ny() * self.pw()
                + self.nx() * operand.nz() * self.nx()
                - self.nx() * operand.pw() * self.ny()
                - self.ny() * operand.nx() * self.pw()
                - self.ny() * operand.ny() * self.nz()
                + self.ny() * operand.nz() * self.ny()
                + self.ny() * operand.pw() * self.nx()
                - self.nz() * operand.nx() * self.nx()
                - self.nz() * operand.ny() * self.ny()
                - self.nz() * operand.nz() * self.nz()
                - self.nz() * operand.pw() * self.pw()
                - self.pw() * operand.nx() * self.ny()
                + self.pw() * operand.ny() * self.nx()
                - self.pw() * operand.nz() * self.pw()
                + self.pw() * operand.pw() * self.nz())
                * inv_norm_sq,
            (-(self.nx() * operand.nx() * self.ny()) + self.nx() * operand.ny() * self.nx()
                - self.nx() * operand.nz() * self.pw()
                + self.nx() * operand.pw() * self.nz()
                - self.ny() * operand.nx() * self.nx()
                - self.ny() * operand.ny() * self.ny()
                - self.ny() * operand.nz() * self.nz()
                - self.ny() * operand.pw() * self.pw()
                + self.nz() * operand.nx() * self.pw()
                + self.nz() * operand.ny() * self.nz()
                - self.nz() * operand.nz() * self.ny()
                - self.nz() * operand.pw() * self.nx()
                + self.pw() * operand.nx() * self.nz()
                - self.pw() * operand.ny() * self.pw()
                - self.pw() * operand.nz() * self.nx()
                + self.pw() * operand.pw() * self.ny())
                * inv_norm_sq,
            (-(self.nx() * operand.nx() * self.nx())
                - self.nx() * operand.ny() * self.ny()
                - self.nx() * operand.nz() * self.nz()
                - self.nx() * operand.pw() * self.pw()
                + self.ny() * operand.nx() * self.ny()
                - self.ny() * operand.ny() * self.nx()
                + self.ny() * operand.nz() * self.pw()
                - self.ny() * operand.pw() * self.nz()
                + self.nz() * operand.nx() * self.nz()
                - self.nz() * operand.ny() * self.pw()
                - self.nz() * operand.nz() * self.nx()
                + self.nz() * operand.pw() * self.ny()
                - self.pw() * operand.nx() * self.pw()
                - self.pw() * operand.ny() * self.nz()
                + self.pw() * operand.nz() * self.ny()
                + self.pw() * operand.pw() * self.nx())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Line<T>> for Flector<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (-(self.dist() * operand.dir_x() * self.ny())
                - self.dist() * operand.dir_y() * self.nx()
                - self.dist() * operand.dir_z() * self.pw()
                + self.nx() * operand.dir_x() * self.pz()
                - self.nx() * operand.dir_y() * self.dist()
                - self.nx() * operand.dir_z() * self.px()
                + self.nx() * operand.moment_x() * self.nz()
                - self.nx() * operand.moment_y() * self.pw()
                - self.nx() * operand.moment_z() * self.nx()
                - self.ny() * operand.dir_x() * self.dist()
                - self.ny() * operand.dir_y() * self.pz()
                + self.ny() * operand.dir_z() * self.py()
                + self.ny() * operand.moment_x() * self.pw()
                + self.ny() * operand.moment_y() * self.nz()
                - self.ny() * operand.moment_z() * self.ny()
                + self.nz() * operand.dir_x() * self.px()
                + self.nz() * operand.dir_y() * self.py()
                + self.nz() * operand.dir_z() * self.pz()
                + self.nz() * operand.moment_x() * self.nx()
                + self.nz() * operand.moment_y() * self.ny()
                + self.nz() * operand.moment_z() * self.nz()
                - self.pw() * operand.dir_x() * self.py()
                + self.pw() * operand.dir_y() * self.px()
                - self.pw() * operand.dir_z() * self.dist()
                + self.pw() * operand.moment_x() * self.ny()
                - self.pw() * operand.moment_y() * self.nx()
                + self.pw() * operand.moment_z() * self.pw()
                + self.px() * operand.dir_x() * self.nz()
                + self.px() * operand.dir_y() * self.pw()
                - self.px() * operand.dir_z() * self.nx()
                - self.py() * operand.dir_x() * self.pw()
                + self.py() * operand.dir_y() * self.nz()
                + self.py() * operand.dir_z() * self.ny()
                + self.pz() * operand.dir_x() * self.nx()
                - self.pz() * operand.dir_y() * self.ny()
                + self.pz() * operand.dir_z() * self.nz())
                * inv_norm_sq,
            (self.dist() * operand.dir_x() * self.nz() + self.dist() * operand.dir_y() * self.pw()
                - self.dist() * operand.dir_z() * self.nx()
                - self.nx() * operand.dir_x() * self.py()
                + self.nx() * operand.dir_y() * self.px()
                - self.nx() * operand.dir_z() * self.dist()
                + self.nx() * operand.moment_x() * self.ny()
                - self.nx() * operand.moment_y() * self.nx()
                + self.nx() * operand.moment_z() * self.pw()
                + self.ny() * operand.dir_x() * self.px()
                + self.ny() * operand.dir_y() * self.py()
                + self.ny() * operand.dir_z() * self.pz()
                + self.ny() * operand.moment_x() * self.nx()
                + self.ny() * operand.moment_y() * self.ny()
                + self.ny() * operand.moment_z() * self.nz()
                + self.nz() * operand.dir_x() * self.dist()
                + self.nz() * operand.dir_y() * self.pz()
                - self.nz() * operand.dir_z() * self.py()
                - self.nz() * operand.moment_x() * self.pw()
                - self.nz() * operand.moment_y() * self.nz()
                + self.nz() * operand.moment_z() * self.ny()
                - self.pw() * operand.dir_x() * self.pz()
                + self.pw() * operand.dir_y() * self.dist()
                + self.pw() * operand.dir_z() * self.px()
                - self.pw() * operand.moment_x() * self.nz()
                + self.pw() * operand.moment_y() * self.pw()
                + self.pw() * operand.moment_z() * self.nx()
                + self.px() * operand.dir_x() * self.ny()
                + self.px() * operand.dir_y() * self.nx()
                + self.px() * operand.dir_z() * self.pw()
                - self.py() * operand.dir_x() * self.nx()
                + self.py() * operand.dir_y() * self.ny()
                - self.py() * operand.dir_z() * self.nz()
                - self.pz() * operand.dir_x() * self.pw()
                + self.pz() * operand.dir_y() * self.nz()
                + self.pz() * operand.dir_z() * self.ny())
                * inv_norm_sq,
            (-(self.nx() * operand.dir_x() * self.nx()) + self.nx() * operand.dir_y() * self.ny()
                - self.nx() * operand.dir_z() * self.nz()
                + self.ny() * operand.dir_x() * self.ny()
                + self.ny() * operand.dir_y() * self.nx()
                + self.ny() * operand.dir_z() * self.pw()
                + self.nz() * operand.dir_x() * self.nz()
                + self.nz() * operand.dir_y() * self.pw()
                - self.nz() * operand.dir_z() * self.nx()
                - self.pw() * operand.dir_x() * self.pw()
                + self.pw() * operand.dir_y() * self.nz()
                + self.pw() * operand.dir_z() * self.ny())
                * inv_norm_sq,
            (-(self.dist() * operand.dir_x() * self.pw())
                + self.dist() * operand.dir_y() * self.nz()
                + self.dist() * operand.dir_z() * self.ny()
                + self.nx() * operand.dir_x() * self.px()
                + self.nx() * operand.dir_y() * self.py()
                + self.nx() * operand.dir_z() * self.pz()
                + self.nx() * operand.moment_x() * self.nx()
                + self.nx() * operand.moment_y() * self.ny()
                + self.nx() * operand.moment_z() * self.nz()
                + self.ny() * operand.dir_x() * self.py()
                - self.ny() * operand.dir_y() * self.px()
                + self.ny() * operand.dir_z() * self.dist()
                - self.ny() * operand.moment_x() * self.ny()
                + self.ny() * operand.moment_y() * self.nx()
                - self.ny() * operand.moment_z() * self.pw()
                - self.nz() * operand.dir_x() * self.pz()
                + self.nz() * operand.dir_y() * self.dist()
                + self.nz() * operand.dir_z() * self.px()
                - self.nz() * operand.moment_x() * self.nz()
                + self.nz() * operand.moment_y() * self.pw()
                + self.nz() * operand.moment_z() * self.nx()
                - self.pw() * operand.dir_x() * self.dist()
                - self.pw() * operand.dir_y() * self.pz()
                + self.pw() * operand.dir_z() * self.py()
                + self.pw() * operand.moment_x() * self.pw()
                + self.pw() * operand.moment_y() * self.nz()
                - self.pw() * operand.moment_z() * self.ny()
                + self.px() * operand.dir_x() * self.nx()
                - self.px() * operand.dir_y() * self.ny()
                + self.px() * operand.dir_z() * self.nz()
                + self.py() * operand.dir_x() * self.ny()
                + self.py() * operand.dir_y() * self.nx()
                + self.py() * operand.dir_z() * self.pw()
                - self.pz() * operand.dir_x() * self.nz()
                - self.pz() * operand.dir_y() * self.pw()
                + self.pz() * operand.dir_z() * self.nx())
                * inv_norm_sq,
            (self.nx() * operand.dir_x() * self.ny()
                + self.nx() * operand.dir_y() * self.nx()
                + self.nx() * operand.dir_z() * self.pw()
                + self.ny() * operand.dir_x() * self.nx()
                - self.ny() * operand.dir_y() * self.ny()
                + self.ny() * operand.dir_z() * self.nz()
                - self.nz() * operand.dir_x() * self.pw()
                + self.nz() * operand.dir_y() * self.nz()
                + self.nz() * operand.dir_z() * self.ny()
                - self.pw() * operand.dir_x() * self.nz()
                - self.pw() * operand.dir_y() * self.pw()
                + self.pw() * operand.dir_z() * self.nx())
                * inv_norm_sq,
            (-(self.nx() * operand.dir_x() * self.nz()) - self.nx() * operand.dir_y() * self.pw()
                + self.nx() * operand.dir_z() * self.nx()
                - self.ny() * operand.dir_x() * self.pw()
                + self.ny() * operand.dir_y() * self.nz()
                + self.ny() * operand.dir_z() * self.ny()
                - self.nz() * operand.dir_x() * self.nx()
                + self.nz() * operand.dir_y() * self.ny()
                - self.nz() * operand.dir_z() * self.nz()
                - self.pw() * operand.dir_x() * self.ny()
                - self.pw() * operand.dir_y() * self.nx()
                - self.pw() * operand.dir_z() * self.pw())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Motor<T>> for Flector<T> {
    type Output = Motor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Motor<T>) -> Option<Motor<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Motor::new_unchecked(
            (self.dist() * operand.ps() * self.pw() + self.dist() * operand.ry() * self.ny()
                - self.dist() * operand.rz() * self.nz()
                - self.dist() * operand.tx() * self.nx()
                - self.nx() * operand.ps() * self.px()
                - self.nx() * operand.rx() * self.pw()
                + self.nx() * operand.ry() * self.pz()
                - self.nx() * operand.rz() * self.py()
                + self.nx() * operand.s() * self.nx()
                + self.nx() * operand.tx() * self.dist()
                - self.nx() * operand.ty() * self.nz()
                + self.nx() * operand.tz() * self.ny()
                + self.ny() * operand.ps() * self.py()
                + self.ny() * operand.rx() * self.nz()
                - self.ny() * operand.ry() * self.dist()
                - self.ny() * operand.rz() * self.px()
                + self.ny() * operand.s() * self.ny()
                + self.ny() * operand.tx() * self.pz()
                - self.ny() * operand.ty() * self.pw()
                - self.ny() * operand.tz() * self.nx()
                - self.nz() * operand.ps() * self.pz()
                - self.nz() * operand.rx() * self.ny()
                - self.nz() * operand.ry() * self.px()
                + self.nz() * operand.rz() * self.dist()
                + self.nz() * operand.s() * self.nz()
                + self.nz() * operand.tx() * self.py()
                + self.nz() * operand.ty() * self.nx()
                - self.nz() * operand.tz() * self.pw()
                + self.pw() * operand.ps() * self.dist()
                + self.pw() * operand.rx() * self.nx()
                + self.pw() * operand.ry() * self.py()
                + self.pw() * operand.rz() * self.pz()
                + self.pw() * operand.s() * self.pw()
                + self.pw() * operand.tx() * self.px()
                + self.pw() * operand.ty() * self.ny()
                + self.pw() * operand.tz() * self.nz()
                - self.px() * operand.ps() * self.nx()
                + self.px() * operand.ry() * self.nz()
                + self.px() * operand.rz() * self.ny()
                - self.px() * operand.tx() * self.pw()
                + self.py() * operand.ps() * self.ny()
                - self.py() * operand.ry() * self.pw()
                + self.py() * operand.rz() * self.nx()
                - self.py() * operand.tx() * self.nz()
                - self.pz() * operand.ps() * self.nz()
                - self.pz() * operand.ry() * self.nx()
                - self.pz() * operand.rz() * self.pw()
                - self.pz() * operand.tx() * self.ny())
                * inv_norm_sq,
            (-(self.dist() * operand.ps() * self.nz())
                - self.dist() * operand.ry() * self.nx()
                - self.dist() * operand.rz() * self.pw()
                - self.dist() * operand.tx() * self.ny()
                + self.nx() * operand.ps() * self.py()
                + self.nx() * operand.rx() * self.nz()
                - self.nx() * operand.ry() * self.dist()
                - self.nx() * operand.rz() * self.px()
                + self.nx() * operand.s() * self.ny()
                + self.nx() * operand.tx() * self.pz()
                - self.nx() * operand.ty() * self.pw()
                - self.nx() * operand.tz() * self.nx()
                + self.ny() * operand.ps() * self.px()
                + self.ny() * operand.rx() * self.pw()
                - self.ny() * operand.ry() * self.pz()
                + self.ny() * operand.rz() * self.py()
                - self.ny() * operand.s() * self.nx()
                - self.ny() * operand.tx() * self.dist()
                + self.ny() * operand.ty() * self.nz()
                - self.ny() * operand.tz() * self.ny()
                + self.nz() * operand.ps() * self.dist()
                + self.nz() * operand.rx() * self.nx()
                + self.nz() * operand.ry() * self.py()
                + self.nz() * operand.rz() * self.pz()
                + self.nz() * operand.s() * self.pw()
                + self.nz() * operand.tx() * self.px()
                + self.nz() * operand.ty() * self.ny()
                + self.nz() * operand.tz() * self.nz()
                + self.pw() * operand.ps() * self.pz()
                + self.pw() * operand.rx() * self.ny()
                + self.pw() * operand.ry() * self.px()
                - self.pw() * operand.rz() * self.dist()
                - self.pw() * operand.s() * self.nz()
                - self.pw() * operand.tx() * self.py()
                - self.pw() * operand.ty() * self.nx()
                + self.pw() * operand.tz() * self.pw()
                - self.px() * operand.ps() * self.ny()
                + self.px() * operand.ry() * self.pw()
                - self.px() * operand.rz() * self.nx()
                + self.px() * operand.tx() * self.nz()
                - self.py() * operand.ps() * self.nx()
                + self.py() * operand.ry() * self.nz()
                + self.py() * operand.rz() * self.ny()
                - self.py() * operand.tx() * self.pw()
                - self.pz() * operand.ps() * self.pw()
                - self.pz() * operand.ry() * self.ny()
                + self.pz() * operand.rz() * self.nz()
                + self.pz() * operand.tx() * self.nx())
                * inv_norm_sq,
            (-(self.dist() * operand.ps() * self.ny()) + self.dist() * operand.ry() * self.pw()
                - self.dist() * operand.rz() * self.nx()
                + self.dist() * operand.tx() * self.nz()
                + self.nx() * operand.ps() * self.pz()
                + self.nx() * operand.rx() * self.ny()
                + self.nx() * operand.ry() * self.px()
                - self.nx() * operand.rz() * self.dist()
                - self.nx() * operand.s() * self.nz()
                - self.nx() * operand.tx() * self.py()
                - self.nx() * operand.ty() * self.nx()
                + self.nx() * operand.tz() * self.pw()
                + self.ny() * operand.ps() * self.dist()
                + self.ny() * operand.rx() * self.nx()
                + self.ny() * operand.ry() * self.py()
                + self.ny() * operand.rz() * self.pz()
                + self.ny() * operand.s() * self.pw()
                + self.ny() * operand.tx() * self.px()
                + self.ny() * operand.ty() * self.ny()
                + self.ny() * operand.tz() * self.nz()
                - self.nz() * operand.ps() * self.px()
                - self.nz() * operand.rx() * self.pw()
                + self.nz() * operand.ry() * self.pz()
                - self.nz() * operand.rz() * self.py()
                + self.nz() * operand.s() * self.nx()
                + self.nz() * operand.tx() * self.dist()
                - self.nz() * operand.ty() * self.nz()
                + self.nz() * operand.tz() * self.ny()
                - self.pw() * operand.ps() * self.py()
                - self.pw() * operand.rx() * self.nz()
                + self.pw() * operand.ry() * self.dist()
                + self.pw() * operand.rz() * self.px()
                - self.pw() * operand.s() * self.ny()
                - self.pw() * operand.tx() * self.pz()
                + self.pw() * operand.ty() * self.pw()
                + self.pw() * operand.tz() * self.nx()
                + self.px() * operand.ps() * self.nz()
                + self.px() * operand.ry() * self.nx()
                + self.px() * operand.rz() * self.pw()
                + self.px() * operand.tx() * self.ny()
                + self.py() * operand.ps() * self.pw()
                + self.py() * operand.ry() * self.ny()
                - self.py() * operand.rz() * self.nz()
                - self.py() * operand.tx() * self.nx()
                - self.pz() * operand.ps() * self.nx()
                + self.pz() * operand.ry() * self.nz()
                + self.pz() * operand.rz() * self.ny()
                - self.pz() * operand.tx() * self.pw())
                * inv_norm_sq,
            (self.nx() * operand.ps() * self.pw() + self.nx() * operand.ry() * self.ny()
                - self.nx() * operand.rz() * self.nz()
                - self.nx() * operand.tx() * self.nx()
                + self.ny() * operand.ps() * self.nz()
                + self.ny() * operand.ry() * self.nx()
                + self.ny() * operand.rz() * self.pw()
                + self.ny() * operand.tx() * self.ny()
                - self.nz() * operand.ps() * self.ny()
                + self.nz() * operand.ry() * self.pw()
                - self.nz() * operand.rz() * self.nx()
                + self.nz() * operand.tx() * self.nz()
                - self.pw() * operand.ps() * self.nx()
                + self.pw() * operand.ry() * self.nz()
                + self.pw() * operand.rz() * self.ny()
                - self.pw() * operand.tx() * self.pw())
                * inv_norm_sq,
            (-(self.dist() * operand.ps() * self.nx())
                + self.dist() * operand.ry() * self.nz()
                + self.dist() * operand.rz() * self.ny()
                - self.dist() * operand.tx() * self.pw()
                + self.nx() * operand.ps() * self.dist()
                + self.nx() * operand.rx() * self.nx()
                + self.nx() * operand.ry() * self.py()
                + self.nx() * operand.rz() * self.pz()
                + self.nx() * operand.s() * self.pw()
                + self.nx() * operand.tx() * self.px()
                + self.nx() * operand.ty() * self.ny()
                + self.nx() * operand.tz() * self.nz()
                - self.ny() * operand.ps() * self.pz()
                - self.ny() * operand.rx() * self.ny()
                - self.ny() * operand.ry() * self.px()
                + self.ny() * operand.rz() * self.dist()
                + self.ny() * operand.s() * self.nz()
                + self.ny() * operand.tx() * self.py()
                + self.ny() * operand.ty() * self.nx()
                - self.ny() * operand.tz() * self.pw()
                - self.nz() * operand.ps() * self.py()
                - self.nz() * operand.rx() * self.nz()
                + self.nz() * operand.ry() * self.dist()
                + self.nz() * operand.rz() * self.px()
                - self.nz() * operand.s() * self.ny()
                - self.nz() * operand.tx() * self.pz()
                + self.nz() * operand.ty() * self.pw()
                + self.nz() * operand.tz() * self.nx()
                + self.pw() * operand.ps() * self.px()
                + self.pw() * operand.rx() * self.pw()
                - self.pw() * operand.ry() * self.pz()
                + self.pw() * operand.rz() * self.py()
                - self.pw() * operand.s() * self.nx()
                - self.pw() * operand.tx() * self.dist()
                + self.pw() * operand.ty() * self.nz()
                - self.pw() * operand.tz() * self.ny()
                - self.px() * operand.ps() * self.pw()
                - self.px() * operand.ry() * self.ny()
                + self.px() * operand.rz() * self.nz()
                + self.px() * operand.tx() * self.nx()
                + self.py() * operand.ps() * self.nz()
                + self.py() * operand.ry() * self.nx()
                + self.py() * operand.rz() * self.pw()
                + self.py() * operand.tx() * self.ny()
                + self.pz() * operand.ps() * self.ny()
                - self.pz() * operand.ry() * self.pw()
                + self.pz() * operand.rz() * self.nx()
                - self.pz() * operand.tx() * self.nz())
                * inv_norm_sq,
            (self.nx() * operand.ps() * self.nz()
                + self.nx() * operand.ry() * self.nx()
                + self.nx() * operand.rz() * self.pw()
                + self.nx() * operand.tx() * self.ny()
                - self.ny() * operand.ps() * self.pw()
                - self.ny() * operand.ry() * self.ny()
                + self.ny() * operand.rz() * self.nz()
                + self.ny() * operand.tx() * self.nx()
                - self.nz() * operand.ps() * self.nx()
                + self.nz() * operand.ry() * self.nz()
                + self.nz() * operand.rz() * self.ny()
                - self.nz() * operand.tx() * self.pw()
                + self.pw() * operand.ps() * self.ny()
                - self.pw() * operand.ry() * self.pw()
                + self.pw() * operand.rz() * self.nx()
                - self.pw() * operand.tx() * self.nz())
                * inv_norm_sq,
            (self.nx() * operand.ps() * self.ny() - self.nx() * operand.ry() * self.pw()
                + self.nx() * operand.rz() * self.nx()
                - self.nx() * operand.tx() * self.nz()
                - self.ny() * operand.ps() * self.nx()
                + self.ny() * operand.ry() * self.nz()
                + self.ny() * operand.rz() * self.ny()
                - self.ny() * operand.tx() * self.pw()
                + self.nz() * operand.ps() * self.pw()
                + self.nz() * operand.ry() * self.ny()
                - self.nz() * operand.rz() * self.nz()
                - self.nz() * operand.tx() * self.nx()
                - self.pw() * operand.ps() * self.nz()
                - self.pw() * operand.ry() * self.nx()
                - self.pw() * operand.rz() * self.pw()
                - self.pw() * operand.tx() * self.ny())
                * inv_norm_sq,
            (-(self.nx() * operand.ps() * self.nx())
                + self.nx() * operand.ry() * self.nz()
                + self.nx() * operand.rz() * self.ny()
                - self.nx() * operand.tx() * self.pw()
                - self.ny() * operand.ps() * self.ny()
                + self.ny() * operand.ry() * self.pw()
                - self.ny() * operand.rz() * self.nx()
                + self.ny() * operand.tx() * self.nz()
                - self.nz() * operand.ps() * self.nz()
                - self.nz() * operand.ry() * self.nx()
                - self.nz() * operand.rz() * self.pw()
                - self.nz() * operand.tx() * self.ny()
                - self.pw() * operand.ps() * self.pw()
                - self.pw() * operand.ry() * self.ny()
                + self.pw() * operand.rz() * self.nz()
                + self.pw() * operand.tx() * self.nx())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Plane<T>> for Flector<T> {
    type Output = Plane<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Plane<T>) -> Option<Plane<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Plane::new_unchecked(
            (-(self.dist() * operand.nx() * self.nx())
                - self.dist() * operand.ny() * self.ny()
                - self.dist() * operand.nz() * self.nz()
                + self.nx() * operand.dist() * self.nx()
                - self.nx() * operand.nx() * self.dist()
                + self.nx() * operand.ny() * self.pz()
                + self.nx() * operand.nz() * self.py()
                + self.ny() * operand.dist() * self.ny()
                - self.ny() * operand.nx() * self.pz()
                - self.ny() * operand.ny() * self.dist()
                + self.ny() * operand.nz() * self.px()
                + self.nz() * operand.dist() * self.nz()
                - self.nz() * operand.nx() * self.py()
                - self.nz() * operand.ny() * self.px()
                - self.nz() * operand.nz() * self.dist()
                + self.pw() * operand.dist() * self.pw()
                - self.pw() * operand.nx() * self.px()
                + self.pw() * operand.ny() * self.py()
                - self.pw() * operand.nz() * self.pz()
                - self.px() * operand.nx() * self.pw()
                - self.px() * operand.ny() * self.nz()
                + self.px() * operand.nz() * self.ny()
                - self.py() * operand.nx() * self.nz()
                + self.py() * operand.ny() * self.pw()
                + self.py() * operand.nz() * self.nx()
                - self.pz() * operand.nx() * self.ny()
                + self.pz() * operand.ny() * self.nx()
                - self.pz() * operand.nz() * self.pw())
                * inv_norm_sq,
            (-(self.nx() * operand.nx() * self.nz())
                + self.nx() * operand.ny() * self.pw()
                + self.nx() * operand.nz() * self.nx()
                - self.ny() * operand.nx() * self.pw()
                - self.ny() * operand.ny() * self.nz()
                + self.ny() * operand.nz() * self.ny()
                - self.nz() * operand.nx() * self.nx()
                - self.nz() * operand.ny() * self.ny()
                - self.nz() * operand.nz() * self.nz()
                - self.pw() * operand.nx() * self.ny()
                + self.pw() * operand.ny() * self.nx()
                - self.pw() * operand.nz() * self.pw())
                * inv_norm_sq,
            (-(self.nx() * operand.nx() * self.ny()) + self.nx() * operand.ny() * self.nx()
                - self.nx() * operand.nz() * self.pw()
                - self.ny() * operand.nx() * self.nx()
                - self.ny() * operand.ny() * self.ny()
                - self.ny() * operand.nz() * self.nz()
                + self.nz() * operand.nx() * self.pw()
                + self.nz() * operand.ny() * self.nz()
                - self.nz() * operand.nz() * self.ny()
                + self.pw() * operand.nx() * self.nz()
                - self.pw() * operand.ny() * self.pw()
                - self.pw() * operand.nz() * self.nx())
                * inv_norm_sq,
            (-(self.nx() * operand.nx() * self.nx())
                - self.nx() * operand.ny() * self.ny()
                - self.nx() * operand.nz() * self.nz()
                + self.ny() * operand.nx() * self.ny()
                - self.ny() * operand.ny() * self.nx()
                + self.ny() * operand.nz() * self.pw()
                + self.nz() * operand.nx() * self.nz()
                - self.nz() * operand.ny() * self.pw()
                - self.nz() * operand.nz() * self.nx()
                - self.pw() * operand.nx() * self.pw()
                - self.pw() * operand.ny() * self.nz()
                + self.pw() * operand.nz() * self.ny())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Point<T>> for Flector<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (-(self.dist() * operand.w() * self.nx()) - self.nx() * operand.w() * self.dist()
                + self.nx() * operand.x() * self.nx()
                - self.nx() * operand.y() * self.ny()
                + self.nx() * operand.z() * self.nz()
                + self.ny() * operand.w() * self.pz()
                - self.ny() * operand.x() * self.ny()
                - self.ny() * operand.y() * self.nx()
                - self.ny() * operand.z() * self.pw()
                + self.nz() * operand.w() * self.py()
                - self.nz() * operand.x() * self.nz()
                - self.nz() * operand.y() * self.pw()
                + self.nz() * operand.z() * self.nx()
                - self.pw() * operand.w() * self.px()
                + self.pw() * operand.x() * self.pw()
                - self.pw() * operand.y() * self.nz()
                - self.pw() * operand.z() * self.ny()
                - self.px() * operand.w() * self.pw()
                + self.py() * operand.w() * self.nz()
                + self.pz() * operand.w() * self.ny())
                * inv_norm_sq,
            (self.dist() * operand.w() * self.ny() + self.nx() * operand.w() * self.pz()
                - self.nx() * operand.x() * self.ny()
                - self.nx() * operand.y() * self.nx()
                - self.nx() * operand.z() * self.pw()
                + self.ny() * operand.w() * self.dist()
                - self.ny() * operand.x() * self.nx()
                + self.ny() * operand.y() * self.ny()
                - self.ny() * operand.z() * self.nz()
                - self.nz() * operand.w() * self.px()
                + self.nz() * operand.x() * self.pw()
                - self.nz() * operand.y() * self.nz()
                - self.nz() * operand.z() * self.ny()
                - self.pw() * operand.w() * self.py()
                + self.pw() * operand.x() * self.nz()
                + self.pw() * operand.y() * self.pw()
                - self.pw() * operand.z() * self.nx()
                - self.px() * operand.w() * self.nz()
                - self.py() * operand.w() * self.pw()
                + self.pz() * operand.w() * self.nx())
                * inv_norm_sq,
            (-(self.dist() * operand.w() * self.nz()) - self.nx() * operand.w() * self.py()
                + self.nx() * operand.x() * self.nz()
                + self.nx() * operand.y() * self.pw()
                - self.nx() * operand.z() * self.nx()
                - self.ny() * operand.w() * self.px()
                + self.ny() * operand.x() * self.pw()
                - self.ny() * operand.y() * self.nz()
                - self.ny() * operand.z() * self.ny()
                - self.nz() * operand.w() * self.dist()
                + self.nz() * operand.x() * self.nx()
                - self.nz() * operand.y() * self.ny()
                + self.nz() * operand.z() * self.nz()
                - self.pw() * operand.w() * self.pz()
                + self.pw() * operand.x() * self.ny()
                + self.pw() * operand.y() * self.nx()
                + self.pw() * operand.z() * self.pw()
                - self.px() * operand.w() * self.ny()
                - self.py() * operand.w() * self.nx()
                - self.pz() * operand.w() * self.pw())
                * inv_norm_sq,
            (-(self.nx() * operand.w() * self.nx())
                - self.ny() * operand.w() * self.ny()
                - self.nz() * operand.w() * self.nz()
                - self.pw() * operand.w() * self.pw())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Quadvector<T>> for Flector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Quadvector<T>) -> Option<Quadvector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Quadvector::new_unchecked(
            (-(self.nx() * operand.ps() * self.nx())
                - self.ny() * operand.ps() * self.ny()
                - self.nz() * operand.ps() * self.nz()
                - self.pw() * operand.ps() * self.pw())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Flector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.nx() * operand.s() * self.nx()
                + self.ny() * operand.s() * self.ny()
                + self.nz() * operand.s() * self.nz()
                + self.pw() * operand.s() * self.pw())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Flector<T>> for Line<T> {
    type Output = Flector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Flector<T>) -> Option<Flector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Flector::new_unchecked(
            (self.dir_x() * operand.nx() * self.moment_x()
                + self.dir_x() * operand.ny() * self.moment_y()
                + self.dir_x() * operand.nz() * self.moment_z()
                + self.dir_x() * operand.px() * self.dir_x()
                + self.dir_x() * operand.py() * self.dir_y()
                + self.dir_x() * operand.pz() * self.dir_z()
                + self.dir_y() * operand.dist() * self.dir_z()
                + self.dir_y() * operand.nx() * self.moment_y()
                - self.dir_y() * operand.ny() * self.moment_x()
                - self.dir_y() * operand.pw() * self.moment_z()
                - self.dir_y() * operand.px() * self.dir_y()
                + self.dir_y() * operand.py() * self.dir_x()
                - self.dir_z() * operand.dist() * self.dir_y()
                - self.dir_z() * operand.nx() * self.moment_z()
                + self.dir_z() * operand.nz() * self.moment_x()
                - self.dir_z() * operand.pw() * self.moment_y()
                - self.dir_z() * operand.px() * self.dir_z()
                + self.dir_z() * operand.pz() * self.dir_x()
                - self.moment_x() * operand.nx() * self.dir_x()
                + self.moment_x() * operand.ny() * self.dir_y()
                - self.moment_x() * operand.nz() * self.dir_z()
                - self.moment_y() * operand.nx() * self.dir_y()
                - self.moment_y() * operand.ny() * self.dir_x()
                - self.moment_y() * operand.pw() * self.dir_z()
                + self.moment_z() * operand.nx() * self.dir_z()
                - self.moment_z() * operand.nz() * self.dir_x()
                - self.moment_z() * operand.pw() * self.dir_y())
                * inv_norm_sq,
            (-(self.dir_x() * operand.dist() * self.dir_z())
                - self.dir_x() * operand.nx() * self.moment_y()
                + self.dir_x() * operand.ny() * self.moment_x()
                + self.dir_x() * operand.pw() * self.moment_z()
                + self.dir_x() * operand.px() * self.dir_y()
                - self.dir_x() * operand.py() * self.dir_x()
                + self.dir_y() * operand.nx() * self.moment_x()
                + self.dir_y() * operand.ny() * self.moment_y()
                + self.dir_y() * operand.nz() * self.moment_z()
                + self.dir_y() * operand.px() * self.dir_x()
                + self.dir_y() * operand.py() * self.dir_y()
                + self.dir_y() * operand.pz() * self.dir_z()
                + self.dir_z() * operand.dist() * self.dir_x()
                + self.dir_z() * operand.ny() * self.moment_z()
                - self.dir_z() * operand.nz() * self.moment_y()
                - self.dir_z() * operand.pw() * self.moment_x()
                - self.dir_z() * operand.py() * self.dir_z()
                + self.dir_z() * operand.pz() * self.dir_y()
                - self.moment_x() * operand.nx() * self.dir_y()
                - self.moment_x() * operand.ny() * self.dir_x()
                - self.moment_x() * operand.pw() * self.dir_z()
                + self.moment_y() * operand.nx() * self.dir_x()
                - self.moment_y() * operand.ny() * self.dir_y()
                + self.moment_y() * operand.nz() * self.dir_z()
                - self.moment_z() * operand.ny() * self.dir_z()
                - self.moment_z() * operand.nz() * self.dir_y()
                + self.moment_z() * operand.pw() * self.dir_x())
                * inv_norm_sq,
            (self.dir_x() * operand.dist() * self.dir_y()
                + self.dir_x() * operand.nx() * self.moment_z()
                - self.dir_x() * operand.nz() * self.moment_x()
                + self.dir_x() * operand.pw() * self.moment_y()
                + self.dir_x() * operand.px() * self.dir_z()
                - self.dir_x() * operand.pz() * self.dir_x()
                - self.dir_y() * operand.dist() * self.dir_x()
                - self.dir_y() * operand.ny() * self.moment_z()
                + self.dir_y() * operand.nz() * self.moment_y()
                + self.dir_y() * operand.pw() * self.moment_x()
                + self.dir_y() * operand.py() * self.dir_z()
                - self.dir_y() * operand.pz() * self.dir_y()
                + self.dir_z() * operand.nx() * self.moment_x()
                + self.dir_z() * operand.ny() * self.moment_y()
                + self.dir_z() * operand.nz() * self.moment_z()
                + self.dir_z() * operand.px() * self.dir_x()
                + self.dir_z() * operand.py() * self.dir_y()
                + self.dir_z() * operand.pz() * self.dir_z()
                - self.moment_x() * operand.nx() * self.dir_z()
                + self.moment_x() * operand.nz() * self.dir_x()
                + self.moment_x() * operand.pw() * self.dir_y()
                - self.moment_y() * operand.ny() * self.dir_z()
                - self.moment_y() * operand.nz() * self.dir_y()
                + self.moment_y() * operand.pw() * self.dir_x()
                - self.moment_z() * operand.nx() * self.dir_x()
                + self.moment_z() * operand.ny() * self.dir_y()
                - self.moment_z() * operand.nz() * self.dir_z())
                * inv_norm_sq,
            (-(self.dir_x() * operand.ny() * self.dir_z())
                - self.dir_x() * operand.nz() * self.dir_y()
                + self.dir_x() * operand.pw() * self.dir_x()
                - self.dir_y() * operand.nx() * self.dir_z()
                + self.dir_y() * operand.nz() * self.dir_x()
                + self.dir_y() * operand.pw() * self.dir_y()
                + self.dir_z() * operand.nx() * self.dir_y()
                + self.dir_z() * operand.ny() * self.dir_x()
                + self.dir_z() * operand.pw() * self.dir_z())
                * inv_norm_sq,
            (self.dir_x() * operand.dist() * self.dir_x()
                + self.dir_x() * operand.ny() * self.moment_z()
                - self.dir_x() * operand.nz() * self.moment_y()
                - self.dir_x() * operand.pw() * self.moment_x()
                - self.dir_x() * operand.py() * self.dir_z()
                + self.dir_x() * operand.pz() * self.dir_y()
                + self.dir_y() * operand.dist() * self.dir_y()
                + self.dir_y() * operand.nx() * self.moment_z()
                - self.dir_y() * operand.nz() * self.moment_x()
                + self.dir_y() * operand.pw() * self.moment_y()
                + self.dir_y() * operand.px() * self.dir_z()
                - self.dir_y() * operand.pz() * self.dir_x()
                + self.dir_z() * operand.dist() * self.dir_z()
                + self.dir_z() * operand.nx() * self.moment_y()
                - self.dir_z() * operand.ny() * self.moment_x()
                - self.dir_z() * operand.pw() * self.moment_z()
                - self.dir_z() * operand.px() * self.dir_y()
                + self.dir_z() * operand.py() * self.dir_x()
                - self.moment_x() * operand.ny() * self.dir_z()
                - self.moment_x() * operand.nz() * self.dir_y()
                + self.moment_x() * operand.pw() * self.dir_x()
                + self.moment_y() * operand.nx() * self.dir_z()
                - self.moment_y() * operand.nz() * self.dir_x()
                - self.moment_y() * operand.pw() * self.dir_y()
                + self.moment_z() * operand.nx() * self.dir_y()
                + self.moment_z() * operand.ny() * self.dir_x()
                + self.moment_z() * operand.pw() * self.dir_z())
                * inv_norm_sq,
            (self.dir_x() * operand.nx() * self.dir_z()
                - self.dir_x() * operand.nz() * self.dir_x()
                - self.dir_x() * operand.pw() * self.dir_y()
                - self.dir_y() * operand.ny() * self.dir_z()
                - self.dir_y() * operand.nz() * self.dir_y()
                + self.dir_y() * operand.pw() * self.dir_x()
                + self.dir_z() * operand.nx() * self.dir_x()
                - self.dir_z() * operand.ny() * self.dir_y()
                + self.dir_z() * operand.nz() * self.dir_z())
                * inv_norm_sq,
            (-(self.dir_x() * operand.nx() * self.dir_y())
                - self.dir_x() * operand.ny() * self.dir_x()
                - self.dir_x() * operand.pw() * self.dir_z()
                - self.dir_y() * operand.nx() * self.dir_x()
                + self.dir_y() * operand.ny() * self.dir_y()
                - self.dir_y() * operand.nz() * self.dir_z()
                - self.dir_z() * operand.ny() * self.dir_z()
                - self.dir_z() * operand.nz() * self.dir_y()
                + self.dir_z() * operand.pw() * self.dir_x())
                * inv_norm_sq,
            (self.dir_x() * operand.nx() * self.dir_x()
                - self.dir_x() * operand.ny() * self.dir_y()
                + self.dir_x() * operand.nz() * self.dir_z()
                - self.dir_y() * operand.nx() * self.dir_y()
                - self.dir_y() * operand.ny() * self.dir_x()
                - self.dir_y() * operand.pw() * self.dir_z()
                - self.dir_z() * operand.nx() * self.dir_z()
                + self.dir_z() * operand.nz() * self.dir_x()
                + self.dir_z() * operand.pw() * self.dir_y())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Line<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (self.dir_x() * operand.dir_x() * self.moment_z()
                - self.dir_x() * operand.dir_z() * self.moment_x()
                + self.dir_x() * operand.moment_x() * self.dir_z()
                - self.dir_x() * operand.moment_z() * self.dir_x()
                + self.dir_y() * operand.dir_y() * self.moment_z()
                + self.dir_y() * operand.dir_z() * self.moment_y()
                - self.dir_y() * operand.moment_y() * self.dir_z()
                - self.dir_y() * operand.moment_z() * self.dir_y()
                + self.dir_z() * operand.dir_x() * self.moment_x()
                - self.dir_z() * operand.dir_y() * self.moment_y()
                + self.dir_z() * operand.dir_z() * self.moment_z()
                + self.dir_z() * operand.moment_x() * self.dir_x()
                - self.dir_z() * operand.moment_y() * self.dir_y()
                + self.dir_z() * operand.moment_z() * self.dir_z()
                + self.moment_x() * operand.dir_x() * self.dir_z()
                - self.moment_x() * operand.dir_z() * self.dir_x()
                - self.moment_y() * operand.dir_y() * self.dir_z()
                + self.moment_y() * operand.dir_z() * self.dir_y()
                + self.moment_z() * operand.dir_x() * self.dir_x()
                + self.moment_z() * operand.dir_y() * self.dir_y()
                + self.moment_z() * operand.dir_z() * self.dir_z())
                * inv_norm_sq,
            (self.dir_x() * operand.dir_x() * self.moment_y()
                + self.dir_x() * operand.dir_y() * self.moment_x()
                - self.dir_x() * operand.moment_x() * self.dir_y()
                - self.dir_x() * operand.moment_y() * self.dir_x()
                - self.dir_y() * operand.dir_x() * self.moment_x()
                + self.dir_y() * operand.dir_y() * self.moment_y()
                - self.dir_y() * operand.dir_z() * self.moment_z()
                - self.dir_y() * operand.moment_x() * self.dir_x()
                + self.dir_y() * operand.moment_y() * self.dir_y()
                - self.dir_y() * operand.moment_z() * self.dir_z()
                + self.dir_z() * operand.dir_y() * self.moment_z()
                + self.dir_z() * operand.dir_z() * self.moment_y()
                - self.dir_z() * operand.moment_y() * self.dir_z()
                - self.dir_z() * operand.moment_z() * self.dir_y()
                - self.moment_x() * operand.dir_x() * self.dir_y()
                + self.moment_x() * operand.dir_y() * self.dir_x()
                + self.moment_y() * operand.dir_x() * self.dir_x()
                + self.moment_y() * operand.dir_y() * self.dir_y()
                + self.moment_y() * operand.dir_z() * self.dir_z()
                + self.moment_z() * operand.dir_y() * self.dir_z()
                - self.moment_z() * operand.dir_z() * self.dir_y())
                * inv_norm_sq,
            (self.dir_x() * operand.dir_x() * self.dir_x()
                + self.dir_x() * operand.dir_y() * self.dir_y()
                + self.dir_x() * operand.dir_z() * self.dir_z()
                - self.dir_y() * operand.dir_x() * self.dir_y()
                + self.dir_y() * operand.dir_y() * self.dir_x()
                - self.dir_z() * operand.dir_x() * self.dir_z()
                + self.dir_z() * operand.dir_z() * self.dir_x())
                * inv_norm_sq,
            (self.dir_x() * operand.dir_x() * self.moment_x()
                - self.dir_x() * operand.dir_y() * self.moment_y()
                + self.dir_x() * operand.dir_z() * self.moment_z()
                + self.dir_x() * operand.moment_x() * self.dir_x()
                - self.dir_x() * operand.moment_y() * self.dir_y()
                + self.dir_x() * operand.moment_z() * self.dir_z()
                + self.dir_y() * operand.dir_x() * self.moment_y()
                + self.dir_y() * operand.dir_y() * self.moment_x()
                - self.dir_y() * operand.moment_x() * self.dir_y()
                - self.dir_y() * operand.moment_y() * self.dir_x()
                - self.dir_z() * operand.dir_x() * self.moment_z()
                + self.dir_z() * operand.dir_z() * self.moment_x()
                - self.dir_z() * operand.moment_x() * self.dir_z()
                + self.dir_z() * operand.moment_z() * self.dir_x()
                + self.moment_x() * operand.dir_x() * self.dir_x()
                + self.moment_x() * operand.dir_y() * self.dir_y()
                + self.moment_x() * operand.dir_z() * self.dir_z()
                + self.moment_y() * operand.dir_x() * self.dir_y()
                - self.moment_y() * operand.dir_y() * self.dir_x()
                - self.moment_z() * operand.dir_x() * self.dir_z()
                + self.moment_z() * operand.dir_z() * self.dir_x())
                * inv_norm_sq,
            (self.dir_x() * operand.dir_x() * self.dir_y()
                - self.dir_x() * operand.dir_y() * self.dir_x()
                + self.dir_y() * operand.dir_x() * self.dir_x()
                + self.dir_y() * operand.dir_y() * self.dir_y()
                + self.dir_y() * operand.dir_z() * self.dir_z()
                - self.dir_z() * operand.dir_y() * self.dir_z()
                + self.dir_z() * operand.dir_z() * self.dir_y())
                * inv_norm_sq,
            (self.dir_x() * operand.dir_x() * self.dir_z()
                - self.dir_x() * operand.dir_z() * self.dir_x()
                + self.dir_y() * operand.dir_y() * self.dir_z()
                - self.dir_y() * operand.dir_z() * self.dir_y()
                + self.dir_z() * operand.dir_x() * self.dir_x()
                + self.dir_z() * operand.dir_y() * self.dir_y()
                + self.dir_z() * operand.dir_z() * self.dir_z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Motor<T>> for Line<T> {
    type Output = Motor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Motor<T>) -> Option<Motor<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Motor::new_unchecked(
            (-(self.dir_x() * operand.ps() * self.moment_x())
                + self.dir_x() * operand.ry() * self.moment_z()
                + self.dir_x() * operand.rz() * self.moment_y()
                + self.dir_x() * operand.s() * self.dir_x()
                - self.dir_x() * operand.ty() * self.dir_z()
                - self.dir_x() * operand.tz() * self.dir_y()
                + self.dir_y() * operand.ps() * self.moment_y()
                - self.dir_y() * operand.rx() * self.dir_z()
                + self.dir_y() * operand.rz() * self.moment_x()
                + self.dir_y() * operand.s() * self.dir_y()
                - self.dir_y() * operand.tx() * self.moment_z()
                + self.dir_y() * operand.tz() * self.dir_x()
                - self.dir_z() * operand.ps() * self.moment_z()
                + self.dir_z() * operand.rx() * self.dir_y()
                - self.dir_z() * operand.ry() * self.moment_x()
                + self.dir_z() * operand.s() * self.dir_z()
                - self.dir_z() * operand.tx() * self.moment_y()
                + self.dir_z() * operand.ty() * self.dir_x()
                - self.moment_x() * operand.ps() * self.dir_x()
                + self.moment_x() * operand.ry() * self.dir_z()
                - self.moment_x() * operand.rz() * self.dir_y()
                + self.moment_y() * operand.ps() * self.dir_y()
                - self.moment_y() * operand.rz() * self.dir_x()
                + self.moment_y() * operand.tx() * self.dir_z()
                - self.moment_z() * operand.ps() * self.dir_z()
                - self.moment_z() * operand.ry() * self.dir_x()
                + self.moment_z() * operand.tx() * self.dir_y())
                * inv_norm_sq,
            (-(self.dir_x() * operand.ps() * self.moment_y())
                + self.dir_x() * operand.rx() * self.dir_z()
                - self.dir_x() * operand.rz() * self.moment_x()
                - self.dir_x() * operand.s() * self.dir_y()
                + self.dir_x() * operand.tx() * self.moment_z()
                - self.dir_x() * operand.tz() * self.dir_x()
                - self.dir_y() * operand.ps() * self.moment_x()
                + self.dir_y() * operand.ry() * self.moment_z()
                + self.dir_y() * operand.rz() * self.moment_y()
                + self.dir_y() * operand.s() * self.dir_x()
                - self.dir_y() * operand.ty() * self.dir_z()
                - self.dir_y() * operand.tz() * self.dir_y()
                + self.dir_z() * operand.rx() * self.dir_x()
                - self.dir_z() * operand.ry() * self.moment_y()
                + self.dir_z() * operand.rz() * self.moment_z()
                + self.dir_z() * operand.tx() * self.moment_x()
                - self.dir_z() * operand.ty() * self.dir_y()
                + self.dir_z() * operand.tz() * self.dir_z()
                + self.moment_x() * operand.ps() * self.dir_y()
                - self.moment_x() * operand.rz() * self.dir_x()
                + self.moment_x() * operand.tx() * self.dir_z()
                + self.moment_y() * operand.ps() * self.dir_x()
                - self.moment_y() * operand.ry() * self.dir_z()
                + self.moment_y() * operand.rz() * self.dir_y()
                + self.moment_z() * operand.ry() * self.dir_y()
                + self.moment_z() * operand.rz() * self.dir_z()
                + self.moment_z() * operand.tx() * self.dir_x())
                * inv_norm_sq,
            (self.dir_x() * operand.ps() * self.moment_z()
                - self.dir_x() * operand.rx() * self.dir_y()
                + self.dir_x() * operand.ry() * self.moment_x()
                - self.dir_x() * operand.s() * self.dir_z()
                + self.dir_x() * operand.tx() * self.moment_y()
                - self.dir_x() * operand.ty() * self.dir_x()
                - self.dir_y() * operand.rx() * self.dir_x()
                + self.dir_y() * operand.ry() * self.moment_y()
                - self.dir_y() * operand.rz() * self.moment_z()
                - self.dir_y() * operand.tx() * self.moment_x()
                + self.dir_y() * operand.ty() * self.dir_y()
                - self.dir_y() * operand.tz() * self.dir_z()
                - self.dir_z() * operand.ps() * self.moment_x()
                + self.dir_z() * operand.ry() * self.moment_z()
                + self.dir_z() * operand.rz() * self.moment_y()
                + self.dir_z() * operand.s() * self.dir_x()
                - self.dir_z() * operand.ty() * self.dir_z()
                - self.dir_z() * operand.tz() * self.dir_y()
                + self.moment_x() * operand.ps() * self.dir_z()
                + self.moment_x() * operand.ry() * self.dir_x()
                - self.moment_x() * operand.tx() * self.dir_y()
                + self.moment_y() * operand.ry() * self.dir_y()
                + self.moment_y() * operand.rz() * self.dir_z()
                + self.moment_y() * operand.tx() * self.dir_x()
                - self.moment_z() * operand.ps() * self.dir_x()
                + self.moment_z() * operand.ry() * self.dir_z()
                - self.moment_z() * operand.rz() * self.dir_y())
                * inv_norm_sq,
            (self.dir_x() * operand.ry() * self.dir_y()
                + self.dir_x() * operand.rz() * self.dir_z()
                + self.dir_x() * operand.tx() * self.dir_x()
                + self.dir_y() * operand.ps() * self.dir_z()
                + self.dir_y() * operand.ry() * self.dir_x()
                - self.dir_y() * operand.tx() * self.dir_y()
                - self.dir_z() * operand.ps() * self.dir_y()
                + self.dir_z() * operand.rz() * self.dir_x()
                - self.dir_z() * operand.tx() * self.dir_z())
                * inv_norm_sq,
            (self.dir_x() * operand.rx() * self.dir_x()
                - self.dir_x() * operand.ry() * self.moment_y()
                + self.dir_x() * operand.rz() * self.moment_z()
                + self.dir_x() * operand.tx() * self.moment_x()
                - self.dir_x() * operand.ty() * self.dir_y()
                + self.dir_x() * operand.tz() * self.dir_z()
                + self.dir_y() * operand.ps() * self.moment_z()
                - self.dir_y() * operand.rx() * self.dir_y()
                + self.dir_y() * operand.ry() * self.moment_x()
                - self.dir_y() * operand.s() * self.dir_z()
                + self.dir_y() * operand.tx() * self.moment_y()
                - self.dir_y() * operand.ty() * self.dir_x()
                + self.dir_z() * operand.ps() * self.moment_y()
                - self.dir_z() * operand.rx() * self.dir_z()
                + self.dir_z() * operand.rz() * self.moment_x()
                + self.dir_z() * operand.s() * self.dir_y()
                - self.dir_z() * operand.tx() * self.moment_z()
                + self.dir_z() * operand.tz() * self.dir_x()
                + self.moment_x() * operand.ry() * self.dir_y()
                + self.moment_x() * operand.rz() * self.dir_z()
                + self.moment_x() * operand.tx() * self.dir_x()
                - self.moment_y() * operand.ps() * self.dir_z()
                - self.moment_y() * operand.ry() * self.dir_x()
                + self.moment_y() * operand.tx() * self.dir_y()
                - self.moment_z() * operand.ps() * self.dir_y()
                + self.moment_z() * operand.rz() * self.dir_x()
                - self.moment_z() * operand.tx() * self.dir_z())
                * inv_norm_sq,
            (-(self.dir_x() * operand.ps() * self.dir_z())
                - self.dir_x() * operand.ry() * self.dir_x()
                + self.dir_x() * operand.tx() * self.dir_y()
                + self.dir_y() * operand.ry() * self.dir_y()
                + self.dir_y() * operand.rz() * self.dir_z()
                + self.dir_y() * operand.tx() * self.dir_x()
                + self.dir_z() * operand.ps() * self.dir_x()
                - self.dir_z() * operand.ry() * self.dir_z()
                + self.dir_z() * operand.rz() * self.dir_y())
                * inv_norm_sq,
            (self.dir_x() * operand.ps() * self.dir_y()
                - self.dir_x() * operand.rz() * self.dir_x()
                + self.dir_x() * operand.tx() * self.dir_z()
                - self.dir_y() * operand.ps() * self.dir_x()
                + self.dir_y() * operand.ry() * self.dir_z()
                - self.dir_y() * operand.rz() * self.dir_y()
                + self.dir_z() * operand.ry() * self.dir_y()
                + self.dir_z() * operand.rz() * self.dir_z()
                + self.dir_z() * operand.tx() * self.dir_x())
                * inv_norm_sq,
            (self.dir_x() * operand.ps() * self.dir_x()
                - self.dir_x() * operand.ry() * self.dir_z()
                + self.dir_x() * operand.rz() * self.dir_y()
                + self.dir_y() * operand.ps() * self.dir_y()
                - self.dir_y() * operand.rz() * self.dir_x()
                + self.dir_y() * operand.tx() * self.dir_z()
                + self.dir_z() * operand.ps() * self.dir_z()
                + self.dir_z() * operand.ry() * self.dir_x()
                - self.dir_z() * operand.tx() * self.dir_y())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Plane<T>> for Line<T> {
    type Output = Plane<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Plane<T>) -> Option<Plane<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Plane::new_unchecked(
            (self.dir_x() * operand.dist() * self.dir_x()
                + self.dir_x() * operand.ny() * self.moment_z()
                - self.dir_x() * operand.nz() * self.moment_y()
                + self.dir_y() * operand.dist() * self.dir_y()
                + self.dir_y() * operand.nx() * self.moment_z()
                - self.dir_y() * operand.nz() * self.moment_x()
                + self.dir_z() * operand.dist() * self.dir_z()
                + self.dir_z() * operand.nx() * self.moment_y()
                - self.dir_z() * operand.ny() * self.moment_x()
                - self.moment_x() * operand.ny() * self.dir_z()
                - self.moment_x() * operand.nz() * self.dir_y()
                + self.moment_y() * operand.nx() * self.dir_z()
                - self.moment_y() * operand.nz() * self.dir_x()
                + self.moment_z() * operand.nx() * self.dir_y()
                + self.moment_z() * operand.ny() * self.dir_x())
                * inv_norm_sq,
            (self.dir_x() * operand.nx() * self.dir_z()
                - self.dir_x() * operand.nz() * self.dir_x()
                - self.dir_y() * operand.ny() * self.dir_z()
                - self.dir_y() * operand.nz() * self.dir_y()
                + self.dir_z() * operand.nx() * self.dir_x()
                - self.dir_z() * operand.ny() * self.dir_y()
                + self.dir_z() * operand.nz() * self.dir_z())
                * inv_norm_sq,
            (-(self.dir_x() * operand.nx() * self.dir_y())
                - self.dir_x() * operand.ny() * self.dir_x()
                - self.dir_y() * operand.nx() * self.dir_x()
                + self.dir_y() * operand.ny() * self.dir_y()
                - self.dir_y() * operand.nz() * self.dir_z()
                - self.dir_z() * operand.ny() * self.dir_z()
                - self.dir_z() * operand.nz() * self.dir_y())
                * inv_norm_sq,
            (self.dir_x() * operand.nx() * self.dir_x()
                - self.dir_x() * operand.ny() * self.dir_y()
                + self.dir_x() * operand.nz() * self.dir_z()
                - self.dir_y() * operand.nx() * self.dir_y()
                - self.dir_y() * operand.ny() * self.dir_x()
                - self.dir_z() * operand.nx() * self.dir_z()
                + self.dir_z() * operand.nz() * self.dir_x())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Point<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (self.dir_x() * operand.x() * self.dir_x()
                + self.dir_x() * operand.y() * self.dir_y()
                + self.dir_x() * operand.z() * self.dir_z()
                - self.dir_y() * operand.w() * self.moment_z()
                - self.dir_y() * operand.x() * self.dir_y()
                + self.dir_y() * operand.y() * self.dir_x()
                - self.dir_z() * operand.w() * self.moment_y()
                - self.dir_z() * operand.x() * self.dir_z()
                + self.dir_z() * operand.z() * self.dir_x()
                - self.moment_y() * operand.w() * self.dir_z()
                - self.moment_z() * operand.w() * self.dir_y())
                * inv_norm_sq,
            (self.dir_x() * operand.w() * self.moment_z()
                + self.dir_x() * operand.x() * self.dir_y()
                - self.dir_x() * operand.y() * self.dir_x()
                + self.dir_y() * operand.x() * self.dir_x()
                + self.dir_y() * operand.y() * self.dir_y()
                + self.dir_y() * operand.z() * self.dir_z()
                - self.dir_z() * operand.w() * self.moment_x()
                - self.dir_z() * operand.y() * self.dir_z()
                + self.dir_z() * operand.z() * self.dir_y()
                - self.moment_x() * operand.w() * self.dir_z()
                + self.moment_z() * operand.w() * self.dir_x())
                * inv_norm_sq,
            (self.dir_x() * operand.w() * self.moment_y()
                + self.dir_x() * operand.x() * self.dir_z()
                - self.dir_x() * operand.z() * self.dir_x()
                + self.dir_y() * operand.w() * self.moment_x()
                + self.dir_y() * operand.y() * self.dir_z()
                - self.dir_y() * operand.z() * self.dir_y()
                + self.dir_z() * operand.x() * self.dir_x()
                + self.dir_z() * operand.y() * self.dir_y()
                + self.dir_z() * operand.z() * self.dir_z()
                + self.moment_x() * operand.w() * self.dir_y()
                + self.moment_y() * operand.w() * self.dir_x())
                * inv_norm_sq,
            (self.dir_x() * operand.w() * self.dir_x()
                + self.dir_y() * operand.w() * self.dir_y()
                + self.dir_z() * operand.w() * self.dir_z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Quadvector<T>> for Line<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Quadvector<T>) -> Option<Quadvector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Quadvector::new_unchecked(
            (self.dir_x() * operand.ps() * self.dir_x()
                + self.dir_y() * operand.ps() * self.dir_y()
                + self.dir_z() * operand.ps() * self.dir_z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.dir_x() * operand.s() * self.dir_x()
                + self.dir_y() * operand.s() * self.dir_y()
                + self.dir_z() * operand.s() * self.dir_z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Flector<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Flector<T>) -> Option<Flector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Flector::new_unchecked(
            (-(self.ps() * operand.dist() * self.tx())
                - self.ps() * operand.nx() * self.s()
                - self.ps() * operand.ny() * self.tz()
                + self.ps() * operand.nz() * self.ty()
                + self.ps() * operand.pw() * self.rx()
                + self.ps() * operand.px() * self.ps()
                + self.ps() * operand.py() * self.rz()
                - self.ps() * operand.pz() * self.ry()
                - self.rx() * operand.nx() * self.tx()
                + self.rx() * operand.ny() * self.ry()
                - self.rx() * operand.nz() * self.rz()
                + self.rx() * operand.pw() * self.ps()
                + self.ry() * operand.dist() * self.rz()
                + self.ry() * operand.nx() * self.ty()
                - self.ry() * operand.ny() * self.rx()
                + self.ry() * operand.nz() * self.s()
                - self.ry() * operand.pw() * self.tz()
                - self.ry() * operand.px() * self.ry()
                + self.ry() * operand.py() * self.tx()
                - self.ry() * operand.pz() * self.ps()
                - self.rz() * operand.dist() * self.ry()
                - self.rz() * operand.nx() * self.tz()
                + self.rz() * operand.ny() * self.s()
                + self.rz() * operand.nz() * self.rx()
                - self.rz() * operand.pw() * self.ty()
                - self.rz() * operand.px() * self.rz()
                + self.rz() * operand.py() * self.ps()
                + self.rz() * operand.pz() * self.tx()
                + self.s() * operand.nx() * self.ps()
                - self.s() * operand.ny() * self.rz()
                - self.s() * operand.nz() * self.ry()
                + self.s() * operand.pw() * self.tx()
                + self.tx() * operand.dist() * self.ps()
                + self.tx() * operand.nx() * self.rx()
                + self.tx() * operand.ny() * self.ty()
                + self.tx() * operand.nz() * self.tz()
                + self.tx() * operand.pw() * self.s()
                + self.tx() * operand.px() * self.tx()
                + self.tx() * operand.py() * self.ry()
                + self.tx() * operand.pz() * self.rz()
                - self.ty() * operand.nx() * self.ry()
                - self.ty() * operand.ny() * self.tx()
                - self.ty() * operand.nz() * self.ps()
                - self.ty() * operand.pw() * self.rz()
                + self.tz() * operand.nx() * self.rz()
                + self.tz() * operand.ny() * self.ps()
                - self.tz() * operand.nz() * self.tx()
                - self.tz() * operand.pw() * self.ry())
                * inv_norm_sq,
            (-(self.ps() * operand.dist() * self.ry()) - self.ps() * operand.nx() * self.tz()
                + self.ps() * operand.ny() * self.s()
                + self.ps() * operand.nz() * self.rx()
                - self.ps() * operand.pw() * self.ty()
                - self.ps() * operand.px() * self.rz()
                + self.ps() * operand.py() * self.ps()
                + self.ps() * operand.pz() * self.tx()
                - self.rx() * operand.nx() * self.ry()
                - self.rx() * operand.ny() * self.tx()
                - self.rx() * operand.nz() * self.ps()
                - self.rx() * operand.pw() * self.rz()
                + self.ry() * operand.dist() * self.ps()
                + self.ry() * operand.nx() * self.rx()
                + self.ry() * operand.ny() * self.ty()
                + self.ry() * operand.nz() * self.tz()
                + self.ry() * operand.pw() * self.s()
                + self.ry() * operand.px() * self.tx()
                + self.ry() * operand.py() * self.ry()
                + self.ry() * operand.pz() * self.rz()
                + self.rz() * operand.dist() * self.tx()
                + self.rz() * operand.nx() * self.s()
                + self.rz() * operand.ny() * self.tz()
                - self.rz() * operand.nz() * self.ty()
                - self.rz() * operand.pw() * self.rx()
                - self.rz() * operand.px() * self.ps()
                - self.rz() * operand.py() * self.rz()
                + self.rz() * operand.pz() * self.ry()
                - self.s() * operand.nx() * self.rz()
                - self.s() * operand.ny() * self.ps()
                + self.s() * operand.nz() * self.tx()
                + self.s() * operand.pw() * self.ry()
                - self.tx() * operand.dist() * self.rz()
                - self.tx() * operand.nx() * self.ty()
                + self.tx() * operand.ny() * self.rx()
                - self.tx() * operand.nz() * self.s()
                + self.tx() * operand.pw() * self.tz()
                + self.tx() * operand.px() * self.ry()
                - self.tx() * operand.py() * self.tx()
                + self.tx() * operand.pz() * self.ps()
                + self.ty() * operand.nx() * self.tx()
                - self.ty() * operand.ny() * self.ry()
                + self.ty() * operand.nz() * self.rz()
                - self.ty() * operand.pw() * self.ps()
                + self.tz() * operand.nx() * self.ps()
                - self.tz() * operand.ny() * self.rz()
                - self.tz() * operand.nz() * self.ry()
                + self.tz() * operand.pw() * self.tx())
                * inv_norm_sq,
            (-(self.ps() * operand.dist() * self.rz()) - self.ps() * operand.nx() * self.ty()
                + self.ps() * operand.ny() * self.rx()
                - self.ps() * operand.nz() * self.s()
                + self.ps() * operand.pw() * self.tz()
                + self.ps() * operand.px() * self.ry()
                - self.ps() * operand.py() * self.tx()
                + self.ps() * operand.pz() * self.ps()
                - self.rx() * operand.nx() * self.rz()
                - self.rx() * operand.ny() * self.ps()
                + self.rx() * operand.nz() * self.tx()
                + self.rx() * operand.pw() * self.ry()
                - self.ry() * operand.dist() * self.tx()
                - self.ry() * operand.nx() * self.s()
                - self.ry() * operand.ny() * self.tz()
                + self.ry() * operand.nz() * self.ty()
                + self.ry() * operand.pw() * self.rx()
                + self.ry() * operand.px() * self.ps()
                + self.ry() * operand.py() * self.rz()
                - self.ry() * operand.pz() * self.ry()
                + self.rz() * operand.dist() * self.ps()
                + self.rz() * operand.nx() * self.rx()
                + self.rz() * operand.ny() * self.ty()
                + self.rz() * operand.nz() * self.tz()
                + self.rz() * operand.pw() * self.s()
                + self.rz() * operand.px() * self.tx()
                + self.rz() * operand.py() * self.ry()
                + self.rz() * operand.pz() * self.rz()
                + self.s() * operand.nx() * self.ry()
                + self.s() * operand.ny() * self.tx()
                + self.s() * operand.nz() * self.ps()
                + self.s() * operand.pw() * self.rz()
                + self.tx() * operand.dist() * self.ry()
                + self.tx() * operand.nx() * self.tz()
                - self.tx() * operand.ny() * self.s()
                - self.tx() * operand.nz() * self.rx()
                + self.tx() * operand.pw() * self.ty()
                + self.tx() * operand.px() * self.rz()
                - self.tx() * operand.py() * self.ps()
                - self.tx() * operand.pz() * self.tx()
                + self.ty() * operand.nx() * self.ps()
                - self.ty() * operand.ny() * self.rz()
                - self.ty() * operand.nz() * self.ry()
                + self.ty() * operand.pw() * self.tx()
                - self.tz() * operand.nx() * self.tx()
                + self.tz() * operand.ny() * self.ry()
                - self.tz() * operand.nz() * self.rz()
                + self.tz() * operand.pw() * self.ps())
                * inv_norm_sq,
            (-(self.ps() * operand.nx() * self.tx()) + self.ps() * operand.ny() * self.ry()
                - self.ps() * operand.nz() * self.rz()
                + self.ps() * operand.pw() * self.ps()
                - self.ry() * operand.nx() * self.rz()
                - self.ry() * operand.ny() * self.ps()
                + self.ry() * operand.nz() * self.tx()
                + self.ry() * operand.pw() * self.ry()
                + self.rz() * operand.nx() * self.ry()
                + self.rz() * operand.ny() * self.tx()
                + self.rz() * operand.nz() * self.ps()
                + self.rz() * operand.pw() * self.rz()
                + self.tx() * operand.nx() * self.ps()
                - self.tx() * operand.ny() * self.rz()
                - self.tx() * operand.nz() * self.ry()
                + self.tx() * operand.pw() * self.tx())
                * inv_norm_sq,
            (self.ps() * operand.dist() * self.ps()
                + self.ps() * operand.nx() * self.rx()
                + self.ps() * operand.ny() * self.ty()
                + self.ps() * operand.nz() * self.tz()
                + self.ps() * operand.pw() * self.s()
                + self.ps() * operand.px() * self.tx()
                + self.ps() * operand.py() * self.ry()
                + self.ps() * operand.pz() * self.rz()
                + self.rx() * operand.nx() * self.ps()
                - self.rx() * operand.ny() * self.rz()
                - self.rx() * operand.nz() * self.ry()
                + self.rx() * operand.pw() * self.tx()
                + self.ry() * operand.dist() * self.ry()
                + self.ry() * operand.nx() * self.tz()
                - self.ry() * operand.ny() * self.s()
                - self.ry() * operand.nz() * self.rx()
                + self.ry() * operand.pw() * self.ty()
                + self.ry() * operand.px() * self.rz()
                - self.ry() * operand.py() * self.ps()
                - self.ry() * operand.pz() * self.tx()
                + self.rz() * operand.dist() * self.rz()
                + self.rz() * operand.nx() * self.ty()
                - self.rz() * operand.ny() * self.rx()
                + self.rz() * operand.nz() * self.s()
                - self.rz() * operand.pw() * self.tz()
                - self.rz() * operand.px() * self.ry()
                + self.rz() * operand.py() * self.tx()
                - self.rz() * operand.pz() * self.ps()
                + self.s() * operand.nx() * self.tx()
                - self.s() * operand.ny() * self.ry()
                + self.s() * operand.nz() * self.rz()
                - self.s() * operand.pw() * self.ps()
                + self.tx() * operand.dist() * self.tx()
                + self.tx() * operand.nx() * self.s()
                + self.tx() * operand.ny() * self.tz()
                - self.tx() * operand.nz() * self.ty()
                - self.tx() * operand.pw() * self.rx()
                - self.tx() * operand.px() * self.ps()
                - self.tx() * operand.py() * self.rz()
                + self.tx() * operand.pz() * self.ry()
                + self.ty() * operand.nx() * self.rz()
                + self.ty() * operand.ny() * self.ps()
                - self.ty() * operand.nz() * self.tx()
                - self.ty() * operand.pw() * self.ry()
                + self.tz() * operand.nx() * self.ry()
                + self.tz() * operand.ny() * self.tx()
                + self.tz() * operand.nz() * self.ps()
                + self.tz() * operand.pw() * self.rz())
                * inv_norm_sq,
            (self.ps() * operand.nx() * self.ry()
                + self.ps() * operand.ny() * self.tx()
                + self.ps() * operand.nz() * self.ps()
                + self.ps() * operand.pw() * self.rz()
                + self.ry() * operand.nx() * self.ps()
                - self.ry() * operand.ny() * self.rz()
                - self.ry() * operand.nz() * self.ry()
                + self.ry() * operand.pw() * self.tx()
                + self.rz() * operand.nx() * self.tx()
                - self.rz() * operand.ny() * self.ry()
                + self.rz() * operand.nz() * self.rz()
                - self.rz() * operand.pw() * self.ps()
                + self.tx() * operand.nx() * self.rz()
                + self.tx() * operand.ny() * self.ps()
                - self.tx() * operand.nz() * self.tx()
                - self.tx() * operand.pw() * self.ry())
                * inv_norm_sq,
            (self.ps() * operand.nx() * self.rz() + self.ps() * operand.ny() * self.ps()
                - self.ps() * operand.nz() * self.tx()
                - self.ps() * operand.pw() * self.ry()
                - self.ry() * operand.nx() * self.tx()
                + self.ry() * operand.ny() * self.ry()
                - self.ry() * operand.nz() * self.rz()
                + self.ry() * operand.pw() * self.ps()
                + self.rz() * operand.nx() * self.ps()
                - self.rz() * operand.ny() * self.rz()
                - self.rz() * operand.nz() * self.ry()
                + self.rz() * operand.pw() * self.tx()
                - self.tx() * operand.nx() * self.ry()
                - self.tx() * operand.ny() * self.tx()
                - self.tx() * operand.nz() * self.ps()
                - self.tx() * operand.pw() * self.rz())
                * inv_norm_sq,
            (self.ps() * operand.nx() * self.ps()
                - self.ps() * operand.ny() * self.rz()
                - self.ps() * operand.nz() * self.ry()
                + self.ps() * operand.pw() * self.tx()
                - self.ry() * operand.nx() * self.ry()
                - self.ry() * operand.ny() * self.tx()
                - self.ry() * operand.nz() * self.ps()
                - self.ry() * operand.pw() * self.rz()
                - self.rz() * operand.nx() * self.rz()
                - self.rz() * operand.ny() * self.ps()
                + self.rz() * operand.nz() * self.tx()
                + self.rz() * operand.pw() * self.ry()
                + self.tx() * operand.nx() * self.tx()
                - self.tx() * operand.ny() * self.ry()
                + self.tx() * operand.nz() * self.rz()
                - self.tx() * operand.pw() * self.ps())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Line<T>> for Motor<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (-(self.ps() * operand.dir_x() * self.ty())
                - self.ps() * operand.dir_y() * self.rx()
                - self.ps() * operand.dir_z() * self.s()
                + self.ps() * operand.moment_x() * self.ry()
                + self.ps() * operand.moment_y() * self.tx()
                + self.ps() * operand.moment_z() * self.ps()
                + self.rx() * operand.dir_x() * self.rz()
                - self.rx() * operand.dir_y() * self.ps()
                - self.rx() * operand.dir_z() * self.tx()
                - self.ry() * operand.dir_x() * self.s()
                + self.ry() * operand.dir_y() * self.tz()
                + self.ry() * operand.dir_z() * self.ty()
                + self.ry() * operand.moment_x() * self.ps()
                - self.ry() * operand.moment_y() * self.rz()
                - self.ry() * operand.moment_z() * self.ry()
                + self.rz() * operand.dir_x() * self.rx()
                - self.rz() * operand.dir_y() * self.ty()
                + self.rz() * operand.dir_z() * self.tz()
                + self.rz() * operand.moment_x() * self.tx()
                - self.rz() * operand.moment_y() * self.ry()
                + self.rz() * operand.moment_z() * self.rz()
                - self.s() * operand.dir_x() * self.ry()
                + self.s() * operand.dir_y() * self.tx()
                - self.s() * operand.dir_z() * self.ps()
                + self.tx() * operand.dir_x() * self.tz()
                + self.tx() * operand.dir_y() * self.s()
                - self.tx() * operand.dir_z() * self.rx()
                + self.tx() * operand.moment_x() * self.rz()
                + self.tx() * operand.moment_y() * self.ps()
                - self.tx() * operand.moment_z() * self.tx()
                - self.ty() * operand.dir_x() * self.ps()
                - self.ty() * operand.dir_y() * self.rz()
                + self.ty() * operand.dir_z() * self.ry()
                + self.tz() * operand.dir_x() * self.tx()
                + self.tz() * operand.dir_y() * self.ry()
                + self.tz() * operand.dir_z() * self.rz())
                * inv_norm_sq,
            (self.ps() * operand.dir_x() * self.tz() + self.ps() * operand.dir_y() * self.s()
                - self.ps() * operand.dir_z() * self.rx()
                + self.ps() * operand.moment_x() * self.rz()
                + self.ps() * operand.moment_y() * self.ps()
                - self.ps() * operand.moment_z() * self.tx()
                - self.rx() * operand.dir_x() * self.ry()
                + self.rx() * operand.dir_y() * self.tx()
                - self.rx() * operand.dir_z() * self.ps()
                - self.ry() * operand.dir_x() * self.rx()
                + self.ry() * operand.dir_y() * self.ty()
                - self.ry() * operand.dir_z() * self.tz()
                - self.ry() * operand.moment_x() * self.tx()
                + self.ry() * operand.moment_y() * self.ry()
                - self.ry() * operand.moment_z() * self.rz()
                - self.rz() * operand.dir_x() * self.s()
                + self.rz() * operand.dir_y() * self.tz()
                + self.rz() * operand.dir_z() * self.ty()
                + self.rz() * operand.moment_x() * self.ps()
                - self.rz() * operand.moment_y() * self.rz()
                - self.rz() * operand.moment_z() * self.ry()
                - self.s() * operand.dir_x() * self.rz()
                + self.s() * operand.dir_y() * self.ps()
                + self.s() * operand.dir_z() * self.tx()
                + self.tx() * operand.dir_x() * self.ty()
                + self.tx() * operand.dir_y() * self.rx()
                + self.tx() * operand.dir_z() * self.s()
                - self.tx() * operand.moment_x() * self.ry()
                - self.tx() * operand.moment_y() * self.tx()
                - self.tx() * operand.moment_z() * self.ps()
                + self.ty() * operand.dir_x() * self.tx()
                + self.ty() * operand.dir_y() * self.ry()
                + self.ty() * operand.dir_z() * self.rz()
                + self.tz() * operand.dir_x() * self.ps()
                + self.tz() * operand.dir_y() * self.rz()
                - self.tz() * operand.dir_z() * self.ry())
                * inv_norm_sq,
            (self.ps() * operand.dir_x() * self.ps() + self.ps() * operand.dir_y() * self.rz()
                - self.ps() * operand.dir_z() * self.ry()
                - self.ry() * operand.dir_x() * self.ry()
                + self.ry() * operand.dir_y() * self.tx()
                - self.ry() * operand.dir_z() * self.ps()
                - self.rz() * operand.dir_x() * self.rz()
                + self.rz() * operand.dir_y() * self.ps()
                + self.rz() * operand.dir_z() * self.tx()
                + self.tx() * operand.dir_x() * self.tx()
                + self.tx() * operand.dir_y() * self.ry()
                + self.tx() * operand.dir_z() * self.rz())
                * inv_norm_sq,
            (-(self.ps() * operand.dir_x() * self.s())
                + self.ps() * operand.dir_y() * self.tz()
                + self.ps() * operand.dir_z() * self.ty()
                + self.ps() * operand.moment_x() * self.ps()
                - self.ps() * operand.moment_y() * self.rz()
                - self.ps() * operand.moment_z() * self.ry()
                + self.rx() * operand.dir_x() * self.tx()
                + self.rx() * operand.dir_y() * self.ry()
                + self.rx() * operand.dir_z() * self.rz()
                + self.ry() * operand.dir_x() * self.ty()
                + self.ry() * operand.dir_y() * self.rx()
                + self.ry() * operand.dir_z() * self.s()
                - self.ry() * operand.moment_x() * self.ry()
                - self.ry() * operand.moment_y() * self.tx()
                - self.ry() * operand.moment_z() * self.ps()
                - self.rz() * operand.dir_x() * self.tz()
                - self.rz() * operand.dir_y() * self.s()
                + self.rz() * operand.dir_z() * self.rx()
                - self.rz() * operand.moment_x() * self.rz()
                - self.rz() * operand.moment_y() * self.ps()
                + self.rz() * operand.moment_z() * self.tx()
                - self.s() * operand.dir_x() * self.ps()
                - self.s() * operand.dir_y() * self.rz()
                + self.s() * operand.dir_z() * self.ry()
                + self.tx() * operand.dir_x() * self.rx()
                - self.tx() * operand.dir_y() * self.ty()
                + self.tx() * operand.dir_z() * self.tz()
                + self.tx() * operand.moment_x() * self.tx()
                - self.tx() * operand.moment_y() * self.ry()
                + self.tx() * operand.moment_z() * self.rz()
                + self.ty() * operand.dir_x() * self.ry()
                - self.ty() * operand.dir_y() * self.tx()
                + self.ty() * operand.dir_z() * self.ps()
                - self.tz() * operand.dir_x() * self.rz()
                + self.tz() * operand.dir_y() * self.ps()
                + self.tz() * operand.dir_z() * self.tx())
                * inv_norm_sq,
            (-(self.ps() * operand.dir_x() * self.rz())
                + self.ps() * operand.dir_y() * self.ps()
                + self.ps() * operand.dir_z() * self.tx()
                + self.ry() * operand.dir_x() * self.tx()
                + self.ry() * operand.dir_y() * self.ry()
                + self.ry() * operand.dir_z() * self.rz()
                - self.rz() * operand.dir_x() * self.ps()
                - self.rz() * operand.dir_y() * self.rz()
                + self.rz() * operand.dir_z() * self.ry()
                + self.tx() * operand.dir_x() * self.ry()
                - self.tx() * operand.dir_y() * self.tx()
                + self.tx() * operand.dir_z() * self.ps())
                * inv_norm_sq,
            (self.ps() * operand.dir_x() * self.ry() - self.ps() * operand.dir_y() * self.tx()
                + self.ps() * operand.dir_z() * self.ps()
                + self.ry() * operand.dir_x() * self.ps()
                + self.ry() * operand.dir_y() * self.rz()
                - self.ry() * operand.dir_z() * self.ry()
                + self.rz() * operand.dir_x() * self.tx()
                + self.rz() * operand.dir_y() * self.ry()
                + self.rz() * operand.dir_z() * self.rz()
                + self.tx() * operand.dir_x() * self.rz()
                - self.tx() * operand.dir_y() * self.ps()
                - self.tx() * operand.dir_z() * self.tx())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Motor<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Motor<T>) -> Option<Motor<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Motor::new_unchecked(
            (self.ps() * operand.ps() * self.s() - self.ps() * operand.rx() * self.tx()
                + self.ps() * operand.ry() * self.ty()
                - self.ps() * operand.rz() * self.tz()
                + self.ps() * operand.s() * self.ps()
                - self.ps() * operand.tx() * self.rx()
                + self.ps() * operand.ty() * self.ry()
                - self.ps() * operand.tz() * self.rz()
                - self.rx() * operand.ps() * self.tx()
                + self.rx() * operand.ry() * self.rz()
                - self.rx() * operand.rz() * self.ry()
                + self.rx() * operand.tx() * self.ps()
                + self.ry() * operand.ps() * self.ty()
                - self.ry() * operand.rx() * self.rz()
                - self.ry() * operand.ry() * self.s()
                + self.ry() * operand.rz() * self.rx()
                + self.ry() * operand.s() * self.ry()
                - self.ry() * operand.tx() * self.tz()
                - self.ry() * operand.ty() * self.ps()
                + self.ry() * operand.tz() * self.tx()
                - self.rz() * operand.ps() * self.tz()
                + self.rz() * operand.rx() * self.ry()
                - self.rz() * operand.ry() * self.rx()
                - self.rz() * operand.rz() * self.s()
                + self.rz() * operand.s() * self.rz()
                - self.rz() * operand.tx() * self.ty()
                + self.rz() * operand.ty() * self.tx()
                + self.rz() * operand.tz() * self.ps()
                + self.s() * operand.ps() * self.ps()
                + self.s() * operand.ry() * self.ry()
                + self.s() * operand.rz() * self.rz()
                + self.s() * operand.tx() * self.tx()
                - self.tx() * operand.ps() * self.rx()
                + self.tx() * operand.rx() * self.ps()
                + self.tx() * operand.ry() * self.tz()
                + self.tx() * operand.rz() * self.ty()
                + self.tx() * operand.s() * self.tx()
                - self.tx() * operand.tx() * self.s()
                - self.tx() * operand.ty() * self.rz()
                - self.tx() * operand.tz() * self.ry()
                + self.ty() * operand.ps() * self.ry()
                - self.ty() * operand.ry() * self.ps()
                - self.ty() * operand.rz() * self.tx()
                + self.ty() * operand.tx() * self.rz()
                - self.tz() * operand.ps() * self.rz()
                - self.tz() * operand.ry() * self.tx()
                + self.tz() * operand.rz() * self.ps()
                + self.tz() * operand.tx() * self.ry())
                * inv_norm_sq,
            (-(self.ps() * operand.ps() * self.tz()) + self.ps() * operand.rx() * self.ry()
                - self.ps() * operand.ry() * self.rx()
                - self.ps() * operand.rz() * self.s()
                + self.ps() * operand.s() * self.rz()
                - self.ps() * operand.tx() * self.ty()
                + self.ps() * operand.ty() * self.tx()
                + self.ps() * operand.tz() * self.ps()
                + self.rx() * operand.ps() * self.ry()
                - self.rx() * operand.ry() * self.ps()
                - self.rx() * operand.rz() * self.tx()
                + self.rx() * operand.tx() * self.rz()
                - self.ry() * operand.ps() * self.rx()
                + self.ry() * operand.rx() * self.ps()
                + self.ry() * operand.ry() * self.tz()
                + self.ry() * operand.rz() * self.ty()
                + self.ry() * operand.s() * self.tx()
                - self.ry() * operand.tx() * self.s()
                - self.ry() * operand.ty() * self.rz()
                - self.ry() * operand.tz() * self.ry()
                - self.rz() * operand.ps() * self.s()
                + self.rz() * operand.rx() * self.tx()
                - self.rz() * operand.ry() * self.ty()
                + self.rz() * operand.rz() * self.tz()
                - self.rz() * operand.s() * self.ps()
                + self.rz() * operand.tx() * self.rx()
                - self.rz() * operand.ty() * self.ry()
                + self.rz() * operand.tz() * self.rz()
                + self.s() * operand.ps() * self.rz()
                + self.s() * operand.ry() * self.tx()
                - self.s() * operand.rz() * self.ps()
                - self.s() * operand.tx() * self.ry()
                - self.tx() * operand.ps() * self.ty()
                + self.tx() * operand.rx() * self.rz()
                + self.tx() * operand.ry() * self.s()
                - self.tx() * operand.rz() * self.rx()
                - self.tx() * operand.s() * self.ry()
                + self.tx() * operand.tx() * self.tz()
                + self.tx() * operand.ty() * self.ps()
                - self.tx() * operand.tz() * self.tx()
                + self.ty() * operand.ps() * self.tx()
                - self.ty() * operand.ry() * self.rz()
                + self.ty() * operand.rz() * self.ry()
                - self.ty() * operand.tx() * self.ps()
                + self.tz() * operand.ps() * self.ps()
                + self.tz() * operand.ry() * self.ry()
                + self.tz() * operand.rz() * self.rz()
                + self.tz() * operand.tx() * self.tx())
                * inv_norm_sq,
            (-(self.ps() * operand.ps() * self.ty())
                + self.ps() * operand.rx() * self.rz()
                + self.ps() * operand.ry() * self.s()
                - self.ps() * operand.rz() * self.rx()
                - self.ps() * operand.s() * self.ry()
                + self.ps() * operand.tx() * self.tz()
                + self.ps() * operand.ty() * self.ps()
                - self.ps() * operand.tz() * self.tx()
                + self.rx() * operand.ps() * self.rz()
                + self.rx() * operand.ry() * self.tx()
                - self.rx() * operand.rz() * self.ps()
                - self.rx() * operand.tx() * self.ry()
                + self.ry() * operand.ps() * self.s()
                - self.ry() * operand.rx() * self.tx()
                + self.ry() * operand.ry() * self.ty()
                - self.ry() * operand.rz() * self.tz()
                + self.ry() * operand.s() * self.ps()
                - self.ry() * operand.tx() * self.rx()
                + self.ry() * operand.ty() * self.ry()
                - self.ry() * operand.tz() * self.rz()
                - self.rz() * operand.ps() * self.rx()
                + self.rz() * operand.rx() * self.ps()
                + self.rz() * operand.ry() * self.tz()
                + self.rz() * operand.rz() * self.ty()
                + self.rz() * operand.s() * self.tx()
                - self.rz() * operand.tx() * self.s()
                - self.rz() * operand.ty() * self.rz()
                - self.rz() * operand.tz() * self.ry()
                - self.s() * operand.ps() * self.ry()
                + self.s() * operand.ry() * self.ps()
                + self.s() * operand.rz() * self.tx()
                - self.s() * operand.tx() * self.rz()
                + self.tx() * operand.ps() * self.tz()
                - self.tx() * operand.rx() * self.ry()
                + self.tx() * operand.ry() * self.rx()
                + self.tx() * operand.rz() * self.s()
                - self.tx() * operand.s() * self.rz()
                + self.tx() * operand.tx() * self.ty()
                - self.tx() * operand.ty() * self.tx()
                - self.tx() * operand.tz() * self.ps()
                + self.ty() * operand.ps() * self.ps()
                + self.ty() * operand.ry() * self.ry()
                + self.ty() * operand.rz() * self.rz()
                + self.ty() * operand.tx() * self.tx()
                - self.tz() * operand.ps() * self.tx()
                + self.tz() * operand.ry() * self.rz()
                - self.tz() * operand.rz() * self.ry()
                + self.tz() * operand.tx() * self.ps())
                * inv_norm_sq,
            (-(self.ps() * operand.ps() * self.tx()) + self.ps() * operand.ry() * self.rz()
                - self.ps() * operand.rz() * self.ry()
                + self.ps() * operand.tx() * self.ps()
                + self.ry() * operand.ps() * self.rz()
                + self.ry() * operand.ry() * self.tx()
                - self.ry() * operand.rz() * self.ps()
                - self.ry() * operand.tx() * self.ry()
                - self.rz() * operand.ps() * self.ry()
                + self.rz() * operand.ry() * self.ps()
                + self.rz() * operand.rz() * self.tx()
                - self.rz() * operand.tx() * self.rz()
                + self.tx() * operand.ps() * self.ps()
                + self.tx() * operand.ry() * self.ry()
                + self.tx() * operand.rz() * self.rz()
                + self.tx() * operand.tx() * self.tx())
                * inv_norm_sq,
            (-(self.ps() * operand.ps() * self.rx())
                + self.ps() * operand.rx() * self.ps()
                + self.ps() * operand.ry() * self.tz()
                + self.ps() * operand.rz() * self.ty()
                + self.ps() * operand.s() * self.tx()
                - self.ps() * operand.tx() * self.s()
                - self.ps() * operand.ty() * self.rz()
                - self.ps() * operand.tz() * self.ry()
                + self.rx() * operand.ps() * self.ps()
                + self.rx() * operand.ry() * self.ry()
                + self.rx() * operand.rz() * self.rz()
                + self.rx() * operand.tx() * self.tx()
                + self.ry() * operand.ps() * self.tz()
                - self.ry() * operand.rx() * self.ry()
                + self.ry() * operand.ry() * self.rx()
                + self.ry() * operand.rz() * self.s()
                - self.ry() * operand.s() * self.rz()
                + self.ry() * operand.tx() * self.ty()
                - self.ry() * operand.ty() * self.tx()
                - self.ry() * operand.tz() * self.ps()
                + self.rz() * operand.ps() * self.ty()
                - self.rz() * operand.rx() * self.rz()
                - self.rz() * operand.ry() * self.s()
                + self.rz() * operand.rz() * self.rx()
                + self.rz() * operand.s() * self.ry()
                - self.rz() * operand.tx() * self.tz()
                - self.rz() * operand.ty() * self.ps()
                + self.rz() * operand.tz() * self.tx()
                + self.s() * operand.ps() * self.tx()
                - self.s() * operand.ry() * self.rz()
                + self.s() * operand.rz() * self.ry()
                - self.s() * operand.tx() * self.ps()
                - self.tx() * operand.ps() * self.s()
                + self.tx() * operand.rx() * self.tx()
                - self.tx() * operand.ry() * self.ty()
                + self.tx() * operand.rz() * self.tz()
                - self.tx() * operand.s() * self.ps()
                + self.tx() * operand.tx() * self.rx()
                - self.tx() * operand.ty() * self.ry()
                + self.tx() * operand.tz() * self.rz()
                - self.ty() * operand.ps() * self.rz()
                - self.ty() * operand.ry() * self.tx()
                + self.ty() * operand.rz() * self.ps()
                + self.ty() * operand.tx() * self.ry()
                - self.tz() * operand.ps() * self.ry()
                + self.tz() * operand.ry() * self.ps()
                + self.tz() * operand.rz() * self.tx()
                - self.tz() * operand.tx() * self.rz())
                * inv_norm_sq,
            (-(self.ps() * operand.ps() * self.ry())
                + self.ps() * operand.ry() * self.ps()
                + self.ps() * operand.rz() * self.tx()
                - self.ps() * operand.tx() * self.rz()
                + self.ry() * operand.ps() * self.ps()
                + self.ry() * operand.ry() * self.ry()
                + self.ry() * operand.rz() * self.rz()
                + self.ry() * operand.tx() * self.tx()
                + self.rz() * operand.ps() * self.tx()
                - self.rz() * operand.ry() * self.rz()
                + self.rz() * operand.rz() * self.ry()
                - self.rz() * operand.tx() * self.ps()
                - self.tx() * operand.ps() * self.rz()
                - self.tx() * operand.ry() * self.tx()
                + self.tx() * operand.rz() * self.ps()
                + self.tx() * operand.tx() * self.ry())
                * inv_norm_sq,
            (-(self.ps() * operand.ps() * self.rz()) - self.ps() * operand.ry() * self.tx()
                + self.ps() * operand.rz() * self.ps()
                + self.ps() * operand.tx() * self.ry()
                - self.ry() * operand.ps() * self.tx()
                + self.ry() * operand.ry() * self.rz()
                - self.ry() * operand.rz() * self.ry()
                + self.ry() * operand.tx() * self.ps()
                + self.rz() * operand.ps() * self.ps()
                + self.rz() * operand.ry() * self.ry()
                + self.rz() * operand.rz() * self.rz()
                + self.rz() * operand.tx() * self.tx()
                + self.tx() * operand.ps() * self.ry()
                - self.tx() * operand.ry() * self.ps()
                - self.tx() * operand.rz() * self.tx()
                + self.tx() * operand.tx() * self.rz())
                * inv_norm_sq,
            (self.ps() * operand.ps() * self.ps()
                + self.ps() * operand.ry() * self.ry()
                + self.ps() * operand.rz() * self.rz()
                + self.ps() * operand.tx() * self.tx()
                + self.ry() * operand.ps() * self.ry()
                - self.ry() * operand.ry() * self.ps()
                - self.ry() * operand.rz() * self.tx()
                + self.ry() * operand.tx() * self.rz()
                + self.rz() * operand.ps() * self.rz()
                + self.rz() * operand.ry() * self.tx()
                - self.rz() * operand.rz() * self.ps()
                - self.rz() * operand.tx() * self.ry()
                + self.tx() * operand.ps() * self.tx()
                - self.tx() * operand.ry() * self.rz()
                + self.tx() * operand.rz() * self.ry()
                - self.tx() * operand.tx() * self.ps())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Plane<T>> for Motor<T> {
    type Output = Plane<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Plane<T>) -> Option<Plane<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Plane::new_unchecked(
            (self.ps() * operand.dist() * self.ps()
                + self.ps() * operand.nx() * self.rx()
                + self.ps() * operand.ny() * self.ty()
                + self.ps() * operand.nz() * self.tz()
                + self.rx() * operand.nx() * self.ps()
                - self.rx() * operand.ny() * self.rz()
                - self.rx() * operand.nz() * self.ry()
                + self.ry() * operand.dist() * self.ry()
                + self.ry() * operand.nx() * self.tz()
                - self.ry() * operand.ny() * self.s()
                - self.ry() * operand.nz() * self.rx()
                + self.rz() * operand.dist() * self.rz()
                + self.rz() * operand.nx() * self.ty()
                - self.rz() * operand.ny() * self.rx()
                + self.rz() * operand.nz() * self.s()
                + self.s() * operand.nx() * self.tx()
                - self.s() * operand.ny() * self.ry()
                + self.s() * operand.nz() * self.rz()
                + self.tx() * operand.dist() * self.tx()
                + self.tx() * operand.nx() * self.s()
                + self.tx() * operand.ny() * self.tz()
                - self.tx() * operand.nz() * self.ty()
                + self.ty() * operand.nx() * self.rz()
                + self.ty() * operand.ny() * self.ps()
                - self.ty() * operand.nz() * self.tx()
                + self.tz() * operand.nx() * self.ry()
                + self.tz() * operand.ny() * self.tx()
                + self.tz() * operand.nz() * self.ps())
                * inv_norm_sq,
            (self.ps() * operand.nx() * self.ry()
                + self.ps() * operand.ny() * self.tx()
                + self.ps() * operand.nz() * self.ps()
                + self.ry() * operand.nx() * self.ps()
                - self.ry() * operand.ny() * self.rz()
                - self.ry() * operand.nz() * self.ry()
                + self.rz() * operand.nx() * self.tx()
                - self.rz() * operand.ny() * self.ry()
                + self.rz() * operand.nz() * self.rz()
                + self.tx() * operand.nx() * self.rz()
                + self.tx() * operand.ny() * self.ps()
                - self.tx() * operand.nz() * self.tx())
                * inv_norm_sq,
            (self.ps() * operand.nx() * self.rz() + self.ps() * operand.ny() * self.ps()
                - self.ps() * operand.nz() * self.tx()
                - self.ry() * operand.nx() * self.tx()
                + self.ry() * operand.ny() * self.ry()
                - self.ry() * operand.nz() * self.rz()
                + self.rz() * operand.nx() * self.ps()
                - self.rz() * operand.ny() * self.rz()
                - self.rz() * operand.nz() * self.ry()
                - self.tx() * operand.nx() * self.ry()
                - self.tx() * operand.ny() * self.tx()
                - self.tx() * operand.nz() * self.ps())
                * inv_norm_sq,
            (self.ps() * operand.nx() * self.ps()
                - self.ps() * operand.ny() * self.rz()
                - self.ps() * operand.nz() * self.ry()
                - self.ry() * operand.nx() * self.ry()
                - self.ry() * operand.ny() * self.tx()
                - self.ry() * operand.nz() * self.ps()
                - self.rz() * operand.nx() * self.rz()
                - self.rz() * operand.ny() * self.ps()
                + self.rz() * operand.nz() * self.tx()
                + self.tx() * operand.nx() * self.tx()
                - self.tx() * operand.ny() * self.ry()
                + self.tx() * operand.nz() * self.rz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Point<T>> for Motor<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (self.ps() * operand.w() * self.rx()
                + self.ps() * operand.x() * self.ps()
                + self.ps() * operand.y() * self.rz()
                - self.ps() * operand.z() * self.ry()
                + self.rx() * operand.w() * self.ps()
                - self.ry() * operand.w() * self.tz()
                - self.ry() * operand.x() * self.ry()
                + self.ry() * operand.y() * self.tx()
                - self.ry() * operand.z() * self.ps()
                - self.rz() * operand.w() * self.ty()
                - self.rz() * operand.x() * self.rz()
                + self.rz() * operand.y() * self.ps()
                + self.rz() * operand.z() * self.tx()
                + self.s() * operand.w() * self.tx()
                + self.tx() * operand.w() * self.s()
                + self.tx() * operand.x() * self.tx()
                + self.tx() * operand.y() * self.ry()
                + self.tx() * operand.z() * self.rz()
                - self.ty() * operand.w() * self.rz()
                - self.tz() * operand.w() * self.ry())
                * inv_norm_sq,
            (-(self.ps() * operand.w() * self.ty()) - self.ps() * operand.x() * self.rz()
                + self.ps() * operand.y() * self.ps()
                + self.ps() * operand.z() * self.tx()
                - self.rx() * operand.w() * self.rz()
                + self.ry() * operand.w() * self.s()
                + self.ry() * operand.x() * self.tx()
                + self.ry() * operand.y() * self.ry()
                + self.ry() * operand.z() * self.rz()
                - self.rz() * operand.w() * self.rx()
                - self.rz() * operand.x() * self.ps()
                - self.rz() * operand.y() * self.rz()
                + self.rz() * operand.z() * self.ry()
                + self.s() * operand.w() * self.ry()
                + self.tx() * operand.w() * self.tz()
                + self.tx() * operand.x() * self.ry()
                - self.tx() * operand.y() * self.tx()
                + self.tx() * operand.z() * self.ps()
                - self.ty() * operand.w() * self.ps()
                + self.tz() * operand.w() * self.tx())
                * inv_norm_sq,
            (self.ps() * operand.w() * self.tz() + self.ps() * operand.x() * self.ry()
                - self.ps() * operand.y() * self.tx()
                + self.ps() * operand.z() * self.ps()
                + self.rx() * operand.w() * self.ry()
                + self.ry() * operand.w() * self.rx()
                + self.ry() * operand.x() * self.ps()
                + self.ry() * operand.y() * self.rz()
                - self.ry() * operand.z() * self.ry()
                + self.rz() * operand.w() * self.s()
                + self.rz() * operand.x() * self.tx()
                + self.rz() * operand.y() * self.ry()
                + self.rz() * operand.z() * self.rz()
                + self.s() * operand.w() * self.rz()
                + self.tx() * operand.w() * self.ty()
                + self.tx() * operand.x() * self.rz()
                - self.tx() * operand.y() * self.ps()
                - self.tx() * operand.z() * self.tx()
                + self.ty() * operand.w() * self.tx()
                + self.tz() * operand.w() * self.ps())
                * inv_norm_sq,
            (self.ps() * operand.w() * self.ps()
                + self.ry() * operand.w() * self.ry()
                + self.rz() * operand.w() * self.rz()
                + self.tx() * operand.w() * self.tx())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Quadvector<T>> for Motor<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Quadvector<T>) -> Option<Quadvector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Quadvector::new_unchecked(
            (self.ps() * operand.ps() * self.ps()
                + self.ry() * operand.ps() * self.ry()
                + self.rz() * operand.ps() * self.rz()
                + self.tx() * operand.ps() * self.tx())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Motor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.ps() * operand.s() * self.ps()
                + self.ry() * operand.s() * self.ry()
                + self.rz() * operand.s() * self.rz()
                + self.tx() * operand.s() * self.tx())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Flector<T>> for Plane<T> {
    type Output = Flector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Flector<T>) -> Option<Flector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Flector::new_unchecked(
            (self.dist() * operand.ny() * self.nz()
                - self.dist() * operand.nz() * self.ny()
                - self.dist() * operand.pw() * self.nx()
                - self.nx() * operand.pw() * self.dist()
                + self.nx() * operand.px() * self.nx()
                - self.nx() * operand.py() * self.ny()
                + self.nx() * operand.pz() * self.nz()
                - self.ny() * operand.dist() * self.nz()
                + self.ny() * operand.nz() * self.dist()
                - self.ny() * operand.px() * self.ny()
                - self.ny() * operand.py() * self.nx()
                + self.nz() * operand.dist() * self.ny()
                - self.nz() * operand.ny() * self.dist()
                - self.nz() * operand.px() * self.nz()
                + self.nz() * operand.pz() * self.nx())
                * inv_norm_sq,
            (self.dist() * operand.nx() * self.nz() - self.dist() * operand.nz() * self.nx()
                + self.dist() * operand.pw() * self.ny()
                - self.nx() * operand.dist() * self.nz()
                + self.nx() * operand.nz() * self.dist()
                - self.nx() * operand.px() * self.ny()
                - self.nx() * operand.py() * self.nx()
                + self.ny() * operand.pw() * self.dist()
                - self.ny() * operand.px() * self.nx()
                + self.ny() * operand.py() * self.ny()
                - self.ny() * operand.pz() * self.nz()
                + self.nz() * operand.dist() * self.nx()
                - self.nz() * operand.nx() * self.dist()
                - self.nz() * operand.py() * self.nz()
                - self.nz() * operand.pz() * self.ny())
                * inv_norm_sq,
            (self.dist() * operand.nx() * self.ny()
                - self.dist() * operand.ny() * self.nx()
                - self.dist() * operand.pw() * self.nz()
                - self.nx() * operand.dist() * self.ny()
                + self.nx() * operand.ny() * self.dist()
                + self.nx() * operand.px() * self.nz()
                - self.nx() * operand.pz() * self.nx()
                + self.ny() * operand.dist() * self.nx()
                - self.ny() * operand.nx() * self.dist()
                - self.ny() * operand.py() * self.nz()
                - self.ny() * operand.pz() * self.ny()
                - self.nz() * operand.pw() * self.dist()
                + self.nz() * operand.px() * self.nx()
                - self.nz() * operand.py() * self.ny()
                + self.nz() * operand.pz() * self.nz())
                * inv_norm_sq,
            (self.nx() * operand.ny() * self.nz()
                - self.nx() * operand.nz() * self.ny()
                - self.nx() * operand.pw() * self.nx()
                - self.ny() * operand.nx() * self.nz()
                + self.ny() * operand.nz() * self.nx()
                - self.ny() * operand.pw() * self.ny()
                + self.nz() * operand.nx() * self.ny()
                - self.nz() * operand.ny() * self.nx()
                - self.nz() * operand.pw() * self.nz())
                * inv_norm_sq,
            (-(self.dist() * operand.nx() * self.nx())
                - self.dist() * operand.ny() * self.ny()
                - self.dist() * operand.nz() * self.nz()
                + self.nx() * operand.dist() * self.nx()
                - self.nx() * operand.nx() * self.dist()
                - self.nx() * operand.py() * self.nz()
                - self.nx() * operand.pz() * self.ny()
                + self.ny() * operand.dist() * self.ny()
                - self.ny() * operand.ny() * self.dist()
                - self.ny() * operand.px() * self.nz()
                + self.ny() * operand.pz() * self.nx()
                + self.nz() * operand.dist() * self.nz()
                - self.nz() * operand.nz() * self.dist()
                + self.nz() * operand.px() * self.ny()
                + self.nz() * operand.py() * self.nx())
                * inv_norm_sq,
            (-(self.nx() * operand.nx() * self.nz()) + self.nx() * operand.nz() * self.nx()
                - self.nx() * operand.pw() * self.ny()
                - self.ny() * operand.ny() * self.nz()
                + self.ny() * operand.nz() * self.ny()
                + self.ny() * operand.pw() * self.nx()
                - self.nz() * operand.nx() * self.nx()
                - self.nz() * operand.ny() * self.ny()
                - self.nz() * operand.nz() * self.nz())
                * inv_norm_sq,
            (-(self.nx() * operand.nx() * self.ny())
                + self.nx() * operand.ny() * self.nx()
                + self.nx() * operand.pw() * self.nz()
                - self.ny() * operand.nx() * self.nx()
                - self.ny() * operand.ny() * self.ny()
                - self.ny() * operand.nz() * self.nz()
                + self.nz() * operand.ny() * self.nz()
                - self.nz() * operand.nz() * self.ny()
                - self.nz() * operand.pw() * self.nx())
                * inv_norm_sq,
            (-(self.nx() * operand.nx() * self.nx())
                - self.nx() * operand.ny() * self.ny()
                - self.nx() * operand.nz() * self.nz()
                + self.ny() * operand.nx() * self.ny()
                - self.ny() * operand.ny() * self.nx()
                - self.ny() * operand.pw() * self.nz()
                + self.nz() * operand.nx() * self.nz()
                - self.nz() * operand.nz() * self.nx()
                + self.nz() * operand.pw() * self.ny())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Line<T>> for Plane<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (-(self.dist() * operand.dir_x() * self.ny())
                - self.dist() * operand.dir_y() * self.nx()
                - self.nx() * operand.dir_y() * self.dist()
                + self.nx() * operand.moment_x() * self.nz()
                - self.nx() * operand.moment_z() * self.nx()
                - self.ny() * operand.dir_x() * self.dist()
                + self.ny() * operand.moment_y() * self.nz()
                - self.ny() * operand.moment_z() * self.ny()
                + self.nz() * operand.moment_x() * self.nx()
                + self.nz() * operand.moment_y() * self.ny()
                + self.nz() * operand.moment_z() * self.nz())
                * inv_norm_sq,
            (self.dist() * operand.dir_x() * self.nz()
                - self.dist() * operand.dir_z() * self.nx()
                - self.nx() * operand.dir_z() * self.dist()
                + self.nx() * operand.moment_x() * self.ny()
                - self.nx() * operand.moment_y() * self.nx()
                + self.ny() * operand.moment_x() * self.nx()
                + self.ny() * operand.moment_y() * self.ny()
                + self.ny() * operand.moment_z() * self.nz()
                + self.nz() * operand.dir_x() * self.dist()
                - self.nz() * operand.moment_y() * self.nz()
                + self.nz() * operand.moment_z() * self.ny())
                * inv_norm_sq,
            (-(self.nx() * operand.dir_x() * self.nx()) + self.nx() * operand.dir_y() * self.ny()
                - self.nx() * operand.dir_z() * self.nz()
                + self.ny() * operand.dir_x() * self.ny()
                + self.ny() * operand.dir_y() * self.nx()
                + self.nz() * operand.dir_x() * self.nz()
                - self.nz() * operand.dir_z() * self.nx())
                * inv_norm_sq,
            (self.dist() * operand.dir_y() * self.nz()
                + self.dist() * operand.dir_z() * self.ny()
                + self.nx() * operand.moment_x() * self.nx()
                + self.nx() * operand.moment_y() * self.ny()
                + self.nx() * operand.moment_z() * self.nz()
                + self.ny() * operand.dir_z() * self.dist()
                - self.ny() * operand.moment_x() * self.ny()
                + self.ny() * operand.moment_y() * self.nx()
                + self.nz() * operand.dir_y() * self.dist()
                - self.nz() * operand.moment_x() * self.nz()
                + self.nz() * operand.moment_z() * self.nx())
                * inv_norm_sq,
            (self.nx() * operand.dir_x() * self.ny()
                + self.nx() * operand.dir_y() * self.nx()
                + self.ny() * operand.dir_x() * self.nx()
                - self.ny() * operand.dir_y() * self.ny()
                + self.ny() * operand.dir_z() * self.nz()
                + self.nz() * operand.dir_y() * self.nz()
                + self.nz() * operand.dir_z() * self.ny())
                * inv_norm_sq,
            (-(self.nx() * operand.dir_x() * self.nz())
                + self.nx() * operand.dir_z() * self.nx()
                + self.ny() * operand.dir_y() * self.nz()
                + self.ny() * operand.dir_z() * self.ny()
                - self.nz() * operand.dir_x() * self.nx()
                + self.nz() * operand.dir_y() * self.ny()
                - self.nz() * operand.dir_z() * self.nz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Motor<T>> for Plane<T> {
    type Output = Motor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Motor<T>) -> Option<Motor<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Motor::new_unchecked(
            (self.dist() * operand.ry() * self.ny()
                - self.dist() * operand.rz() * self.nz()
                - self.dist() * operand.tx() * self.nx()
                + self.nx() * operand.s() * self.nx()
                + self.nx() * operand.tx() * self.dist()
                - self.nx() * operand.ty() * self.nz()
                + self.nx() * operand.tz() * self.ny()
                + self.ny() * operand.rx() * self.nz()
                - self.ny() * operand.ry() * self.dist()
                + self.ny() * operand.s() * self.ny()
                - self.ny() * operand.tz() * self.nx()
                - self.nz() * operand.rx() * self.ny()
                + self.nz() * operand.rz() * self.dist()
                + self.nz() * operand.s() * self.nz()
                + self.nz() * operand.ty() * self.nx())
                * inv_norm_sq,
            (-(self.dist() * operand.ps() * self.nz())
                - self.dist() * operand.ry() * self.nx()
                - self.dist() * operand.tx() * self.ny()
                + self.nx() * operand.rx() * self.nz()
                - self.nx() * operand.ry() * self.dist()
                + self.nx() * operand.s() * self.ny()
                - self.nx() * operand.tz() * self.nx()
                - self.ny() * operand.s() * self.nx()
                - self.ny() * operand.tx() * self.dist()
                + self.ny() * operand.ty() * self.nz()
                - self.ny() * operand.tz() * self.ny()
                + self.nz() * operand.ps() * self.dist()
                + self.nz() * operand.rx() * self.nx()
                + self.nz() * operand.ty() * self.ny()
                + self.nz() * operand.tz() * self.nz())
                * inv_norm_sq,
            (-(self.dist() * operand.ps() * self.ny()) - self.dist() * operand.rz() * self.nx()
                + self.dist() * operand.tx() * self.nz()
                + self.nx() * operand.rx() * self.ny()
                - self.nx() * operand.rz() * self.dist()
                - self.nx() * operand.s() * self.nz()
                - self.nx() * operand.ty() * self.nx()
                + self.ny() * operand.ps() * self.dist()
                + self.ny() * operand.rx() * self.nx()
                + self.ny() * operand.ty() * self.ny()
                + self.ny() * operand.tz() * self.nz()
                + self.nz() * operand.s() * self.nx()
                + self.nz() * operand.tx() * self.dist()
                - self.nz() * operand.ty() * self.nz()
                + self.nz() * operand.tz() * self.ny())
                * inv_norm_sq,
            (self.nx() * operand.ry() * self.ny()
                - self.nx() * operand.rz() * self.nz()
                - self.nx() * operand.tx() * self.nx()
                + self.ny() * operand.ps() * self.nz()
                + self.ny() * operand.ry() * self.nx()
                + self.ny() * operand.tx() * self.ny()
                - self.nz() * operand.ps() * self.ny()
                - self.nz() * operand.rz() * self.nx()
                + self.nz() * operand.tx() * self.nz())
                * inv_norm_sq,
            (-(self.dist() * operand.ps() * self.nx())
                + self.dist() * operand.ry() * self.nz()
                + self.dist() * operand.rz() * self.ny()
                + self.nx() * operand.ps() * self.dist()
                + self.nx() * operand.rx() * self.nx()
                + self.nx() * operand.ty() * self.ny()
                + self.nx() * operand.tz() * self.nz()
                - self.ny() * operand.rx() * self.ny()
                + self.ny() * operand.rz() * self.dist()
                + self.ny() * operand.s() * self.nz()
                + self.ny() * operand.ty() * self.nx()
                - self.nz() * operand.rx() * self.nz()
                + self.nz() * operand.ry() * self.dist()
                - self.nz() * operand.s() * self.ny()
                + self.nz() * operand.tz() * self.nx())
                * inv_norm_sq,
            (self.nx() * operand.ps() * self.nz()
                + self.nx() * operand.ry() * self.nx()
                + self.nx() * operand.tx() * self.ny()
                - self.ny() * operand.ry() * self.ny()
                + self.ny() * operand.rz() * self.nz()
                + self.ny() * operand.tx() * self.nx()
                - self.nz() * operand.ps() * self.nx()
                + self.nz() * operand.ry() * self.nz()
                + self.nz() * operand.rz() * self.ny())
                * inv_norm_sq,
            (self.nx() * operand.ps() * self.ny() + self.nx() * operand.rz() * self.nx()
                - self.nx() * operand.tx() * self.nz()
                - self.ny() * operand.ps() * self.nx()
                + self.ny() * operand.ry() * self.nz()
                + self.ny() * operand.rz() * self.ny()
                + self.nz() * operand.ry() * self.ny()
                - self.nz() * operand.rz() * self.nz()
                - self.nz() * operand.tx() * self.nx())
                * inv_norm_sq,
            (-(self.nx() * operand.ps() * self.nx())
                + self.nx() * operand.ry() * self.nz()
                + self.nx() * operand.rz() * self.ny()
                - self.ny() * operand.ps() * self.ny()
                - self.ny() * operand.rz() * self.nx()
                + self.ny() * operand.tx() * self.nz()
                - self.nz() * operand.ps() * self.nz()
                - self.nz() * operand.ry() * self.nx()
                - self.nz() * operand.tx() * self.ny())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Plane<T>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Plane<T>) -> Option<Plane<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Plane::new_unchecked(
            (-(self.dist() * operand.nx() * self.nx())
                - self.dist() * operand.ny() * self.ny()
                - self.dist() * operand.nz() * self.nz()
                + self.nx() * operand.dist() * self.nx()
                - self.nx() * operand.nx() * self.dist()
                + self.ny() * operand.dist() * self.ny()
                - self.ny() * operand.ny() * self.dist()
                + self.nz() * operand.dist() * self.nz()
                - self.nz() * operand.nz() * self.dist())
                * inv_norm_sq,
            (-(self.nx() * operand.nx() * self.nz()) + self.nx() * operand.nz() * self.nx()
                - self.ny() * operand.ny() * self.nz()
                + self.ny() * operand.nz() * self.ny()
                - self.nz() * operand.nx() * self.nx()
                - self.nz() * operand.ny() * self.ny()
                - self.nz() * operand.nz() * self.nz())
                * inv_norm_sq,
            (-(self.nx() * operand.nx() * self.ny()) + self.nx() * operand.ny() * self.nx()
                - self.ny() * operand.nx() * self.nx()
                - self.ny() * operand.ny() * self.ny()
                - self.ny() * operand.nz() * self.nz()
                + self.nz() * operand.ny() * self.nz()
                - self.nz() * operand.nz() * self.ny())
                * inv_norm_sq,
            (-(self.nx() * operand.nx() * self.nx())
                - self.nx() * operand.ny() * self.ny()
                - self.nx() * operand.nz() * self.nz()
                + self.ny() * operand.nx() * self.ny()
                - self.ny() * operand.ny() * self.nx()
                + self.nz() * operand.nx() * self.nz()
                - self.nz() * operand.nz() * self.nx())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Point<T>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (-(self.dist() * operand.w() * self.nx()) - self.nx() * operand.w() * self.dist()
                + self.nx() * operand.x() * self.nx()
                - self.nx() * operand.y() * self.ny()
                + self.nx() * operand.z() * self.nz()
                - self.ny() * operand.x() * self.ny()
                - self.ny() * operand.y() * self.nx()
                - self.nz() * operand.x() * self.nz()
                + self.nz() * operand.z() * self.nx())
                * inv_norm_sq,
            (self.dist() * operand.w() * self.ny()
                - self.nx() * operand.x() * self.ny()
                - self.nx() * operand.y() * self.nx()
                + self.ny() * operand.w() * self.dist()
                - self.ny() * operand.x() * self.nx()
                + self.ny() * operand.y() * self.ny()
                - self.ny() * operand.z() * self.nz()
                - self.nz() * operand.y() * self.nz()
                - self.nz() * operand.z() * self.ny())
                * inv_norm_sq,
            (-(self.dist() * operand.w() * self.nz()) + self.nx() * operand.x() * self.nz()
                - self.nx() * operand.z() * self.nx()
                - self.ny() * operand.y() * self.nz()
                - self.ny() * operand.z() * self.ny()
                - self.nz() * operand.w() * self.dist()
                + self.nz() * operand.x() * self.nx()
                - self.nz() * operand.y() * self.ny()
                + self.nz() * operand.z() * self.nz())
                * inv_norm_sq,
            (-(self.nx() * operand.w() * self.nx())
                - self.ny() * operand.w() * self.ny()
                - self.nz() * operand.w() * self.nz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Quadvector<T>> for Plane<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Quadvector<T>) -> Option<Quadvector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Quadvector::new_unchecked(
            (-(self.nx() * operand.ps() * self.nx())
                - self.ny() * operand.ps() * self.ny()
                - self.nz() * operand.ps() * self.nz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Plane<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.nx() * operand.s() * self.nx()
                + self.ny() * operand.s() * self.ny()
                + self.nz() * operand.s() * self.nz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Flector<T>> for Point<T> {
    type Output = Flector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Flector<T>) -> Option<Flector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Flector::new_unchecked(
            (self.w() * operand.ny() * self.z() + self.w() * operand.nz() * self.y()
                - self.w() * operand.pw() * self.x()
                + self.w() * operand.px() * self.w()
                - self.x() * operand.pw() * self.w()
                - self.y() * operand.nz() * self.w()
                - self.z() * operand.ny() * self.w())
                * inv_norm_sq,
            (self.w() * operand.nx() * self.z()
                - self.w() * operand.nz() * self.x()
                - self.w() * operand.pw() * self.y()
                + self.w() * operand.py() * self.w()
                + self.x() * operand.nz() * self.w()
                - self.y() * operand.pw() * self.w()
                - self.z() * operand.nx() * self.w())
                * inv_norm_sq,
            (-(self.w() * operand.nx() * self.y())
                - self.w() * operand.ny() * self.x()
                - self.w() * operand.pw() * self.z()
                + self.w() * operand.pz() * self.w()
                + self.x() * operand.ny() * self.w()
                + self.y() * operand.nx() * self.w()
                - self.z() * operand.pw() * self.w())
                * inv_norm_sq,
            (-(self.w() * operand.pw() * self.w())) * inv_norm_sq,
            (self.w() * operand.dist() * self.w() - self.w() * operand.nx() * self.x()
                + self.w() * operand.ny() * self.y()
                - self.w() * operand.nz() * self.z()
                - self.x() * operand.nx() * self.w()
                + self.y() * operand.ny() * self.w()
                - self.z() * operand.nz() * self.w())
                * inv_norm_sq,
            (-(self.w() * operand.nz() * self.w())) * inv_norm_sq,
            (-(self.w() * operand.ny() * self.w())) * inv_norm_sq,
            (-(self.w() * operand.nx() * self.w())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Line<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (-(self.w() * operand.dir_x() * self.y())
                + self.w() * operand.dir_y() * self.x()
                + self.w() * operand.moment_z() * self.w()
                + self.x() * operand.dir_y() * self.w()
                - self.y() * operand.dir_x() * self.w())
                * inv_norm_sq,
            (-(self.w() * operand.dir_x() * self.z())
                + self.w() * operand.dir_z() * self.x()
                + self.w() * operand.moment_y() * self.w()
                + self.x() * operand.dir_z() * self.w()
                - self.z() * operand.dir_x() * self.w())
                * inv_norm_sq,
            (-(self.w() * operand.dir_x() * self.w())) * inv_norm_sq,
            (-(self.w() * operand.dir_y() * self.z())
                + self.w() * operand.dir_z() * self.y()
                + self.w() * operand.moment_x() * self.w()
                + self.y() * operand.dir_z() * self.w()
                - self.z() * operand.dir_y() * self.w())
                * inv_norm_sq,
            (-(self.w() * operand.dir_y() * self.w())) * inv_norm_sq,
            (-(self.w() * operand.dir_z() * self.w())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Motor<T>> for Point<T> {
    type Output = Motor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Motor<T>) -> Option<Motor<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Motor::new_unchecked(
            (self.w() * operand.ry() * self.y()
                + self.w() * operand.rz() * self.z()
                + self.w() * operand.s() * self.w()
                + self.w() * operand.tx() * self.x()
                - self.x() * operand.tx() * self.w()
                - self.y() * operand.ry() * self.w()
                - self.z() * operand.rz() * self.w())
                * inv_norm_sq,
            (self.w() * operand.ps() * self.z() + self.w() * operand.ry() * self.x()
                - self.w() * operand.tx() * self.y()
                + self.w() * operand.tz() * self.w()
                + self.x() * operand.ry() * self.w()
                - self.y() * operand.tx() * self.w()
                - self.z() * operand.ps() * self.w())
                * inv_norm_sq,
            (-(self.w() * operand.ps() * self.y()) + self.w() * operand.rz() * self.x()
                - self.w() * operand.tx() * self.z()
                + self.w() * operand.ty() * self.w()
                + self.x() * operand.rz() * self.w()
                + self.y() * operand.ps() * self.w()
                - self.z() * operand.tx() * self.w())
                * inv_norm_sq,
            (-(self.w() * operand.tx() * self.w())) * inv_norm_sq,
            (self.w() * operand.ps() * self.x() + self.w() * operand.rx() * self.w()
                - self.w() * operand.ry() * self.z()
                + self.w() * operand.rz() * self.y()
                - self.x() * operand.ps() * self.w()
                + self.y() * operand.rz() * self.w()
                - self.z() * operand.ry() * self.w())
                * inv_norm_sq,
            (-(self.w() * operand.ry() * self.w())) * inv_norm_sq,
            (-(self.w() * operand.rz() * self.w())) * inv_norm_sq,
            (-(self.w() * operand.ps() * self.w())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Plane<T>> for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Plane<T>) -> Option<Plane<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Plane::new_unchecked(
            (self.w() * operand.dist() * self.w() - self.w() * operand.nx() * self.x()
                + self.w() * operand.ny() * self.y()
                - self.w() * operand.nz() * self.z()
                - self.x() * operand.nx() * self.w()
                + self.y() * operand.ny() * self.w()
                - self.z() * operand.nz() * self.w())
                * inv_norm_sq,
            (-(self.w() * operand.nz() * self.w())) * inv_norm_sq,
            (-(self.w() * operand.ny() * self.w())) * inv_norm_sq,
            (-(self.w() * operand.nx() * self.w())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Point<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (-(self.w() * operand.w() * self.x()) + self.w() * operand.x() * self.w()
                - self.x() * operand.w() * self.w())
                * inv_norm_sq,
            (-(self.w() * operand.w() * self.y()) + self.w() * operand.y() * self.w()
                - self.y() * operand.w() * self.w())
                * inv_norm_sq,
            (-(self.w() * operand.w() * self.z()) + self.w() * operand.z() * self.w()
                - self.z() * operand.w() * self.w())
                * inv_norm_sq,
            (-(self.w() * operand.w() * self.w())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Quadvector<T>> for Point<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Quadvector<T>) -> Option<Quadvector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Quadvector::new_unchecked(
            (-(self.w() * operand.ps() * self.w())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.w() * operand.s() * self.w()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Flector<T>> for Quadvector<T> {
    type Output = Flector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Flector<T>) -> Option<Flector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Flector::new_unchecked(
            (self.ps() * operand.px() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.py() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.pz() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.pw() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.dist() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.nz() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.ny() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.nx() * self.ps()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Line<T>> for Quadvector<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (self.ps() * operand.moment_z() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.moment_y() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.dir_x() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.moment_x() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.dir_y() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.dir_z() * self.ps()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Motor<T>> for Quadvector<T> {
    type Output = Motor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Motor<T>) -> Option<Motor<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Motor::new_unchecked(
            (self.ps() * operand.s() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.tz() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.ty() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.tx() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.rx() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.ry() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.rz() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.ps() * self.ps()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Plane<T>> for Quadvector<T> {
    type Output = Plane<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Plane<T>) -> Option<Plane<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Plane::new_unchecked(
            (self.ps() * operand.dist() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.nz() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.ny() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.nx() * self.ps()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Point<T>> for Quadvector<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (self.ps() * operand.x() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.y() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.z() * self.ps()) * inv_norm_sq,
            (self.ps() * operand.w() * self.ps()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Quadvector<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Quadvector<T>) -> Option<Quadvector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Quadvector::new_unchecked(
            (self.ps() * operand.ps() * self.ps()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Quadvector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.ps() * operand.s() * self.ps()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Flector<T>> for Scalar<T> {
    type Output = Flector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Flector<T>) -> Option<Flector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Flector::new_unchecked(
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Motor<T>> for Scalar<T> {
    type Output = Motor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Motor<T>) -> Option<Motor<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Motor::new_unchecked(
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Plane<T>> for Scalar<T> {
    type Output = Plane<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Plane<T>) -> Option<Plane<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Plane::new_unchecked(
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Quadvector<T>> for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Quadvector<T>) -> Option<Quadvector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Quadvector::new_unchecked((T::zero()) * inv_norm_sq))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked((T::zero()) * inv_norm_sq))
    }
}
impl<T: Float> Versor<Flector<T>> for Flector<T> {
    type Output = Motor<T>;
    #[inline]
    fn compose(&self, other: &Flector<T>) -> Motor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Line<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn compose(&self, other: &Line<T>) -> Flector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Motor<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn compose(&self, other: &Motor<T>) -> Flector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Plane<T>> for Flector<T> {
    type Output = Motor<T>;
    #[inline]
    fn compose(&self, other: &Plane<T>) -> Motor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Point<T>> for Flector<T> {
    type Output = Motor<T>;
    #[inline]
    fn compose(&self, other: &Point<T>) -> Motor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Quadvector<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn compose(&self, other: &Quadvector<T>) -> Flector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Flector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Flector<T>> for Line<T> {
    type Output = Flector<T>;
    #[inline]
    fn compose(&self, other: &Flector<T>) -> Flector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Line<T>> for Line<T> {
    type Output = Motor<T>;
    #[inline]
    fn compose(&self, other: &Line<T>) -> Motor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Motor<T>> for Line<T> {
    type Output = Motor<T>;
    #[inline]
    fn compose(&self, other: &Motor<T>) -> Motor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Plane<T>> for Line<T> {
    type Output = Flector<T>;
    #[inline]
    fn compose(&self, other: &Plane<T>) -> Flector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Point<T>> for Line<T> {
    type Output = Flector<T>;
    #[inline]
    fn compose(&self, other: &Point<T>) -> Flector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Quadvector<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn compose(&self, other: &Quadvector<T>) -> Line<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Line<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Flector<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn compose(&self, other: &Flector<T>) -> Flector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Line<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn compose(&self, other: &Line<T>) -> Motor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Motor<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn compose(&self, other: &Motor<T>) -> Motor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Plane<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn compose(&self, other: &Plane<T>) -> Flector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Point<T>> for Motor<T> {
    type Output = Flector<T>;
    #[inline]
    fn compose(&self, other: &Point<T>) -> Flector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Motor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Flector<T>> for Plane<T> {
    type Output = Motor<T>;
    #[inline]
    fn compose(&self, other: &Flector<T>) -> Motor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Line<T>> for Plane<T> {
    type Output = Flector<T>;
    #[inline]
    fn compose(&self, other: &Line<T>) -> Flector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Motor<T>> for Plane<T> {
    type Output = Flector<T>;
    #[inline]
    fn compose(&self, other: &Motor<T>) -> Flector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Quadvector<T>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn compose(&self, other: &Quadvector<T>) -> Point<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Plane<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Flector<T>> for Point<T> {
    type Output = Motor<T>;
    #[inline]
    fn compose(&self, other: &Flector<T>) -> Motor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Line<T>> for Point<T> {
    type Output = Flector<T>;
    #[inline]
    fn compose(&self, other: &Line<T>) -> Flector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Motor<T>> for Point<T> {
    type Output = Flector<T>;
    #[inline]
    fn compose(&self, other: &Motor<T>) -> Flector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Quadvector<T>> for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn compose(&self, other: &Quadvector<T>) -> Plane<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Point<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Flector<T>> for Quadvector<T> {
    type Output = Flector<T>;
    #[inline]
    fn compose(&self, other: &Flector<T>) -> Flector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Line<T>> for Quadvector<T> {
    type Output = Line<T>;
    #[inline]
    fn compose(&self, other: &Line<T>) -> Line<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Plane<T>> for Quadvector<T> {
    type Output = Point<T>;
    #[inline]
    fn compose(&self, other: &Plane<T>) -> Point<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Point<T>> for Quadvector<T> {
    type Output = Plane<T>;
    #[inline]
    fn compose(&self, other: &Point<T>) -> Plane<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Quadvector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Flector<T>> for Scalar<T> {
    type Output = Flector<T>;
    #[inline]
    fn compose(&self, other: &Flector<T>) -> Flector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn compose(&self, other: &Line<T>) -> Line<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Motor<T>> for Scalar<T> {
    type Output = Motor<T>;
    #[inline]
    fn compose(&self, other: &Motor<T>) -> Motor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Plane<T>> for Scalar<T> {
    type Output = Plane<T>;
    #[inline]
    fn compose(&self, other: &Plane<T>) -> Plane<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn compose(&self, other: &Point<T>) -> Point<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Quadvector<T>> for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn compose(&self, other: &Quadvector<T>) -> Quadvector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Scalar<T> {
        *self * *other
    }
}
impl<T: Float> ScalarProduct<Line<T>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Line<T>) -> T {
        -(self.moment_z() * rhs.moment_z())
            - self.moment_y() * rhs.moment_y()
            - self.moment_x() * rhs.moment_x()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Line<T>> for Unitized<Line<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Line<T>) -> T {
        -(rhs.moment_x() * self.as_inner().moment_x())
            + -(rhs.moment_y() * self.as_inner().moment_y())
            + -(rhs.moment_z() * self.as_inner().moment_z())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unitized<Line<T>>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unitized<Line<T>>) -> T {
        -(rhs.as_inner().moment_x() * self.moment_x())
            + -(rhs.as_inner().moment_y() * self.moment_y())
            + -(rhs.as_inner().moment_z() * self.moment_z())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unitized<Line<T>>> for Unitized<Line<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unitized<Line<T>>) -> T {
        -(rhs.as_inner().moment_x() * self.as_inner().moment_x())
            + -(rhs.as_inner().moment_y() * self.as_inner().moment_y())
            + -(rhs.as_inner().moment_z() * self.as_inner().moment_z())
    }
}
impl<T: Float> ScalarProduct<Plane<T>> for Plane<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Plane<T>) -> T {
        -(self.dist() * rhs.dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Plane<T>> for Unitized<Plane<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Plane<T>) -> T {
        -(rhs.dist() * self.as_inner().dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unitized<Plane<T>>> for Plane<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unitized<Plane<T>>) -> T {
        -(rhs.as_inner().dist() * self.dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unitized<Plane<T>>> for Unitized<Plane<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unitized<Plane<T>>) -> T {
        -(rhs.as_inner().dist() * self.as_inner().dist())
    }
}
impl<T: Float> ScalarProduct<Point<T>> for Point<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Point<T>) -> T {
        self.x() * rhs.x() + self.y() * rhs.y() + self.z() * rhs.z()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Point<T>> for Unitized<Point<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Point<T>) -> T {
        rhs.x() * self.as_inner().x()
            + rhs.y() * self.as_inner().y()
            + rhs.z() * self.as_inner().z()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unitized<Point<T>>> for Point<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unitized<Point<T>>) -> T {
        rhs.as_inner().x() * self.x()
            + rhs.as_inner().y() * self.y()
            + rhs.as_inner().z() * self.z()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unitized<Point<T>>> for Unitized<Point<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unitized<Point<T>>) -> T {
        rhs.as_inner().x() * self.as_inner().x()
            + rhs.as_inner().y() * self.as_inner().y()
            + rhs.as_inner().z() * self.as_inner().z()
    }
}
impl<T: Float> ScalarProduct<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Scalar<T>> for Unitized<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Scalar<T>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unitized<Scalar<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unitized<Scalar<T>>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unitized<Scalar<T>>) -> T {
        T::zero()
    }
}
#[doc = "Bulk contraction of [`Line`] with [`Line`].\n\nThe bulk contraction extracts the Euclidean (non-degenerate) component\nof the interior product. In PGA, this isolates the finite/spatial part."]
impl<T: Float> BulkContract<Line<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.moment_x() * self.moment_x()
                + rhs.moment_y() * self.moment_y()
                + rhs.moment_z() * self.moment_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Line<T>> for Unitized<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.moment_x() * self.as_inner().moment_x()
                + rhs.moment_y() * self.as_inner().moment_y()
                + rhs.moment_z() * self.as_inner().moment_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Line<T>>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.as_inner().moment_x() * self.moment_x()
                + rhs.as_inner().moment_y() * self.moment_y()
                + rhs.as_inner().moment_z() * self.moment_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Line<T>>> for Unitized<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.as_inner().moment_x() * self.as_inner().moment_x()
                + rhs.as_inner().moment_y() * self.as_inner().moment_y()
                + rhs.as_inner().moment_z() * self.as_inner().moment_z(),
        )
    }
}
#[doc = "Bulk contraction of [`Line`] with [`Point`].\n\nThe bulk contraction extracts the Euclidean (non-degenerate) component\nof the interior product. In PGA, this isolates the finite/spatial part."]
impl<T: Float> BulkContract<Point<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.y() * self.moment_z() + rhs.z() * self.moment_y(),
            -(rhs.x() * self.moment_z()) + rhs.z() * self.moment_x(),
            -(rhs.x() * self.moment_y()) + -(rhs.y() * self.moment_x()),
            -(rhs.x() * self.dir_x()) + -(rhs.y() * self.dir_y()) + -(rhs.z() * self.dir_z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Point<T>> for Unitized<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.y() * self.as_inner().moment_z() + rhs.z() * self.as_inner().moment_y(),
            -(rhs.x() * self.as_inner().moment_z()) + rhs.z() * self.as_inner().moment_x(),
            -(rhs.x() * self.as_inner().moment_y()) + -(rhs.y() * self.as_inner().moment_x()),
            -(rhs.x() * self.as_inner().dir_x())
                + -(rhs.y() * self.as_inner().dir_y())
                + -(rhs.z() * self.as_inner().dir_z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Point<T>>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            rhs.as_inner().y() * self.moment_z() + rhs.as_inner().z() * self.moment_y(),
            -(rhs.as_inner().x() * self.moment_z()) + rhs.as_inner().z() * self.moment_x(),
            -(rhs.as_inner().x() * self.moment_y()) + -(rhs.as_inner().y() * self.moment_x()),
            -(rhs.as_inner().x() * self.dir_x())
                + -(rhs.as_inner().y() * self.dir_y())
                + -(rhs.as_inner().z() * self.dir_z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Point<T>>> for Unitized<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            rhs.as_inner().y() * self.as_inner().moment_z()
                + rhs.as_inner().z() * self.as_inner().moment_y(),
            -(rhs.as_inner().x() * self.as_inner().moment_z())
                + rhs.as_inner().z() * self.as_inner().moment_x(),
            -(rhs.as_inner().x() * self.as_inner().moment_y())
                + -(rhs.as_inner().y() * self.as_inner().moment_x()),
            -(rhs.as_inner().x() * self.as_inner().dir_x())
                + -(rhs.as_inner().y() * self.as_inner().dir_y())
                + -(rhs.as_inner().z() * self.as_inner().dir_z()),
        )
    }
}
#[doc = "Bulk contraction of [`Line`] with [`Scalar`].\n\nThe bulk contraction extracts the Euclidean (non-degenerate) component\nof the interior product. In PGA, this isolates the finite/spatial part."]
impl<T: Float> BulkContract<Scalar<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.s() * self.moment_z(),
            rhs.s() * self.moment_y(),
            rhs.s() * self.dir_x(),
            rhs.s() * self.moment_x(),
            rhs.s() * self.dir_y(),
            rhs.s() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.s() * self.as_inner().moment_z(),
            rhs.s() * self.as_inner().moment_y(),
            rhs.s() * self.as_inner().dir_x(),
            rhs.s() * self.as_inner().moment_x(),
            rhs.s() * self.as_inner().dir_y(),
            rhs.s() * self.as_inner().dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[doc = "Bulk contraction of [`Plane`] with [`Line`].\n\nThe bulk contraction extracts the Euclidean (non-degenerate) component\nof the interior product. In PGA, this isolates the finite/spatial part."]
impl<T: Float> BulkContract<Line<T>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.moment_x() * self.dist()),
            rhs.moment_y() * self.dist(),
            -(rhs.moment_z() * self.dist()),
            -(rhs.moment_x() * self.nx())
                + -(rhs.moment_y() * self.ny())
                + -(rhs.moment_z() * self.nz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Line<T>> for Unitized<Plane<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.moment_x() * self.as_inner().dist()),
            rhs.moment_y() * self.as_inner().dist(),
            -(rhs.moment_z() * self.as_inner().dist()),
            -(rhs.moment_x() * self.as_inner().nx())
                + -(rhs.moment_y() * self.as_inner().ny())
                + -(rhs.moment_z() * self.as_inner().nz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Line<T>>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().moment_x() * self.dist()),
            rhs.as_inner().moment_y() * self.dist(),
            -(rhs.as_inner().moment_z() * self.dist()),
            -(rhs.as_inner().moment_x() * self.nx())
                + -(rhs.as_inner().moment_y() * self.ny())
                + -(rhs.as_inner().moment_z() * self.nz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Line<T>>> for Unitized<Plane<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().moment_x() * self.as_inner().dist()),
            rhs.as_inner().moment_y() * self.as_inner().dist(),
            -(rhs.as_inner().moment_z() * self.as_inner().dist()),
            -(rhs.as_inner().moment_x() * self.as_inner().nx())
                + -(rhs.as_inner().moment_y() * self.as_inner().ny())
                + -(rhs.as_inner().moment_z() * self.as_inner().nz()),
        )
    }
}
#[doc = "Bulk contraction of [`Plane`] with [`Plane`].\n\nThe bulk contraction extracts the Euclidean (non-degenerate) component\nof the interior product. In PGA, this isolates the finite/spatial part."]
impl<T: Float> BulkContract<Plane<T>> for Plane<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Plane<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.dist() * self.dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Plane<T>> for Unitized<Plane<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Plane<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.dist() * self.as_inner().dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Plane<T>>> for Plane<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Plane<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().dist() * self.dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Plane<T>>> for Unitized<Plane<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Plane<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().dist() * self.as_inner().dist())
    }
}
#[doc = "Bulk contraction of [`Plane`] with [`Point`].\n\nThe bulk contraction extracts the Euclidean (non-degenerate) component\nof the interior product. In PGA, this isolates the finite/spatial part."]
impl<T: Float> BulkContract<Point<T>> for Plane<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.z() * self.dist(),
            -(rhs.y() * self.dist()),
            -(rhs.y() * self.nz()) + -(rhs.z() * self.ny()),
            rhs.x() * self.dist(),
            -(rhs.z() * self.nx()) + rhs.x() * self.nz(),
            rhs.x() * self.ny() + rhs.y() * self.nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Point<T>> for Unitized<Plane<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.z() * self.as_inner().dist(),
            -(rhs.y() * self.as_inner().dist()),
            -(rhs.y() * self.as_inner().nz()) + -(rhs.z() * self.as_inner().ny()),
            rhs.x() * self.as_inner().dist(),
            -(rhs.z() * self.as_inner().nx()) + rhs.x() * self.as_inner().nz(),
            rhs.x() * self.as_inner().ny() + rhs.y() * self.as_inner().nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Point<T>>> for Plane<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().z() * self.dist(),
            -(rhs.as_inner().y() * self.dist()),
            -(rhs.as_inner().y() * self.nz()) + -(rhs.as_inner().z() * self.ny()),
            rhs.as_inner().x() * self.dist(),
            -(rhs.as_inner().z() * self.nx()) + rhs.as_inner().x() * self.nz(),
            rhs.as_inner().x() * self.ny() + rhs.as_inner().y() * self.nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Point<T>>> for Unitized<Plane<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().z() * self.as_inner().dist(),
            -(rhs.as_inner().y() * self.as_inner().dist()),
            -(rhs.as_inner().y() * self.as_inner().nz())
                + -(rhs.as_inner().z() * self.as_inner().ny()),
            rhs.as_inner().x() * self.as_inner().dist(),
            -(rhs.as_inner().z() * self.as_inner().nx())
                + rhs.as_inner().x() * self.as_inner().nz(),
            rhs.as_inner().x() * self.as_inner().ny() + rhs.as_inner().y() * self.as_inner().nx(),
        )
    }
}
#[doc = "Bulk contraction of [`Plane`] with [`Scalar`].\n\nThe bulk contraction extracts the Euclidean (non-degenerate) component\nof the interior product. In PGA, this isolates the finite/spatial part."]
impl<T: Float> BulkContract<Scalar<T>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.s() * self.dist()),
            -(rhs.s() * self.nz()),
            -(rhs.s() * self.ny()),
            -(rhs.s() * self.nx()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.s() * self.as_inner().dist()),
            -(rhs.s() * self.as_inner().nz()),
            -(rhs.s() * self.as_inner().ny()),
            -(rhs.s() * self.as_inner().nx()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Bulk contraction of [`Point`] with [`Point`].\n\nThe bulk contraction extracts the Euclidean (non-degenerate) component\nof the interior product. In PGA, this isolates the finite/spatial part."]
impl<T: Float> BulkContract<Point<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.x() * self.x() + rhs.y() * self.y() + rhs.z() * self.z())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Point<T>> for Unitized<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.x() * self.as_inner().x()
                + rhs.y() * self.as_inner().y()
                + rhs.z() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Point<T>>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.as_inner().x() * self.x()
                + rhs.as_inner().y() * self.y()
                + rhs.as_inner().z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Point<T>>> for Unitized<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.as_inner().x() * self.as_inner().x()
                + rhs.as_inner().y() * self.as_inner().y()
                + rhs.as_inner().z() * self.as_inner().z(),
        )
    }
}
#[doc = "Bulk contraction of [`Point`] with [`Scalar`].\n\nThe bulk contraction extracts the Euclidean (non-degenerate) component\nof the interior product. In PGA, this isolates the finite/spatial part."]
impl<T: Float> BulkContract<Scalar<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.s() * self.x()),
            -(rhs.s() * self.y()),
            -(rhs.s() * self.z()),
            -(rhs.s() * self.w()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.s() * self.as_inner().x()),
            -(rhs.s() * self.as_inner().y()),
            -(rhs.s() * self.as_inner().z()),
            -(rhs.s() * self.as_inner().w()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Bulk contraction of [`Quadvector`] with [`Line`].\n\nThe bulk contraction extracts the Euclidean (non-degenerate) component\nof the interior product. In PGA, this isolates the finite/spatial part."]
impl<T: Float> BulkContract<Line<T>> for Quadvector<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            rhs.moment_x() * self.ps(),
            T::zero(),
            -(rhs.moment_y() * self.ps()),
            rhs.moment_z() * self.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Line<T>> for Unitized<Quadvector<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            rhs.moment_x() * self.as_inner().ps(),
            T::zero(),
            -(rhs.moment_y() * self.as_inner().ps()),
            rhs.moment_z() * self.as_inner().ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Line<T>>> for Quadvector<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            rhs.as_inner().moment_x() * self.ps(),
            T::zero(),
            -(rhs.as_inner().moment_y() * self.ps()),
            rhs.as_inner().moment_z() * self.ps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Line<T>>> for Unitized<Quadvector<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            rhs.as_inner().moment_x() * self.as_inner().ps(),
            T::zero(),
            -(rhs.as_inner().moment_y() * self.as_inner().ps()),
            rhs.as_inner().moment_z() * self.as_inner().ps(),
        )
    }
}
#[doc = "Bulk contraction of [`Quadvector`] with [`Plane`].\n\nThe bulk contraction extracts the Euclidean (non-degenerate) component\nof the interior product. In PGA, this isolates the finite/spatial part."]
impl<T: Float> BulkContract<Plane<T>> for Quadvector<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Plane<T>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), -(rhs.dist() * self.ps()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Plane<T>> for Unitized<Quadvector<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Plane<T>) -> Point<T> {
        Point::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            -(rhs.dist() * self.as_inner().ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Plane<T>>> for Quadvector<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Plane<T>>) -> Point<T> {
        Point::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            -(rhs.as_inner().dist() * self.ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Plane<T>>> for Unitized<Quadvector<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Plane<T>>) -> Point<T> {
        Point::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            -(rhs.as_inner().dist() * self.as_inner().ps()),
        )
    }
}
#[doc = "Bulk contraction of [`Quadvector`] with [`Point`].\n\nThe bulk contraction extracts the Euclidean (non-degenerate) component\nof the interior product. In PGA, this isolates the finite/spatial part."]
impl<T: Float> BulkContract<Point<T>> for Quadvector<T> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Point<T>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            -(rhs.z() * self.ps()),
            rhs.y() * self.ps(),
            -(rhs.x() * self.ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Point<T>> for Unitized<Quadvector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Point<T>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            -(rhs.z() * self.as_inner().ps()),
            rhs.y() * self.as_inner().ps(),
            -(rhs.x() * self.as_inner().ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Point<T>>> for Quadvector<T> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Point<T>>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            -(rhs.as_inner().z() * self.ps()),
            rhs.as_inner().y() * self.ps(),
            -(rhs.as_inner().x() * self.ps()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Point<T>>> for Unitized<Quadvector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Point<T>>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            -(rhs.as_inner().z() * self.as_inner().ps()),
            rhs.as_inner().y() * self.as_inner().ps(),
            -(rhs.as_inner().x() * self.as_inner().ps()),
        )
    }
}
#[doc = "Bulk contraction of [`Quadvector`] with [`Scalar`].\n\nThe bulk contraction extracts the Euclidean (non-degenerate) component\nof the interior product. In PGA, this isolates the finite/spatial part."]
impl<T: Float> BulkContract<Scalar<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.s() * self.ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.s() * self.as_inner().ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[doc = "Bulk contraction of [`Scalar`] with [`Scalar`].\n\nThe bulk contraction extracts the Euclidean (non-degenerate) component\nof the interior product. In PGA, this isolates the finite/spatial part."]
impl<T: Float> BulkContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Weight contraction of [`Line`] with [`Line`].\n\nThe weight contraction extracts the degenerate/ideal component of the\ninterior product. In PGA, this measures the 'weight' or projective part."]
impl<T: Float> WeightContract<Line<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.dir_x() * self.dir_x() + rhs.dir_y() * self.dir_y() + rhs.dir_z() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Line<T>> for Unitized<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.dir_x() * self.as_inner().dir_x()
                + rhs.dir_y() * self.as_inner().dir_y()
                + rhs.dir_z() * self.as_inner().dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Line<T>>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.as_inner().dir_x() * self.dir_x()
                + rhs.as_inner().dir_y() * self.dir_y()
                + rhs.as_inner().dir_z() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Line<T>>> for Unitized<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.as_inner().dir_x() * self.as_inner().dir_x()
                + rhs.as_inner().dir_y() * self.as_inner().dir_y()
                + rhs.as_inner().dir_z() * self.as_inner().dir_z(),
        )
    }
}
#[doc = "Weight contraction of [`Line`] with [`Point`].\n\nThe weight contraction extracts the degenerate/ideal component of the\ninterior product. In PGA, this measures the 'weight' or projective part."]
impl<T: Float> WeightContract<Point<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.w() * self.dir_x(),
            rhs.w() * self.dir_y(),
            rhs.w() * self.dir_z(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Point<T>> for Unitized<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.w() * self.as_inner().dir_x(),
            rhs.w() * self.as_inner().dir_y(),
            rhs.w() * self.as_inner().dir_z(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Point<T>>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            rhs.as_inner().w() * self.dir_x(),
            rhs.as_inner().w() * self.dir_y(),
            rhs.as_inner().w() * self.dir_z(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Point<T>>> for Unitized<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            rhs.as_inner().w() * self.as_inner().dir_x(),
            rhs.as_inner().w() * self.as_inner().dir_y(),
            rhs.as_inner().w() * self.as_inner().dir_z(),
            T::zero(),
        )
    }
}
#[doc = "Weight contraction of [`Plane`] with [`Line`].\n\nThe weight contraction extracts the degenerate/ideal component of the\ninterior product. In PGA, this measures the 'weight' or projective part."]
impl<T: Float> WeightContract<Line<T>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.dir_y() * self.nz()) + -(rhs.dir_z() * self.ny()),
            -(rhs.dir_z() * self.nx()) + rhs.dir_x() * self.nz(),
            rhs.dir_x() * self.ny() + rhs.dir_y() * self.nx(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Line<T>> for Unitized<Plane<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.dir_y() * self.as_inner().nz()) + -(rhs.dir_z() * self.as_inner().ny()),
            -(rhs.dir_z() * self.as_inner().nx()) + rhs.dir_x() * self.as_inner().nz(),
            rhs.dir_x() * self.as_inner().ny() + rhs.dir_y() * self.as_inner().nx(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Line<T>>> for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().dir_y() * self.nz()) + -(rhs.as_inner().dir_z() * self.ny()),
            -(rhs.as_inner().dir_z() * self.nx()) + rhs.as_inner().dir_x() * self.nz(),
            rhs.as_inner().dir_x() * self.ny() + rhs.as_inner().dir_y() * self.nx(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Line<T>>> for Unitized<Plane<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().dir_y() * self.as_inner().nz())
                + -(rhs.as_inner().dir_z() * self.as_inner().ny()),
            -(rhs.as_inner().dir_z() * self.as_inner().nx())
                + rhs.as_inner().dir_x() * self.as_inner().nz(),
            rhs.as_inner().dir_x() * self.as_inner().ny()
                + rhs.as_inner().dir_y() * self.as_inner().nx(),
            T::zero(),
        )
    }
}
#[doc = "Weight contraction of [`Plane`] with [`Plane`].\n\nThe weight contraction extracts the degenerate/ideal component of the\ninterior product. In PGA, this measures the 'weight' or projective part."]
impl<T: Float> WeightContract<Plane<T>> for Plane<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Plane<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.nx() * self.nx() + rhs.ny() * self.ny() + rhs.nz() * self.nz())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Plane<T>> for Unitized<Plane<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Plane<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.nx() * self.as_inner().nx()
                + rhs.ny() * self.as_inner().ny()
                + rhs.nz() * self.as_inner().nz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Plane<T>>> for Plane<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Plane<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.as_inner().nx() * self.nx()
                + rhs.as_inner().ny() * self.ny()
                + rhs.as_inner().nz() * self.nz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Plane<T>>> for Unitized<Plane<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Plane<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.as_inner().nx() * self.as_inner().nx()
                + rhs.as_inner().ny() * self.as_inner().ny()
                + rhs.as_inner().nz() * self.as_inner().nz(),
        )
    }
}
#[doc = "Weight contraction of [`Plane`] with [`Point`].\n\nThe weight contraction extracts the degenerate/ideal component of the\ninterior product. In PGA, this measures the 'weight' or projective part."]
impl<T: Float> WeightContract<Point<T>> for Plane<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.w() * self.nz(),
            rhs.w() * self.ny(),
            T::zero(),
            rhs.w() * self.nx(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Point<T>> for Unitized<Plane<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.w() * self.as_inner().nz(),
            rhs.w() * self.as_inner().ny(),
            T::zero(),
            rhs.w() * self.as_inner().nx(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Point<T>>> for Plane<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().w() * self.nz(),
            rhs.as_inner().w() * self.ny(),
            T::zero(),
            rhs.as_inner().w() * self.nx(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Point<T>>> for Unitized<Plane<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().w() * self.as_inner().nz(),
            rhs.as_inner().w() * self.as_inner().ny(),
            T::zero(),
            rhs.as_inner().w() * self.as_inner().nx(),
            T::zero(),
            T::zero(),
        )
    }
}
#[doc = "Weight contraction of [`Point`] with [`Point`].\n\nThe weight contraction extracts the degenerate/ideal component of the\ninterior product. In PGA, this measures the 'weight' or projective part."]
impl<T: Float> WeightContract<Point<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.w() * self.w())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Point<T>> for Unitized<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.w() * self.as_inner().w())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Point<T>>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().w() * self.w())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Point<T>>> for Unitized<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().w() * self.as_inner().w())
    }
}
#[doc = "Weight contraction of [`Quadvector`] with [`Line`].\n\nThe weight contraction extracts the degenerate/ideal component of the\ninterior product. In PGA, this measures the 'weight' or projective part."]
impl<T: Float> WeightContract<Line<T>> for Quadvector<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.dir_z() * self.ps(),
            -(rhs.dir_y() * self.ps()),
            T::zero(),
            rhs.dir_x() * self.ps(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Line<T>> for Unitized<Quadvector<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.dir_z() * self.as_inner().ps(),
            -(rhs.dir_y() * self.as_inner().ps()),
            T::zero(),
            rhs.dir_x() * self.as_inner().ps(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Line<T>>> for Quadvector<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().dir_z() * self.ps(),
            -(rhs.as_inner().dir_y() * self.ps()),
            T::zero(),
            rhs.as_inner().dir_x() * self.ps(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Line<T>>> for Unitized<Quadvector<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().dir_z() * self.as_inner().ps(),
            -(rhs.as_inner().dir_y() * self.as_inner().ps()),
            T::zero(),
            rhs.as_inner().dir_x() * self.as_inner().ps(),
            T::zero(),
            T::zero(),
        )
    }
}
#[doc = "Weight contraction of [`Quadvector`] with [`Plane`].\n\nThe weight contraction extracts the degenerate/ideal component of the\ninterior product. In PGA, this measures the 'weight' or projective part."]
impl<T: Float> WeightContract<Plane<T>> for Quadvector<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Plane<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.nx() * self.ps(),
            -(rhs.ny() * self.ps()),
            rhs.nz() * self.ps(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Plane<T>> for Unitized<Quadvector<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Plane<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.nx() * self.as_inner().ps(),
            -(rhs.ny() * self.as_inner().ps()),
            rhs.nz() * self.as_inner().ps(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Plane<T>>> for Quadvector<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Plane<T>>) -> Point<T> {
        Point::new_unchecked(
            rhs.as_inner().nx() * self.ps(),
            -(rhs.as_inner().ny() * self.ps()),
            rhs.as_inner().nz() * self.ps(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Plane<T>>> for Unitized<Quadvector<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Plane<T>>) -> Point<T> {
        Point::new_unchecked(
            rhs.as_inner().nx() * self.as_inner().ps(),
            -(rhs.as_inner().ny() * self.as_inner().ps()),
            rhs.as_inner().nz() * self.as_inner().ps(),
            T::zero(),
        )
    }
}
#[doc = "Weight contraction of [`Quadvector`] with [`Point`].\n\nThe weight contraction extracts the degenerate/ideal component of the\ninterior product. In PGA, this measures the 'weight' or projective part."]
impl<T: Float> WeightContract<Point<T>> for Quadvector<T> {
    type Output = Plane<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Point<T>) -> Plane<T> {
        Plane::new_unchecked(rhs.w() * self.ps(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Point<T>> for Unitized<Quadvector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Point<T>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.w() * self.as_inner().ps(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Point<T>>> for Quadvector<T> {
    type Output = Plane<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Point<T>>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.as_inner().w() * self.ps(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Point<T>>> for Unitized<Quadvector<T>> {
    type Output = Plane<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Point<T>>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.as_inner().w() * self.as_inner().ps(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[doc = "Weight contraction of [`Quadvector`] with [`Quadvector`].\n\nThe weight contraction extracts the degenerate/ideal component of the\ninterior product. In PGA, this measures the 'weight' or projective part."]
impl<T: Float> WeightContract<Quadvector<T>> for Quadvector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Quadvector<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.ps() * self.ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Quadvector<T>> for Unitized<Quadvector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Quadvector<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.ps() * self.as_inner().ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Quadvector<T>>> for Quadvector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Quadvector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().ps() * self.ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Quadvector<T>>> for Unitized<Quadvector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Quadvector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().ps() * self.as_inner().ps())
    }
}
#[doc = "Bulk expansion of [`Line`] with [`Line`].\n\nThe bulk expansion is the dual of bulk contraction, extracting the\nEuclidean component of the exterior product complement."]
impl<T: Float> BulkExpand<Line<T>> for Line<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Line<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            rhs.moment_x() * self.moment_x()
                + rhs.moment_y() * self.moment_y()
                + rhs.moment_z() * self.moment_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Line<T>> for Unitized<Line<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Line<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            rhs.moment_x() * self.as_inner().moment_x()
                + rhs.moment_y() * self.as_inner().moment_y()
                + rhs.moment_z() * self.as_inner().moment_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Line<T>>> for Line<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Line<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            rhs.as_inner().moment_x() * self.moment_x()
                + rhs.as_inner().moment_y() * self.moment_y()
                + rhs.as_inner().moment_z() * self.moment_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Line<T>>> for Unitized<Line<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Line<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            rhs.as_inner().moment_x() * self.as_inner().moment_x()
                + rhs.as_inner().moment_y() * self.as_inner().moment_y()
                + rhs.as_inner().moment_z() * self.as_inner().moment_z(),
        )
    }
}
#[doc = "Bulk expansion of [`Line`] with [`Plane`].\n\nThe bulk expansion is the dual of bulk contraction, extracting the\nEuclidean component of the exterior product complement."]
impl<T: Float> BulkExpand<Plane<T>> for Line<T> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            rhs.dist() * self.moment_z(),
            rhs.dist() * self.moment_y(),
            rhs.dist() * self.moment_x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Plane<T>> for Unitized<Line<T>> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            rhs.dist() * self.as_inner().moment_z(),
            rhs.dist() * self.as_inner().moment_y(),
            rhs.dist() * self.as_inner().moment_x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Plane<T>>> for Line<T> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            rhs.as_inner().dist() * self.moment_z(),
            rhs.as_inner().dist() * self.moment_y(),
            rhs.as_inner().dist() * self.moment_x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Plane<T>>> for Unitized<Line<T>> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            rhs.as_inner().dist() * self.as_inner().moment_z(),
            rhs.as_inner().dist() * self.as_inner().moment_y(),
            rhs.as_inner().dist() * self.as_inner().moment_x(),
        )
    }
}
#[doc = "Bulk expansion of [`Plane`] with [`Plane`].\n\nThe bulk expansion is the dual of bulk contraction, extracting the\nEuclidean component of the exterior product complement."]
impl<T: Float> BulkExpand<Plane<T>> for Plane<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Plane<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.dist() * self.dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Plane<T>> for Unitized<Plane<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Plane<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.dist() * self.as_inner().dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Plane<T>>> for Plane<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Plane<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.as_inner().dist() * self.dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Plane<T>>> for Unitized<Plane<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Plane<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.as_inner().dist() * self.as_inner().dist())
    }
}
#[doc = "Bulk expansion of [`Point`] with [`Line`].\n\nThe bulk expansion is the dual of bulk contraction, extracting the\nEuclidean component of the exterior product complement."]
impl<T: Float> BulkExpand<Line<T>> for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Line<T>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            -(rhs.moment_x() * self.y()) + -(rhs.moment_y() * self.x()),
            -(rhs.moment_x() * self.z()) + rhs.moment_z() * self.x(),
            rhs.moment_y() * self.z() + rhs.moment_z() * self.y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Line<T>> for Unitized<Point<T>> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Line<T>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            -(rhs.moment_x() * self.as_inner().y()) + -(rhs.moment_y() * self.as_inner().x()),
            -(rhs.moment_x() * self.as_inner().z()) + rhs.moment_z() * self.as_inner().x(),
            rhs.moment_y() * self.as_inner().z() + rhs.moment_z() * self.as_inner().y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Line<T>>> for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Line<T>>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            -(rhs.as_inner().moment_x() * self.y()) + -(rhs.as_inner().moment_y() * self.x()),
            -(rhs.as_inner().moment_x() * self.z()) + rhs.as_inner().moment_z() * self.x(),
            rhs.as_inner().moment_y() * self.z() + rhs.as_inner().moment_z() * self.y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Line<T>>> for Unitized<Point<T>> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Line<T>>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            -(rhs.as_inner().moment_x() * self.as_inner().y())
                + -(rhs.as_inner().moment_y() * self.as_inner().x()),
            -(rhs.as_inner().moment_x() * self.as_inner().z())
                + rhs.as_inner().moment_z() * self.as_inner().x(),
            rhs.as_inner().moment_y() * self.as_inner().z()
                + rhs.as_inner().moment_z() * self.as_inner().y(),
        )
    }
}
#[doc = "Bulk expansion of [`Point`] with [`Plane`].\n\nThe bulk expansion is the dual of bulk contraction, extracting the\nEuclidean component of the exterior product complement."]
impl<T: Float> BulkExpand<Plane<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Plane<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            rhs.dist() * self.x(),
            T::zero(),
            rhs.dist() * self.y(),
            rhs.dist() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Plane<T>> for Unitized<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Plane<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            rhs.dist() * self.as_inner().x(),
            T::zero(),
            rhs.dist() * self.as_inner().y(),
            rhs.dist() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Plane<T>>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Plane<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            rhs.as_inner().dist() * self.x(),
            T::zero(),
            rhs.as_inner().dist() * self.y(),
            rhs.as_inner().dist() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Plane<T>>> for Unitized<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Plane<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            rhs.as_inner().dist() * self.as_inner().x(),
            T::zero(),
            rhs.as_inner().dist() * self.as_inner().y(),
            rhs.as_inner().dist() * self.as_inner().z(),
        )
    }
}
#[doc = "Bulk expansion of [`Point`] with [`Point`].\n\nThe bulk expansion is the dual of bulk contraction, extracting the\nEuclidean component of the exterior product complement."]
impl<T: Float> BulkExpand<Point<T>> for Point<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Point<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.x() * self.x() + rhs.y() * self.y() + rhs.z() * self.z())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Point<T>> for Unitized<Point<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Point<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            rhs.x() * self.as_inner().x()
                + rhs.y() * self.as_inner().y()
                + rhs.z() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Point<T>>> for Point<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Point<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            rhs.as_inner().x() * self.x()
                + rhs.as_inner().y() * self.y()
                + rhs.as_inner().z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Point<T>>> for Unitized<Point<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Point<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            rhs.as_inner().x() * self.as_inner().x()
                + rhs.as_inner().y() * self.as_inner().y()
                + rhs.as_inner().z() * self.as_inner().z(),
        )
    }
}
#[doc = "Bulk expansion of [`Scalar`] with [`Line`].\n\nThe bulk expansion is the dual of bulk contraction, extracting the\nEuclidean component of the exterior product complement."]
impl<T: Float> BulkExpand<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            rhs.moment_x() * self.s(),
            T::zero(),
            -(rhs.moment_y() * self.s()),
            rhs.moment_z() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Line<T>> for Unitized<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Line<T>>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            rhs.as_inner().moment_x() * self.s(),
            T::zero(),
            -(rhs.as_inner().moment_y() * self.s()),
            rhs.as_inner().moment_z() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Line<T>>> for Unitized<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[doc = "Bulk expansion of [`Scalar`] with [`Plane`].\n\nThe bulk expansion is the dual of bulk contraction, extracting the\nEuclidean component of the exterior product complement."]
impl<T: Float> BulkExpand<Plane<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Plane<T>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), rhs.dist() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Plane<T>> for Unitized<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Plane<T>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Plane<T>>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Plane<T>>) -> Point<T> {
        Point::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            rhs.as_inner().dist() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Plane<T>>> for Unitized<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Plane<T>>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Bulk expansion of [`Scalar`] with [`Point`].\n\nThe bulk expansion is the dual of bulk contraction, extracting the\nEuclidean component of the exterior product complement."]
impl<T: Float> BulkExpand<Point<T>> for Scalar<T> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Point<T>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            rhs.z() * self.s(),
            -(rhs.y() * self.s()),
            rhs.x() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Point<T>> for Unitized<Scalar<T>> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Point<T>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Point<T>>> for Scalar<T> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Point<T>>) -> Plane<T> {
        Plane::new_unchecked(
            T::zero(),
            rhs.as_inner().z() * self.s(),
            -(rhs.as_inner().y() * self.s()),
            rhs.as_inner().x() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Point<T>>> for Unitized<Scalar<T>> {
    type Output = Plane<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Point<T>>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Bulk expansion of [`Scalar`] with [`Scalar`].\n\nThe bulk expansion is the dual of bulk contraction, extracting the\nEuclidean component of the exterior product complement."]
impl<T: Float> BulkExpand<Scalar<T>> for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Scalar<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Scalar<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Scalar<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Scalar<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
#[doc = "Weight expansion of [`Line`] with [`Line`].\n\nThe weight expansion is the dual of weight contraction, extracting the\ndegenerate/ideal component of the exterior product complement."]
impl<T: Float> WeightExpand<Line<T>> for Line<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Line<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            rhs.dir_x() * self.dir_x() + rhs.dir_y() * self.dir_y() + rhs.dir_z() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Line<T>> for Unitized<Line<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Line<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            rhs.dir_x() * self.as_inner().dir_x()
                + rhs.dir_y() * self.as_inner().dir_y()
                + rhs.dir_z() * self.as_inner().dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Line<T>>> for Line<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Line<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            rhs.as_inner().dir_x() * self.dir_x()
                + rhs.as_inner().dir_y() * self.dir_y()
                + rhs.as_inner().dir_z() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Line<T>>> for Unitized<Line<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Line<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            rhs.as_inner().dir_x() * self.as_inner().dir_x()
                + rhs.as_inner().dir_y() * self.as_inner().dir_y()
                + rhs.as_inner().dir_z() * self.as_inner().dir_z(),
        )
    }
}
#[doc = "Weight expansion of [`Line`] with [`Plane`].\n\nThe weight expansion is the dual of weight contraction, extracting the\ndegenerate/ideal component of the exterior product complement."]
impl<T: Float> WeightExpand<Plane<T>> for Line<T> {
    type Output = Plane<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.nx() * self.moment_x())
                + -(rhs.ny() * self.moment_y())
                + -(rhs.nz() * self.moment_z()),
            -(rhs.nx() * self.dir_y()) + -(rhs.ny() * self.dir_x()),
            -(rhs.nx() * self.dir_z()) + rhs.nz() * self.dir_x(),
            rhs.ny() * self.dir_z() + rhs.nz() * self.dir_y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Plane<T>> for Unitized<Line<T>> {
    type Output = Plane<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.nx() * self.as_inner().moment_x())
                + -(rhs.ny() * self.as_inner().moment_y())
                + -(rhs.nz() * self.as_inner().moment_z()),
            -(rhs.nx() * self.as_inner().dir_y()) + -(rhs.ny() * self.as_inner().dir_x()),
            -(rhs.nx() * self.as_inner().dir_z()) + rhs.nz() * self.as_inner().dir_x(),
            rhs.ny() * self.as_inner().dir_z() + rhs.nz() * self.as_inner().dir_y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Plane<T>>> for Line<T> {
    type Output = Plane<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.as_inner().nx() * self.moment_x())
                + -(rhs.as_inner().ny() * self.moment_y())
                + -(rhs.as_inner().nz() * self.moment_z()),
            -(rhs.as_inner().nx() * self.dir_y()) + -(rhs.as_inner().ny() * self.dir_x()),
            -(rhs.as_inner().nx() * self.dir_z()) + rhs.as_inner().nz() * self.dir_x(),
            rhs.as_inner().ny() * self.dir_z() + rhs.as_inner().nz() * self.dir_y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Plane<T>>> for Unitized<Line<T>> {
    type Output = Plane<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Plane<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.as_inner().nx() * self.as_inner().moment_x())
                + -(rhs.as_inner().ny() * self.as_inner().moment_y())
                + -(rhs.as_inner().nz() * self.as_inner().moment_z()),
            -(rhs.as_inner().nx() * self.as_inner().dir_y())
                + -(rhs.as_inner().ny() * self.as_inner().dir_x()),
            -(rhs.as_inner().nx() * self.as_inner().dir_z())
                + rhs.as_inner().nz() * self.as_inner().dir_x(),
            rhs.as_inner().ny() * self.as_inner().dir_z()
                + rhs.as_inner().nz() * self.as_inner().dir_y(),
        )
    }
}
#[doc = "Weight expansion of [`Line`] with [`Quadvector`].\n\nThe weight expansion is the dual of weight contraction, extracting the\ndegenerate/ideal component of the exterior product complement."]
impl<T: Float> WeightExpand<Quadvector<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Quadvector<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.ps() * self.moment_z(),
            rhs.ps() * self.moment_y(),
            rhs.ps() * self.dir_x(),
            rhs.ps() * self.moment_x(),
            rhs.ps() * self.dir_y(),
            rhs.ps() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Quadvector<T>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Quadvector<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.ps() * self.as_inner().moment_z(),
            rhs.ps() * self.as_inner().moment_y(),
            rhs.ps() * self.as_inner().dir_x(),
            rhs.ps() * self.as_inner().moment_x(),
            rhs.ps() * self.as_inner().dir_y(),
            rhs.ps() * self.as_inner().dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Quadvector<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Quadvector<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().ps() * self.moment_z(),
            rhs.as_inner().ps() * self.moment_y(),
            rhs.as_inner().ps() * self.dir_x(),
            rhs.as_inner().ps() * self.moment_x(),
            rhs.as_inner().ps() * self.dir_y(),
            rhs.as_inner().ps() * self.dir_z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Quadvector<T>>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Quadvector<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().ps() * self.as_inner().moment_z(),
            rhs.as_inner().ps() * self.as_inner().moment_y(),
            rhs.as_inner().ps() * self.as_inner().dir_x(),
            rhs.as_inner().ps() * self.as_inner().moment_x(),
            rhs.as_inner().ps() * self.as_inner().dir_y(),
            rhs.as_inner().ps() * self.as_inner().dir_z(),
        )
    }
}
#[doc = "Weight expansion of [`Plane`] with [`Plane`].\n\nThe weight expansion is the dual of weight contraction, extracting the\ndegenerate/ideal component of the exterior product complement."]
impl<T: Float> WeightExpand<Plane<T>> for Plane<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Plane<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            rhs.nx() * self.nx() + rhs.ny() * self.ny() + rhs.nz() * self.nz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Plane<T>> for Unitized<Plane<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Plane<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            rhs.nx() * self.as_inner().nx()
                + rhs.ny() * self.as_inner().ny()
                + rhs.nz() * self.as_inner().nz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Plane<T>>> for Plane<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Plane<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            rhs.as_inner().nx() * self.nx()
                + rhs.as_inner().ny() * self.ny()
                + rhs.as_inner().nz() * self.nz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Plane<T>>> for Unitized<Plane<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Plane<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            rhs.as_inner().nx() * self.as_inner().nx()
                + rhs.as_inner().ny() * self.as_inner().ny()
                + rhs.as_inner().nz() * self.as_inner().nz(),
        )
    }
}
#[doc = "Weight expansion of [`Plane`] with [`Quadvector`].\n\nThe weight expansion is the dual of weight contraction, extracting the\ndegenerate/ideal component of the exterior product complement."]
impl<T: Float> WeightExpand<Quadvector<T>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Quadvector<T>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.ps() * self.dist(),
            rhs.ps() * self.nz(),
            rhs.ps() * self.ny(),
            rhs.ps() * self.nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Quadvector<T>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Quadvector<T>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.ps() * self.as_inner().dist(),
            rhs.ps() * self.as_inner().nz(),
            rhs.ps() * self.as_inner().ny(),
            rhs.ps() * self.as_inner().nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Quadvector<T>>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Quadvector<T>>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.as_inner().ps() * self.dist(),
            rhs.as_inner().ps() * self.nz(),
            rhs.as_inner().ps() * self.ny(),
            rhs.as_inner().ps() * self.nx(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Quadvector<T>>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Quadvector<T>>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.as_inner().ps() * self.as_inner().dist(),
            rhs.as_inner().ps() * self.as_inner().nz(),
            rhs.as_inner().ps() * self.as_inner().ny(),
            rhs.as_inner().ps() * self.as_inner().nx(),
        )
    }
}
#[doc = "Weight expansion of [`Point`] with [`Line`].\n\nThe weight expansion is the dual of weight contraction, extracting the\ndegenerate/ideal component of the exterior product complement."]
impl<T: Float> WeightExpand<Line<T>> for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Line<T>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.dir_x() * self.x() + rhs.dir_y() * self.y() + rhs.dir_z() * self.z(),
            rhs.dir_z() * self.w(),
            -(rhs.dir_y() * self.w()),
            rhs.dir_x() * self.w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Line<T>> for Unitized<Point<T>> {
    type Output = Plane<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Line<T>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.dir_x() * self.as_inner().x()
                + rhs.dir_y() * self.as_inner().y()
                + rhs.dir_z() * self.as_inner().z(),
            rhs.dir_z() * self.as_inner().w(),
            -(rhs.dir_y() * self.as_inner().w()),
            rhs.dir_x() * self.as_inner().w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Line<T>>> for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Line<T>>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.as_inner().dir_x() * self.x()
                + rhs.as_inner().dir_y() * self.y()
                + rhs.as_inner().dir_z() * self.z(),
            rhs.as_inner().dir_z() * self.w(),
            -(rhs.as_inner().dir_y() * self.w()),
            rhs.as_inner().dir_x() * self.w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Line<T>>> for Unitized<Point<T>> {
    type Output = Plane<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Line<T>>) -> Plane<T> {
        Plane::new_unchecked(
            rhs.as_inner().dir_x() * self.as_inner().x()
                + rhs.as_inner().dir_y() * self.as_inner().y()
                + rhs.as_inner().dir_z() * self.as_inner().z(),
            rhs.as_inner().dir_z() * self.as_inner().w(),
            -(rhs.as_inner().dir_y() * self.as_inner().w()),
            rhs.as_inner().dir_x() * self.as_inner().w(),
        )
    }
}
#[doc = "Weight expansion of [`Point`] with [`Plane`].\n\nThe weight expansion is the dual of weight contraction, extracting the\ndegenerate/ideal component of the exterior product complement."]
impl<T: Float> WeightExpand<Plane<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Plane<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.nx() * self.y() + rhs.ny() * self.x(),
            -(rhs.nz() * self.x()) + rhs.nx() * self.z(),
            rhs.nx() * self.w(),
            -(rhs.ny() * self.z()) + -(rhs.nz() * self.y()),
            -(rhs.ny() * self.w()),
            rhs.nz() * self.w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Plane<T>> for Unitized<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Plane<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.nx() * self.as_inner().y() + rhs.ny() * self.as_inner().x(),
            -(rhs.nz() * self.as_inner().x()) + rhs.nx() * self.as_inner().z(),
            rhs.nx() * self.as_inner().w(),
            -(rhs.ny() * self.as_inner().z()) + -(rhs.nz() * self.as_inner().y()),
            -(rhs.ny() * self.as_inner().w()),
            rhs.nz() * self.as_inner().w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Plane<T>>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Plane<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().nx() * self.y() + rhs.as_inner().ny() * self.x(),
            -(rhs.as_inner().nz() * self.x()) + rhs.as_inner().nx() * self.z(),
            rhs.as_inner().nx() * self.w(),
            -(rhs.as_inner().ny() * self.z()) + -(rhs.as_inner().nz() * self.y()),
            -(rhs.as_inner().ny() * self.w()),
            rhs.as_inner().nz() * self.w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Plane<T>>> for Unitized<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Plane<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().nx() * self.as_inner().y() + rhs.as_inner().ny() * self.as_inner().x(),
            -(rhs.as_inner().nz() * self.as_inner().x())
                + rhs.as_inner().nx() * self.as_inner().z(),
            rhs.as_inner().nx() * self.as_inner().w(),
            -(rhs.as_inner().ny() * self.as_inner().z())
                + -(rhs.as_inner().nz() * self.as_inner().y()),
            -(rhs.as_inner().ny() * self.as_inner().w()),
            rhs.as_inner().nz() * self.as_inner().w(),
        )
    }
}
#[doc = "Weight expansion of [`Point`] with [`Point`].\n\nThe weight expansion is the dual of weight contraction, extracting the\ndegenerate/ideal component of the exterior product complement."]
impl<T: Float> WeightExpand<Point<T>> for Point<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Point<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.w() * self.w())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Point<T>> for Unitized<Point<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Point<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.w() * self.as_inner().w())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Point<T>>> for Point<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Point<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.as_inner().w() * self.w())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Point<T>>> for Unitized<Point<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Point<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.as_inner().w() * self.as_inner().w())
    }
}
#[doc = "Weight expansion of [`Point`] with [`Quadvector`].\n\nThe weight expansion is the dual of weight contraction, extracting the\ndegenerate/ideal component of the exterior product complement."]
impl<T: Float> WeightExpand<Quadvector<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Quadvector<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.ps() * self.x(),
            rhs.ps() * self.y(),
            rhs.ps() * self.z(),
            rhs.ps() * self.w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Quadvector<T>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Quadvector<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.ps() * self.as_inner().x(),
            rhs.ps() * self.as_inner().y(),
            rhs.ps() * self.as_inner().z(),
            rhs.ps() * self.as_inner().w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Quadvector<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Quadvector<T>>) -> Point<T> {
        Point::new_unchecked(
            rhs.as_inner().ps() * self.x(),
            rhs.as_inner().ps() * self.y(),
            rhs.as_inner().ps() * self.z(),
            rhs.as_inner().ps() * self.w(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Quadvector<T>>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Quadvector<T>>) -> Point<T> {
        Point::new_unchecked(
            rhs.as_inner().ps() * self.as_inner().x(),
            rhs.as_inner().ps() * self.as_inner().y(),
            rhs.as_inner().ps() * self.as_inner().z(),
            rhs.as_inner().ps() * self.as_inner().w(),
        )
    }
}
#[doc = "Weight expansion of [`Quadvector`] with [`Quadvector`].\n\nThe weight expansion is the dual of weight contraction, extracting the\ndegenerate/ideal component of the exterior product complement."]
impl<T: Float> WeightExpand<Quadvector<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.ps() * self.ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Quadvector<T>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.ps() * self.as_inner().ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Quadvector<T>>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.as_inner().ps() * self.ps())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Quadvector<T>>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        Quadvector::new_unchecked(rhs.as_inner().ps() * self.as_inner().ps())
    }
}
#[doc = "Weight expansion of [`Scalar`] with [`Line`].\n\nThe weight expansion is the dual of weight contraction, extracting the\ndegenerate/ideal component of the exterior product complement."]
impl<T: Float> WeightExpand<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.dir_z() * self.s(),
            -(rhs.dir_y() * self.s()),
            T::zero(),
            rhs.dir_x() * self.s(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Line<T>> for Unitized<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Line<T>>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().dir_z() * self.s(),
            -(rhs.as_inner().dir_y() * self.s()),
            T::zero(),
            rhs.as_inner().dir_x() * self.s(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Line<T>>> for Unitized<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[doc = "Weight expansion of [`Scalar`] with [`Plane`].\n\nThe weight expansion is the dual of weight contraction, extracting the\ndegenerate/ideal component of the exterior product complement."]
impl<T: Float> WeightExpand<Plane<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Plane<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.nx() * self.s()),
            rhs.ny() * self.s(),
            -(rhs.nz() * self.s()),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Plane<T>> for Unitized<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Plane<T>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Plane<T>>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Plane<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().nx() * self.s()),
            rhs.as_inner().ny() * self.s(),
            -(rhs.as_inner().nz() * self.s()),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Plane<T>>> for Unitized<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Plane<T>>) -> Point<T> {
        Point::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Weight expansion of [`Scalar`] with [`Point`].\n\nThe weight expansion is the dual of weight contraction, extracting the\ndegenerate/ideal component of the exterior product complement."]
impl<T: Float> WeightExpand<Point<T>> for Scalar<T> {
    type Output = Plane<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Point<T>) -> Plane<T> {
        Plane::new_unchecked(-(rhs.w() * self.s()), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Point<T>> for Unitized<Scalar<T>> {
    type Output = Plane<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Point<T>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Point<T>>> for Scalar<T> {
    type Output = Plane<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Point<T>>) -> Plane<T> {
        Plane::new_unchecked(
            -(rhs.as_inner().w() * self.s()),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Point<T>>> for Unitized<Scalar<T>> {
    type Output = Plane<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Point<T>>) -> Plane<T> {
        Plane::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
}
#[doc = "Weight expansion of [`Scalar`] with [`Quadvector`].\n\nThe weight expansion is the dual of weight contraction, extracting the\ndegenerate/ideal component of the exterior product complement."]
impl<T: Float> WeightExpand<Quadvector<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Quadvector<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.ps() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Quadvector<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Quadvector<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Quadvector<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Quadvector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().ps() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Quadvector<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Quadvector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
impl<T: Float> Dot<Flector<T>> for Flector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Flector<T>) -> T {
        self.px() * rhs.px() + self.py() * rhs.py() + self.pz() * rhs.pz()
            - self.dist() * rhs.dist()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Flector<T>> for Unitized<Flector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Flector<T>) -> T {
        -(rhs.dist() * self.as_inner().dist())
            + rhs.px() * self.as_inner().px()
            + rhs.py() * self.as_inner().py()
            + rhs.pz() * self.as_inner().pz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Flector<T>>> for Flector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Flector<T>>) -> T {
        -(rhs.as_inner().dist() * self.dist())
            + rhs.as_inner().px() * self.px()
            + rhs.as_inner().py() * self.py()
            + rhs.as_inner().pz() * self.pz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Flector<T>>> for Unitized<Flector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Flector<T>>) -> T {
        -(rhs.as_inner().dist() * self.as_inner().dist())
            + rhs.as_inner().px() * self.as_inner().px()
            + rhs.as_inner().py() * self.as_inner().py()
            + rhs.as_inner().pz() * self.as_inner().pz()
    }
}
impl<T: Float> Dot<Plane<T>> for Flector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Plane<T>) -> T {
        -(self.dist() * rhs.dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Plane<T>> for Unitized<Flector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Plane<T>) -> T {
        -(rhs.dist() * self.as_inner().dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Plane<T>>> for Flector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Plane<T>>) -> T {
        -(rhs.as_inner().dist() * self.dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Plane<T>>> for Unitized<Flector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Plane<T>>) -> T {
        -(rhs.as_inner().dist() * self.as_inner().dist())
    }
}
impl<T: Float> Dot<Point<T>> for Flector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Point<T>) -> T {
        self.px() * rhs.x() + self.py() * rhs.y() + self.pz() * rhs.z()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Point<T>> for Unitized<Flector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Point<T>) -> T {
        rhs.x() * self.as_inner().px()
            + rhs.y() * self.as_inner().py()
            + rhs.z() * self.as_inner().pz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Point<T>>> for Flector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Point<T>>) -> T {
        rhs.as_inner().x() * self.px()
            + rhs.as_inner().y() * self.py()
            + rhs.as_inner().z() * self.pz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Point<T>>> for Unitized<Flector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Point<T>>) -> T {
        rhs.as_inner().x() * self.as_inner().px()
            + rhs.as_inner().y() * self.as_inner().py()
            + rhs.as_inner().z() * self.as_inner().pz()
    }
}
impl<T: Float> Dot<Line<T>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Line<T>) -> T {
        -(self.moment_z() * rhs.moment_z())
            - self.moment_y() * rhs.moment_y()
            - self.moment_x() * rhs.moment_x()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Line<T>> for Unitized<Line<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Line<T>) -> T {
        -(rhs.moment_x() * self.as_inner().moment_x())
            + -(rhs.moment_y() * self.as_inner().moment_y())
            + -(rhs.moment_z() * self.as_inner().moment_z())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Line<T>>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Line<T>>) -> T {
        -(rhs.as_inner().moment_x() * self.moment_x())
            + -(rhs.as_inner().moment_y() * self.moment_y())
            + -(rhs.as_inner().moment_z() * self.moment_z())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Line<T>>> for Unitized<Line<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Line<T>>) -> T {
        -(rhs.as_inner().moment_x() * self.as_inner().moment_x())
            + -(rhs.as_inner().moment_y() * self.as_inner().moment_y())
            + -(rhs.as_inner().moment_z() * self.as_inner().moment_z())
    }
}
impl<T: Float> Dot<Motor<T>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Motor<T>) -> T {
        -(self.moment_z() * rhs.tz()) - self.moment_y() * rhs.ty() - self.moment_x() * rhs.rx()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Motor<T>> for Unitized<Line<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Motor<T>) -> T {
        -(rhs.rx() * self.as_inner().moment_x())
            + -(rhs.ty() * self.as_inner().moment_y())
            + -(rhs.tz() * self.as_inner().moment_z())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Motor<T>>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Motor<T>>) -> T {
        -(rhs.as_inner().rx() * self.moment_x())
            + -(rhs.as_inner().ty() * self.moment_y())
            + -(rhs.as_inner().tz() * self.moment_z())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Motor<T>>> for Unitized<Line<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Motor<T>>) -> T {
        -(rhs.as_inner().rx() * self.as_inner().moment_x())
            + -(rhs.as_inner().ty() * self.as_inner().moment_y())
            + -(rhs.as_inner().tz() * self.as_inner().moment_z())
    }
}
impl<T: Float> Dot<Line<T>> for Motor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Line<T>) -> T {
        -(self.tz() * rhs.moment_z()) - self.ty() * rhs.moment_y() - self.rx() * rhs.moment_x()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Line<T>> for Unitized<Motor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Line<T>) -> T {
        -(rhs.moment_x() * self.as_inner().rx())
            + -(rhs.moment_y() * self.as_inner().ty())
            + -(rhs.moment_z() * self.as_inner().tz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Line<T>>> for Motor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Line<T>>) -> T {
        -(rhs.as_inner().moment_x() * self.rx())
            + -(rhs.as_inner().moment_y() * self.ty())
            + -(rhs.as_inner().moment_z() * self.tz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Line<T>>> for Unitized<Motor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Line<T>>) -> T {
        -(rhs.as_inner().moment_x() * self.as_inner().rx())
            + -(rhs.as_inner().moment_y() * self.as_inner().ty())
            + -(rhs.as_inner().moment_z() * self.as_inner().tz())
    }
}
impl<T: Float> Dot<Motor<T>> for Motor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Motor<T>) -> T {
        self.s() * rhs.s() - self.tz() * rhs.tz() - self.ty() * rhs.ty() - self.rx() * rhs.rx()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Motor<T>> for Unitized<Motor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Motor<T>) -> T {
        -(rhs.rx() * self.as_inner().rx())
            + -(rhs.ty() * self.as_inner().ty())
            + -(rhs.tz() * self.as_inner().tz())
            + rhs.s() * self.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Motor<T>>> for Motor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Motor<T>>) -> T {
        -(rhs.as_inner().rx() * self.rx())
            + -(rhs.as_inner().ty() * self.ty())
            + -(rhs.as_inner().tz() * self.tz())
            + rhs.as_inner().s() * self.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Motor<T>>> for Unitized<Motor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Motor<T>>) -> T {
        -(rhs.as_inner().rx() * self.as_inner().rx())
            + -(rhs.as_inner().ty() * self.as_inner().ty())
            + -(rhs.as_inner().tz() * self.as_inner().tz())
            + rhs.as_inner().s() * self.as_inner().s()
    }
}
impl<T: Float> Dot<Scalar<T>> for Motor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Scalar<T>> for Unitized<Motor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        rhs.s() * self.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Scalar<T>>> for Motor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Scalar<T>>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Scalar<T>>> for Unitized<Motor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Scalar<T>>) -> T {
        T::zero()
    }
}
impl<T: Float> Dot<Flector<T>> for Plane<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Flector<T>) -> T {
        -(self.dist() * rhs.dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Flector<T>> for Unitized<Plane<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Flector<T>) -> T {
        -(rhs.dist() * self.as_inner().dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Flector<T>>> for Plane<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Flector<T>>) -> T {
        -(rhs.as_inner().dist() * self.dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Flector<T>>> for Unitized<Plane<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Flector<T>>) -> T {
        -(rhs.as_inner().dist() * self.as_inner().dist())
    }
}
impl<T: Float> Dot<Plane<T>> for Plane<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Plane<T>) -> T {
        -(self.dist() * rhs.dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Plane<T>> for Unitized<Plane<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Plane<T>) -> T {
        -(rhs.dist() * self.as_inner().dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Plane<T>>> for Plane<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Plane<T>>) -> T {
        -(rhs.as_inner().dist() * self.dist())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Plane<T>>> for Unitized<Plane<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Plane<T>>) -> T {
        -(rhs.as_inner().dist() * self.as_inner().dist())
    }
}
impl<T: Float> Dot<Flector<T>> for Point<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Flector<T>) -> T {
        self.x() * rhs.px() + self.y() * rhs.py() + self.z() * rhs.pz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Flector<T>> for Unitized<Point<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Flector<T>) -> T {
        rhs.px() * self.as_inner().x()
            + rhs.py() * self.as_inner().y()
            + rhs.pz() * self.as_inner().z()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Flector<T>>> for Point<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Flector<T>>) -> T {
        rhs.as_inner().px() * self.x()
            + rhs.as_inner().py() * self.y()
            + rhs.as_inner().pz() * self.z()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Flector<T>>> for Unitized<Point<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Flector<T>>) -> T {
        rhs.as_inner().px() * self.as_inner().x()
            + rhs.as_inner().py() * self.as_inner().y()
            + rhs.as_inner().pz() * self.as_inner().z()
    }
}
impl<T: Float> Dot<Point<T>> for Point<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Point<T>) -> T {
        self.x() * rhs.x() + self.y() * rhs.y() + self.z() * rhs.z()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Point<T>> for Unitized<Point<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Point<T>) -> T {
        rhs.x() * self.as_inner().x()
            + rhs.y() * self.as_inner().y()
            + rhs.z() * self.as_inner().z()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Point<T>>> for Point<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Point<T>>) -> T {
        rhs.as_inner().x() * self.x()
            + rhs.as_inner().y() * self.y()
            + rhs.as_inner().z() * self.z()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Point<T>>> for Unitized<Point<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Point<T>>) -> T {
        rhs.as_inner().x() * self.as_inner().x()
            + rhs.as_inner().y() * self.as_inner().y()
            + rhs.as_inner().z() * self.as_inner().z()
    }
}
impl<T: Float> Dot<Motor<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Motor<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Motor<T>> for Unitized<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Motor<T>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Motor<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Motor<T>>) -> T {
        rhs.as_inner().s() * self.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Motor<T>>> for Unitized<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Motor<T>>) -> T {
        T::zero()
    }
}
impl<T: Float> Dot<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Scalar<T>> for Unitized<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Scalar<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Scalar<T>>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Scalar<T>>) -> T {
        T::zero()
    }
}
impl<T: Float> Antidot<Flector<T>> for Flector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Flector<T>) -> T {
        -(self.pw() * rhs.pw()) + self.nz() * rhs.nz() + self.ny() * rhs.ny() + self.nx() * rhs.nx()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Flector<T>> for Unitized<Flector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Flector<T>) -> T {
        -(rhs.pw() * self.as_inner().pw())
            + rhs.nx() * self.as_inner().nx()
            + rhs.ny() * self.as_inner().ny()
            + rhs.nz() * self.as_inner().nz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Flector<T>>> for Flector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Flector<T>>) -> T {
        -(rhs.as_inner().pw() * self.pw())
            + rhs.as_inner().nx() * self.nx()
            + rhs.as_inner().ny() * self.ny()
            + rhs.as_inner().nz() * self.nz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Flector<T>>> for Unitized<Flector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Flector<T>>) -> T {
        -(rhs.as_inner().pw() * self.as_inner().pw())
            + rhs.as_inner().nx() * self.as_inner().nx()
            + rhs.as_inner().ny() * self.as_inner().ny()
            + rhs.as_inner().nz() * self.as_inner().nz()
    }
}
impl<T: Float> Antidot<Plane<T>> for Flector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Plane<T>) -> T {
        self.nz() * rhs.nz() + self.ny() * rhs.ny() + self.nx() * rhs.nx()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Plane<T>> for Unitized<Flector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Plane<T>) -> T {
        rhs.nx() * self.as_inner().nx()
            + rhs.ny() * self.as_inner().ny()
            + rhs.nz() * self.as_inner().nz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Plane<T>>> for Flector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Plane<T>>) -> T {
        rhs.as_inner().nx() * self.nx()
            + rhs.as_inner().ny() * self.ny()
            + rhs.as_inner().nz() * self.nz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Plane<T>>> for Unitized<Flector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Plane<T>>) -> T {
        rhs.as_inner().nx() * self.as_inner().nx()
            + rhs.as_inner().ny() * self.as_inner().ny()
            + rhs.as_inner().nz() * self.as_inner().nz()
    }
}
impl<T: Float> Antidot<Point<T>> for Flector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Point<T>) -> T {
        -(self.pw() * rhs.w())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Point<T>> for Unitized<Flector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Point<T>) -> T {
        -(rhs.w() * self.as_inner().pw())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Point<T>>> for Flector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Point<T>>) -> T {
        -(rhs.as_inner().w() * self.pw())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Point<T>>> for Unitized<Flector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Point<T>>) -> T {
        -(rhs.as_inner().w() * self.as_inner().pw())
    }
}
impl<T: Float> Antidot<Line<T>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Line<T>) -> T {
        -(self.dir_x() * rhs.dir_x()) - self.dir_y() * rhs.dir_y() - self.dir_z() * rhs.dir_z()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Line<T>> for Unitized<Line<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Line<T>) -> T {
        -(rhs.dir_x() * self.as_inner().dir_x())
            + -(rhs.dir_y() * self.as_inner().dir_y())
            + -(rhs.dir_z() * self.as_inner().dir_z())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Line<T>>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Line<T>>) -> T {
        -(rhs.as_inner().dir_x() * self.dir_x())
            + -(rhs.as_inner().dir_y() * self.dir_y())
            + -(rhs.as_inner().dir_z() * self.dir_z())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Line<T>>> for Unitized<Line<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Line<T>>) -> T {
        -(rhs.as_inner().dir_x() * self.as_inner().dir_x())
            + -(rhs.as_inner().dir_y() * self.as_inner().dir_y())
            + -(rhs.as_inner().dir_z() * self.as_inner().dir_z())
    }
}
impl<T: Float> Antidot<Motor<T>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Motor<T>) -> T {
        -(self.dir_x() * rhs.tx()) - self.dir_y() * rhs.ry() - self.dir_z() * rhs.rz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Motor<T>> for Unitized<Line<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Motor<T>) -> T {
        -(rhs.ry() * self.as_inner().dir_y())
            + -(rhs.rz() * self.as_inner().dir_z())
            + -(rhs.tx() * self.as_inner().dir_x())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Motor<T>>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Motor<T>>) -> T {
        -(rhs.as_inner().ry() * self.dir_y())
            + -(rhs.as_inner().rz() * self.dir_z())
            + -(rhs.as_inner().tx() * self.dir_x())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Motor<T>>> for Unitized<Line<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Motor<T>>) -> T {
        -(rhs.as_inner().ry() * self.as_inner().dir_y())
            + -(rhs.as_inner().rz() * self.as_inner().dir_z())
            + -(rhs.as_inner().tx() * self.as_inner().dir_x())
    }
}
impl<T: Float> Antidot<Line<T>> for Motor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Line<T>) -> T {
        -(self.tx() * rhs.dir_x()) - self.ry() * rhs.dir_y() - self.rz() * rhs.dir_z()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Line<T>> for Unitized<Motor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Line<T>) -> T {
        -(rhs.dir_x() * self.as_inner().tx())
            + -(rhs.dir_y() * self.as_inner().ry())
            + -(rhs.dir_z() * self.as_inner().rz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Line<T>>> for Motor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Line<T>>) -> T {
        -(rhs.as_inner().dir_x() * self.tx())
            + -(rhs.as_inner().dir_y() * self.ry())
            + -(rhs.as_inner().dir_z() * self.rz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Line<T>>> for Unitized<Motor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Line<T>>) -> T {
        -(rhs.as_inner().dir_x() * self.as_inner().tx())
            + -(rhs.as_inner().dir_y() * self.as_inner().ry())
            + -(rhs.as_inner().dir_z() * self.as_inner().rz())
    }
}
impl<T: Float> Antidot<Motor<T>> for Motor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Motor<T>) -> T {
        -(self.tx() * rhs.tx()) - self.ry() * rhs.ry() - self.rz() * rhs.rz() + self.ps() * rhs.ps()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Motor<T>> for Unitized<Motor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Motor<T>) -> T {
        -(rhs.ry() * self.as_inner().ry())
            + -(rhs.rz() * self.as_inner().rz())
            + -(rhs.tx() * self.as_inner().tx())
            + rhs.ps() * self.as_inner().ps()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Motor<T>>> for Motor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Motor<T>>) -> T {
        -(rhs.as_inner().ry() * self.ry())
            + -(rhs.as_inner().rz() * self.rz())
            + -(rhs.as_inner().tx() * self.tx())
            + rhs.as_inner().ps() * self.ps()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Motor<T>>> for Unitized<Motor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Motor<T>>) -> T {
        -(rhs.as_inner().ry() * self.as_inner().ry())
            + -(rhs.as_inner().rz() * self.as_inner().rz())
            + -(rhs.as_inner().tx() * self.as_inner().tx())
            + rhs.as_inner().ps() * self.as_inner().ps()
    }
}
impl<T: Float> Antidot<Quadvector<T>> for Motor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Quadvector<T>) -> T {
        self.ps() * rhs.ps()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Quadvector<T>> for Unitized<Motor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Quadvector<T>) -> T {
        rhs.ps() * self.as_inner().ps()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Quadvector<T>>> for Motor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Quadvector<T>>) -> T {
        rhs.as_inner().ps() * self.ps()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Quadvector<T>>> for Unitized<Motor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Quadvector<T>>) -> T {
        rhs.as_inner().ps() * self.as_inner().ps()
    }
}
impl<T: Float> Antidot<Flector<T>> for Plane<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Flector<T>) -> T {
        self.nz() * rhs.nz() + self.ny() * rhs.ny() + self.nx() * rhs.nx()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Flector<T>> for Unitized<Plane<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Flector<T>) -> T {
        rhs.nx() * self.as_inner().nx()
            + rhs.ny() * self.as_inner().ny()
            + rhs.nz() * self.as_inner().nz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Flector<T>>> for Plane<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Flector<T>>) -> T {
        rhs.as_inner().nx() * self.nx()
            + rhs.as_inner().ny() * self.ny()
            + rhs.as_inner().nz() * self.nz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Flector<T>>> for Unitized<Plane<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Flector<T>>) -> T {
        rhs.as_inner().nx() * self.as_inner().nx()
            + rhs.as_inner().ny() * self.as_inner().ny()
            + rhs.as_inner().nz() * self.as_inner().nz()
    }
}
impl<T: Float> Antidot<Plane<T>> for Plane<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Plane<T>) -> T {
        self.nz() * rhs.nz() + self.ny() * rhs.ny() + self.nx() * rhs.nx()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Plane<T>> for Unitized<Plane<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Plane<T>) -> T {
        rhs.nx() * self.as_inner().nx()
            + rhs.ny() * self.as_inner().ny()
            + rhs.nz() * self.as_inner().nz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Plane<T>>> for Plane<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Plane<T>>) -> T {
        rhs.as_inner().nx() * self.nx()
            + rhs.as_inner().ny() * self.ny()
            + rhs.as_inner().nz() * self.nz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Plane<T>>> for Unitized<Plane<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Plane<T>>) -> T {
        rhs.as_inner().nx() * self.as_inner().nx()
            + rhs.as_inner().ny() * self.as_inner().ny()
            + rhs.as_inner().nz() * self.as_inner().nz()
    }
}
impl<T: Float> Antidot<Flector<T>> for Point<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Flector<T>) -> T {
        -(self.w() * rhs.pw())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Flector<T>> for Unitized<Point<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Flector<T>) -> T {
        -(rhs.pw() * self.as_inner().w())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Flector<T>>> for Point<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Flector<T>>) -> T {
        -(rhs.as_inner().pw() * self.w())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Flector<T>>> for Unitized<Point<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Flector<T>>) -> T {
        -(rhs.as_inner().pw() * self.as_inner().w())
    }
}
impl<T: Float> Antidot<Point<T>> for Point<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Point<T>) -> T {
        -(self.w() * rhs.w())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Point<T>> for Unitized<Point<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Point<T>) -> T {
        -(rhs.w() * self.as_inner().w())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Point<T>>> for Point<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Point<T>>) -> T {
        -(rhs.as_inner().w() * self.w())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Point<T>>> for Unitized<Point<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Point<T>>) -> T {
        -(rhs.as_inner().w() * self.as_inner().w())
    }
}
impl<T: Float> Antidot<Motor<T>> for Quadvector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Motor<T>) -> T {
        self.ps() * rhs.ps()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Motor<T>> for Unitized<Quadvector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Motor<T>) -> T {
        rhs.ps() * self.as_inner().ps()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Motor<T>>> for Quadvector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Motor<T>>) -> T {
        rhs.as_inner().ps() * self.ps()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Motor<T>>> for Unitized<Quadvector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Motor<T>>) -> T {
        rhs.as_inner().ps() * self.as_inner().ps()
    }
}
impl<T: Float> Antidot<Quadvector<T>> for Quadvector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Quadvector<T>) -> T {
        self.ps() * rhs.ps()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Quadvector<T>> for Unitized<Quadvector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Quadvector<T>) -> T {
        rhs.ps() * self.as_inner().ps()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Quadvector<T>>> for Quadvector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Quadvector<T>>) -> T {
        rhs.as_inner().ps() * self.ps()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Quadvector<T>>> for Unitized<Quadvector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Quadvector<T>>) -> T {
        rhs.as_inner().ps() * self.as_inner().ps()
    }
}
impl<T: Float> Project<Line<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn project(&self, target: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.dir_x() * target.dir_x() * target.moment_z()
                + self.dir_y() * target.dir_y() * target.moment_z()
                + self.dir_z() * target.dir_z() * target.moment_z(),
            self.dir_x() * target.dir_x() * target.moment_y()
                + self.dir_y() * target.dir_y() * target.moment_y()
                + self.dir_z() * target.dir_z() * target.moment_y(),
            self.dir_x() * target.dir_x() * target.dir_x()
                + self.dir_y() * target.dir_y() * target.dir_x()
                + self.dir_z() * target.dir_z() * target.dir_x(),
            self.dir_x() * target.dir_x() * target.moment_x()
                + self.dir_y() * target.dir_y() * target.moment_x()
                + self.dir_z() * target.dir_z() * target.moment_x(),
            self.dir_x() * target.dir_x() * target.dir_y()
                + self.dir_y() * target.dir_y() * target.dir_y()
                + self.dir_z() * target.dir_z() * target.dir_y(),
            self.dir_x() * target.dir_x() * target.dir_z()
                + self.dir_y() * target.dir_y() * target.dir_z()
                + self.dir_z() * target.dir_z() * target.dir_z(),
        )
    }
}
impl<T: Float> Project<Line<T>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn project(&self, target: &Line<T>) -> Line<T> {
        self.as_inner().project(target)
    }
}
impl<T: Float> Project<Unitized<Line<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn project(&self, target: &Unitized<Line<T>>) -> Line<T> {
        self.project(target.as_inner())
    }
}
impl<T: Float> Project<Unitized<Line<T>>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn project(&self, target: &Unitized<Line<T>>) -> Line<T> {
        self.as_inner().project(target.as_inner())
    }
}
impl<T: Float> Project<Plane<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn project(&self, target: &Plane<T>) -> Line<T> {
        Line::new_unchecked(
            -(self.dir_x() * target.ny() * target.dist())
                - self.dir_y() * target.nx() * target.dist()
                + self.moment_x() * target.nx() * target.nz()
                + self.moment_y() * target.ny() * target.nz()
                + self.moment_z() * target.nz() * target.nz(),
            self.dir_x() * target.nz() * target.dist() - self.dir_z() * target.nx() * target.dist()
                + self.moment_x() * target.nx() * target.ny()
                + self.moment_y() * target.ny() * target.ny()
                + self.moment_z() * target.nz() * target.ny(),
            self.dir_x() * target.ny() * target.ny()
                + self.dir_x() * target.nz() * target.nz()
                + self.dir_y() * target.nx() * target.ny()
                - self.dir_z() * target.nx() * target.nz(),
            self.dir_y() * target.nz() * target.dist()
                + self.dir_z() * target.ny() * target.dist()
                + self.moment_x() * target.nx() * target.nx()
                + self.moment_y() * target.ny() * target.nx()
                + self.moment_z() * target.nz() * target.nx(),
            self.dir_x() * target.ny() * target.nx()
                + self.dir_y() * target.nx() * target.nx()
                + self.dir_y() * target.nz() * target.nz()
                + self.dir_z() * target.ny() * target.nz(),
            -(self.dir_x() * target.nz() * target.nx())
                + self.dir_y() * target.nz() * target.ny()
                + self.dir_z() * target.nx() * target.nx()
                + self.dir_z() * target.ny() * target.ny(),
        )
    }
}
impl<T: Float> Project<Plane<T>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn project(&self, target: &Plane<T>) -> Line<T> {
        self.as_inner().project(target)
    }
}
impl<T: Float> Project<Unitized<Plane<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn project(&self, target: &Unitized<Plane<T>>) -> Line<T> {
        self.project(target.as_inner())
    }
}
impl<T: Float> Project<Unitized<Plane<T>>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn project(&self, target: &Unitized<Plane<T>>) -> Line<T> {
        self.as_inner().project(target.as_inner())
    }
}
impl<T: Float> Project<Quadvector<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn project(&self, target: &Quadvector<T>) -> Line<T> {
        Line::new_unchecked(
            self.moment_z() * target.ps() * target.ps(),
            self.moment_y() * target.ps() * target.ps(),
            self.dir_x() * target.ps() * target.ps(),
            self.moment_x() * target.ps() * target.ps(),
            self.dir_y() * target.ps() * target.ps(),
            self.dir_z() * target.ps() * target.ps(),
        )
    }
}
impl<T: Float> Project<Quadvector<T>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn project(&self, target: &Quadvector<T>) -> Line<T> {
        self.as_inner().project(target)
    }
}
impl<T: Float> Project<Unitized<Quadvector<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn project(&self, target: &Unitized<Quadvector<T>>) -> Line<T> {
        self.project(target.as_inner())
    }
}
impl<T: Float> Project<Unitized<Quadvector<T>>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn project(&self, target: &Unitized<Quadvector<T>>) -> Line<T> {
        self.as_inner().project(target.as_inner())
    }
}
impl<T: Float> Project<Plane<T>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn project(&self, target: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            -(self.nx() * target.nx() * target.dist())
                - self.ny() * target.ny() * target.dist()
                - self.nz() * target.nz() * target.dist(),
            -(self.nx() * target.nx() * target.nz())
                - self.ny() * target.ny() * target.nz()
                - self.nz() * target.nz() * target.nz(),
            -(self.nx() * target.nx() * target.ny())
                - self.ny() * target.ny() * target.ny()
                - self.nz() * target.nz() * target.ny(),
            -(self.nx() * target.nx() * target.nx())
                - self.ny() * target.ny() * target.nx()
                - self.nz() * target.nz() * target.nx(),
        )
    }
}
impl<T: Float> Project<Plane<T>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn project(&self, target: &Plane<T>) -> Plane<T> {
        self.as_inner().project(target)
    }
}
impl<T: Float> Project<Unitized<Plane<T>>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn project(&self, target: &Unitized<Plane<T>>) -> Plane<T> {
        self.project(target.as_inner())
    }
}
impl<T: Float> Project<Unitized<Plane<T>>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn project(&self, target: &Unitized<Plane<T>>) -> Plane<T> {
        self.as_inner().project(target.as_inner())
    }
}
impl<T: Float> Project<Quadvector<T>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn project(&self, target: &Quadvector<T>) -> Plane<T> {
        Plane::new_unchecked(
            -(self.dist() * target.ps() * target.ps()),
            -(self.nz() * target.ps() * target.ps()),
            -(self.ny() * target.ps() * target.ps()),
            -(self.nx() * target.ps() * target.ps()),
        )
    }
}
impl<T: Float> Project<Quadvector<T>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn project(&self, target: &Quadvector<T>) -> Plane<T> {
        self.as_inner().project(target)
    }
}
impl<T: Float> Project<Unitized<Quadvector<T>>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn project(&self, target: &Unitized<Quadvector<T>>) -> Plane<T> {
        self.project(target.as_inner())
    }
}
impl<T: Float> Project<Unitized<Quadvector<T>>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn project(&self, target: &Unitized<Quadvector<T>>) -> Plane<T> {
        self.as_inner().project(target.as_inner())
    }
}
impl<T: Float> Project<Line<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn project(&self, target: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            self.w() * target.dir_y() * target.moment_z()
                + self.w() * target.dir_z() * target.moment_y()
                - self.x() * target.dir_x() * target.dir_x()
                - self.y() * target.dir_y() * target.dir_x()
                - self.z() * target.dir_z() * target.dir_x(),
            -(self.w() * target.dir_x() * target.moment_z())
                + self.w() * target.dir_z() * target.moment_x()
                - self.x() * target.dir_x() * target.dir_y()
                - self.y() * target.dir_y() * target.dir_y()
                - self.z() * target.dir_z() * target.dir_y(),
            -(self.w() * target.dir_x() * target.moment_y())
                - self.w() * target.dir_y() * target.moment_x()
                - self.x() * target.dir_x() * target.dir_z()
                - self.y() * target.dir_y() * target.dir_z()
                - self.z() * target.dir_z() * target.dir_z(),
            -(self.w() * target.dir_x() * target.dir_x())
                - self.w() * target.dir_y() * target.dir_y()
                - self.w() * target.dir_z() * target.dir_z(),
        )
    }
}
impl<T: Float> Project<Line<T>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn project(&self, target: &Line<T>) -> Point<T> {
        self.as_inner().project(target)
    }
}
impl<T: Float> Project<Unitized<Line<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn project(&self, target: &Unitized<Line<T>>) -> Point<T> {
        self.project(target.as_inner())
    }
}
impl<T: Float> Project<Unitized<Line<T>>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn project(&self, target: &Unitized<Line<T>>) -> Point<T> {
        self.as_inner().project(target.as_inner())
    }
}
impl<T: Float> Project<Plane<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn project(&self, target: &Plane<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.w() * target.nx() * target.dist())
                - self.x() * target.ny() * target.ny()
                - self.x() * target.nz() * target.nz()
                - self.y() * target.nx() * target.ny()
                + self.z() * target.nx() * target.nz(),
            self.w() * target.ny() * target.dist()
                - self.x() * target.ny() * target.nx()
                - self.y() * target.nx() * target.nx()
                - self.y() * target.nz() * target.nz()
                - self.z() * target.ny() * target.nz(),
            -(self.w() * target.nz() * target.dist()) + self.x() * target.nz() * target.nx()
                - self.y() * target.nz() * target.ny()
                - self.z() * target.nx() * target.nx()
                - self.z() * target.ny() * target.ny(),
            -(self.w() * target.nx() * target.nx())
                - self.w() * target.ny() * target.ny()
                - self.w() * target.nz() * target.nz(),
        )
    }
}
impl<T: Float> Project<Plane<T>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn project(&self, target: &Plane<T>) -> Point<T> {
        self.as_inner().project(target)
    }
}
impl<T: Float> Project<Unitized<Plane<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn project(&self, target: &Unitized<Plane<T>>) -> Point<T> {
        self.project(target.as_inner())
    }
}
impl<T: Float> Project<Unitized<Plane<T>>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn project(&self, target: &Unitized<Plane<T>>) -> Point<T> {
        self.as_inner().project(target.as_inner())
    }
}
impl<T: Float> Project<Point<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn project(&self, target: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.w() * target.w() * target.x()),
            -(self.w() * target.w() * target.y()),
            -(self.w() * target.w() * target.z()),
            -(self.w() * target.w() * target.w()),
        )
    }
}
impl<T: Float> Project<Point<T>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn project(&self, target: &Point<T>) -> Point<T> {
        self.as_inner().project(target)
    }
}
impl<T: Float> Project<Unitized<Point<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn project(&self, target: &Unitized<Point<T>>) -> Point<T> {
        self.project(target.as_inner())
    }
}
impl<T: Float> Project<Unitized<Point<T>>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn project(&self, target: &Unitized<Point<T>>) -> Point<T> {
        self.as_inner().project(target.as_inner())
    }
}
impl<T: Float> Project<Quadvector<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn project(&self, target: &Quadvector<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.x() * target.ps() * target.ps()),
            -(self.y() * target.ps() * target.ps()),
            -(self.z() * target.ps() * target.ps()),
            -(self.w() * target.ps() * target.ps()),
        )
    }
}
impl<T: Float> Project<Quadvector<T>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn project(&self, target: &Quadvector<T>) -> Point<T> {
        self.as_inner().project(target)
    }
}
impl<T: Float> Project<Unitized<Quadvector<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn project(&self, target: &Unitized<Quadvector<T>>) -> Point<T> {
        self.project(target.as_inner())
    }
}
impl<T: Float> Project<Unitized<Quadvector<T>>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn project(&self, target: &Unitized<Quadvector<T>>) -> Point<T> {
        self.as_inner().project(target.as_inner())
    }
}
impl<T: Float> Project<Quadvector<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn project(&self, target: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(self.ps() * target.ps() * target.ps())
    }
}
impl<T: Float> Project<Quadvector<T>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn project(&self, target: &Quadvector<T>) -> Quadvector<T> {
        self.as_inner().project(target)
    }
}
impl<T: Float> Project<Unitized<Quadvector<T>>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn project(&self, target: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        self.project(target.as_inner())
    }
}
impl<T: Float> Project<Unitized<Quadvector<T>>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn project(&self, target: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        self.as_inner().project(target.as_inner())
    }
}
impl<T: Float> Antiproject<Line<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn antiproject(&self, target: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.dir_x() * target.dir_x() * target.moment_z()
                + self.dir_y() * target.dir_y() * target.moment_z()
                + self.dir_z() * target.dir_z() * target.moment_z(),
            self.dir_x() * target.dir_x() * target.moment_y()
                + self.dir_y() * target.dir_y() * target.moment_y()
                + self.dir_z() * target.dir_z() * target.moment_y(),
            self.dir_x() * target.dir_x() * target.dir_x()
                + self.dir_y() * target.dir_y() * target.dir_x()
                + self.dir_z() * target.dir_z() * target.dir_x(),
            self.dir_x() * target.dir_x() * target.moment_x()
                + self.dir_y() * target.dir_y() * target.moment_x()
                + self.dir_z() * target.dir_z() * target.moment_x(),
            self.dir_x() * target.dir_x() * target.dir_y()
                + self.dir_y() * target.dir_y() * target.dir_y()
                + self.dir_z() * target.dir_z() * target.dir_y(),
            self.dir_x() * target.dir_x() * target.dir_z()
                + self.dir_y() * target.dir_y() * target.dir_z()
                + self.dir_z() * target.dir_z() * target.dir_z(),
        )
    }
}
impl<T: Float> Antiproject<Line<T>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn antiproject(&self, target: &Line<T>) -> Line<T> {
        self.as_inner().antiproject(target)
    }
}
impl<T: Float> Antiproject<Unitized<Line<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Line<T>>) -> Line<T> {
        self.antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Unitized<Line<T>>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Line<T>>) -> Line<T> {
        self.as_inner().antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Point<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn antiproject(&self, target: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            -(self.dir_x() * target.w() * target.y()) + self.dir_y() * target.w() * target.x(),
            -(self.dir_x() * target.w() * target.z()) + self.dir_z() * target.w() * target.x(),
            -(self.dir_x() * target.w() * target.w()),
            -(self.dir_y() * target.w() * target.z()) + self.dir_z() * target.w() * target.y(),
            -(self.dir_y() * target.w() * target.w()),
            -(self.dir_z() * target.w() * target.w()),
        )
    }
}
impl<T: Float> Antiproject<Point<T>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn antiproject(&self, target: &Point<T>) -> Line<T> {
        self.as_inner().antiproject(target)
    }
}
impl<T: Float> Antiproject<Unitized<Point<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Point<T>>) -> Line<T> {
        self.antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Unitized<Point<T>>> for Unitized<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Point<T>>) -> Line<T> {
        self.as_inner().antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Line<T>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn antiproject(&self, target: &Line<T>) -> Plane<T> {
        Plane::new_unchecked(
            self.nx() * target.dir_y() * target.moment_z()
                + self.nx() * target.dir_z() * target.moment_y()
                + self.ny() * target.dir_x() * target.moment_z()
                - self.ny() * target.dir_z() * target.moment_x()
                - self.nz() * target.dir_x() * target.moment_y()
                - self.nz() * target.dir_y() * target.moment_x(),
            self.nx() * target.dir_z() * target.dir_x()
                - self.ny() * target.dir_z() * target.dir_y()
                - self.nz() * target.dir_x() * target.dir_x()
                - self.nz() * target.dir_y() * target.dir_y(),
            -(self.nx() * target.dir_y() * target.dir_x())
                - self.ny() * target.dir_x() * target.dir_x()
                - self.ny() * target.dir_z() * target.dir_z()
                - self.nz() * target.dir_y() * target.dir_z(),
            -(self.nx() * target.dir_y() * target.dir_y())
                - self.nx() * target.dir_z() * target.dir_z()
                - self.ny() * target.dir_x() * target.dir_y()
                + self.nz() * target.dir_x() * target.dir_z(),
        )
    }
}
impl<T: Float> Antiproject<Line<T>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antiproject(&self, target: &Line<T>) -> Plane<T> {
        self.as_inner().antiproject(target)
    }
}
impl<T: Float> Antiproject<Unitized<Line<T>>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Line<T>>) -> Plane<T> {
        self.antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Unitized<Line<T>>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Line<T>>) -> Plane<T> {
        self.as_inner().antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Plane<T>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn antiproject(&self, target: &Plane<T>) -> Plane<T> {
        Plane::new_unchecked(
            self.nx() * target.nx() * target.dist()
                + self.ny() * target.ny() * target.dist()
                + self.nz() * target.nz() * target.dist(),
            self.nx() * target.nx() * target.nz()
                + self.ny() * target.ny() * target.nz()
                + self.nz() * target.nz() * target.nz(),
            self.nx() * target.nx() * target.ny()
                + self.ny() * target.ny() * target.ny()
                + self.nz() * target.nz() * target.ny(),
            self.nx() * target.nx() * target.nx()
                + self.ny() * target.ny() * target.nx()
                + self.nz() * target.nz() * target.nx(),
        )
    }
}
impl<T: Float> Antiproject<Plane<T>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antiproject(&self, target: &Plane<T>) -> Plane<T> {
        self.as_inner().antiproject(target)
    }
}
impl<T: Float> Antiproject<Unitized<Plane<T>>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Plane<T>>) -> Plane<T> {
        self.antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Unitized<Plane<T>>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Plane<T>>) -> Plane<T> {
        self.as_inner().antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Point<T>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn antiproject(&self, target: &Point<T>) -> Plane<T> {
        Plane::new_unchecked(
            self.nx() * target.w() * target.x() - self.ny() * target.w() * target.y()
                + self.nz() * target.w() * target.z(),
            self.nz() * target.w() * target.w(),
            self.ny() * target.w() * target.w(),
            self.nx() * target.w() * target.w(),
        )
    }
}
impl<T: Float> Antiproject<Point<T>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antiproject(&self, target: &Point<T>) -> Plane<T> {
        self.as_inner().antiproject(target)
    }
}
impl<T: Float> Antiproject<Unitized<Point<T>>> for Plane<T> {
    type Output = Plane<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Point<T>>) -> Plane<T> {
        self.antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Unitized<Point<T>>> for Unitized<Plane<T>> {
    type Output = Plane<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Point<T>>) -> Plane<T> {
        self.as_inner().antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Point<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn antiproject(&self, target: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.w() * target.w() * target.x(),
            self.w() * target.w() * target.y(),
            self.w() * target.w() * target.z(),
            self.w() * target.w() * target.w(),
        )
    }
}
impl<T: Float> Antiproject<Point<T>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn antiproject(&self, target: &Point<T>) -> Point<T> {
        self.as_inner().antiproject(target)
    }
}
impl<T: Float> Antiproject<Unitized<Point<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Point<T>>) -> Point<T> {
        self.antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Unitized<Point<T>>> for Unitized<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Point<T>>) -> Point<T> {
        self.as_inner().antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Line<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiproject(&self, target: &Line<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            self.ps() * target.dir_x() * target.dir_x()
                + self.ps() * target.dir_y() * target.dir_y()
                + self.ps() * target.dir_z() * target.dir_z(),
        )
    }
}
impl<T: Float> Antiproject<Line<T>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiproject(&self, target: &Line<T>) -> Quadvector<T> {
        self.as_inner().antiproject(target)
    }
}
impl<T: Float> Antiproject<Unitized<Line<T>>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Line<T>>) -> Quadvector<T> {
        self.antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Unitized<Line<T>>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Line<T>>) -> Quadvector<T> {
        self.as_inner().antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Plane<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiproject(&self, target: &Plane<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(
            -(self.ps() * target.nx() * target.nx())
                - self.ps() * target.ny() * target.ny()
                - self.ps() * target.nz() * target.nz(),
        )
    }
}
impl<T: Float> Antiproject<Plane<T>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiproject(&self, target: &Plane<T>) -> Quadvector<T> {
        self.as_inner().antiproject(target)
    }
}
impl<T: Float> Antiproject<Unitized<Plane<T>>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Plane<T>>) -> Quadvector<T> {
        self.antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Unitized<Plane<T>>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Plane<T>>) -> Quadvector<T> {
        self.as_inner().antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Point<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiproject(&self, target: &Point<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(-(self.ps() * target.w() * target.w()))
    }
}
impl<T: Float> Antiproject<Point<T>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiproject(&self, target: &Point<T>) -> Quadvector<T> {
        self.as_inner().antiproject(target)
    }
}
impl<T: Float> Antiproject<Unitized<Point<T>>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Point<T>>) -> Quadvector<T> {
        self.antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Unitized<Point<T>>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Point<T>>) -> Quadvector<T> {
        self.as_inner().antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Quadvector<T>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiproject(&self, target: &Quadvector<T>) -> Quadvector<T> {
        Quadvector::new_unchecked(self.ps() * target.ps() * target.ps())
    }
}
impl<T: Float> Antiproject<Quadvector<T>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiproject(&self, target: &Quadvector<T>) -> Quadvector<T> {
        self.as_inner().antiproject(target)
    }
}
impl<T: Float> Antiproject<Unitized<Quadvector<T>>> for Quadvector<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        self.antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Unitized<Quadvector<T>>> for Unitized<Quadvector<T>> {
    type Output = Quadvector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Quadvector<T>>) -> Quadvector<T> {
        self.as_inner().antiproject(target.as_inner())
    }
}
impl<T: Float> Reverse for Flector<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(
            self.px(),
            self.py(),
            self.pz(),
            self.pw(),
            -self.dist(),
            -self.nz(),
            -self.ny(),
            -self.nx(),
        )
    }
}
impl<T: Float> Reverse for Line<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(
            -self.moment_z(),
            -self.moment_y(),
            -self.dir_x(),
            -self.moment_x(),
            -self.dir_y(),
            -self.dir_z(),
        )
    }
}
impl<T: Float> Reverse for Motor<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(
            self.s(),
            -self.tz(),
            -self.ty(),
            -self.tx(),
            -self.rx(),
            -self.ry(),
            -self.rz(),
            self.ps(),
        )
    }
}
impl<T: Float> Reverse for Plane<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(-self.dist(), -self.nz(), -self.ny(), -self.nx())
    }
}
impl<T: Float> Reverse for Point<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.x(), self.y(), self.z(), self.w())
    }
}
impl<T: Float> Reverse for Quadvector<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.ps())
    }
}
impl<T: Float> Reverse for Scalar<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> Antireverse for Flector<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(
            -self.px(),
            -self.py(),
            -self.pz(),
            -self.pw(),
            self.dist(),
            self.nz(),
            self.ny(),
            self.nx(),
        )
    }
}
impl<T: Float> Antireverse for Line<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(
            -self.moment_z(),
            -self.moment_y(),
            -self.dir_x(),
            -self.moment_x(),
            -self.dir_y(),
            -self.dir_z(),
        )
    }
}
impl<T: Float> Antireverse for Motor<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(
            self.s(),
            -self.tz(),
            -self.ty(),
            -self.tx(),
            -self.rx(),
            -self.ry(),
            -self.rz(),
            self.ps(),
        )
    }
}
impl<T: Float> Antireverse for Plane<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.dist(), self.nz(), self.ny(), self.nx())
    }
}
impl<T: Float> Antireverse for Point<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(-self.x(), -self.y(), -self.z(), -self.w())
    }
}
impl<T: Float> Antireverse for Quadvector<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.ps())
    }
}
impl<T: Float> Antireverse for Scalar<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> Involute for Flector<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(
            self.px(),
            self.py(),
            self.pz(),
            self.pw(),
            -self.dist(),
            -self.nz(),
            -self.ny(),
            -self.nx(),
        )
    }
}
impl<T: Float> Involute for Line<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(
            -self.moment_z(),
            -self.moment_y(),
            -self.dir_x(),
            -self.moment_x(),
            -self.dir_y(),
            -self.dir_z(),
        )
    }
}
impl<T: Float> Involute for Motor<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(
            self.s(),
            -self.tz(),
            -self.ty(),
            -self.tx(),
            -self.rx(),
            -self.ry(),
            -self.rz(),
            self.ps(),
        )
    }
}
impl<T: Float> Involute for Plane<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(-self.dist(), -self.nz(), -self.ny(), -self.nx())
    }
}
impl<T: Float> Involute for Point<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.x(), self.y(), self.z(), self.w())
    }
}
impl<T: Float> Involute for Quadvector<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.ps())
    }
}
impl<T: Float> Involute for Scalar<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> RightComplement for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn right_complement(&self) -> Flector<T> {
        Flector::new_unchecked(
            -self.nx(),
            self.ny(),
            -self.nz(),
            self.dist(),
            -self.pw(),
            self.pz(),
            -self.py(),
            self.px(),
        )
    }
}
impl<T: Float> RightComplement for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn right_complement(&self) -> Line<T> {
        Line::new_unchecked(
            self.dir_z(),
            -self.dir_y(),
            self.moment_x(),
            self.dir_x(),
            -self.moment_y(),
            self.moment_z(),
        )
    }
}
impl<T: Float> RightComplement for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn right_complement(&self) -> Motor<T> {
        Motor::new_unchecked(
            self.ps(),
            self.rz(),
            -self.ry(),
            self.rx(),
            self.tx(),
            -self.ty(),
            self.tz(),
            self.s(),
        )
    }
}
impl<T: Float> RightComplement for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn right_complement(&self) -> Point<T> {
        Point::new_unchecked(-self.nx(), self.ny(), -self.nz(), self.dist())
    }
}
impl<T: Float> RightComplement for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn right_complement(&self) -> Plane<T> {
        Plane::new_unchecked(-self.w(), self.z(), -self.y(), self.x())
    }
}
impl<T: Float> RightComplement for Quadvector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_complement(&self) -> Scalar<T> {
        Scalar::new_unchecked(self.ps())
    }
}
impl<T: Float> RightComplement for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn right_complement(&self) -> Quadvector<T> {
        Quadvector::new_unchecked(self.s())
    }
}
impl<T: Float> WeightDual for Flector<T> {
    type Output = Flector<T>;
    #[inline]
    fn weight_dual(&self) -> Flector<T> {
        Flector::new_unchecked(
            -self.nx(),
            self.ny(),
            -self.nz(),
            T::zero(),
            -self.pw(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
impl<T: Float> WeightDual for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_dual(&self) -> Line<T> {
        Line::new_unchecked(
            self.dir_z(),
            -self.dir_y(),
            T::zero(),
            self.dir_x(),
            T::zero(),
            T::zero(),
        )
    }
}
impl<T: Float> WeightDual for Motor<T> {
    type Output = Motor<T>;
    #[inline]
    fn weight_dual(&self) -> Motor<T> {
        Motor::new_unchecked(
            self.ps(),
            self.rz(),
            -self.ry(),
            T::zero(),
            self.tx(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
impl<T: Float> WeightDual for Plane<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_dual(&self) -> Point<T> {
        Point::new_unchecked(-self.nx(), self.ny(), -self.nz(), T::zero())
    }
}
impl<T: Float> WeightDual for Point<T> {
    type Output = Plane<T>;
    #[inline]
    fn weight_dual(&self) -> Plane<T> {
        Plane::new_unchecked(-self.w(), T::zero(), T::zero(), T::zero())
    }
}
impl<T: Float> WeightDual for Quadvector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_dual(&self) -> Scalar<T> {
        Scalar::new_unchecked(self.ps())
    }
}
impl<T: Float> WeightDual for Scalar<T> {
    type Output = Quadvector<T>;
    #[inline]
    fn weight_dual(&self) -> Quadvector<T> {
        Quadvector::new_unchecked(T::zero())
    }
}
impl<T: Float> VersorInverse for Flector<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(
            self.px() * inv_norm_sq,
            self.py() * inv_norm_sq,
            self.pz() * inv_norm_sq,
            self.pw() * inv_norm_sq,
            -self.dist() * inv_norm_sq,
            -self.nz() * inv_norm_sq,
            -self.ny() * inv_norm_sq,
            -self.nx() * inv_norm_sq,
        ))
    }
}
impl<T: Float> VersorInverse for Line<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(
            -self.moment_z() * inv_norm_sq,
            -self.moment_y() * inv_norm_sq,
            -self.dir_x() * inv_norm_sq,
            -self.moment_x() * inv_norm_sq,
            -self.dir_y() * inv_norm_sq,
            -self.dir_z() * inv_norm_sq,
        ))
    }
}
impl<T: Float> VersorInverse for Motor<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(
            self.s() * inv_norm_sq,
            -self.tz() * inv_norm_sq,
            -self.ty() * inv_norm_sq,
            -self.tx() * inv_norm_sq,
            -self.rx() * inv_norm_sq,
            -self.ry() * inv_norm_sq,
            -self.rz() * inv_norm_sq,
            self.ps() * inv_norm_sq,
        ))
    }
}
impl<T: Float> VersorInverse for Plane<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(
            -self.dist() * inv_norm_sq,
            -self.nz() * inv_norm_sq,
            -self.ny() * inv_norm_sq,
            -self.nx() * inv_norm_sq,
        ))
    }
}
impl<T: Float> VersorInverse for Point<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(
            self.x() * inv_norm_sq,
            self.y() * inv_norm_sq,
            self.z() * inv_norm_sq,
            self.w() * inv_norm_sq,
        ))
    }
}
impl<T: Float> VersorInverse for Quadvector<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(self.ps() * inv_norm_sq))
    }
}
impl<T: Float> VersorInverse for Scalar<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(self.s() * inv_norm_sq))
    }
}
impl<T: Float> crate::norm::Normed for Flector<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.px() * self.px()
            + self.py() * self.py()
            + self.pz() * self.pz()
            + self.dist() * self.dist()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(
            self.px() * factor,
            self.py() * factor,
            self.pz() * factor,
            self.pw() * factor,
            self.dist() * factor,
            self.nz() * factor,
            self.ny() * factor,
            self.nx() * factor,
        )
    }
}
impl<T: Float> crate::norm::Normed for Line<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.moment_z() * self.moment_z()
            + self.moment_y() * self.moment_y()
            + self.moment_x() * self.moment_x()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(
            self.moment_z() * factor,
            self.moment_y() * factor,
            self.dir_x() * factor,
            self.moment_x() * factor,
            self.dir_y() * factor,
            self.dir_z() * factor,
        )
    }
}
impl<T: Float> crate::norm::Normed for Motor<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.s() * self.s() + self.tz() * self.tz() + self.ty() * self.ty() + self.rx() * self.rx()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(
            self.s() * factor,
            self.tz() * factor,
            self.ty() * factor,
            self.tx() * factor,
            self.rx() * factor,
            self.ry() * factor,
            self.rz() * factor,
            self.ps() * factor,
        )
    }
}
impl<T: Float> crate::norm::Normed for Plane<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.dist() * self.dist()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(
            self.dist() * factor,
            self.nz() * factor,
            self.ny() * factor,
            self.nx() * factor,
        )
    }
}
impl<T: Float> crate::norm::Normed for Point<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.x() * self.x() + self.y() * self.y() + self.z() * self.z()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(
            self.x() * factor,
            self.y() * factor,
            self.z() * factor,
            self.w() * factor,
        )
    }
}
impl<T: Float> crate::norm::Normed for Quadvector<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        T::zero()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.ps() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.s() * self.s()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.s() * factor)
    }
}
impl<T: Float> crate::norm::DegenerateNormed for Flector<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        self.px() * self.px()
            + self.py() * self.py()
            + self.pz() * self.pz()
            + self.dist() * self.dist()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        self.pw() * self.pw()
            + self.nz() * self.nz()
            + self.ny() * self.ny()
            + self.nx() * self.nx()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new_unchecked(
                self.px() * inv_w,
                self.py() * inv_w,
                self.pz() * inv_w,
                self.pw() * inv_w,
                self.dist() * inv_w,
                self.nz() * inv_w,
                self.ny() * inv_w,
                self.nx() * inv_w,
            ))
        }
    }
}
impl<T: Float> crate::norm::DegenerateNormed for Line<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        self.moment_z() * self.moment_z()
            + self.moment_y() * self.moment_y()
            + self.moment_x() * self.moment_x()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        self.dir_x() * self.dir_x() + self.dir_y() * self.dir_y() + self.dir_z() * self.dir_z()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new_unchecked(
                self.moment_z() * inv_w,
                self.moment_y() * inv_w,
                self.dir_x() * inv_w,
                self.moment_x() * inv_w,
                self.dir_y() * inv_w,
                self.dir_z() * inv_w,
            ))
        }
    }
}
impl<T: Float> crate::norm::DegenerateNormed for Motor<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        self.s() * self.s() + self.tz() * self.tz() + self.ty() * self.ty() + self.rx() * self.rx()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        self.tx() * self.tx()
            + self.ry() * self.ry()
            + self.rz() * self.rz()
            + self.ps() * self.ps()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new_unchecked(
                self.s() * inv_w,
                self.tz() * inv_w,
                self.ty() * inv_w,
                self.tx() * inv_w,
                self.rx() * inv_w,
                self.ry() * inv_w,
                self.rz() * inv_w,
                self.ps() * inv_w,
            ))
        }
    }
}
impl<T: Float> crate::norm::DegenerateNormed for Plane<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        self.dist() * self.dist()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        self.nz() * self.nz() + self.ny() * self.ny() + self.nx() * self.nx()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new_unchecked(
                self.dist() * inv_w,
                self.nz() * inv_w,
                self.ny() * inv_w,
                self.nx() * inv_w,
            ))
        }
    }
}
impl<T: Float> crate::norm::DegenerateNormed for Point<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        self.x() * self.x() + self.y() * self.y() + self.z() * self.z()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        self.w() * self.w()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new_unchecked(
                self.x() * inv_w,
                self.y() * inv_w,
                self.z() * inv_w,
                self.w() * inv_w,
            ))
        }
    }
}
impl<T: Float> crate::norm::DegenerateNormed for Quadvector<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        T::zero()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        self.ps() * self.ps()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new_unchecked(self.ps() * inv_w))
        }
    }
}
impl<T: Float> crate::norm::DegenerateNormed for Scalar<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        self.s() * self.s()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        T::zero()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new_unchecked(self.s() * inv_w))
        }
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Flector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.px().abs_diff_eq(&other.px(), epsilon)
            && self.py().abs_diff_eq(&other.py(), epsilon)
            && self.pz().abs_diff_eq(&other.pz(), epsilon)
            && self.pw().abs_diff_eq(&other.pw(), epsilon)
            && self.dist().abs_diff_eq(&other.dist(), epsilon)
            && self.nz().abs_diff_eq(&other.nz(), epsilon)
            && self.ny().abs_diff_eq(&other.ny(), epsilon)
            && self.nx().abs_diff_eq(&other.nx(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Flector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.px().relative_eq(&other.px(), epsilon, max_relative)
            && self.py().relative_eq(&other.py(), epsilon, max_relative)
            && self.pz().relative_eq(&other.pz(), epsilon, max_relative)
            && self.pw().relative_eq(&other.pw(), epsilon, max_relative)
            && self
                .dist()
                .relative_eq(&other.dist(), epsilon, max_relative)
            && self.nz().relative_eq(&other.nz(), epsilon, max_relative)
            && self.ny().relative_eq(&other.ny(), epsilon, max_relative)
            && self.nx().relative_eq(&other.nx(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Flector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.px().ulps_eq(&other.px(), epsilon, max_ulps)
            && self.py().ulps_eq(&other.py(), epsilon, max_ulps)
            && self.pz().ulps_eq(&other.pz(), epsilon, max_ulps)
            && self.pw().ulps_eq(&other.pw(), epsilon, max_ulps)
            && self.dist().ulps_eq(&other.dist(), epsilon, max_ulps)
            && self.nz().ulps_eq(&other.nz(), epsilon, max_ulps)
            && self.ny().ulps_eq(&other.ny(), epsilon, max_ulps)
            && self.nx().ulps_eq(&other.nx(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Line<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.moment_z().abs_diff_eq(&other.moment_z(), epsilon)
            && self.moment_y().abs_diff_eq(&other.moment_y(), epsilon)
            && self.dir_x().abs_diff_eq(&other.dir_x(), epsilon)
            && self.moment_x().abs_diff_eq(&other.moment_x(), epsilon)
            && self.dir_y().abs_diff_eq(&other.dir_y(), epsilon)
            && self.dir_z().abs_diff_eq(&other.dir_z(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Line<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.moment_z()
            .relative_eq(&other.moment_z(), epsilon, max_relative)
            && self
                .moment_y()
                .relative_eq(&other.moment_y(), epsilon, max_relative)
            && self
                .dir_x()
                .relative_eq(&other.dir_x(), epsilon, max_relative)
            && self
                .moment_x()
                .relative_eq(&other.moment_x(), epsilon, max_relative)
            && self
                .dir_y()
                .relative_eq(&other.dir_y(), epsilon, max_relative)
            && self
                .dir_z()
                .relative_eq(&other.dir_z(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Line<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.moment_z()
            .ulps_eq(&other.moment_z(), epsilon, max_ulps)
            && self
                .moment_y()
                .ulps_eq(&other.moment_y(), epsilon, max_ulps)
            && self.dir_x().ulps_eq(&other.dir_x(), epsilon, max_ulps)
            && self
                .moment_x()
                .ulps_eq(&other.moment_x(), epsilon, max_ulps)
            && self.dir_y().ulps_eq(&other.dir_y(), epsilon, max_ulps)
            && self.dir_z().ulps_eq(&other.dir_z(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Motor<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon)
            && self.tz().abs_diff_eq(&other.tz(), epsilon)
            && self.ty().abs_diff_eq(&other.ty(), epsilon)
            && self.tx().abs_diff_eq(&other.tx(), epsilon)
            && self.rx().abs_diff_eq(&other.rx(), epsilon)
            && self.ry().abs_diff_eq(&other.ry(), epsilon)
            && self.rz().abs_diff_eq(&other.rz(), epsilon)
            && self.ps().abs_diff_eq(&other.ps(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Motor<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
            && self.tz().relative_eq(&other.tz(), epsilon, max_relative)
            && self.ty().relative_eq(&other.ty(), epsilon, max_relative)
            && self.tx().relative_eq(&other.tx(), epsilon, max_relative)
            && self.rx().relative_eq(&other.rx(), epsilon, max_relative)
            && self.ry().relative_eq(&other.ry(), epsilon, max_relative)
            && self.rz().relative_eq(&other.rz(), epsilon, max_relative)
            && self.ps().relative_eq(&other.ps(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Motor<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
            && self.tz().ulps_eq(&other.tz(), epsilon, max_ulps)
            && self.ty().ulps_eq(&other.ty(), epsilon, max_ulps)
            && self.tx().ulps_eq(&other.tx(), epsilon, max_ulps)
            && self.rx().ulps_eq(&other.rx(), epsilon, max_ulps)
            && self.ry().ulps_eq(&other.ry(), epsilon, max_ulps)
            && self.rz().ulps_eq(&other.rz(), epsilon, max_ulps)
            && self.ps().ulps_eq(&other.ps(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Plane<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.dist().abs_diff_eq(&other.dist(), epsilon)
            && self.nz().abs_diff_eq(&other.nz(), epsilon)
            && self.ny().abs_diff_eq(&other.ny(), epsilon)
            && self.nx().abs_diff_eq(&other.nx(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Plane<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.dist()
            .relative_eq(&other.dist(), epsilon, max_relative)
            && self.nz().relative_eq(&other.nz(), epsilon, max_relative)
            && self.ny().relative_eq(&other.ny(), epsilon, max_relative)
            && self.nx().relative_eq(&other.nx(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Plane<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.dist().ulps_eq(&other.dist(), epsilon, max_ulps)
            && self.nz().ulps_eq(&other.nz(), epsilon, max_ulps)
            && self.ny().ulps_eq(&other.ny(), epsilon, max_ulps)
            && self.nx().ulps_eq(&other.nx(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Point<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.x().abs_diff_eq(&other.x(), epsilon)
            && self.y().abs_diff_eq(&other.y(), epsilon)
            && self.z().abs_diff_eq(&other.z(), epsilon)
            && self.w().abs_diff_eq(&other.w(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Point<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.x().relative_eq(&other.x(), epsilon, max_relative)
            && self.y().relative_eq(&other.y(), epsilon, max_relative)
            && self.z().relative_eq(&other.z(), epsilon, max_relative)
            && self.w().relative_eq(&other.w(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Point<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.x().ulps_eq(&other.x(), epsilon, max_ulps)
            && self.y().ulps_eq(&other.y(), epsilon, max_ulps)
            && self.z().ulps_eq(&other.z(), epsilon, max_ulps)
            && self.w().ulps_eq(&other.w(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Quadvector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.ps().abs_diff_eq(&other.ps(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Quadvector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.ps().relative_eq(&other.ps(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Quadvector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.ps().ulps_eq(&other.ps(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Scalar<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Scalar<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Scalar<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
    }
}
#[cfg(any(test, feature = "proptest-support"))]
#[allow(clippy::missing_docs_in_private_items)]
mod arbitrary_impls {
    use super::*;
    use proptest::prelude::*;
    use proptest::strategy::BoxedStrategy;
    use std::fmt::Debug;
    impl<T: Float + Debug + 'static> Arbitrary for Flector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
            )
                .prop_filter("non-zero divisor", |(x0, _x1, _x2, _x3, _x4, _x5, _x6)| {
                    (x0).abs() > 0.1
                })
                .prop_map(|(x0, x1, x2, x3, x4, x5, x6)| {
                    Flector::new_unchecked(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64(x3),
                        T::from_f64(x4),
                        T::from_f64(x5),
                        T::from_f64(x6),
                        T::from_f64((x6 * x1 - x2 * x5 + x3 * x4) / (x0)),
                    )
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Line<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
            )
                .prop_filter("non-zero divisor", |(x0, _x1, _x2, _x3, _x4)| {
                    (x0).abs() > 0.1
                })
                .prop_map(|(x0, x1, x2, x3, x4)| {
                    Line::new_unchecked(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64(x3),
                        T::from_f64(x4),
                        T::from_f64((x1 * x4 - x2 * x3) / (x0)),
                    )
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Motor<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
            )
                .prop_filter("non-zero divisor", |(x0, _x1, _x2, _x3, _x4, _x5, _x6)| {
                    (x0).abs() > 0.1
                })
                .prop_map(|(x0, x1, x2, x3, x4, x5, x6)| {
                    Motor::new_unchecked(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64(x3),
                        T::from_f64(x4),
                        T::from_f64(x5),
                        T::from_f64(x6),
                        T::from_f64((x6 * x1 - x5 * x2 + x4 * x3) / (x0)),
                    )
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Plane<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
            )
                .prop_map(|(x0, x1, x2, x3)| {
                    Plane::new_unchecked(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64(x3),
                    )
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Point<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
            )
                .prop_map(|(x0, x1, x2, x3)| {
                    Point::new_unchecked(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64(x3),
                    )
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Quadvector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| Quadvector::new_unchecked(T::from_f64(x0)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Scalar<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| Scalar::new_unchecked(T::from_f64(x0)))
                .boxed()
        }
    }
}

// ============================================================
// Verification Tests (compare against Multivector)
// ============================================================

#[cfg(test)]
#[allow(clippy::missing_docs_in_private_items)]
mod verification_tests {
    use super::*;
    use crate::algebra::Multivector;
    #[allow(unused_imports)]
    use crate::norm::{DegenerateNormed, Normed};
    use crate::signature::Projective3;
    #[allow(unused_imports)]
    use crate::wrappers::{Bulk, Unit, Unitized};
    use approx::relative_eq;
    use proptest::prelude::*;

    /// Relative epsilon for floating-point comparisons in verification tests.
    /// Using relative comparison handles varying magnitudes better than absolute.
    const REL_EPSILON: f64 = 1e-10;

    proptest! {
        #[test]
        fn flector_add_matches_multivector(a in any::<Flector<f64>>(), b in any::<Flector<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn flector_sub_matches_multivector(a in any::<Flector<f64>>(), b in any::<Flector<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn flector_neg_matches_multivector(a in any::<Flector<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn line_add_matches_multivector(a in any::<Line<f64>>(), b in any::<Line<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn line_sub_matches_multivector(a in any::<Line<f64>>(), b in any::<Line<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn line_neg_matches_multivector(a in any::<Line<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn motor_add_matches_multivector(a in any::<Motor<f64>>(), b in any::<Motor<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn motor_sub_matches_multivector(a in any::<Motor<f64>>(), b in any::<Motor<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn motor_neg_matches_multivector(a in any::<Motor<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn plane_add_matches_multivector(a in any::<Plane<f64>>(), b in any::<Plane<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn plane_sub_matches_multivector(a in any::<Plane<f64>>(), b in any::<Plane<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn plane_neg_matches_multivector(a in any::<Plane<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn point_add_matches_multivector(a in any::<Point<f64>>(), b in any::<Point<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn point_sub_matches_multivector(a in any::<Point<f64>>(), b in any::<Point<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn point_neg_matches_multivector(a in any::<Point<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn quadvector_add_matches_multivector(a in any::<Quadvector<f64>>(), b in any::<Quadvector<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn quadvector_sub_matches_multivector(a in any::<Quadvector<f64>>(), b in any::<Quadvector<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn quadvector_neg_matches_multivector(a in any::<Quadvector<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn scalar_add_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn scalar_sub_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn scalar_neg_matches_multivector(a in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_line_line_quadvector_matches_multivector(a in any::<Line<f64>>(), b in any::<Line<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Quadvector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_line_point_plane_matches_multivector(a in any::<Line<f64>>(), b in any::<Point<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Plane<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_line_scalar_line_matches_multivector(a in any::<Line<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Line<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_plane_point_quadvector_matches_multivector(a in any::<Plane<f64>>(), b in any::<Point<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Quadvector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_plane_scalar_plane_matches_multivector(a in any::<Plane<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Plane<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_point_line_plane_matches_multivector(a in any::<Point<f64>>(), b in any::<Line<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Plane<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_point_plane_quadvector_matches_multivector(a in any::<Point<f64>>(), b in any::<Plane<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Quadvector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_point_point_line_matches_multivector(a in any::<Point<f64>>(), b in any::<Point<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Line<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_point_scalar_point_matches_multivector(a in any::<Point<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Point<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_quadvector_scalar_quadvector_matches_multivector(a in any::<Quadvector<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Quadvector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_scalar_line_line_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Line<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Line<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_scalar_plane_plane_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Plane<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Plane<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_scalar_point_point_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Point<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Point<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_scalar_quadvector_quadvector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Quadvector<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Quadvector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_scalar_scalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Scalar<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_line_line_scalar_matches_multivector(a in any::<Line<f64>>(), b in any::<Line<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Scalar<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_line_point_point_matches_multivector(a in any::<Line<f64>>(), b in any::<Point<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Point<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_line_scalar_line_matches_multivector(a in any::<Line<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Line<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_plane_line_point_matches_multivector(a in any::<Plane<f64>>(), b in any::<Line<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Point<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_plane_plane_scalar_matches_multivector(a in any::<Plane<f64>>(), b in any::<Plane<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Scalar<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_plane_point_line_matches_multivector(a in any::<Plane<f64>>(), b in any::<Point<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Line<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_plane_scalar_plane_matches_multivector(a in any::<Plane<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Plane<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_point_point_scalar_matches_multivector(a in any::<Point<f64>>(), b in any::<Point<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Scalar<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_point_scalar_point_matches_multivector(a in any::<Point<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Point<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_quadvector_line_line_matches_multivector(a in any::<Quadvector<f64>>(), b in any::<Line<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Line<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_quadvector_plane_point_matches_multivector(a in any::<Quadvector<f64>>(), b in any::<Plane<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Point<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_quadvector_point_plane_matches_multivector(a in any::<Quadvector<f64>>(), b in any::<Point<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Plane<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_quadvector_scalar_quadvector_matches_multivector(a in any::<Quadvector<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Quadvector<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_scalar_scalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Scalar<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_line_line_scalar_matches_multivector(a in any::<Line<f64>>(), b in any::<Line<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Scalar<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_line_point_point_matches_multivector(a in any::<Line<f64>>(), b in any::<Point<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Point<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_plane_line_point_matches_multivector(a in any::<Plane<f64>>(), b in any::<Line<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Point<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_plane_plane_scalar_matches_multivector(a in any::<Plane<f64>>(), b in any::<Plane<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Scalar<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_plane_point_line_matches_multivector(a in any::<Plane<f64>>(), b in any::<Point<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Line<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_point_point_scalar_matches_multivector(a in any::<Point<f64>>(), b in any::<Point<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Scalar<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_quadvector_line_line_matches_multivector(a in any::<Quadvector<f64>>(), b in any::<Line<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Line<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_quadvector_plane_point_matches_multivector(a in any::<Quadvector<f64>>(), b in any::<Plane<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Point<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_quadvector_point_plane_matches_multivector(a in any::<Quadvector<f64>>(), b in any::<Point<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Plane<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_quadvector_quadvector_scalar_matches_multivector(a in any::<Quadvector<f64>>(), b in any::<Quadvector<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Scalar<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_line_line_quadvector_matches_multivector(a in any::<Line<f64>>(), b in any::<Line<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Quadvector<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_line_plane_plane_matches_multivector(a in any::<Line<f64>>(), b in any::<Plane<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Plane<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_plane_plane_quadvector_matches_multivector(a in any::<Plane<f64>>(), b in any::<Plane<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Quadvector<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_point_line_plane_matches_multivector(a in any::<Point<f64>>(), b in any::<Line<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Plane<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_point_plane_line_matches_multivector(a in any::<Point<f64>>(), b in any::<Plane<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Line<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_point_point_quadvector_matches_multivector(a in any::<Point<f64>>(), b in any::<Point<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Quadvector<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_scalar_line_line_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Line<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Line<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_scalar_plane_point_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Plane<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Point<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_scalar_point_plane_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Point<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Plane<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_scalar_scalar_quadvector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Quadvector<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_line_line_quadvector_matches_multivector(a in any::<Line<f64>>(), b in any::<Line<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Quadvector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_line_plane_plane_matches_multivector(a in any::<Line<f64>>(), b in any::<Plane<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Plane<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_line_quadvector_line_matches_multivector(a in any::<Line<f64>>(), b in any::<Quadvector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Line<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_plane_plane_quadvector_matches_multivector(a in any::<Plane<f64>>(), b in any::<Plane<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Quadvector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_plane_quadvector_plane_matches_multivector(a in any::<Plane<f64>>(), b in any::<Quadvector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Plane<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_point_line_plane_matches_multivector(a in any::<Point<f64>>(), b in any::<Line<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Plane<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_point_plane_line_matches_multivector(a in any::<Point<f64>>(), b in any::<Plane<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Line<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_point_point_quadvector_matches_multivector(a in any::<Point<f64>>(), b in any::<Point<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Quadvector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_point_quadvector_point_matches_multivector(a in any::<Point<f64>>(), b in any::<Quadvector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Point<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_quadvector_quadvector_quadvector_matches_multivector(a in any::<Quadvector<f64>>(), b in any::<Quadvector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Quadvector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_scalar_line_line_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Line<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Line<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_scalar_plane_point_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Plane<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Point<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_scalar_point_plane_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Point<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Plane<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_scalar_quadvector_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Quadvector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            let specialized_result: Scalar<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Projective3> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_line(a in any::<Line<f64>>(), b in any::<Line<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            // LHS: complement(a * b)
            let lhs = (mv_a * mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_line(a in any::<Line<f64>>(), b in any::<Line<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = mv_a.complement() * mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_plane(a in any::<Plane<f64>>(), b in any::<Plane<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            // LHS: complement(a * b)
            let lhs = (mv_a * mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_plane(a in any::<Plane<f64>>(), b in any::<Plane<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = mv_a.complement() * mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_point(a in any::<Point<f64>>(), b in any::<Point<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            // LHS: complement(a * b)
            let lhs = (mv_a * mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_point(a in any::<Point<f64>>(), b in any::<Point<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = mv_a.complement() * mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_quadvector(a in any::<Quadvector<f64>>(), b in any::<Quadvector<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            // LHS: complement(a * b)
            let lhs = (mv_a * mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_quadvector(a in any::<Quadvector<f64>>(), b in any::<Quadvector<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = mv_a.complement() * mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_scalar(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            // LHS: complement(a * b)
            let lhs = (mv_a * mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_scalar(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = mv_a.complement() * mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// Project idempotency with normalized target: project(project(a, unit_b), unit_b) == project(a, unit_b)
        #[test]
        fn project_idempotent_line_point(a in any::<Line<f64>>(), unit_b in any::<Unitized<Point<f64>>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = unit_b.into_inner().into();

            let first = mv_a.project(&mv_b);
            let second = first.project(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Project idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Project idempotency with normalized target: project(project(a, unit_b), unit_b) == project(a, unit_b)
        #[test]
        fn project_idempotent_plane_line(a in any::<Plane<f64>>(), unit_b in any::<Unitized<Line<f64>>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = unit_b.into_inner().into();

            let first = mv_a.project(&mv_b);
            let second = first.project(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Project idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Project idempotency with normalized target: project(project(a, unit_b), unit_b) == project(a, unit_b)
        #[test]
        fn project_idempotent_plane_point(a in any::<Plane<f64>>(), unit_b in any::<Unitized<Point<f64>>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = unit_b.into_inner().into();

            let first = mv_a.project(&mv_b);
            let second = first.project(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Project idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Project idempotency with normalized target: project(project(a, unit_b), unit_b) == project(a, unit_b)
        #[test]
        fn project_idempotent_quadvector_line(a in any::<Quadvector<f64>>(), unit_b in any::<Unitized<Line<f64>>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = unit_b.into_inner().into();

            let first = mv_a.project(&mv_b);
            let second = first.project(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Project idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Project idempotency with normalized target: project(project(a, unit_b), unit_b) == project(a, unit_b)
        #[test]
        fn project_idempotent_quadvector_plane(a in any::<Quadvector<f64>>(), unit_b in any::<Unitized<Plane<f64>>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = unit_b.into_inner().into();

            let first = mv_a.project(&mv_b);
            let second = first.project(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Project idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Project idempotency with normalized target: project(project(a, unit_b), unit_b) == project(a, unit_b)
        #[test]
        fn project_idempotent_quadvector_point(a in any::<Quadvector<f64>>(), unit_b in any::<Unitized<Point<f64>>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = unit_b.into_inner().into();

            let first = mv_a.project(&mv_b);
            let second = first.project(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Project idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Antiproject idempotency with normalized target: antiproject(antiproject(a, unit_b), unit_b) == antiproject(a, unit_b)
        #[test]
        fn antiproject_idempotent_line_plane(a in any::<Line<f64>>(), unit_b in any::<Unitized<Plane<f64>>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = unit_b.into_inner().into();

            let first = mv_a.antiproject(&mv_b);
            let second = first.antiproject(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Antiproject idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Antiproject idempotency with normalized target: antiproject(antiproject(a, unit_b), unit_b) == antiproject(a, unit_b)
        #[test]
        fn antiproject_idempotent_line_quadvector(a in any::<Line<f64>>(), unit_b in any::<Unitized<Quadvector<f64>>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = unit_b.into_inner().into();

            let first = mv_a.antiproject(&mv_b);
            let second = first.antiproject(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Antiproject idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Antiproject idempotency with normalized target: antiproject(antiproject(a, unit_b), unit_b) == antiproject(a, unit_b)
        #[test]
        fn antiproject_idempotent_plane_quadvector(a in any::<Plane<f64>>(), unit_b in any::<Unitized<Quadvector<f64>>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = unit_b.into_inner().into();

            let first = mv_a.antiproject(&mv_b);
            let second = first.antiproject(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Antiproject idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Antiproject idempotency with normalized target: antiproject(antiproject(a, unit_b), unit_b) == antiproject(a, unit_b)
        #[test]
        fn antiproject_idempotent_point_line(a in any::<Point<f64>>(), unit_b in any::<Unitized<Line<f64>>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = unit_b.into_inner().into();

            let first = mv_a.antiproject(&mv_b);
            let second = first.antiproject(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Antiproject idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Antiproject idempotency with normalized target: antiproject(antiproject(a, unit_b), unit_b) == antiproject(a, unit_b)
        #[test]
        fn antiproject_idempotent_point_plane(a in any::<Point<f64>>(), unit_b in any::<Unitized<Plane<f64>>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = unit_b.into_inner().into();

            let first = mv_a.antiproject(&mv_b);
            let second = first.antiproject(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Antiproject idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Antiproject idempotency with normalized target: antiproject(antiproject(a, unit_b), unit_b) == antiproject(a, unit_b)
        #[test]
        fn antiproject_idempotent_point_quadvector(a in any::<Point<f64>>(), unit_b in any::<Unitized<Quadvector<f64>>>()) {
            let mv_a: Multivector<f64, Projective3> = a.into();
            let mv_b: Multivector<f64, Projective3> = unit_b.into_inner().into();

            let first = mv_a.antiproject(&mv_b);
            let second = first.antiproject(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Antiproject idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Bulk<Flector>.bulk_norm() should equal 1.0 (by definition of Bulk wrapper).
        #[test]
        fn bulk_flector_bulk_norm_matches_inner(b in any::<Bulk<Flector<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_bulk = <Flector<f64> as DegenerateNormed>::bulk_norm(b.as_inner());
            let wrapper_bulk = <Bulk<Flector<f64>> as DegenerateNormed>::bulk_norm(&b);

            prop_assert!(
                relative_eq!(inner_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Inner bulk_norm should be 1.0, got {}", inner_bulk
            );
            prop_assert!(
                relative_eq!(wrapper_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wrapper bulk_norm should be 1.0, got {}", wrapper_bulk
            );
        }

        /// Bulk<Flector>.weight_norm() should match inner's weight_norm (delegation).
        #[test]
        fn bulk_flector_weight_norm_delegates(b in any::<Bulk<Flector<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_weight = <Flector<f64> as DegenerateNormed>::weight_norm(b.as_inner());
            let wrapper_weight = <Bulk<Flector<f64>> as DegenerateNormed>::weight_norm(&b);

            prop_assert!(
                relative_eq!(inner_weight, wrapper_weight, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight norms should match: {} vs {}", inner_weight, wrapper_weight
            );
        }
    }

    proptest! {
        /// Bulk<Line>.bulk_norm() should equal 1.0 (by definition of Bulk wrapper).
        #[test]
        fn bulk_line_bulk_norm_matches_inner(b in any::<Bulk<Line<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_bulk = <Line<f64> as DegenerateNormed>::bulk_norm(b.as_inner());
            let wrapper_bulk = <Bulk<Line<f64>> as DegenerateNormed>::bulk_norm(&b);

            prop_assert!(
                relative_eq!(inner_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Inner bulk_norm should be 1.0, got {}", inner_bulk
            );
            prop_assert!(
                relative_eq!(wrapper_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wrapper bulk_norm should be 1.0, got {}", wrapper_bulk
            );
        }

        /// Bulk<Line>.weight_norm() should match inner's weight_norm (delegation).
        #[test]
        fn bulk_line_weight_norm_delegates(b in any::<Bulk<Line<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_weight = <Line<f64> as DegenerateNormed>::weight_norm(b.as_inner());
            let wrapper_weight = <Bulk<Line<f64>> as DegenerateNormed>::weight_norm(&b);

            prop_assert!(
                relative_eq!(inner_weight, wrapper_weight, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight norms should match: {} vs {}", inner_weight, wrapper_weight
            );
        }
    }

    proptest! {
        /// Bulk<Motor>.bulk_norm() should equal 1.0 (by definition of Bulk wrapper).
        #[test]
        fn bulk_motor_bulk_norm_matches_inner(b in any::<Bulk<Motor<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_bulk = <Motor<f64> as DegenerateNormed>::bulk_norm(b.as_inner());
            let wrapper_bulk = <Bulk<Motor<f64>> as DegenerateNormed>::bulk_norm(&b);

            prop_assert!(
                relative_eq!(inner_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Inner bulk_norm should be 1.0, got {}", inner_bulk
            );
            prop_assert!(
                relative_eq!(wrapper_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wrapper bulk_norm should be 1.0, got {}", wrapper_bulk
            );
        }

        /// Bulk<Motor>.weight_norm() should match inner's weight_norm (delegation).
        #[test]
        fn bulk_motor_weight_norm_delegates(b in any::<Bulk<Motor<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_weight = <Motor<f64> as DegenerateNormed>::weight_norm(b.as_inner());
            let wrapper_weight = <Bulk<Motor<f64>> as DegenerateNormed>::weight_norm(&b);

            prop_assert!(
                relative_eq!(inner_weight, wrapper_weight, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight norms should match: {} vs {}", inner_weight, wrapper_weight
            );
        }
    }

    proptest! {
        /// Bulk<Plane>.bulk_norm() should equal 1.0 (by definition of Bulk wrapper).
        #[test]
        fn bulk_plane_bulk_norm_matches_inner(b in any::<Bulk<Plane<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_bulk = <Plane<f64> as DegenerateNormed>::bulk_norm(b.as_inner());
            let wrapper_bulk = <Bulk<Plane<f64>> as DegenerateNormed>::bulk_norm(&b);

            prop_assert!(
                relative_eq!(inner_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Inner bulk_norm should be 1.0, got {}", inner_bulk
            );
            prop_assert!(
                relative_eq!(wrapper_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wrapper bulk_norm should be 1.0, got {}", wrapper_bulk
            );
        }

        /// Bulk<Plane>.weight_norm() should match inner's weight_norm (delegation).
        #[test]
        fn bulk_plane_weight_norm_delegates(b in any::<Bulk<Plane<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_weight = <Plane<f64> as DegenerateNormed>::weight_norm(b.as_inner());
            let wrapper_weight = <Bulk<Plane<f64>> as DegenerateNormed>::weight_norm(&b);

            prop_assert!(
                relative_eq!(inner_weight, wrapper_weight, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight norms should match: {} vs {}", inner_weight, wrapper_weight
            );
        }
    }

    proptest! {
        /// Bulk<Point>.bulk_norm() should equal 1.0 (by definition of Bulk wrapper).
        #[test]
        fn bulk_point_bulk_norm_matches_inner(b in any::<Bulk<Point<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_bulk = <Point<f64> as DegenerateNormed>::bulk_norm(b.as_inner());
            let wrapper_bulk = <Bulk<Point<f64>> as DegenerateNormed>::bulk_norm(&b);

            prop_assert!(
                relative_eq!(inner_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Inner bulk_norm should be 1.0, got {}", inner_bulk
            );
            prop_assert!(
                relative_eq!(wrapper_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wrapper bulk_norm should be 1.0, got {}", wrapper_bulk
            );
        }

        /// Bulk<Point>.weight_norm() should match inner's weight_norm (delegation).
        #[test]
        fn bulk_point_weight_norm_delegates(b in any::<Bulk<Point<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_weight = <Point<f64> as DegenerateNormed>::weight_norm(b.as_inner());
            let wrapper_weight = <Bulk<Point<f64>> as DegenerateNormed>::weight_norm(&b);

            prop_assert!(
                relative_eq!(inner_weight, wrapper_weight, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight norms should match: {} vs {}", inner_weight, wrapper_weight
            );
        }
    }

    proptest! {
        /// Bulk<Scalar>.bulk_norm() should equal 1.0 (by definition of Bulk wrapper).
        #[test]
        fn bulk_scalar_bulk_norm_matches_inner(b in any::<Bulk<Scalar<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_bulk = <Scalar<f64> as DegenerateNormed>::bulk_norm(b.as_inner());
            let wrapper_bulk = <Bulk<Scalar<f64>> as DegenerateNormed>::bulk_norm(&b);

            prop_assert!(
                relative_eq!(inner_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Inner bulk_norm should be 1.0, got {}", inner_bulk
            );
            prop_assert!(
                relative_eq!(wrapper_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wrapper bulk_norm should be 1.0, got {}", wrapper_bulk
            );
        }

        /// Bulk<Scalar>.weight_norm() should match inner's weight_norm (delegation).
        #[test]
        fn bulk_scalar_weight_norm_delegates(b in any::<Bulk<Scalar<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_weight = <Scalar<f64> as DegenerateNormed>::weight_norm(b.as_inner());
            let wrapper_weight = <Bulk<Scalar<f64>> as DegenerateNormed>::weight_norm(&b);

            prop_assert!(
                relative_eq!(inner_weight, wrapper_weight, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight norms should match: {} vs {}", inner_weight, wrapper_weight
            );
        }
    }
}
