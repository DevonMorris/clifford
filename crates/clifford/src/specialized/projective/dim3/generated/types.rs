#![doc = " Type definitions for projective3."]
#![doc = ""]
#![doc = " 3D Projective Geometric Algebra"]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
#![allow(clippy::too_many_arguments)]
use crate::scalar::Float;
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
#[doc = "3D reflection/glide transformation\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 1 | e1 | `px` |\n| 2 | e2 | `py` |\n| 4 | e3 | `pz` |\n| 8 | e4 | `pw` |\n| 7 | e1e2e3 | `dist` |\n| 11 | e1e2e4 | `nz` |\n| 13 | e1e3e4 | `ny` |\n| 14 | e2e3e4 | `nx` |\n\n\n# Example\n\n```\nuse clifford::specialized::projective::dim3::Flector;\n\nlet v = Flector::new_unchecked(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Flector<T: Float> {
    #[doc = "Coefficient of `px`."]
    px: T,
    #[doc = "Coefficient of `py`."]
    py: T,
    #[doc = "Coefficient of `pz`."]
    pz: T,
    #[doc = "Coefficient of `pw`."]
    pw: T,
    #[doc = "Coefficient of `dist`."]
    dist: T,
    #[doc = "Coefficient of `nz`."]
    nz: T,
    #[doc = "Coefficient of `ny`."]
    ny: T,
    #[doc = "Coefficient of `nx`."]
    nx: T,
}
impl<T: Float> Flector<T> {
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" **Warning:** This does not validate the geometric constraint."]
    #[doc = r" Use `new_checked()` to validate, or `from_components()` to"]
    #[doc = r" construct from independent parameters."]
    #[inline]
    pub fn new_unchecked(px: T, py: T, pz: T, pw: T, dist: T, nz: T, ny: T, nx: T) -> Self {
        Self {
            px,
            py,
            pz,
            pw,
            dist,
            nz,
            ny,
            nx,
        }
    }
    #[doc = r" Creates a new element, validating the geometric constraint."]
    #[doc = r""]
    #[doc = r" Returns `Err` if the constraint is violated beyond the given tolerance."]
    #[inline]
    pub fn new_checked(
        px: T,
        py: T,
        pz: T,
        pw: T,
        dist: T,
        nz: T,
        ny: T,
        nx: T,
        tolerance: T,
    ) -> Result<Self, &'static str> {
        let expected = (ny * py - pz * nz + pw * dist) / (px);
        let actual = nx;
        if (actual - expected).abs() > tolerance {
            return Err("Flector constraint");
        }
        Ok(Self::new_unchecked(px, py, pz, pw, dist, nz, ny, nx))
    }
    #[doc = "Creates a Flector from 7 independent components, computing `nx`.\n\nReturns `None` if the divisor would be zero (unstable computation)."]
    #[inline]
    pub fn from_components(px: T, py: T, pz: T, pw: T, dist: T, nz: T, ny: T) -> Option<Self> {
        if (px).abs() < T::epsilon() {
            return None;
        }
        Some(Self::new_unchecked(
            px,
            py,
            pz,
            pw,
            dist,
            nz,
            ny,
            (ny * py - pz * nz + pw * dist) / (px),
        ))
    }
    #[doc = "Returns the `px` coefficient."]
    #[inline]
    pub fn px(&self) -> T {
        self.px
    }
    #[doc = "Returns the `py` coefficient."]
    #[inline]
    pub fn py(&self) -> T {
        self.py
    }
    #[doc = "Returns the `pz` coefficient."]
    #[inline]
    pub fn pz(&self) -> T {
        self.pz
    }
    #[doc = "Returns the `pw` coefficient."]
    #[inline]
    pub fn pw(&self) -> T {
        self.pw
    }
    #[doc = "Returns the `dist` coefficient."]
    #[inline]
    pub fn dist(&self) -> T {
        self.dist
    }
    #[doc = "Returns the `nz` coefficient."]
    #[inline]
    pub fn nz(&self) -> T {
        self.nz
    }
    #[doc = "Returns the `ny` coefficient."]
    #[inline]
    pub fn ny(&self) -> T {
        self.ny
    }
    #[doc = "Returns the `nx` coefficient."]
    #[inline]
    pub fn nx(&self) -> T {
        self.nx
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.px * self.px + self.py * self.py + self.pz * self.pz + self.dist * self.dist
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(
            self.px * s,
            self.py * s,
            self.pz * s,
            self.pw * s,
            self.dist * s,
            self.nz * s,
            self.ny * s,
            self.nx * s,
        )
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(
            self.px, self.py, self.pz, self.pw, -self.dist, -self.nz, -self.ny, -self.nx,
        )
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(
            -self.px, -self.py, -self.pz, -self.pw, self.dist, self.nz, self.ny, self.nx,
        )
    }
}
impl<T: Float> Default for Flector<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "3D line in Pl√ºcker coordinates\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 3 | e1e2 | `moment_z` |\n| 5 | e1e3 | `moment_y` |\n| 9 | e1e4 | `dir_x` |\n| 6 | e2e3 | `moment_x` |\n| 10 | e2e4 | `dir_y` |\n| 12 | e3e4 | `dir_z` |\n\n\n# Example\n\n```\nuse clifford::specialized::projective::dim3::Line;\n\nlet v = Line::new_unchecked(1.0, 2.0, 3.0, 4.0, 5.0, 6.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Line<T: Float> {
    #[doc = "Coefficient of `moment_z`."]
    moment_z: T,
    #[doc = "Coefficient of `moment_y`."]
    moment_y: T,
    #[doc = "Coefficient of `dir_x`."]
    dir_x: T,
    #[doc = "Coefficient of `moment_x`."]
    moment_x: T,
    #[doc = "Coefficient of `dir_y`."]
    dir_y: T,
    #[doc = "Coefficient of `dir_z`."]
    dir_z: T,
}
impl<T: Float> Line<T> {
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" **Warning:** This does not validate the geometric constraint."]
    #[doc = r" Use `new_checked()` to validate, or `from_components()` to"]
    #[doc = r" construct from independent parameters."]
    #[inline]
    pub fn new_unchecked(
        moment_z: T,
        moment_y: T,
        dir_x: T,
        moment_x: T,
        dir_y: T,
        dir_z: T,
    ) -> Self {
        Self {
            moment_z,
            moment_y,
            dir_x,
            moment_x,
            dir_y,
            dir_z,
        }
    }
    #[doc = r" Creates a new element, validating the geometric constraint."]
    #[doc = r""]
    #[doc = r" Returns `Err` if the constraint is violated beyond the given tolerance."]
    #[inline]
    pub fn new_checked(
        moment_z: T,
        moment_y: T,
        dir_x: T,
        moment_x: T,
        dir_y: T,
        dir_z: T,
        tolerance: T,
    ) -> Result<Self, &'static str> {
        let expected = (moment_y * dir_y - dir_x * moment_x) / (moment_z);
        let actual = dir_z;
        if (actual - expected).abs() > tolerance {
            return Err("Line constraint");
        }
        Ok(Self::new_unchecked(
            moment_z, moment_y, dir_x, moment_x, dir_y, dir_z,
        ))
    }
    #[doc = "Creates a Line from 5 independent components, computing `dir_z`.\n\nReturns `None` if the divisor would be zero (unstable computation)."]
    #[inline]
    pub fn from_components(
        moment_z: T,
        moment_y: T,
        dir_x: T,
        moment_x: T,
        dir_y: T,
    ) -> Option<Self> {
        if (moment_z).abs() < T::epsilon() {
            return None;
        }
        Some(Self::new_unchecked(
            moment_z,
            moment_y,
            dir_x,
            moment_x,
            dir_y,
            (moment_y * dir_y - dir_x * moment_x) / (moment_z),
        ))
    }
    #[doc = "Returns the `moment_z` coefficient."]
    #[inline]
    pub fn moment_z(&self) -> T {
        self.moment_z
    }
    #[doc = "Returns the `moment_y` coefficient."]
    #[inline]
    pub fn moment_y(&self) -> T {
        self.moment_y
    }
    #[doc = "Returns the `dir_x` coefficient."]
    #[inline]
    pub fn dir_x(&self) -> T {
        self.dir_x
    }
    #[doc = "Returns the `moment_x` coefficient."]
    #[inline]
    pub fn moment_x(&self) -> T {
        self.moment_x
    }
    #[doc = "Returns the `dir_y` coefficient."]
    #[inline]
    pub fn dir_y(&self) -> T {
        self.dir_y
    }
    #[doc = "Returns the `dir_z` coefficient."]
    #[inline]
    pub fn dir_z(&self) -> T {
        self.dir_z
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e2 element."]
    #[inline]
    pub fn unit_moment_z() -> Self {
        Self::new_unchecked(
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e3 element."]
    #[inline]
    pub fn unit_moment_y() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e4 element."]
    #[inline]
    pub fn unit_dir_x() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e2e3 element."]
    #[inline]
    pub fn unit_moment_x() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e2e4 element."]
    #[inline]
    pub fn unit_dir_y() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e3e4 element."]
    #[inline]
    pub fn unit_dir_z() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
        )
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.moment_z * self.moment_z
            + self.moment_y * self.moment_y
            + self.moment_x * self.moment_x
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(
            self.moment_z * s,
            self.moment_y * s,
            self.dir_x * s,
            self.moment_x * s,
            self.dir_y * s,
            self.dir_z * s,
        )
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(
            -self.moment_z,
            -self.moment_y,
            -self.dir_x,
            -self.moment_x,
            -self.dir_y,
            -self.dir_z,
        )
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(
            -self.moment_z,
            -self.moment_y,
            -self.dir_x,
            -self.moment_x,
            -self.dir_y,
            -self.dir_z,
        )
    }
}
impl<T: Float> Default for Line<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "3D rigid transformation (rotation + translation)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 0 | s | `s` |\n| 3 | e1e2 | `tz` |\n| 5 | e1e3 | `ty` |\n| 9 | e1e4 | `tx` |\n| 6 | e2e3 | `rx` |\n| 10 | e2e4 | `ry` |\n| 12 | e3e4 | `rz` |\n| 15 | e1e2e3e4 | `ps` |\n\n\n# Example\n\n```\nuse clifford::specialized::projective::dim3::Motor;\n\nlet v = Motor::new_unchecked(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Motor<T: Float> {
    #[doc = "Coefficient of `s`."]
    s: T,
    #[doc = "Coefficient of `tz`."]
    tz: T,
    #[doc = "Coefficient of `ty`."]
    ty: T,
    #[doc = "Coefficient of `tx`."]
    tx: T,
    #[doc = "Coefficient of `rx`."]
    rx: T,
    #[doc = "Coefficient of `ry`."]
    ry: T,
    #[doc = "Coefficient of `rz`."]
    rz: T,
    #[doc = "Coefficient of `ps`."]
    ps: T,
}
impl<T: Float> Motor<T> {
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" **Warning:** This does not validate the geometric constraint."]
    #[doc = r" Use `new_checked()` to validate, or `from_components()` to"]
    #[doc = r" construct from independent parameters."]
    #[inline]
    pub fn new_unchecked(s: T, tz: T, ty: T, tx: T, rx: T, ry: T, rz: T, ps: T) -> Self {
        Self {
            s,
            tz,
            ty,
            tx,
            rx,
            ry,
            rz,
            ps,
        }
    }
    #[doc = r" Creates a new element, validating the geometric constraint."]
    #[doc = r""]
    #[doc = r" Returns `Err` if the constraint is violated beyond the given tolerance."]
    #[inline]
    pub fn new_checked(
        s: T,
        tz: T,
        ty: T,
        tx: T,
        rx: T,
        ry: T,
        rz: T,
        ps: T,
        tolerance: T,
    ) -> Result<Self, &'static str> {
        let expected = (rz * tz - ry * ty + rx * tx) / (s);
        let actual = ps;
        if (actual - expected).abs() > tolerance {
            return Err("Motor constraint");
        }
        Ok(Self::new_unchecked(s, tz, ty, tx, rx, ry, rz, ps))
    }
    #[doc = "Creates a Motor from 7 independent components, computing `ps`.\n\nReturns `None` if the divisor would be zero (unstable computation)."]
    #[inline]
    pub fn from_components(s: T, tz: T, ty: T, tx: T, rx: T, ry: T, rz: T) -> Option<Self> {
        if (s).abs() < T::epsilon() {
            return None;
        }
        Some(Self::new_unchecked(
            s,
            tz,
            ty,
            tx,
            rx,
            ry,
            rz,
            (rz * tz - ry * ty + rx * tx) / (s),
        ))
    }
    #[doc = "Returns the `s` coefficient."]
    #[inline]
    pub fn s(&self) -> T {
        self.s
    }
    #[doc = "Returns the `tz` coefficient."]
    #[inline]
    pub fn tz(&self) -> T {
        self.tz
    }
    #[doc = "Returns the `ty` coefficient."]
    #[inline]
    pub fn ty(&self) -> T {
        self.ty
    }
    #[doc = "Returns the `tx` coefficient."]
    #[inline]
    pub fn tx(&self) -> T {
        self.tx
    }
    #[doc = "Returns the `rx` coefficient."]
    #[inline]
    pub fn rx(&self) -> T {
        self.rx
    }
    #[doc = "Returns the `ry` coefficient."]
    #[inline]
    pub fn ry(&self) -> T {
        self.ry
    }
    #[doc = "Returns the `rz` coefficient."]
    #[inline]
    pub fn rz(&self) -> T {
        self.rz
    }
    #[doc = "Returns the `ps` coefficient."]
    #[inline]
    pub fn ps(&self) -> T {
        self.ps
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.s * self.s + self.tz * self.tz + self.ty * self.ty + self.rx * self.rx
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(
            self.s * s,
            self.tz * s,
            self.ty * s,
            self.tx * s,
            self.rx * s,
            self.ry * s,
            self.rz * s,
            self.ps * s,
        )
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(
            self.s, -self.tz, -self.ty, -self.tx, -self.rx, -self.ry, -self.rz, self.ps,
        )
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(
            self.s, -self.tz, -self.ty, -self.tx, -self.rx, -self.ry, -self.rz, self.ps,
        )
    }
}
impl<T: Float> Default for Motor<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "3D plane\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 7 | e1e2e3 | `dist` |\n| 11 | e1e2e4 | `nz` |\n| 13 | e1e3e4 | `ny` |\n| 14 | e2e3e4 | `nx` |\n\n\n# Example\n\n```\nuse clifford::specialized::projective::dim3::Plane;\n\nlet v = Plane::new_unchecked(1.0, 2.0, 3.0, 4.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Plane<T: Float> {
    #[doc = "Coefficient of `dist`."]
    dist: T,
    #[doc = "Coefficient of `nz`."]
    nz: T,
    #[doc = "Coefficient of `ny`."]
    ny: T,
    #[doc = "Coefficient of `nx`."]
    nx: T,
}
impl<T: Float> Plane<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(dist: T, nz: T, ny: T, nx: T) -> Self {
        Self { dist, nz, ny, nx }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(dist: T, nz: T, ny: T, nx: T) -> Self {
        Self::new(dist, nz, ny, nx)
    }
    #[doc = "Returns the `dist` coefficient."]
    #[inline]
    pub fn dist(&self) -> T {
        self.dist
    }
    #[doc = "Returns the `nz` coefficient."]
    #[inline]
    pub fn nz(&self) -> T {
        self.nz
    }
    #[doc = "Returns the `ny` coefficient."]
    #[inline]
    pub fn ny(&self) -> T {
        self.ny
    }
    #[doc = "Returns the `nx` coefficient."]
    #[inline]
    pub fn nx(&self) -> T {
        self.nx
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e2e3 element."]
    #[inline]
    pub fn unit_dist() -> Self {
        Self::new_unchecked(T::one(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e2e4 element."]
    #[inline]
    pub fn unit_nz() -> Self {
        Self::new_unchecked(T::zero(), T::one(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e3e4 element."]
    #[inline]
    pub fn unit_ny() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::one(), T::zero())
    }
    #[doc = "Creates the unit e2e3e4 element."]
    #[inline]
    pub fn unit_nx() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.dist * self.dist
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.dist * s, self.nz * s, self.ny * s, self.nx * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(-self.dist, -self.nz, -self.ny, -self.nx)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.dist, self.nz, self.ny, self.nx)
    }
}
impl<T: Float> Default for Plane<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "3D point in homogeneous coordinates\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 1 | e1 | `x` |\n| 2 | e2 | `y` |\n| 4 | e3 | `z` |\n| 8 | e4 | `w` |\n\n\n# Example\n\n```\nuse clifford::specialized::projective::dim3::Point;\n\nlet v = Point::new_unchecked(1.0, 2.0, 3.0, 4.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Point<T: Float> {
    #[doc = "Coefficient of `x`."]
    x: T,
    #[doc = "Coefficient of `y`."]
    y: T,
    #[doc = "Coefficient of `z`."]
    z: T,
    #[doc = "Coefficient of `w`."]
    w: T,
}
impl<T: Float> Point<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(x: T, y: T, z: T, w: T) -> Self {
        Self { x, y, z, w }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(x: T, y: T, z: T, w: T) -> Self {
        Self::new(x, y, z, w)
    }
    #[doc = "Returns the `x` coefficient."]
    #[inline]
    pub fn x(&self) -> T {
        self.x
    }
    #[doc = "Returns the `y` coefficient."]
    #[inline]
    pub fn y(&self) -> T {
        self.y
    }
    #[doc = "Returns the `z` coefficient."]
    #[inline]
    pub fn z(&self) -> T {
        self.z
    }
    #[doc = "Returns the `w` coefficient."]
    #[inline]
    pub fn w(&self) -> T {
        self.w
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1 element."]
    #[inline]
    pub fn unit_x() -> Self {
        Self::new_unchecked(T::one(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e2 element."]
    #[inline]
    pub fn unit_y() -> Self {
        Self::new_unchecked(T::zero(), T::one(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e3 element."]
    #[inline]
    pub fn unit_z() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::one(), T::zero())
    }
    #[doc = "Creates the unit e4 element."]
    #[inline]
    pub fn unit_w() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.x * self.x + self.y * self.y + self.z * self.z
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.x * s, self.y * s, self.z * s, self.w * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.x, self.y, self.z, self.w)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(-self.x, -self.y, -self.z, -self.w)
    }
}
impl<T: Float> Default for Point<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Quadvector\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 15 | e1e2e3e4 | `ps` |\n\n\n# Example\n\n```\nuse clifford::specialized::projective::dim3::Quadvector;\n\nlet v = Quadvector::new_unchecked(1.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Quadvector<T: Float> {
    #[doc = "Coefficient of `ps`."]
    ps: T,
}
impl<T: Float> Quadvector<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(ps: T) -> Self {
        Self { ps }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(ps: T) -> Self {
        Self::new(ps)
    }
    #[doc = "Returns the `ps` coefficient."]
    #[inline]
    pub fn ps(&self) -> T {
        self.ps
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero())
    }
    #[doc = "Creates the unit e1e2e3e4 element."]
    #[inline]
    pub fn unit_ps() -> Self {
        Self::new_unchecked(T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        T::zero()
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.ps * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.ps)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.ps)
    }
}
impl<T: Float> Default for Quadvector<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Scalar\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 0 | s | `s` |\n\n\n# Example\n\n```\nuse clifford::specialized::projective::dim3::Scalar;\n\nlet v = Scalar::new_unchecked(1.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Scalar<T: Float> {
    #[doc = "Coefficient of `s`."]
    s: T,
}
impl<T: Float> Scalar<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(s: T) -> Self {
        Self { s }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(s: T) -> Self {
        Self::new(s)
    }
    #[doc = "Returns the `s` coefficient."]
    #[inline]
    pub fn s(&self) -> T {
        self.s
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero())
    }
    #[doc = "Creates the unit s element."]
    #[inline]
    pub fn unit_s() -> Self {
        Self::new_unchecked(T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.s * self.s
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.s * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.s)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.s)
    }
}
impl<T: Float> Default for Scalar<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "A bulk-normalized Flector (bulk norm = 1).\n\nThis type alias wraps Flector in `Bulk<T>`, which normalizes by the bulk (non-degenerate) part of the norm."]
pub type BulkFlector<T> = crate::wrappers::Bulk<Flector<T>>;
#[doc = "A unitized Flector (weight norm = 1).\n\nThis type alias wraps Flector in `Unitized<T>`, which normalizes by the weight (degenerate) part of the norm."]
pub type UnitizedFlector<T> = crate::wrappers::Unitized<Flector<T>>;
#[doc = "A bulk-normalized Line (bulk norm = 1).\n\nThis type alias wraps Line in `Bulk<T>`, which normalizes by the bulk (non-degenerate) part of the norm."]
pub type BulkLine<T> = crate::wrappers::Bulk<Line<T>>;
#[doc = "A unitized Line (weight norm = 1).\n\nThis type alias wraps Line in `Unitized<T>`, which normalizes by the weight (degenerate) part of the norm."]
pub type UnitizedLine<T> = crate::wrappers::Unitized<Line<T>>;
#[doc = "A bulk-normalized Motor (bulk norm = 1).\n\nThis type alias wraps Motor in `Bulk<T>`, which normalizes by the bulk (non-degenerate) part of the norm."]
pub type BulkMotor<T> = crate::wrappers::Bulk<Motor<T>>;
#[doc = "A unitized Motor (weight norm = 1).\n\nThis type alias wraps Motor in `Unitized<T>`, which normalizes by the weight (degenerate) part of the norm."]
pub type UnitizedMotor<T> = crate::wrappers::Unitized<Motor<T>>;
#[doc = "A bulk-normalized Plane (bulk norm = 1).\n\nThis type alias wraps Plane in `Bulk<T>`, which normalizes by the bulk (non-degenerate) part of the norm."]
pub type BulkPlane<T> = crate::wrappers::Bulk<Plane<T>>;
#[doc = "A unitized Plane (weight norm = 1).\n\nThis type alias wraps Plane in `Unitized<T>`, which normalizes by the weight (degenerate) part of the norm."]
pub type UnitizedPlane<T> = crate::wrappers::Unitized<Plane<T>>;
#[doc = "A bulk-normalized Point (bulk norm = 1).\n\nThis type alias wraps Point in `Bulk<T>`, which normalizes by the bulk (non-degenerate) part of the norm."]
pub type BulkPoint<T> = crate::wrappers::Bulk<Point<T>>;
#[doc = "A unitized Point (weight norm = 1).\n\nThis type alias wraps Point in `Unitized<T>`, which normalizes by the weight (degenerate) part of the norm."]
pub type UnitizedPoint<T> = crate::wrappers::Unitized<Point<T>>;
#[doc = "A bulk-normalized Quadvector (bulk norm = 1).\n\nThis type alias wraps Quadvector in `Bulk<T>`, which normalizes by the bulk (non-degenerate) part of the norm."]
pub type BulkQuadvector<T> = crate::wrappers::Bulk<Quadvector<T>>;
#[doc = "A unitized Quadvector (weight norm = 1).\n\nThis type alias wraps Quadvector in `Unitized<T>`, which normalizes by the weight (degenerate) part of the norm."]
pub type UnitizedQuadvector<T> = crate::wrappers::Unitized<Quadvector<T>>;
