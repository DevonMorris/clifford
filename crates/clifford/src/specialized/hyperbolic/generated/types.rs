#![doc = " Type definitions for hyperbolic."]
#![doc = ""]
#![doc = " Hyperbolic numbers (split-complex) Cl(1,0,0)"]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
#![allow(clippy::too_many_arguments)]
use crate::scalar::Float;
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
#[doc = "Pure hyperbolic unit (j where j² = +1)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 1 | e1 | `j` |\n\n\n# Example\n\n```\nuse clifford::specialized::hyperbolic::HypUnit;\n\nlet v = HypUnit::new_unchecked(1.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct HypUnit<T: Float> {
    #[doc = "Coefficient of `j`."]
    j: T,
}
impl<T: Float> HypUnit<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(j: T) -> Self {
        Self { j }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(j: T) -> Self {
        Self::new(j)
    }
    #[doc = "Returns the `j` coefficient."]
    #[inline]
    pub fn j(&self) -> T {
        self.j
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero())
    }
    #[doc = "Creates the unit e1 element."]
    #[inline]
    pub fn unit_j() -> Self {
        Self::new_unchecked(T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.j * self.j
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.j * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.j)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.j)
    }
}
impl<T: Float> Default for HypUnit<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Hyperbolic number: a + bj where j² = +1\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 0 | s | `real` |\n| 1 | e1 | `hyp` |\n\n\n# Example\n\n```\nuse clifford::specialized::hyperbolic::Hyperbolic;\n\nlet v = Hyperbolic::new_unchecked(1.0, 2.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Hyperbolic<T: Float> {
    #[doc = "Coefficient of `real`."]
    real: T,
    #[doc = "Coefficient of `hyp`."]
    hyp: T,
}
impl<T: Float> Hyperbolic<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(real: T, hyp: T) -> Self {
        Self { real, hyp }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(real: T, hyp: T) -> Self {
        Self::new(real, hyp)
    }
    #[doc = "Returns the `real` coefficient."]
    #[inline]
    pub fn real(&self) -> T {
        self.real
    }
    #[doc = "Returns the `hyp` coefficient."]
    #[inline]
    pub fn hyp(&self) -> T {
        self.hyp
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero(), T::zero())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.real * self.real + self.hyp * self.hyp
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.real * s, self.hyp * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.real, self.hyp)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.real, self.hyp)
    }
}
impl<T: Float> Default for Hyperbolic<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Scalar (grade-0 element)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 0 | s | `s` |\n\n\n# Example\n\n```\nuse clifford::specialized::hyperbolic::Scalar;\n\nlet v = Scalar::new_unchecked(1.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Scalar<T: Float> {
    #[doc = "Coefficient of `s`."]
    s: T,
}
impl<T: Float> Scalar<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(s: T) -> Self {
        Self { s }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(s: T) -> Self {
        Self::new(s)
    }
    #[doc = "Returns the `s` coefficient."]
    #[inline]
    pub fn s(&self) -> T {
        self.s
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero())
    }
    #[doc = "Creates the unit s element."]
    #[inline]
    pub fn unit_s() -> Self {
        Self::new_unchecked(T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.s * self.s
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.s * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.s)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.s)
    }
}
impl<T: Float> Default for Scalar<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "A unit HypUnit (norm = 1).\n\nThis type alias provides compile-time documentation that the HypUnit has been normalized."]
pub type UnitHypUnit<T> = crate::wrappers::Unit<HypUnit<T>>;
