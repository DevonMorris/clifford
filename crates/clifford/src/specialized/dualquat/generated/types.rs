#![doc = " Type definitions for dualquat."]
#![doc = ""]
#![doc = " Dual quaternions Cl(0,2,1)"]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
#![allow(clippy::too_many_arguments)]
use crate::scalar::Float;
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
#[doc = "Bivector: k from quaternion, di/dj from dual part\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 3 | e1e2 | `k` |\n| 5 | e1e3 | `di` |\n| 6 | e2e3 | `dj` |\n\n\n# Example\n\n```\nuse clifford::specialized::dualquat::Bivector;\n\nlet v = Bivector::new_unchecked(1.0, 2.0, 3.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Bivector<T: Float> {
    #[doc = "Coefficient of `k`."]
    k: T,
    #[doc = "Coefficient of `di`."]
    di: T,
    #[doc = "Coefficient of `dj`."]
    dj: T,
}
impl<T: Float> Bivector<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(k: T, di: T, dj: T) -> Self {
        Self { k, di, dj }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(k: T, di: T, dj: T) -> Self {
        Self::new(k, di, dj)
    }
    #[doc = "Returns the `k` coefficient."]
    #[inline]
    pub fn k(&self) -> T {
        self.k
    }
    #[doc = "Returns the `di` coefficient."]
    #[inline]
    pub fn di(&self) -> T {
        self.di
    }
    #[doc = "Returns the `dj` coefficient."]
    #[inline]
    pub fn dj(&self) -> T {
        self.dj
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e2 element."]
    #[inline]
    pub fn unit_k() -> Self {
        Self::new_unchecked(T::one(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e3 element."]
    #[inline]
    pub fn unit_di() -> Self {
        Self::new_unchecked(T::zero(), T::one(), T::zero())
    }
    #[doc = "Creates the unit e2e3 element."]
    #[inline]
    pub fn unit_dj() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.k * self.k
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.k * s, self.di * s, self.dj * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(-self.k, -self.di, -self.dj)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.k, self.di, self.dj)
    }
}
impl<T: Float> Default for Bivector<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Full dual quaternion for rigid transformations\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 0 | s | `s` |\n| 1 | e1 | `i` |\n| 2 | e2 | `j` |\n| 4 | e3 | `d` |\n| 3 | e1e2 | `k` |\n| 5 | e1e3 | `di` |\n| 6 | e2e3 | `dj` |\n| 7 | e1e2e3 | `dk` |\n\n\n# Example\n\n```\nuse clifford::specialized::dualquat::DualQuaternion;\n\nlet v = DualQuaternion::new_unchecked(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct DualQuaternion<T: Float> {
    #[doc = "Coefficient of `s`."]
    s: T,
    #[doc = "Coefficient of `i`."]
    i: T,
    #[doc = "Coefficient of `j`."]
    j: T,
    #[doc = "Coefficient of `d`."]
    d: T,
    #[doc = "Coefficient of `k`."]
    k: T,
    #[doc = "Coefficient of `di`."]
    di: T,
    #[doc = "Coefficient of `dj`."]
    dj: T,
    #[doc = "Coefficient of `dk`."]
    dk: T,
}
impl<T: Float> DualQuaternion<T> {
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" **Warning:** This does not validate the geometric constraint."]
    #[doc = r" Use `new_checked()` to validate, or `from_components()` to"]
    #[doc = r" construct from independent parameters."]
    #[inline]
    pub fn new_unchecked(s: T, i: T, j: T, d: T, k: T, di: T, dj: T, dk: T) -> Self {
        Self {
            s,
            i,
            j,
            d,
            k,
            di,
            dj,
            dk,
        }
    }
    #[doc = r" Creates a new element, validating the geometric constraint."]
    #[doc = r""]
    #[doc = r" Returns `Err` if the constraint is violated beyond the given tolerance."]
    #[inline]
    pub fn new_checked(
        s: T,
        i: T,
        j: T,
        d: T,
        k: T,
        di: T,
        dj: T,
        dk: T,
        tolerance: T,
    ) -> Result<Self, &'static str> {
        let expected = (d * k + i * dj - j * di) / (s);
        let actual = dk;
        if (actual - expected).abs() > tolerance {
            return Err("DualQuaternion constraint");
        }
        Ok(Self::new_unchecked(s, i, j, d, k, di, dj, dk))
    }
    #[doc = "Creates a DualQuaternion from 7 independent components, computing `dk`.\n\nReturns `None` if the divisor would be zero (unstable computation)."]
    #[inline]
    pub fn from_components(s: T, i: T, j: T, d: T, k: T, di: T, dj: T) -> Option<Self> {
        if (s).abs() < T::epsilon() {
            return None;
        }
        Some(Self::new_unchecked(
            s,
            i,
            j,
            d,
            k,
            di,
            dj,
            (d * k + i * dj - j * di) / (s),
        ))
    }
    #[doc = "Returns the `s` coefficient."]
    #[inline]
    pub fn s(&self) -> T {
        self.s
    }
    #[doc = "Returns the `i` coefficient."]
    #[inline]
    pub fn i(&self) -> T {
        self.i
    }
    #[doc = "Returns the `j` coefficient."]
    #[inline]
    pub fn j(&self) -> T {
        self.j
    }
    #[doc = "Returns the `d` coefficient."]
    #[inline]
    pub fn d(&self) -> T {
        self.d
    }
    #[doc = "Returns the `k` coefficient."]
    #[inline]
    pub fn k(&self) -> T {
        self.k
    }
    #[doc = "Returns the `di` coefficient."]
    #[inline]
    pub fn di(&self) -> T {
        self.di
    }
    #[doc = "Returns the `dj` coefficient."]
    #[inline]
    pub fn dj(&self) -> T {
        self.dj
    }
    #[doc = "Returns the `dk` coefficient."]
    #[inline]
    pub fn dk(&self) -> T {
        self.dk
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.s * self.s + self.i * self.i + self.j * self.j + self.k * self.k
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(
            self.s * s,
            self.i * s,
            self.j * s,
            self.d * s,
            self.k * s,
            self.di * s,
            self.dj * s,
            self.dk * s,
        )
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(
            self.s, self.i, self.j, self.d, -self.k, -self.di, -self.dj, -self.dk,
        )
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(
            -self.s, -self.i, -self.j, -self.d, self.k, self.di, self.dj, self.dk,
        )
    }
}
impl<T: Float> Default for DualQuaternion<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Scalar (grade-0 element)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 0 | s | `s` |\n\n\n# Example\n\n```\nuse clifford::specialized::dualquat::Scalar;\n\nlet v = Scalar::new_unchecked(1.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Scalar<T: Float> {
    #[doc = "Coefficient of `s`."]
    s: T,
}
impl<T: Float> Scalar<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(s: T) -> Self {
        Self { s }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(s: T) -> Self {
        Self::new(s)
    }
    #[doc = "Returns the `s` coefficient."]
    #[inline]
    pub fn s(&self) -> T {
        self.s
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero())
    }
    #[doc = "Creates the unit s element."]
    #[inline]
    pub fn unit_s() -> Self {
        Self::new_unchecked(T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.s * self.s
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.s * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.s)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(-self.s)
    }
}
impl<T: Float> Default for Scalar<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Trivector (pseudoscalar, dk component)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 7 | e1e2e3 | `dk` |\n\n\n# Example\n\n```\nuse clifford::specialized::dualquat::Trivector;\n\nlet v = Trivector::new_unchecked(1.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Trivector<T: Float> {
    #[doc = "Coefficient of `dk`."]
    dk: T,
}
impl<T: Float> Trivector<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(dk: T) -> Self {
        Self { dk }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(dk: T) -> Self {
        Self::new(dk)
    }
    #[doc = "Returns the `dk` coefficient."]
    #[inline]
    pub fn dk(&self) -> T {
        self.dk
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero())
    }
    #[doc = "Creates the unit e1e2e3 element."]
    #[inline]
    pub fn unit_dk() -> Self {
        Self::new_unchecked(T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        T::zero()
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.dk * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(-self.dk)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.dk)
    }
}
impl<T: Float> Default for Trivector<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Vector with quaternion (i,j) and dual (d) components\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 1 | e1 | `i` |\n| 2 | e2 | `j` |\n| 4 | e3 | `d` |\n\n\n# Example\n\n```\nuse clifford::specialized::dualquat::Vector;\n\nlet v = Vector::new_unchecked(1.0, 2.0, 3.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Vector<T: Float> {
    #[doc = "Coefficient of `i`."]
    i: T,
    #[doc = "Coefficient of `j`."]
    j: T,
    #[doc = "Coefficient of `d`."]
    d: T,
}
impl<T: Float> Vector<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(i: T, j: T, d: T) -> Self {
        Self { i, j, d }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(i: T, j: T, d: T) -> Self {
        Self::new(i, j, d)
    }
    #[doc = "Returns the `i` coefficient."]
    #[inline]
    pub fn i(&self) -> T {
        self.i
    }
    #[doc = "Returns the `j` coefficient."]
    #[inline]
    pub fn j(&self) -> T {
        self.j
    }
    #[doc = "Returns the `d` coefficient."]
    #[inline]
    pub fn d(&self) -> T {
        self.d
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1 element."]
    #[inline]
    pub fn unit_i() -> Self {
        Self::new_unchecked(T::one(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e2 element."]
    #[inline]
    pub fn unit_j() -> Self {
        Self::new_unchecked(T::zero(), T::one(), T::zero())
    }
    #[doc = "Creates the unit e3 element."]
    #[inline]
    pub fn unit_d() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.i * self.i + self.j * self.j
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.i * s, self.j * s, self.d * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.i, self.j, self.d)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(-self.i, -self.j, -self.d)
    }
}
impl<T: Float> Default for Vector<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "A bulk-normalized Bivector (bulk norm = 1).\n\nThis type alias wraps Bivector in `Bulk<T>`, which normalizes by the bulk (non-degenerate) part of the norm."]
pub type BulkBivector<T> = crate::wrappers::Bulk<Bivector<T>>;
#[doc = "A unitized Bivector (weight norm = 1).\n\nThis type alias wraps Bivector in `Unitized<T>`, which normalizes by the weight (degenerate) part of the norm."]
pub type UnitizedBivector<T> = crate::wrappers::Unitized<Bivector<T>>;
#[doc = "A bulk-normalized DualQuaternion (bulk norm = 1).\n\nThis type alias wraps DualQuaternion in `Bulk<T>`, which normalizes by the bulk (non-degenerate) part of the norm."]
pub type BulkDualQuaternion<T> = crate::wrappers::Bulk<DualQuaternion<T>>;
#[doc = "A unitized DualQuaternion (weight norm = 1).\n\nThis type alias wraps DualQuaternion in `Unitized<T>`, which normalizes by the weight (degenerate) part of the norm."]
pub type UnitizedDualQuaternion<T> = crate::wrappers::Unitized<DualQuaternion<T>>;
#[doc = "A bulk-normalized Trivector (bulk norm = 1).\n\nThis type alias wraps Trivector in `Bulk<T>`, which normalizes by the bulk (non-degenerate) part of the norm."]
pub type BulkTrivector<T> = crate::wrappers::Bulk<Trivector<T>>;
#[doc = "A unitized Trivector (weight norm = 1).\n\nThis type alias wraps Trivector in `Unitized<T>`, which normalizes by the weight (degenerate) part of the norm."]
pub type UnitizedTrivector<T> = crate::wrappers::Unitized<Trivector<T>>;
#[doc = "A bulk-normalized Vector (bulk norm = 1).\n\nThis type alias wraps Vector in `Bulk<T>`, which normalizes by the bulk (non-degenerate) part of the norm."]
pub type BulkVector<T> = crate::wrappers::Bulk<Vector<T>>;
#[doc = "A unitized Vector (weight norm = 1).\n\nThis type alias wraps Vector in `Unitized<T>`, which normalizes by the weight (degenerate) part of the norm."]
pub type UnitizedVector<T> = crate::wrappers::Unitized<Vector<T>>;
