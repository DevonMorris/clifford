#![doc = " Trait implementations for dualquat."]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
use super::types::{Bivector, DualQuaternion, Scalar, Trivector, Vector};
#[allow(unused_imports)]
use crate::ops::{
    Antidot, Antiproject, Antireverse, Antisandwich, Antiwedge, BulkContract, BulkExpand, Dot,
    InverseAntisandwich, InverseSandwich, Involute, LeftContract, Project, Reverse,
    RightComplement, RightContract, Sandwich, ScalarProduct, Transform, Versor, VersorInverse,
    Wedge, WeightContract, WeightDual, WeightExpand,
};
use crate::scalar::Float;
#[allow(unused_imports)]
use crate::wrappers::Unitized;
use approx::{AbsDiffEq, RelativeEq, UlpsEq};
use std::ops::{Add, Mul, Neg, Sub};
impl<T: Float> Add for Bivector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.k() + rhs.k(),
            self.di() + rhs.di(),
            self.dj() + rhs.dj(),
        )
    }
}
impl<T: Float> Sub for Bivector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.k() - rhs.k(),
            self.di() - rhs.di(),
            self.dj() - rhs.dj(),
        )
    }
}
impl<T: Float> Neg for Bivector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.k(), -self.di(), -self.dj())
    }
}
impl<T: Float> Mul<T> for Bivector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Bivector<f32>> for f32 {
    type Output = Bivector<f32>;
    #[inline]
    fn mul(self, v: Bivector<f32>) -> Bivector<f32> {
        v.scale(self)
    }
}
impl Mul<Bivector<f64>> for f64 {
    type Output = Bivector<f64>;
    #[inline]
    fn mul(self, v: Bivector<f64>) -> Bivector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<DualQuaternion<T>> for Bivector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn mul(self, rhs: DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            -(rhs.k() * self.k()),
            -(rhs.j() * self.k()),
            rhs.i() * self.k(),
            -(rhs.dk() * self.k()) + rhs.i() * self.di() + rhs.j() * self.dj(),
            rhs.s() * self.k(),
            -(rhs.dj() * self.k()) + rhs.k() * self.dj() + rhs.s() * self.di(),
            -(rhs.k() * self.di()) + rhs.s() * self.dj() + rhs.di() * self.k(),
            -(rhs.j() * self.di()) + rhs.d() * self.k() + rhs.i() * self.dj(),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.s() * self.k(), rhs.s() * self.di(), rhs.s() * self.dj())
    }
}
impl<T: Float> Mul<Trivector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), -(rhs.dk() * self.k()))
    }
}
impl<T: Float> Add for DualQuaternion<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.s() + rhs.s(),
            self.i() + rhs.i(),
            self.j() + rhs.j(),
            self.d() + rhs.d(),
            self.k() + rhs.k(),
            self.di() + rhs.di(),
            self.dj() + rhs.dj(),
            self.dk() + rhs.dk(),
        )
    }
}
impl<T: Float> Sub for DualQuaternion<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.s() - rhs.s(),
            self.i() - rhs.i(),
            self.j() - rhs.j(),
            self.d() - rhs.d(),
            self.k() - rhs.k(),
            self.di() - rhs.di(),
            self.dj() - rhs.dj(),
            self.dk() - rhs.dk(),
        )
    }
}
impl<T: Float> Neg for DualQuaternion<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(
            -self.s(),
            -self.i(),
            -self.j(),
            -self.d(),
            -self.k(),
            -self.di(),
            -self.dj(),
            -self.dk(),
        )
    }
}
impl<T: Float> Mul<T> for DualQuaternion<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<DualQuaternion<f32>> for f32 {
    type Output = DualQuaternion<f32>;
    #[inline]
    fn mul(self, v: DualQuaternion<f32>) -> DualQuaternion<f32> {
        v.scale(self)
    }
}
impl Mul<DualQuaternion<f64>> for f64 {
    type Output = DualQuaternion<f64>;
    #[inline]
    fn mul(self, v: DualQuaternion<f64>) -> DualQuaternion<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for DualQuaternion<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            -(rhs.k() * self.k()),
            rhs.k() * self.j(),
            -(rhs.k() * self.i()),
            -(rhs.k() * self.dk()) + -(rhs.di() * self.i()) + -(rhs.dj() * self.j()),
            rhs.k() * self.s(),
            -(rhs.dj() * self.k()) + rhs.k() * self.dj() + rhs.di() * self.s(),
            -(rhs.k() * self.di()) + rhs.di() * self.k() + rhs.dj() * self.s(),
            -(rhs.di() * self.j()) + rhs.k() * self.d() + rhs.dj() * self.i(),
        )
    }
}
impl<T: Float> Mul<DualQuaternion<T>> for DualQuaternion<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn mul(self, rhs: DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            -(rhs.i() * self.i())
                + -(rhs.j() * self.j())
                + -(rhs.k() * self.k())
                + rhs.s() * self.s(),
            -(rhs.j() * self.k()) + rhs.s() * self.i() + rhs.k() * self.j() + rhs.i() * self.s(),
            -(rhs.k() * self.i()) + rhs.i() * self.k() + rhs.s() * self.j() + rhs.j() * self.s(),
            -(rhs.k() * self.dk())
                + -(rhs.di() * self.i())
                + -(rhs.dj() * self.j())
                + -(rhs.dk() * self.k())
                + rhs.i() * self.di()
                + rhs.j() * self.dj()
                + rhs.s() * self.d()
                + rhs.d() * self.s(),
            -(rhs.i() * self.j()) + rhs.s() * self.k() + rhs.j() * self.i() + rhs.k() * self.s(),
            -(rhs.i() * self.d())
                + -(rhs.dj() * self.k())
                + rhs.d() * self.i()
                + rhs.j() * self.dk()
                + rhs.k() * self.dj()
                + rhs.s() * self.di()
                + rhs.dk() * self.j()
                + rhs.di() * self.s(),
            -(rhs.i() * self.dk())
                + -(rhs.k() * self.di())
                + -(rhs.j() * self.d())
                + -(rhs.dk() * self.i())
                + rhs.d() * self.j()
                + rhs.s() * self.dj()
                + rhs.di() * self.k()
                + rhs.dj() * self.s(),
            -(rhs.j() * self.di())
                + -(rhs.di() * self.j())
                + rhs.d() * self.k()
                + rhs.i() * self.dj()
                + rhs.s() * self.dk()
                + rhs.k() * self.d()
                + rhs.dj() * self.i()
                + rhs.dk() * self.s(),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for DualQuaternion<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            rhs.s() * self.s(),
            rhs.s() * self.i(),
            rhs.s() * self.j(),
            rhs.s() * self.d(),
            rhs.s() * self.k(),
            rhs.s() * self.di(),
            rhs.s() * self.dj(),
            rhs.s() * self.dk(),
        )
    }
}
impl<T: Float> Mul<Vector<T>> for DualQuaternion<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn mul(self, rhs: Vector<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            -(rhs.i() * self.i()) + -(rhs.j() * self.j()),
            -(rhs.j() * self.k()) + rhs.i() * self.s(),
            rhs.i() * self.k() + rhs.j() * self.s(),
            rhs.i() * self.di() + rhs.j() * self.dj() + rhs.d() * self.s(),
            -(rhs.i() * self.j()) + rhs.j() * self.i(),
            -(rhs.i() * self.d()) + rhs.d() * self.i() + rhs.j() * self.dk(),
            -(rhs.i() * self.dk()) + -(rhs.j() * self.d()) + rhs.d() * self.j(),
            -(rhs.j() * self.di()) + rhs.d() * self.k() + rhs.i() * self.dj(),
        )
    }
}
impl<T: Float> Add for Scalar<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.s() + rhs.s())
    }
}
impl<T: Float> Sub for Scalar<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.s() - rhs.s())
    }
}
impl<T: Float> Neg for Scalar<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.s())
    }
}
impl<T: Float> Mul<T> for Scalar<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Scalar<f32>> for f32 {
    type Output = Scalar<f32>;
    #[inline]
    fn mul(self, v: Scalar<f32>) -> Scalar<f32> {
        v.scale(self)
    }
}
impl Mul<Scalar<f64>> for f64 {
    type Output = Scalar<f64>;
    #[inline]
    fn mul(self, v: Scalar<f64>) -> Scalar<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.k() * self.s(), rhs.di() * self.s(), rhs.dj() * self.s())
    }
}
impl<T: Float> Mul<DualQuaternion<T>> for Scalar<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn mul(self, rhs: DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            rhs.s() * self.s(),
            rhs.i() * self.s(),
            rhs.j() * self.s(),
            rhs.d() * self.s(),
            rhs.k() * self.s(),
            rhs.di() * self.s(),
            rhs.dj() * self.s(),
            rhs.dk() * self.s(),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
impl<T: Float> Mul<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn mul(self, rhs: Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.dk() * self.s())
    }
}
impl<T: Float> Mul<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Vector<T>) -> Vector<T> {
        Vector::new_unchecked(rhs.i() * self.s(), rhs.j() * self.s(), rhs.d() * self.s())
    }
}
impl<T: Float> Add for Trivector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.dk() + rhs.dk())
    }
}
impl<T: Float> Sub for Trivector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.dk() - rhs.dk())
    }
}
impl<T: Float> Neg for Trivector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.dk())
    }
}
impl<T: Float> Mul<T> for Trivector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Trivector<f32>> for f32 {
    type Output = Trivector<f32>;
    #[inline]
    fn mul(self, v: Trivector<f32>) -> Trivector<f32> {
        v.scale(self)
    }
}
impl Mul<Trivector<f64>> for f64 {
    type Output = Trivector<f64>;
    #[inline]
    fn mul(self, v: Trivector<f64>) -> Trivector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), -(rhs.k() * self.dk()))
    }
}
impl<T: Float> Mul<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.s() * self.dk())
    }
}
impl<T: Float> Mul<Vector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn mul(self, rhs: Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), rhs.j() * self.dk(), -(rhs.i() * self.dk()))
    }
}
impl<T: Float> Add for Vector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.i() + rhs.i(), self.j() + rhs.j(), self.d() + rhs.d())
    }
}
impl<T: Float> Sub for Vector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.i() - rhs.i(), self.j() - rhs.j(), self.d() - rhs.d())
    }
}
impl<T: Float> Neg for Vector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.i(), -self.j(), -self.d())
    }
}
impl<T: Float> Mul<T> for Vector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Vector<f32>> for f32 {
    type Output = Vector<f32>;
    #[inline]
    fn mul(self, v: Vector<f32>) -> Vector<f32> {
        v.scale(self)
    }
}
impl Mul<Vector<f64>> for f64 {
    type Output = Vector<f64>;
    #[inline]
    fn mul(self, v: Vector<f64>) -> Vector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<DualQuaternion<T>> for Vector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn mul(self, rhs: DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            -(rhs.i() * self.i()) + -(rhs.j() * self.j()),
            rhs.s() * self.i() + rhs.k() * self.j(),
            -(rhs.k() * self.i()) + rhs.s() * self.j(),
            -(rhs.di() * self.i()) + -(rhs.dj() * self.j()) + rhs.s() * self.d(),
            -(rhs.i() * self.j()) + rhs.j() * self.i(),
            -(rhs.i() * self.d()) + rhs.d() * self.i() + rhs.dk() * self.j(),
            -(rhs.j() * self.d()) + -(rhs.dk() * self.i()) + rhs.d() * self.j(),
            -(rhs.di() * self.j()) + rhs.k() * self.d() + rhs.dj() * self.i(),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(rhs.s() * self.i(), rhs.s() * self.j(), rhs.s() * self.d())
    }
}
impl<T: Float> Mul<Trivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn mul(self, rhs: Trivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), rhs.dk() * self.j(), -(rhs.dk() * self.i()))
    }
}
impl<T: Float> Wedge<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.s() * self.k(), rhs.s() * self.di(), rhs.s() * self.dj())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.s() * self.as_inner().k(),
            rhs.s() * self.as_inner().di(),
            rhs.s() * self.as_inner().dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
impl<T: Float> Wedge<Vector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(-(rhs.j() * self.di()) + rhs.d() * self.k() + rhs.i() * self.dj())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Vector<T>> for Unitized<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.j() * self.as_inner().di())
                + rhs.d() * self.as_inner().k()
                + rhs.i() * self.as_inner().dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Vector<T>>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Vector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().j() * self.di())
                + rhs.as_inner().d() * self.k()
                + rhs.as_inner().i() * self.dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Vector<T>>> for Unitized<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Vector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().j() * self.as_inner().di())
                + rhs.as_inner().d() * self.as_inner().k()
                + rhs.as_inner().i() * self.as_inner().dj(),
        )
    }
}
impl<T: Float> Wedge<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.k() * self.s(), rhs.di() * self.s(), rhs.dj() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Bivector<T>> for Unitized<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Bivector<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().k() * self.s(),
            rhs.as_inner().di() * self.s(),
            rhs.as_inner().dj() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Bivector<T>>> for Unitized<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
impl<T: Float> Wedge<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
impl<T: Float> Wedge<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.dk() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Trivector<T>> for Unitized<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Trivector<T>>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.as_inner().dk() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Trivector<T>>> for Unitized<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
impl<T: Float> Wedge<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(rhs.i() * self.s(), rhs.j() * self.s(), rhs.d() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Vector<T>> for Unitized<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Vector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().i() * self.s(),
            rhs.as_inner().j() * self.s(),
            rhs.as_inner().d() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Vector<T>>> for Unitized<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
impl<T: Float> Wedge<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.s() * self.dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.s() * self.as_inner().dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
impl<T: Float> Wedge<Bivector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Bivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(-(rhs.di() * self.j()) + rhs.k() * self.d() + rhs.dj() * self.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Bivector<T>> for Unitized<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Bivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.di() * self.as_inner().j())
                + rhs.k() * self.as_inner().d()
                + rhs.dj() * self.as_inner().i(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Bivector<T>>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Bivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().di() * self.j())
                + rhs.as_inner().k() * self.d()
                + rhs.as_inner().dj() * self.i(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Bivector<T>>> for Unitized<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Bivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().di() * self.as_inner().j())
                + rhs.as_inner().k() * self.as_inner().d()
                + rhs.as_inner().dj() * self.as_inner().i(),
        )
    }
}
impl<T: Float> Wedge<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(rhs.s() * self.i(), rhs.s() * self.j(), rhs.s() * self.d())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.s() * self.as_inner().i(),
            rhs.s() * self.as_inner().j(),
            rhs.s() * self.as_inner().d(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
impl<T: Float> Wedge<Vector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.i() * self.j()) + rhs.j() * self.i(),
            -(rhs.i() * self.d()) + rhs.d() * self.i(),
            -(rhs.j() * self.d()) + rhs.d() * self.j(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Vector<T>> for Unitized<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.i() * self.as_inner().j()) + rhs.j() * self.as_inner().i(),
            -(rhs.i() * self.as_inner().d()) + rhs.d() * self.as_inner().i(),
            -(rhs.j() * self.as_inner().d()) + rhs.d() * self.as_inner().j(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Vector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().i() * self.j()) + rhs.as_inner().j() * self.i(),
            -(rhs.as_inner().i() * self.d()) + rhs.as_inner().d() * self.i(),
            -(rhs.as_inner().j() * self.d()) + rhs.as_inner().d() * self.j(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Vector<T>>> for Unitized<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().i() * self.as_inner().j()) + rhs.as_inner().j() * self.as_inner().i(),
            -(rhs.as_inner().i() * self.as_inner().d()) + rhs.as_inner().d() * self.as_inner().i(),
            -(rhs.as_inner().j() * self.as_inner().d()) + rhs.as_inner().d() * self.as_inner().j(),
        )
    }
}
impl<T: Float> Antiwedge<Bivector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.k() * self.di()) + rhs.di() * self.k(),
            -(rhs.k() * self.dj()) + rhs.dj() * self.k(),
            -(rhs.di() * self.dj()) + rhs.dj() * self.di(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Bivector<T>> for Unitized<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.k() * self.as_inner().di()) + rhs.di() * self.as_inner().k(),
            -(rhs.k() * self.as_inner().dj()) + rhs.dj() * self.as_inner().k(),
            -(rhs.di() * self.as_inner().dj()) + rhs.dj() * self.as_inner().di(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Bivector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().k() * self.di()) + rhs.as_inner().di() * self.k(),
            -(rhs.as_inner().k() * self.dj()) + rhs.as_inner().dj() * self.k(),
            -(rhs.as_inner().di() * self.dj()) + rhs.as_inner().dj() * self.di(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Bivector<T>>> for Unitized<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().k() * self.as_inner().di())
                + rhs.as_inner().di() * self.as_inner().k(),
            -(rhs.as_inner().k() * self.as_inner().dj())
                + rhs.as_inner().dj() * self.as_inner().k(),
            -(rhs.as_inner().di() * self.as_inner().dj())
                + rhs.as_inner().dj() * self.as_inner().di(),
        )
    }
}
impl<T: Float> Antiwedge<Trivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.dk() * self.k(),
            rhs.dk() * self.di(),
            rhs.dk() * self.dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Trivector<T>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.dk() * self.as_inner().k(),
            rhs.dk() * self.as_inner().di(),
            rhs.dk() * self.as_inner().dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Trivector<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Trivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().dk() * self.k(),
            rhs.as_inner().dk() * self.di(),
            rhs.as_inner().dk() * self.dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Trivector<T>>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Trivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().dk() * self.as_inner().k(),
            rhs.as_inner().dk() * self.as_inner().di(),
            rhs.as_inner().dk() * self.as_inner().dj(),
        )
    }
}
impl<T: Float> Antiwedge<Vector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.j() * self.di()) + rhs.d() * self.k() + rhs.i() * self.dj())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Vector<T>> for Unitized<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.j() * self.as_inner().di())
                + rhs.d() * self.as_inner().k()
                + rhs.i() * self.as_inner().dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Vector<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().j() * self.di())
                + rhs.as_inner().d() * self.k()
                + rhs.as_inner().i() * self.dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Vector<T>>> for Unitized<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().j() * self.as_inner().di())
                + rhs.as_inner().d() * self.as_inner().k()
                + rhs.as_inner().i() * self.as_inner().dj(),
        )
    }
}
impl<T: Float> Antiwedge<Trivector<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.dk() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Trivector<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Trivector<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Trivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().dk() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Trivector<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Trivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
impl<T: Float> Antiwedge<Bivector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.k() * self.dk(),
            rhs.di() * self.dk(),
            rhs.dj() * self.dk(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Bivector<T>> for Unitized<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.k() * self.as_inner().dk(),
            rhs.di() * self.as_inner().dk(),
            rhs.dj() * self.as_inner().dk(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Bivector<T>>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().k() * self.dk(),
            rhs.as_inner().di() * self.dk(),
            rhs.as_inner().dj() * self.dk(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Bivector<T>>> for Unitized<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().k() * self.as_inner().dk(),
            rhs.as_inner().di() * self.as_inner().dk(),
            rhs.as_inner().dj() * self.as_inner().dk(),
        )
    }
}
impl<T: Float> Antiwedge<Scalar<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Scalar<T>> for Unitized<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.as_inner().dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Scalar<T>>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Scalar<T>>> for Unitized<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
impl<T: Float> Antiwedge<Trivector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.dk() * self.dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Trivector<T>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.dk() * self.as_inner().dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Trivector<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.as_inner().dk() * self.dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Trivector<T>>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.as_inner().dk() * self.as_inner().dk())
    }
}
impl<T: Float> Antiwedge<Vector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.i() * self.dk(),
            rhs.j() * self.dk(),
            rhs.d() * self.dk(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Vector<T>> for Unitized<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.i() * self.as_inner().dk(),
            rhs.j() * self.as_inner().dk(),
            rhs.d() * self.as_inner().dk(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Vector<T>>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().i() * self.dk(),
            rhs.as_inner().j() * self.dk(),
            rhs.as_inner().d() * self.dk(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Vector<T>>> for Unitized<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().i() * self.as_inner().dk(),
            rhs.as_inner().j() * self.as_inner().dk(),
            rhs.as_inner().d() * self.as_inner().dk(),
        )
    }
}
impl<T: Float> Antiwedge<Bivector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.di() * self.j()) + rhs.k() * self.d() + rhs.dj() * self.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Bivector<T>> for Unitized<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.di() * self.as_inner().j())
                + rhs.k() * self.as_inner().d()
                + rhs.dj() * self.as_inner().i(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Bivector<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().di() * self.j())
                + rhs.as_inner().k() * self.d()
                + rhs.as_inner().dj() * self.i(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Bivector<T>>> for Unitized<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().di() * self.as_inner().j())
                + rhs.as_inner().k() * self.as_inner().d()
                + rhs.as_inner().dj() * self.as_inner().i(),
        )
    }
}
impl<T: Float> Antiwedge<Trivector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.dk() * self.i(),
            rhs.dk() * self.j(),
            rhs.dk() * self.d(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Trivector<T>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.dk() * self.as_inner().i(),
            rhs.dk() * self.as_inner().j(),
            rhs.dk() * self.as_inner().d(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Trivector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().dk() * self.i(),
            rhs.as_inner().dk() * self.j(),
            rhs.as_inner().dk() * self.d(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Trivector<T>>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().dk() * self.as_inner().i(),
            rhs.as_inner().dk() * self.as_inner().j(),
            rhs.as_inner().dk() * self.as_inner().d(),
        )
    }
}
impl<T: Float> LeftContract<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.k() * self.k()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Bivector<T>> for Unitized<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.k() * self.as_inner().k()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Bivector<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().k() * self.k()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Bivector<T>>> for Unitized<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().k() * self.as_inner().k()))
    }
}
impl<T: Float> LeftContract<Trivector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), -(rhs.dk() * self.k()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Trivector<T>> for Unitized<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), -(rhs.dk() * self.as_inner().k()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Trivector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), -(rhs.as_inner().dk() * self.k()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Trivector<T>>> for Unitized<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            T::zero(),
            T::zero(),
            -(rhs.as_inner().dk() * self.as_inner().k()),
        )
    }
}
impl<T: Float> LeftContract<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.k() * self.s(), rhs.di() * self.s(), rhs.dj() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Bivector<T>> for Unitized<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Bivector<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().k() * self.s(),
            rhs.as_inner().di() * self.s(),
            rhs.as_inner().dj() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Bivector<T>>> for Unitized<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
impl<T: Float> LeftContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
impl<T: Float> LeftContract<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.dk() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Trivector<T>> for Unitized<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Trivector<T>>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.as_inner().dk() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Trivector<T>>> for Unitized<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
impl<T: Float> LeftContract<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(rhs.i() * self.s(), rhs.j() * self.s(), rhs.d() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Vector<T>> for Unitized<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Vector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().i() * self.s(),
            rhs.as_inner().j() * self.s(),
            rhs.as_inner().d() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Vector<T>>> for Unitized<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
impl<T: Float> LeftContract<Bivector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.k() * self.j(),
            -(rhs.k() * self.i()),
            -(rhs.di() * self.i()) + -(rhs.dj() * self.j()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Bivector<T>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.k() * self.as_inner().j(),
            -(rhs.k() * self.as_inner().i()),
            -(rhs.di() * self.as_inner().i()) + -(rhs.dj() * self.as_inner().j()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Bivector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().k() * self.j(),
            -(rhs.as_inner().k() * self.i()),
            -(rhs.as_inner().di() * self.i()) + -(rhs.as_inner().dj() * self.j()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Bivector<T>>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().k() * self.as_inner().j(),
            -(rhs.as_inner().k() * self.as_inner().i()),
            -(rhs.as_inner().di() * self.as_inner().i())
                + -(rhs.as_inner().dj() * self.as_inner().j()),
        )
    }
}
impl<T: Float> LeftContract<Trivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Trivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), rhs.dk() * self.j(), -(rhs.dk() * self.i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Trivector<T>> for Unitized<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Trivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            T::zero(),
            rhs.dk() * self.as_inner().j(),
            -(rhs.dk() * self.as_inner().i()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Trivector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Trivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            T::zero(),
            rhs.as_inner().dk() * self.j(),
            -(rhs.as_inner().dk() * self.i()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Trivector<T>>> for Unitized<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Trivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            T::zero(),
            rhs.as_inner().dk() * self.as_inner().j(),
            -(rhs.as_inner().dk() * self.as_inner().i()),
        )
    }
}
impl<T: Float> LeftContract<Vector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.i() * self.i()) + -(rhs.j() * self.j()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Vector<T>> for Unitized<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.i() * self.as_inner().i()) + -(rhs.j() * self.as_inner().j()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Vector<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().i() * self.i()) + -(rhs.as_inner().j() * self.j()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Vector<T>>> for Unitized<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().i() * self.as_inner().i())
                + -(rhs.as_inner().j() * self.as_inner().j()),
        )
    }
}
impl<T: Float> RightContract<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.k() * self.k()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Bivector<T>> for Unitized<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.k() * self.as_inner().k()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Bivector<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().k() * self.k()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Bivector<T>>> for Unitized<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().k() * self.as_inner().k()))
    }
}
impl<T: Float> RightContract<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.s() * self.k(), rhs.s() * self.di(), rhs.s() * self.dj())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.s() * self.as_inner().k(),
            rhs.s() * self.as_inner().di(),
            rhs.s() * self.as_inner().dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
impl<T: Float> RightContract<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.j() * self.k()),
            rhs.i() * self.k(),
            rhs.i() * self.di() + rhs.j() * self.dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Vector<T>> for Unitized<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.j() * self.as_inner().k()),
            rhs.i() * self.as_inner().k(),
            rhs.i() * self.as_inner().di() + rhs.j() * self.as_inner().dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Vector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().j() * self.k()),
            rhs.as_inner().i() * self.k(),
            rhs.as_inner().i() * self.di() + rhs.as_inner().j() * self.dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Vector<T>>> for Unitized<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().j() * self.as_inner().k()),
            rhs.as_inner().i() * self.as_inner().k(),
            rhs.as_inner().i() * self.as_inner().di() + rhs.as_inner().j() * self.as_inner().dj(),
        )
    }
}
impl<T: Float> RightContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
impl<T: Float> RightContract<Bivector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), -(rhs.k() * self.dk()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Bivector<T>> for Unitized<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), -(rhs.k() * self.as_inner().dk()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Bivector<T>>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), -(rhs.as_inner().k() * self.dk()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Bivector<T>>> for Unitized<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            T::zero(),
            T::zero(),
            -(rhs.as_inner().k() * self.as_inner().dk()),
        )
    }
}
impl<T: Float> RightContract<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.s() * self.dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.s() * self.as_inner().dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
impl<T: Float> RightContract<Vector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), rhs.j() * self.dk(), -(rhs.i() * self.dk()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Vector<T>> for Unitized<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            T::zero(),
            rhs.j() * self.as_inner().dk(),
            -(rhs.i() * self.as_inner().dk()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Vector<T>>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            T::zero(),
            rhs.as_inner().j() * self.dk(),
            -(rhs.as_inner().i() * self.dk()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Vector<T>>> for Unitized<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            T::zero(),
            rhs.as_inner().j() * self.as_inner().dk(),
            -(rhs.as_inner().i() * self.as_inner().dk()),
        )
    }
}
impl<T: Float> RightContract<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(rhs.s() * self.i(), rhs.s() * self.j(), rhs.s() * self.d())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.s() * self.as_inner().i(),
            rhs.s() * self.as_inner().j(),
            rhs.s() * self.as_inner().d(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
impl<T: Float> RightContract<Vector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.i() * self.i()) + -(rhs.j() * self.j()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Vector<T>> for Unitized<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.i() * self.as_inner().i()) + -(rhs.j() * self.as_inner().j()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Vector<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().i() * self.i()) + -(rhs.as_inner().j() * self.j()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Vector<T>>> for Unitized<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().i() * self.as_inner().i())
                + -(rhs.as_inner().j() * self.as_inner().j()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.k() * operand.k() * self.k(),
            self.k() * operand.k() * self.di() + self.di() * operand.k() * self.k()
                - self.k() * operand.di() * self.k(),
            self.k() * operand.k() * self.dj() - self.k() * operand.dj() * self.k()
                + self.dj() * operand.k() * self.k(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            operand.k() * self.as_inner().k() * self.as_inner().k(),
            -(operand.di() * self.as_inner().k() * self.as_inner().k())
                + T::TWO * operand.k() * self.as_inner().di() * self.as_inner().k(),
            -(operand.dj() * self.as_inner().k() * self.as_inner().k())
                + T::TWO * operand.k() * self.as_inner().dj() * self.as_inner().k(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Bivector<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            operand.as_inner().k() * self.k() * self.k(),
            -(operand.as_inner().di() * self.k() * self.k())
                + T::TWO * operand.as_inner().k() * self.di() * self.k(),
            -(operand.as_inner().dj() * self.k() * self.k())
                + T::TWO * operand.as_inner().k() * self.dj() * self.k(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Bivector<T>>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            operand.as_inner().k() * self.as_inner().k() * self.as_inner().k(),
            -(operand.as_inner().di() * self.as_inner().k() * self.as_inner().k())
                + T::TWO * operand.as_inner().k() * self.as_inner().di() * self.as_inner().k(),
            -(operand.as_inner().dj() * self.as_inner().k() * self.as_inner().k())
                + T::TWO * operand.as_inner().k() * self.as_inner().dj() * self.as_inner().k(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<DualQuaternion<T>> for Bivector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn sandwich(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            self.k() * operand.s() * self.k(),
            -(self.k() * operand.i() * self.k()),
            -(self.k() * operand.j() * self.k()),
            self.k() * operand.i() * self.dj() - self.k() * operand.j() * self.di()
                + self.dj() * operand.i() * self.k()
                + self.k() * operand.d() * self.k()
                - self.di() * operand.j() * self.k(),
            self.k() * operand.k() * self.k(),
            self.di() * operand.k() * self.k() - self.dj() * operand.s() * self.k()
                + self.k() * operand.s() * self.dj()
                - self.k() * operand.di() * self.k()
                + self.k() * operand.k() * self.di(),
            -(self.k() * operand.s() * self.di()) + self.di() * operand.s() * self.k()
                - self.k() * operand.dj() * self.k()
                + self.dj() * operand.k() * self.k()
                + self.k() * operand.k() * self.dj(),
            self.k() * operand.i() * self.di()
                - self.di() * operand.i() * self.k()
                - self.dj() * operand.j() * self.k()
                + self.k() * operand.j() * self.dj()
                + self.k() * operand.dk() * self.k(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<DualQuaternion<T>> for Unitized<Bivector<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn sandwich(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            operand.s() * self.as_inner().k() * self.as_inner().k(),
            -(operand.i() * self.as_inner().k() * self.as_inner().k()),
            -(operand.j() * self.as_inner().k() * self.as_inner().k()),
            -T::TWO * operand.j() * self.as_inner().di() * self.as_inner().k()
                + T::TWO * operand.i() * self.as_inner().dj() * self.as_inner().k()
                + operand.d() * self.as_inner().k() * self.as_inner().k(),
            operand.k() * self.as_inner().k() * self.as_inner().k(),
            -(operand.di() * self.as_inner().k() * self.as_inner().k())
                + T::TWO * operand.k() * self.as_inner().di() * self.as_inner().k(),
            -(operand.dj() * self.as_inner().k() * self.as_inner().k())
                + T::TWO * operand.k() * self.as_inner().dj() * self.as_inner().k(),
            operand.dk() * self.as_inner().k() * self.as_inner().k(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<DualQuaternion<T>>> for Bivector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            operand.as_inner().s() * self.k() * self.k(),
            -(operand.as_inner().i() * self.k() * self.k()),
            -(operand.as_inner().j() * self.k() * self.k()),
            -T::TWO * operand.as_inner().j() * self.di() * self.k()
                + T::TWO * operand.as_inner().i() * self.dj() * self.k()
                + operand.as_inner().d() * self.k() * self.k(),
            operand.as_inner().k() * self.k() * self.k(),
            -(operand.as_inner().di() * self.k() * self.k())
                + T::TWO * operand.as_inner().k() * self.di() * self.k(),
            -(operand.as_inner().dj() * self.k() * self.k())
                + T::TWO * operand.as_inner().k() * self.dj() * self.k(),
            operand.as_inner().dk() * self.k() * self.k(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<DualQuaternion<T>>> for Unitized<Bivector<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            operand.as_inner().s() * self.as_inner().k() * self.as_inner().k(),
            -(operand.as_inner().i() * self.as_inner().k() * self.as_inner().k()),
            -(operand.as_inner().j() * self.as_inner().k() * self.as_inner().k()),
            -T::TWO * operand.as_inner().j() * self.as_inner().di() * self.as_inner().k()
                + T::TWO * operand.as_inner().i() * self.as_inner().dj() * self.as_inner().k()
                + operand.as_inner().d() * self.as_inner().k() * self.as_inner().k(),
            operand.as_inner().k() * self.as_inner().k() * self.as_inner().k(),
            -(operand.as_inner().di() * self.as_inner().k() * self.as_inner().k())
                + T::TWO * operand.as_inner().k() * self.as_inner().di() * self.as_inner().k(),
            -(operand.as_inner().dj() * self.as_inner().k() * self.as_inner().k())
                + T::TWO * operand.as_inner().k() * self.as_inner().dj() * self.as_inner().k(),
            operand.as_inner().dk() * self.as_inner().k() * self.as_inner().k(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.k() * operand.s() * self.k())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unitized<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s() * self.as_inner().k() * self.as_inner().k())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Unitized<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(self.k() * operand.dk() * self.k())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Unitized<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(operand.dk() * self.as_inner().k() * self.as_inner().k())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Trivector<T>>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(operand.as_inner().dk() * self.k() * self.k())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Trivector<T>>> for Unitized<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            operand.as_inner().dk() * self.as_inner().k() * self.as_inner().k(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.k() * operand.i() * self.k()),
            -(self.k() * operand.j() * self.k()),
            self.dj() * operand.i() * self.k() + self.k() * operand.d() * self.k()
                - self.k() * operand.j() * self.di()
                - self.di() * operand.j() * self.k()
                + self.k() * operand.i() * self.dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Unitized<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.i() * self.as_inner().k() * self.as_inner().k()),
            -(operand.j() * self.as_inner().k() * self.as_inner().k()),
            -T::TWO * operand.j() * self.as_inner().di() * self.as_inner().k()
                + T::TWO * operand.i() * self.as_inner().dj() * self.as_inner().k()
                + operand.d() * self.as_inner().k() * self.as_inner().k(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Vector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.as_inner().i() * self.k() * self.k()),
            -(operand.as_inner().j() * self.k() * self.k()),
            -T::TWO * operand.as_inner().j() * self.di() * self.k()
                + T::TWO * operand.as_inner().i() * self.dj() * self.k()
                + operand.as_inner().d() * self.k() * self.k(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Vector<T>>> for Unitized<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.as_inner().i() * self.as_inner().k() * self.as_inner().k()),
            -(operand.as_inner().j() * self.as_inner().k() * self.as_inner().k()),
            -T::TWO * operand.as_inner().j() * self.as_inner().di() * self.as_inner().k()
                + T::TWO * operand.as_inner().i() * self.as_inner().dj() * self.as_inner().k()
                + operand.as_inner().d() * self.as_inner().k() * self.as_inner().k(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.s() * operand.k() * self.s(),
            self.s() * operand.di() * self.s(),
            self.s() * operand.dj() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Unitized<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Bivector<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            operand.as_inner().k() * self.s() * self.s(),
            operand.as_inner().di() * self.s() * self.s(),
            operand.as_inner().dj() * self.s() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Bivector<T>>> for Unitized<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<DualQuaternion<T>> for Scalar<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn sandwich(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            self.s() * operand.s() * self.s(),
            self.s() * operand.i() * self.s(),
            self.s() * operand.j() * self.s(),
            self.s() * operand.d() * self.s(),
            self.s() * operand.k() * self.s(),
            self.s() * operand.di() * self.s(),
            self.s() * operand.dj() * self.s(),
            self.s() * operand.dk() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<DualQuaternion<T>> for Unitized<Scalar<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn sandwich(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<DualQuaternion<T>>> for Scalar<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            operand.as_inner().s() * self.s() * self.s(),
            operand.as_inner().i() * self.s() * self.s(),
            operand.as_inner().j() * self.s() * self.s(),
            operand.as_inner().d() * self.s() * self.s(),
            operand.as_inner().k() * self.s() * self.s(),
            operand.as_inner().di() * self.s() * self.s(),
            operand.as_inner().dj() * self.s() * self.s(),
            operand.as_inner().dk() * self.s() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<DualQuaternion<T>>> for Unitized<Scalar<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * operand.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(self.s() * operand.dk() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Unitized<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Trivector<T>>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(operand.as_inner().dk() * self.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Trivector<T>>> for Unitized<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            self.s() * operand.i() * self.s(),
            self.s() * operand.j() * self.s(),
            self.s() * operand.d() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Unitized<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Vector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            operand.as_inner().i() * self.s() * self.s(),
            operand.as_inner().j() * self.s() * self.s(),
            operand.as_inner().d() * self.s() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Vector<T>>> for Unitized<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Unitized<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Bivector<T>>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Bivector<T>>> for Unitized<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<DualQuaternion<T>> for Trivector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn sandwich(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<DualQuaternion<T>> for Unitized<Trivector<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn sandwich(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<DualQuaternion<T>>> for Trivector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<DualQuaternion<T>>> for Unitized<Trivector<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unitized<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Unitized<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Trivector<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Trivector<T>>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Unitized<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Vector<T>>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Vector<T>>> for Unitized<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.j() * operand.k() * self.j() + self.i() * operand.k() * self.i(),
            self.i() * operand.dj() * self.j()
                + self.j() * operand.dj() * self.i()
                + self.j() * operand.k() * self.d()
                + self.d() * operand.k() * self.j()
                + self.i() * operand.di() * self.i()
                - self.j() * operand.di() * self.j(),
            -(self.i() * operand.k() * self.d()) - self.d() * operand.k() * self.i()
                + self.i() * operand.di() * self.j()
                + self.j() * operand.di() * self.i()
                - self.i() * operand.dj() * self.i()
                + self.j() * operand.dj() * self.j(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Unitized<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            operand.k() * self.as_inner().i() * self.as_inner().i()
                + operand.k() * self.as_inner().j() * self.as_inner().j(),
            -(operand.di() * self.as_inner().j() * self.as_inner().j())
                + T::TWO * operand.k() * self.as_inner().d() * self.as_inner().j()
                + T::TWO * operand.dj() * self.as_inner().i() * self.as_inner().j()
                + operand.di() * self.as_inner().i() * self.as_inner().i(),
            -T::TWO * operand.k() * self.as_inner().d() * self.as_inner().i()
                + -(operand.dj() * self.as_inner().i() * self.as_inner().i())
                + T::TWO * operand.di() * self.as_inner().i() * self.as_inner().j()
                + operand.dj() * self.as_inner().j() * self.as_inner().j(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Bivector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            operand.as_inner().k() * self.i() * self.i()
                + operand.as_inner().k() * self.j() * self.j(),
            -(operand.as_inner().di() * self.j() * self.j())
                + T::TWO * operand.as_inner().k() * self.d() * self.j()
                + T::TWO * operand.as_inner().dj() * self.i() * self.j()
                + operand.as_inner().di() * self.i() * self.i(),
            -T::TWO * operand.as_inner().k() * self.d() * self.i()
                + -(operand.as_inner().dj() * self.i() * self.i())
                + T::TWO * operand.as_inner().di() * self.i() * self.j()
                + operand.as_inner().dj() * self.j() * self.j(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Bivector<T>>> for Unitized<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            operand.as_inner().k() * self.as_inner().i() * self.as_inner().i()
                + operand.as_inner().k() * self.as_inner().j() * self.as_inner().j(),
            -(operand.as_inner().di() * self.as_inner().j() * self.as_inner().j())
                + T::TWO * operand.as_inner().k() * self.as_inner().d() * self.as_inner().j()
                + T::TWO * operand.as_inner().dj() * self.as_inner().i() * self.as_inner().j()
                + operand.as_inner().di() * self.as_inner().i() * self.as_inner().i(),
            -T::TWO * operand.as_inner().k() * self.as_inner().d() * self.as_inner().i()
                + -(operand.as_inner().dj() * self.as_inner().i() * self.as_inner().i())
                + T::TWO * operand.as_inner().di() * self.as_inner().i() * self.as_inner().j()
                + operand.as_inner().dj() * self.as_inner().j() * self.as_inner().j(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<DualQuaternion<T>> for Vector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn sandwich(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            -(self.j() * operand.k() * self.i()) + self.i() * operand.k() * self.j()
                - self.j() * operand.s() * self.j()
                - self.i() * operand.s() * self.i(),
            self.j() * operand.i() * self.j()
                - self.j() * operand.j() * self.i()
                - self.i() * operand.j() * self.j()
                - self.i() * operand.i() * self.i(),
            -(self.j() * operand.i() * self.i()) + self.i() * operand.j() * self.i()
                - self.j() * operand.j() * self.j()
                - self.i() * operand.i() * self.j(),
            self.j() * operand.d() * self.j()
                - self.d() * operand.i() * self.i()
                - self.i() * operand.i() * self.d()
                + self.i() * operand.d() * self.i()
                - self.i() * operand.dk() * self.j()
                - self.d() * operand.j() * self.j()
                + self.j() * operand.dk() * self.i()
                - self.j() * operand.j() * self.d(),
            self.i() * operand.s() * self.j() + self.i() * operand.k() * self.i()
                - self.j() * operand.s() * self.i()
                + self.j() * operand.k() * self.j(),
            self.i() * operand.dj() * self.j() - self.d() * operand.s() * self.i()
                + self.i() * operand.s() * self.d()
                + self.i() * operand.di() * self.i()
                + self.j() * operand.k() * self.d()
                - self.j() * operand.di() * self.j()
                + self.j() * operand.dj() * self.i()
                + self.d() * operand.k() * self.j(),
            self.j() * operand.s() * self.d()
                + self.j() * operand.di() * self.i()
                + self.j() * operand.dj() * self.j()
                - self.d() * operand.k() * self.i()
                - self.i() * operand.k() * self.d()
                + self.i() * operand.di() * self.j()
                - self.d() * operand.s() * self.j()
                - self.i() * operand.dj() * self.i(),
            -(self.j() * operand.dk() * self.j()) - self.d() * operand.j() * self.i()
                + self.i() * operand.j() * self.d()
                - self.i() * operand.dk() * self.i()
                - self.j() * operand.i() * self.d()
                + self.j() * operand.d() * self.i()
                - self.i() * operand.d() * self.j()
                + self.d() * operand.i() * self.j(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<DualQuaternion<T>> for Unitized<Vector<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn sandwich(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            -(operand.s() * self.as_inner().i() * self.as_inner().i())
                + -(operand.s() * self.as_inner().j() * self.as_inner().j()),
            -T::TWO * operand.j() * self.as_inner().i() * self.as_inner().j()
                + -(operand.i() * self.as_inner().i() * self.as_inner().i())
                + operand.i() * self.as_inner().j() * self.as_inner().j(),
            -T::TWO * operand.i() * self.as_inner().i() * self.as_inner().j()
                + -(operand.j() * self.as_inner().j() * self.as_inner().j())
                + operand.j() * self.as_inner().i() * self.as_inner().i(),
            -T::TWO * operand.i() * self.as_inner().d() * self.as_inner().i()
                + -T::TWO * operand.j() * self.as_inner().d() * self.as_inner().j()
                + operand.d() * self.as_inner().i() * self.as_inner().i()
                + operand.d() * self.as_inner().j() * self.as_inner().j(),
            operand.k() * self.as_inner().i() * self.as_inner().i()
                + operand.k() * self.as_inner().j() * self.as_inner().j(),
            -(operand.di() * self.as_inner().j() * self.as_inner().j())
                + T::TWO * operand.k() * self.as_inner().d() * self.as_inner().j()
                + T::TWO * operand.dj() * self.as_inner().i() * self.as_inner().j()
                + operand.di() * self.as_inner().i() * self.as_inner().i(),
            -T::TWO * operand.k() * self.as_inner().d() * self.as_inner().i()
                + -(operand.dj() * self.as_inner().i() * self.as_inner().i())
                + T::TWO * operand.di() * self.as_inner().i() * self.as_inner().j()
                + operand.dj() * self.as_inner().j() * self.as_inner().j(),
            -(operand.dk() * self.as_inner().i() * self.as_inner().i())
                + -(operand.dk() * self.as_inner().j() * self.as_inner().j()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<DualQuaternion<T>>> for Vector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            -(operand.as_inner().s() * self.i() * self.i())
                + -(operand.as_inner().s() * self.j() * self.j()),
            -T::TWO * operand.as_inner().j() * self.i() * self.j()
                + -(operand.as_inner().i() * self.i() * self.i())
                + operand.as_inner().i() * self.j() * self.j(),
            -T::TWO * operand.as_inner().i() * self.i() * self.j()
                + -(operand.as_inner().j() * self.j() * self.j())
                + operand.as_inner().j() * self.i() * self.i(),
            -T::TWO * operand.as_inner().i() * self.d() * self.i()
                + -T::TWO * operand.as_inner().j() * self.d() * self.j()
                + operand.as_inner().d() * self.i() * self.i()
                + operand.as_inner().d() * self.j() * self.j(),
            operand.as_inner().k() * self.i() * self.i()
                + operand.as_inner().k() * self.j() * self.j(),
            -(operand.as_inner().di() * self.j() * self.j())
                + T::TWO * operand.as_inner().k() * self.d() * self.j()
                + T::TWO * operand.as_inner().dj() * self.i() * self.j()
                + operand.as_inner().di() * self.i() * self.i(),
            -T::TWO * operand.as_inner().k() * self.d() * self.i()
                + -(operand.as_inner().dj() * self.i() * self.i())
                + T::TWO * operand.as_inner().di() * self.i() * self.j()
                + operand.as_inner().dj() * self.j() * self.j(),
            -(operand.as_inner().dk() * self.i() * self.i())
                + -(operand.as_inner().dk() * self.j() * self.j()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<DualQuaternion<T>>> for Unitized<Vector<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            -(operand.as_inner().s() * self.as_inner().i() * self.as_inner().i())
                + -(operand.as_inner().s() * self.as_inner().j() * self.as_inner().j()),
            -T::TWO * operand.as_inner().j() * self.as_inner().i() * self.as_inner().j()
                + -(operand.as_inner().i() * self.as_inner().i() * self.as_inner().i())
                + operand.as_inner().i() * self.as_inner().j() * self.as_inner().j(),
            -T::TWO * operand.as_inner().i() * self.as_inner().i() * self.as_inner().j()
                + -(operand.as_inner().j() * self.as_inner().j() * self.as_inner().j())
                + operand.as_inner().j() * self.as_inner().i() * self.as_inner().i(),
            -T::TWO * operand.as_inner().i() * self.as_inner().d() * self.as_inner().i()
                + -T::TWO * operand.as_inner().j() * self.as_inner().d() * self.as_inner().j()
                + operand.as_inner().d() * self.as_inner().i() * self.as_inner().i()
                + operand.as_inner().d() * self.as_inner().j() * self.as_inner().j(),
            operand.as_inner().k() * self.as_inner().i() * self.as_inner().i()
                + operand.as_inner().k() * self.as_inner().j() * self.as_inner().j(),
            -(operand.as_inner().di() * self.as_inner().j() * self.as_inner().j())
                + T::TWO * operand.as_inner().k() * self.as_inner().d() * self.as_inner().j()
                + T::TWO * operand.as_inner().dj() * self.as_inner().i() * self.as_inner().j()
                + operand.as_inner().di() * self.as_inner().i() * self.as_inner().i(),
            -T::TWO * operand.as_inner().k() * self.as_inner().d() * self.as_inner().i()
                + -(operand.as_inner().dj() * self.as_inner().i() * self.as_inner().i())
                + T::TWO * operand.as_inner().di() * self.as_inner().i() * self.as_inner().j()
                + operand.as_inner().dj() * self.as_inner().j() * self.as_inner().j(),
            -(operand.as_inner().dk() * self.as_inner().i() * self.as_inner().i())
                + -(operand.as_inner().dk() * self.as_inner().j() * self.as_inner().j()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.i() * operand.s() * self.i()) - self.j() * operand.s() * self.j(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unitized<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(operand.s() * self.as_inner().i() * self.as_inner().i())
                + -(operand.s() * self.as_inner().j() * self.as_inner().j()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Unitized<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(self.j() * operand.dk() * self.j()) - self.i() * operand.dk() * self.i(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Unitized<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(operand.dk() * self.as_inner().i() * self.as_inner().i())
                + -(operand.dk() * self.as_inner().j() * self.as_inner().j()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Trivector<T>>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(operand.as_inner().dk() * self.i() * self.i())
                + -(operand.as_inner().dk() * self.j() * self.j()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Trivector<T>>> for Unitized<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(operand.as_inner().dk() * self.as_inner().i() * self.as_inner().i())
                + -(operand.as_inner().dk() * self.as_inner().j() * self.as_inner().j()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.i() * operand.i() * self.i())
                - self.i() * operand.j() * self.j()
                - self.j() * operand.j() * self.i()
                + self.j() * operand.i() * self.j(),
            self.i() * operand.j() * self.i()
                - self.j() * operand.i() * self.i()
                - self.i() * operand.i() * self.j()
                - self.j() * operand.j() * self.j(),
            self.i() * operand.d() * self.i() - self.d() * operand.i() * self.i()
                + self.j() * operand.d() * self.j()
                - self.d() * operand.j() * self.j()
                - self.i() * operand.i() * self.d()
                - self.j() * operand.j() * self.d(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -T::TWO * operand.j() * self.as_inner().i() * self.as_inner().j()
                + -(operand.i() * self.as_inner().i() * self.as_inner().i())
                + operand.i() * self.as_inner().j() * self.as_inner().j(),
            -T::TWO * operand.i() * self.as_inner().i() * self.as_inner().j()
                + -(operand.j() * self.as_inner().j() * self.as_inner().j())
                + operand.j() * self.as_inner().i() * self.as_inner().i(),
            -T::TWO * operand.i() * self.as_inner().d() * self.as_inner().i()
                + -T::TWO * operand.j() * self.as_inner().d() * self.as_inner().j()
                + operand.d() * self.as_inner().i() * self.as_inner().i()
                + operand.d() * self.as_inner().j() * self.as_inner().j(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Vector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -T::TWO * operand.as_inner().j() * self.i() * self.j()
                + -(operand.as_inner().i() * self.i() * self.i())
                + operand.as_inner().i() * self.j() * self.j(),
            -T::TWO * operand.as_inner().i() * self.i() * self.j()
                + -(operand.as_inner().j() * self.j() * self.j())
                + operand.as_inner().j() * self.i() * self.i(),
            -T::TWO * operand.as_inner().i() * self.d() * self.i()
                + -T::TWO * operand.as_inner().j() * self.d() * self.j()
                + operand.as_inner().d() * self.i() * self.i()
                + operand.as_inner().d() * self.j() * self.j(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Vector<T>>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -T::TWO * operand.as_inner().j() * self.as_inner().i() * self.as_inner().j()
                + -(operand.as_inner().i() * self.as_inner().i() * self.as_inner().i())
                + operand.as_inner().i() * self.as_inner().j() * self.as_inner().j(),
            -T::TWO * operand.as_inner().i() * self.as_inner().i() * self.as_inner().j()
                + -(operand.as_inner().j() * self.as_inner().j() * self.as_inner().j())
                + operand.as_inner().j() * self.as_inner().i() * self.as_inner().i(),
            -T::TWO * operand.as_inner().i() * self.as_inner().d() * self.as_inner().i()
                + -T::TWO * operand.as_inner().j() * self.as_inner().d() * self.as_inner().j()
                + operand.as_inner().d() * self.as_inner().i() * self.as_inner().i()
                + operand.as_inner().d() * self.as_inner().j() * self.as_inner().j(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.di() * operand.k() * self.di()
                - self.dj() * operand.dj() * self.k()
                - self.k() * operand.dj() * self.dj()
                - self.k() * operand.di() * self.di()
                - self.di() * operand.di() * self.k()
                + self.dj() * operand.k() * self.dj(),
            -(self.di() * operand.dj() * self.dj()) - self.dj() * operand.dj() * self.di()
                + self.dj() * operand.di() * self.dj()
                - self.di() * operand.di() * self.di(),
            -(self.di() * operand.di() * self.dj()) - self.dj() * operand.di() * self.di()
                + self.di() * operand.dj() * self.di()
                - self.dj() * operand.dj() * self.dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -T::TWO * operand.di() * self.as_inner().di() * self.as_inner().k()
                + -T::TWO * operand.dj() * self.as_inner().dj() * self.as_inner().k()
                + operand.k(),
            -T::TWO * operand.dj() * self.as_inner().di() * self.as_inner().dj()
                + -(operand.di())
                + T::TWO * operand.di() * self.as_inner().dj() * self.as_inner().dj(),
            -T::TWO * operand.di() * self.as_inner().di() * self.as_inner().dj()
                + -T::TWO * operand.dj() * self.as_inner().dj() * self.as_inner().dj()
                + operand.dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Bivector<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -T::TWO * operand.as_inner().di() * self.di() * self.k()
                + -T::TWO * operand.as_inner().dj() * self.dj() * self.k()
                + operand.as_inner().k() * self.di() * self.di()
                + operand.as_inner().k() * self.dj() * self.dj(),
            -T::TWO * operand.as_inner().dj() * self.di() * self.dj()
                + -(operand.as_inner().di() * self.di() * self.di())
                + operand.as_inner().di() * self.dj() * self.dj(),
            -T::TWO * operand.as_inner().di() * self.di() * self.dj()
                + -(operand.as_inner().dj() * self.dj() * self.dj())
                + operand.as_inner().dj() * self.di() * self.di(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Bivector<T>>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -T::TWO * operand.as_inner().di() * self.as_inner().di() * self.as_inner().k()
                + -T::TWO * operand.as_inner().dj() * self.as_inner().dj() * self.as_inner().k()
                + operand.as_inner().k(),
            -T::TWO * operand.as_inner().dj() * self.as_inner().di() * self.as_inner().dj()
                + -(operand.as_inner().di())
                + T::TWO * operand.as_inner().di() * self.as_inner().dj() * self.as_inner().dj(),
            -T::TWO * operand.as_inner().di() * self.as_inner().di() * self.as_inner().dj()
                + -T::TWO * operand.as_inner().dj() * self.as_inner().dj() * self.as_inner().dj()
                + operand.as_inner().dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<DualQuaternion<T>> for Bivector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn antisandwich(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            -(self.dj() * operand.di() * self.k()) - self.dj() * operand.s() * self.dj()
                + self.di() * operand.dj() * self.k()
                - self.k() * operand.dj() * self.di()
                + self.k() * operand.di() * self.dj()
                - self.di() * operand.s() * self.di()
                - self.di() * operand.k() * self.dj()
                + self.dj() * operand.k() * self.di(),
            self.di() * operand.i() * self.di() - self.di() * operand.dk() * self.k()
                + self.dj() * operand.j() * self.di()
                - self.k() * operand.d() * self.dj()
                + self.k() * operand.dk() * self.di()
                - self.dj() * operand.i() * self.dj()
                + self.di() * operand.j() * self.dj()
                - self.dj() * operand.d() * self.k(),
            self.k() * operand.dk() * self.dj()
                + self.dj() * operand.i() * self.di()
                + self.di() * operand.i() * self.dj()
                + self.k() * operand.d() * self.di()
                - self.di() * operand.j() * self.di()
                - self.dj() * operand.dk() * self.k()
                + self.di() * operand.d() * self.k()
                + self.dj() * operand.j() * self.dj(),
            -(self.dj() * operand.dk() * self.di())
                + self.di() * operand.d() * self.di()
                + self.di() * operand.dk() * self.dj()
                + self.dj() * operand.d() * self.dj(),
            -(self.k() * operand.di() * self.di()) - self.k() * operand.dj() * self.dj()
                + self.di() * operand.k() * self.di()
                - self.di() * operand.s() * self.dj()
                + self.dj() * operand.s() * self.di()
                - self.di() * operand.di() * self.k()
                - self.dj() * operand.dj() * self.k()
                + self.dj() * operand.k() * self.dj(),
            self.dj() * operand.di() * self.dj()
                - self.di() * operand.di() * self.di()
                - self.di() * operand.dj() * self.dj()
                - self.dj() * operand.dj() * self.di(),
            -(self.di() * operand.di() * self.dj()) + self.di() * operand.dj() * self.di()
                - self.dj() * operand.dj() * self.dj()
                - self.dj() * operand.di() * self.di(),
            -(self.di() * operand.dk() * self.di()) + self.di() * operand.d() * self.dj()
                - self.dj() * operand.d() * self.di()
                - self.dj() * operand.dk() * self.dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<DualQuaternion<T>> for Unitized<Bivector<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn antisandwich(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            -(operand.s()),
            -T::TWO * operand.d() * self.as_inner().dj() * self.as_inner().k()
                + -T::TWO * operand.i() * self.as_inner().dj() * self.as_inner().dj()
                + T::TWO * operand.j() * self.as_inner().di() * self.as_inner().dj()
                + operand.i(),
            -(operand.j())
                + T::TWO * operand.d() * self.as_inner().di() * self.as_inner().k()
                + T::TWO * operand.i() * self.as_inner().di() * self.as_inner().dj()
                + T::TWO * operand.j() * self.as_inner().dj() * self.as_inner().dj(),
            operand.d(),
            -T::TWO * operand.di() * self.as_inner().di() * self.as_inner().k()
                + -T::TWO * operand.dj() * self.as_inner().dj() * self.as_inner().k()
                + operand.k(),
            -T::TWO * operand.dj() * self.as_inner().di() * self.as_inner().dj()
                + -(operand.di())
                + T::TWO * operand.di() * self.as_inner().dj() * self.as_inner().dj(),
            -T::TWO * operand.di() * self.as_inner().di() * self.as_inner().dj()
                + -T::TWO * operand.dj() * self.as_inner().dj() * self.as_inner().dj()
                + operand.dj(),
            -(operand.dk()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<DualQuaternion<T>>> for Bivector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            -(operand.as_inner().s() * self.di() * self.di())
                + -(operand.as_inner().s() * self.dj() * self.dj()),
            -T::TWO * operand.as_inner().d() * self.dj() * self.k()
                + -(operand.as_inner().i() * self.dj() * self.dj())
                + T::TWO * operand.as_inner().j() * self.di() * self.dj()
                + operand.as_inner().i() * self.di() * self.di(),
            -(operand.as_inner().j() * self.di() * self.di())
                + T::TWO * operand.as_inner().d() * self.di() * self.k()
                + T::TWO * operand.as_inner().i() * self.di() * self.dj()
                + operand.as_inner().j() * self.dj() * self.dj(),
            operand.as_inner().d() * self.di() * self.di()
                + operand.as_inner().d() * self.dj() * self.dj(),
            -T::TWO * operand.as_inner().di() * self.di() * self.k()
                + -T::TWO * operand.as_inner().dj() * self.dj() * self.k()
                + operand.as_inner().k() * self.di() * self.di()
                + operand.as_inner().k() * self.dj() * self.dj(),
            -T::TWO * operand.as_inner().dj() * self.di() * self.dj()
                + -(operand.as_inner().di() * self.di() * self.di())
                + operand.as_inner().di() * self.dj() * self.dj(),
            -T::TWO * operand.as_inner().di() * self.di() * self.dj()
                + -(operand.as_inner().dj() * self.dj() * self.dj())
                + operand.as_inner().dj() * self.di() * self.di(),
            -(operand.as_inner().dk() * self.di() * self.di())
                + -(operand.as_inner().dk() * self.dj() * self.dj()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<DualQuaternion<T>>> for Unitized<Bivector<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            -(operand.as_inner().s()),
            -T::TWO * operand.as_inner().d() * self.as_inner().dj() * self.as_inner().k()
                + -T::TWO * operand.as_inner().i() * self.as_inner().dj() * self.as_inner().dj()
                + T::TWO * operand.as_inner().j() * self.as_inner().di() * self.as_inner().dj()
                + operand.as_inner().i(),
            -(operand.as_inner().j())
                + T::TWO * operand.as_inner().d() * self.as_inner().di() * self.as_inner().k()
                + T::TWO * operand.as_inner().i() * self.as_inner().di() * self.as_inner().dj()
                + T::TWO * operand.as_inner().j() * self.as_inner().dj() * self.as_inner().dj(),
            operand.as_inner().d(),
            -T::TWO * operand.as_inner().di() * self.as_inner().di() * self.as_inner().k()
                + -T::TWO * operand.as_inner().dj() * self.as_inner().dj() * self.as_inner().k()
                + operand.as_inner().k(),
            -T::TWO * operand.as_inner().dj() * self.as_inner().di() * self.as_inner().dj()
                + -(operand.as_inner().di())
                + T::TWO * operand.as_inner().di() * self.as_inner().dj() * self.as_inner().dj(),
            -T::TWO * operand.as_inner().di() * self.as_inner().di() * self.as_inner().dj()
                + -T::TWO * operand.as_inner().dj() * self.as_inner().dj() * self.as_inner().dj()
                + operand.as_inner().dj(),
            -(operand.as_inner().dk()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.di() * operand.s() * self.di()) - self.dj() * operand.s() * self.dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unitized<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Unitized<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(self.dj() * operand.dk() * self.dj()) - self.di() * operand.dk() * self.di(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Unitized<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(-(operand.dk()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Trivector<T>>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(operand.as_inner().dk() * self.di() * self.di())
                + -(operand.as_inner().dk() * self.dj() * self.dj()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Trivector<T>>> for Unitized<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(-(operand.as_inner().dk()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            self.di() * operand.j() * self.dj()
                - self.dj() * operand.d() * self.k()
                - self.k() * operand.d() * self.dj()
                - self.dj() * operand.i() * self.dj()
                + self.dj() * operand.j() * self.di()
                + self.di() * operand.i() * self.di(),
            -(self.di() * operand.j() * self.di())
                + self.di() * operand.d() * self.k()
                + self.dj() * operand.i() * self.di()
                + self.di() * operand.i() * self.dj()
                + self.dj() * operand.j() * self.dj()
                + self.k() * operand.d() * self.di(),
            self.dj() * operand.d() * self.dj() + self.di() * operand.d() * self.di(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Unitized<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -T::TWO * operand.d() * self.as_inner().dj() * self.as_inner().k()
                + -T::TWO * operand.i() * self.as_inner().dj() * self.as_inner().dj()
                + T::TWO * operand.j() * self.as_inner().di() * self.as_inner().dj()
                + operand.i(),
            -(operand.j())
                + T::TWO * operand.d() * self.as_inner().di() * self.as_inner().k()
                + T::TWO * operand.i() * self.as_inner().di() * self.as_inner().dj()
                + T::TWO * operand.j() * self.as_inner().dj() * self.as_inner().dj(),
            operand.d(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Vector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -T::TWO * operand.as_inner().d() * self.dj() * self.k()
                + -(operand.as_inner().i() * self.dj() * self.dj())
                + T::TWO * operand.as_inner().j() * self.di() * self.dj()
                + operand.as_inner().i() * self.di() * self.di(),
            -(operand.as_inner().j() * self.di() * self.di())
                + T::TWO * operand.as_inner().d() * self.di() * self.k()
                + T::TWO * operand.as_inner().i() * self.di() * self.dj()
                + operand.as_inner().j() * self.dj() * self.dj(),
            operand.as_inner().d() * self.di() * self.di()
                + operand.as_inner().d() * self.dj() * self.dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Vector<T>>> for Unitized<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -T::TWO * operand.as_inner().d() * self.as_inner().dj() * self.as_inner().k()
                + -T::TWO * operand.as_inner().i() * self.as_inner().dj() * self.as_inner().dj()
                + T::TWO * operand.as_inner().j() * self.as_inner().di() * self.as_inner().dj()
                + operand.as_inner().i(),
            -(operand.as_inner().j())
                + T::TWO * operand.as_inner().d() * self.as_inner().di() * self.as_inner().k()
                + T::TWO * operand.as_inner().i() * self.as_inner().di() * self.as_inner().dj()
                + T::TWO * operand.as_inner().j() * self.as_inner().dj() * self.as_inner().dj(),
            operand.as_inner().d(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Unitized<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Bivector<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Bivector<T>>> for Unitized<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<DualQuaternion<T>> for Scalar<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn antisandwich(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<DualQuaternion<T>> for Unitized<Scalar<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn antisandwich(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<DualQuaternion<T>>> for Scalar<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<DualQuaternion<T>>> for Unitized<Scalar<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Unitized<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Trivector<T>>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Trivector<T>>> for Unitized<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Unitized<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Vector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Vector<T>>> for Unitized<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.dk() * operand.k() * self.dk(),
            self.dk() * operand.di() * self.dk(),
            self.dk() * operand.dj() * self.dk(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Unitized<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(operand.k(), operand.di(), operand.dj())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Bivector<T>>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            operand.as_inner().k() * self.dk() * self.dk(),
            operand.as_inner().di() * self.dk() * self.dk(),
            operand.as_inner().dj() * self.dk() * self.dk(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Bivector<T>>> for Unitized<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            operand.as_inner().k(),
            operand.as_inner().di(),
            operand.as_inner().dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<DualQuaternion<T>> for Trivector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn antisandwich(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            self.dk() * operand.s() * self.dk(),
            self.dk() * operand.i() * self.dk(),
            self.dk() * operand.j() * self.dk(),
            self.dk() * operand.d() * self.dk(),
            self.dk() * operand.k() * self.dk(),
            self.dk() * operand.di() * self.dk(),
            self.dk() * operand.dj() * self.dk(),
            self.dk() * operand.dk() * self.dk(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<DualQuaternion<T>> for Unitized<Trivector<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn antisandwich(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            operand.s(),
            operand.i(),
            operand.j(),
            operand.d(),
            operand.k(),
            operand.di(),
            operand.dj(),
            operand.dk(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<DualQuaternion<T>>> for Trivector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            operand.as_inner().s() * self.dk() * self.dk(),
            operand.as_inner().i() * self.dk() * self.dk(),
            operand.as_inner().j() * self.dk() * self.dk(),
            operand.as_inner().d() * self.dk() * self.dk(),
            operand.as_inner().k() * self.dk() * self.dk(),
            operand.as_inner().di() * self.dk() * self.dk(),
            operand.as_inner().dj() * self.dk() * self.dk(),
            operand.as_inner().dk() * self.dk() * self.dk(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<DualQuaternion<T>>> for Unitized<Trivector<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            operand.as_inner().s(),
            operand.as_inner().i(),
            operand.as_inner().j(),
            operand.as_inner().d(),
            operand.as_inner().k(),
            operand.as_inner().di(),
            operand.as_inner().dj(),
            operand.as_inner().dk(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.dk() * operand.s() * self.dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unitized<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Unitized<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(self.dk() * operand.dk() * self.dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(operand.dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Trivector<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(operand.as_inner().dk() * self.dk() * self.dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Trivector<T>>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(operand.as_inner().dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            self.dk() * operand.i() * self.dk(),
            self.dk() * operand.j() * self.dk(),
            self.dk() * operand.d() * self.dk(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Unitized<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(operand.i(), operand.j(), operand.d())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Vector<T>>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            operand.as_inner().i() * self.dk() * self.dk(),
            operand.as_inner().j() * self.dk() * self.dk(),
            operand.as_inner().d() * self.dk() * self.dk(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Vector<T>>> for Unitized<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            operand.as_inner().i(),
            operand.as_inner().j(),
            operand.as_inner().d(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.d() * operand.k() * self.d() - self.d() * operand.di() * self.j()
                + self.i() * operand.dj() * self.d()
                - self.j() * operand.di() * self.d()
                + self.d() * operand.dj() * self.i(),
            -(self.d() * operand.di() * self.d()),
            -(self.d() * operand.dj() * self.d()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Unitized<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -T::TWO * operand.di() * self.as_inner().d() * self.as_inner().j()
                + T::TWO * operand.dj() * self.as_inner().d() * self.as_inner().i()
                + operand.k(),
            -(operand.di()),
            -(operand.dj()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Bivector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -T::TWO * operand.as_inner().di() * self.d() * self.j()
                + T::TWO * operand.as_inner().dj() * self.d() * self.i()
                + operand.as_inner().k() * self.d() * self.d(),
            -(operand.as_inner().di() * self.d() * self.d()),
            -(operand.as_inner().dj() * self.d() * self.d()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Bivector<T>>> for Unitized<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -T::TWO * operand.as_inner().di() * self.as_inner().d() * self.as_inner().j()
                + T::TWO * operand.as_inner().dj() * self.as_inner().d() * self.as_inner().i()
                + operand.as_inner().k(),
            -(operand.as_inner().di()),
            -(operand.as_inner().dj()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<DualQuaternion<T>> for Vector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn antisandwich(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            self.i() * operand.di() * self.d() + self.d() * operand.s() * self.d()
                - self.d() * operand.dj() * self.j()
                - self.d() * operand.di() * self.i()
                + self.j() * operand.dj() * self.d(),
            -(self.d() * operand.i() * self.d())
                + self.i() * operand.d() * self.d()
                + self.d() * operand.d() * self.i()
                + self.d() * operand.dk() * self.j()
                - self.j() * operand.dk() * self.d(),
            self.j() * operand.d() * self.d() + self.i() * operand.dk() * self.d()
                - self.d() * operand.j() * self.d()
                - self.d() * operand.dk() * self.i()
                + self.d() * operand.d() * self.j(),
            self.d() * operand.d() * self.d(),
            -(self.j() * operand.di() * self.d())
                + self.i() * operand.dj() * self.d()
                + self.d() * operand.dj() * self.i()
                + self.d() * operand.k() * self.d()
                - self.d() * operand.di() * self.j(),
            -(self.d() * operand.di() * self.d()),
            -(self.d() * operand.dj() * self.d()),
            self.d() * operand.dk() * self.d(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<DualQuaternion<T>> for Unitized<Vector<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn antisandwich(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            operand.s(),
            -(operand.i()) + T::TWO * operand.d() * self.as_inner().d() * self.as_inner().i(),
            -(operand.j()) + T::TWO * operand.d() * self.as_inner().d() * self.as_inner().j(),
            operand.d(),
            -T::TWO * operand.di() * self.as_inner().d() * self.as_inner().j()
                + T::TWO * operand.dj() * self.as_inner().d() * self.as_inner().i()
                + operand.k(),
            -(operand.di()),
            -(operand.dj()),
            operand.dk(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<DualQuaternion<T>>> for Vector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            operand.as_inner().s() * self.d() * self.d(),
            -(operand.as_inner().i() * self.d() * self.d())
                + T::TWO * operand.as_inner().d() * self.d() * self.i(),
            -(operand.as_inner().j() * self.d() * self.d())
                + T::TWO * operand.as_inner().d() * self.d() * self.j(),
            operand.as_inner().d() * self.d() * self.d(),
            -T::TWO * operand.as_inner().di() * self.d() * self.j()
                + T::TWO * operand.as_inner().dj() * self.d() * self.i()
                + operand.as_inner().k() * self.d() * self.d(),
            -(operand.as_inner().di() * self.d() * self.d()),
            -(operand.as_inner().dj() * self.d() * self.d()),
            operand.as_inner().dk() * self.d() * self.d(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<DualQuaternion<T>>> for Unitized<Vector<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            operand.as_inner().s(),
            -(operand.as_inner().i())
                + T::TWO * operand.as_inner().d() * self.as_inner().d() * self.as_inner().i(),
            -(operand.as_inner().j())
                + T::TWO * operand.as_inner().d() * self.as_inner().d() * self.as_inner().j(),
            operand.as_inner().d(),
            -T::TWO * operand.as_inner().di() * self.as_inner().d() * self.as_inner().j()
                + T::TWO * operand.as_inner().dj() * self.as_inner().d() * self.as_inner().i()
                + operand.as_inner().k(),
            -(operand.as_inner().di()),
            -(operand.as_inner().dj()),
            operand.as_inner().dk(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.d() * operand.s() * self.d())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unitized<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Unitized<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(self.d() * operand.dk() * self.d())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Unitized<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(operand.dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Trivector<T>>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(operand.as_inner().dk() * self.d() * self.d())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Trivector<T>>> for Unitized<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(operand.as_inner().dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.d() * operand.i() * self.d())
                + self.d() * operand.d() * self.i()
                + self.i() * operand.d() * self.d(),
            self.d() * operand.d() * self.j() + self.j() * operand.d() * self.d()
                - self.d() * operand.j() * self.d(),
            self.d() * operand.d() * self.d(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.i()) + T::TWO * operand.d() * self.as_inner().d() * self.as_inner().i(),
            -(operand.j()) + T::TWO * operand.d() * self.as_inner().d() * self.as_inner().j(),
            operand.d(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Vector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.as_inner().i() * self.d() * self.d())
                + T::TWO * operand.as_inner().d() * self.d() * self.i(),
            -(operand.as_inner().j() * self.d() * self.d())
                + T::TWO * operand.as_inner().d() * self.d() * self.j(),
            operand.as_inner().d() * self.d() * self.d(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Vector<T>>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.as_inner().i())
                + T::TWO * operand.as_inner().d() * self.as_inner().d() * self.as_inner().i(),
            -(operand.as_inner().j())
                + T::TWO * operand.as_inner().d() * self.as_inner().d() * self.as_inner().j(),
            operand.as_inner().d(),
        )
    }
}
impl<T: Float> Transform<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Bivector<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Bivector<T>>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<DualQuaternion<T>> for Bivector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn transform(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<DualQuaternion<T>> for Unitized<Bivector<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn transform(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<DualQuaternion<T>>> for Bivector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<DualQuaternion<T>>> for Unitized<Bivector<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unitized<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Unitized<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Unitized<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Trivector<T>>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Trivector<T>>> for Unitized<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Unitized<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Vector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Vector<T>>> for Unitized<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Unitized<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Bivector<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Bivector<T>>> for Unitized<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<DualQuaternion<T>> for Scalar<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn transform(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<DualQuaternion<T>> for Unitized<Scalar<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn transform(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<DualQuaternion<T>>> for Scalar<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<DualQuaternion<T>>> for Unitized<Scalar<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Unitized<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Trivector<T>>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Trivector<T>>> for Unitized<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Unitized<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Vector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Vector<T>>> for Unitized<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Unitized<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Bivector<T>>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Bivector<T>>> for Unitized<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<DualQuaternion<T>> for Trivector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn transform(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<DualQuaternion<T>> for Unitized<Trivector<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn transform(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<DualQuaternion<T>>> for Trivector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<DualQuaternion<T>>> for Unitized<Trivector<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unitized<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Unitized<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Trivector<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Trivector<T>>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Unitized<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Vector<T>>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Vector<T>>> for Unitized<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Unitized<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Bivector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Bivector<T>>> for Unitized<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Bivector<T>>) -> Bivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<DualQuaternion<T>> for Vector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn transform(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<DualQuaternion<T>> for Unitized<Vector<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn transform(&self, operand: &DualQuaternion<T>) -> DualQuaternion<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<DualQuaternion<T>>> for Vector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<DualQuaternion<T>>> for Unitized<Vector<T>> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<DualQuaternion<T>>) -> DualQuaternion<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unitized<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Unitized<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Unitized<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Trivector<T>>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Trivector<T>>> for Unitized<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Trivector<T>>) -> Trivector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Vector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Vector<T>>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Vector<T>>) -> Vector<T> {
        self.antisandwich(operand)
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (self.k() * operand.k() * self.k()) * inv_norm_sq,
            (self.k() * operand.k() * self.di() - self.k() * operand.di() * self.k()
                + self.di() * operand.k() * self.k())
                * inv_norm_sq,
            (self.k() * operand.k() * self.dj() - self.k() * operand.dj() * self.k()
                + self.dj() * operand.k() * self.k())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<DualQuaternion<T>> for Bivector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &DualQuaternion<T>) -> Option<DualQuaternion<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(DualQuaternion::new_unchecked(
            (self.k() * operand.s() * self.k()) * inv_norm_sq,
            (-(self.k() * operand.i() * self.k())) * inv_norm_sq,
            (-(self.k() * operand.j() * self.k())) * inv_norm_sq,
            (self.k() * operand.d() * self.k() + self.k() * operand.i() * self.dj()
                - self.k() * operand.j() * self.di()
                - self.di() * operand.j() * self.k()
                + self.dj() * operand.i() * self.k())
                * inv_norm_sq,
            (self.k() * operand.k() * self.k()) * inv_norm_sq,
            (self.k() * operand.s() * self.dj() - self.k() * operand.di() * self.k()
                + self.di() * operand.k() * self.k()
                - self.dj() * operand.s() * self.k()
                + self.k() * operand.k() * self.di())
                * inv_norm_sq,
            (self.k() * operand.k() * self.dj()
                - self.k() * operand.s() * self.di()
                - self.k() * operand.dj() * self.k()
                + self.dj() * operand.k() * self.k()
                + self.di() * operand.s() * self.k())
                * inv_norm_sq,
            (-(self.dj() * operand.j() * self.k()) - self.di() * operand.i() * self.k()
                + self.k() * operand.i() * self.di()
                + self.k() * operand.dk() * self.k()
                + self.k() * operand.j() * self.dj())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.k() * operand.s() * self.k()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Trivector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked(
            (self.k() * operand.dk() * self.k()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (-(self.k() * operand.i() * self.k())) * inv_norm_sq,
            (-(self.k() * operand.j() * self.k())) * inv_norm_sq,
            (self.k() * operand.d() * self.k() + self.k() * operand.i() * self.dj()
                - self.di() * operand.j() * self.k()
                + self.dj() * operand.i() * self.k()
                - self.k() * operand.j() * self.di())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (self.s() * operand.k() * self.s()) * inv_norm_sq,
            (self.s() * operand.di() * self.s()) * inv_norm_sq,
            (self.s() * operand.dj() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<DualQuaternion<T>> for Scalar<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &DualQuaternion<T>) -> Option<DualQuaternion<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(DualQuaternion::new_unchecked(
            (self.s() * operand.s() * self.s()) * inv_norm_sq,
            (self.s() * operand.i() * self.s()) * inv_norm_sq,
            (self.s() * operand.j() * self.s()) * inv_norm_sq,
            (self.s() * operand.d() * self.s()) * inv_norm_sq,
            (self.s() * operand.k() * self.s()) * inv_norm_sq,
            (self.s() * operand.di() * self.s()) * inv_norm_sq,
            (self.s() * operand.dj() * self.s()) * inv_norm_sq,
            (self.s() * operand.dk() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.s() * operand.s() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked(
            (self.s() * operand.dk() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (self.s() * operand.i() * self.s()) * inv_norm_sq,
            (self.s() * operand.j() * self.s()) * inv_norm_sq,
            (self.s() * operand.d() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Bivector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<DualQuaternion<T>> for Trivector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &DualQuaternion<T>) -> Option<DualQuaternion<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(DualQuaternion::new_unchecked(
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked((T::zero()) * inv_norm_sq))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Trivector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked((T::zero()) * inv_norm_sq))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Vector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Bivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (self.i() * operand.k() * self.i() + self.j() * operand.k() * self.j()) * inv_norm_sq,
            (self.j() * operand.dj() * self.i()
                + self.j() * operand.k() * self.d()
                + self.i() * operand.di() * self.i()
                + self.i() * operand.dj() * self.j()
                + self.d() * operand.k() * self.j()
                - self.j() * operand.di() * self.j())
                * inv_norm_sq,
            (self.j() * operand.di() * self.i() - self.i() * operand.k() * self.d()
                + self.i() * operand.di() * self.j()
                + self.j() * operand.dj() * self.j()
                - self.i() * operand.dj() * self.i()
                - self.d() * operand.k() * self.i())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<DualQuaternion<T>> for Vector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &DualQuaternion<T>) -> Option<DualQuaternion<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(DualQuaternion::new_unchecked(
            (-(self.i() * operand.s() * self.i()) + self.i() * operand.k() * self.j()
                - self.j() * operand.s() * self.j()
                - self.j() * operand.k() * self.i())
                * inv_norm_sq,
            (-(self.i() * operand.j() * self.j()) - self.i() * operand.i() * self.i()
                + self.j() * operand.i() * self.j()
                - self.j() * operand.j() * self.i())
                * inv_norm_sq,
            (-(self.i() * operand.i() * self.j()) + self.i() * operand.j() * self.i()
                - self.j() * operand.i() * self.i()
                - self.j() * operand.j() * self.j())
                * inv_norm_sq,
            (self.i() * operand.d() * self.i()
                - self.d() * operand.i() * self.i()
                - self.j() * operand.j() * self.d()
                + self.j() * operand.dk() * self.i()
                + self.j() * operand.d() * self.j()
                - self.d() * operand.j() * self.j()
                - self.i() * operand.i() * self.d()
                - self.i() * operand.dk() * self.j())
                * inv_norm_sq,
            (-(self.j() * operand.s() * self.i())
                + self.i() * operand.k() * self.i()
                + self.i() * operand.s() * self.j()
                + self.j() * operand.k() * self.j())
                * inv_norm_sq,
            (self.d() * operand.k() * self.j()
                + self.i() * operand.s() * self.d()
                + self.j() * operand.dj() * self.i()
                + self.j() * operand.k() * self.d()
                + self.i() * operand.dj() * self.j()
                - self.j() * operand.di() * self.j()
                + self.i() * operand.di() * self.i()
                - self.d() * operand.s() * self.i())
                * inv_norm_sq,
            (self.j() * operand.s() * self.d()
                + self.i() * operand.di() * self.j()
                + self.j() * operand.dj() * self.j()
                - self.i() * operand.k() * self.d()
                - self.d() * operand.k() * self.i()
                - self.i() * operand.dj() * self.i()
                + self.j() * operand.di() * self.i()
                - self.d() * operand.s() * self.j())
                * inv_norm_sq,
            (self.i() * operand.j() * self.d() - self.i() * operand.d() * self.j()
                + self.j() * operand.d() * self.i()
                - self.i() * operand.dk() * self.i()
                - self.j() * operand.dk() * self.j()
                + self.d() * operand.i() * self.j()
                - self.d() * operand.j() * self.i()
                - self.j() * operand.i() * self.d())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (-(self.j() * operand.s() * self.j()) - self.i() * operand.s() * self.i())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Trivector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked(
            (-(self.j() * operand.dk() * self.j()) - self.i() * operand.dk() * self.i())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Vector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (-(self.i() * operand.j() * self.j()) - self.i() * operand.i() * self.i()
                + self.j() * operand.i() * self.j()
                - self.j() * operand.j() * self.i())
                * inv_norm_sq,
            (-(self.j() * operand.i() * self.i()) + self.i() * operand.j() * self.i()
                - self.i() * operand.i() * self.j()
                - self.j() * operand.j() * self.j())
                * inv_norm_sq,
            (-(self.j() * operand.j() * self.d()) + self.j() * operand.d() * self.j()
                - self.d() * operand.i() * self.i()
                - self.i() * operand.i() * self.d()
                + self.i() * operand.d() * self.i()
                - self.d() * operand.j() * self.j())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (-(self.k() * operand.dj() * self.dj()) - self.dj() * operand.dj() * self.k()
                + self.di() * operand.k() * self.di()
                - self.k() * operand.di() * self.di()
                - self.di() * operand.di() * self.k()
                + self.dj() * operand.k() * self.dj())
                * inv_norm_sq,
            (-(self.di() * operand.dj() * self.dj())
                - self.di() * operand.di() * self.di()
                - self.dj() * operand.dj() * self.di()
                + self.dj() * operand.di() * self.dj())
                * inv_norm_sq,
            (self.di() * operand.dj() * self.di()
                - self.dj() * operand.dj() * self.dj()
                - self.dj() * operand.di() * self.di()
                - self.di() * operand.di() * self.dj())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<DualQuaternion<T>> for Bivector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &DualQuaternion<T>) -> Option<DualQuaternion<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(DualQuaternion::new_unchecked(
            (-(self.k() * operand.dj() * self.di())
                - self.dj() * operand.s() * self.dj()
                - self.di() * operand.k() * self.dj()
                - self.dj() * operand.di() * self.k()
                + self.k() * operand.di() * self.dj()
                + self.di() * operand.dj() * self.k()
                + self.dj() * operand.k() * self.di()
                - self.di() * operand.s() * self.di())
                * inv_norm_sq,
            (self.di() * operand.i() * self.di()
                - self.k() * operand.d() * self.dj()
                - self.di() * operand.dk() * self.k()
                + self.k() * operand.dk() * self.di()
                + self.dj() * operand.j() * self.di()
                - self.dj() * operand.i() * self.dj()
                + self.di() * operand.j() * self.dj()
                - self.dj() * operand.d() * self.k())
                * inv_norm_sq,
            (self.dj() * operand.j() * self.dj() + self.k() * operand.d() * self.di()
                - self.dj() * operand.dk() * self.k()
                + self.di() * operand.i() * self.dj()
                - self.di() * operand.j() * self.di()
                + self.k() * operand.dk() * self.dj()
                + self.di() * operand.d() * self.k()
                + self.dj() * operand.i() * self.di())
                * inv_norm_sq,
            (-(self.dj() * operand.dk() * self.di())
                + self.di() * operand.d() * self.di()
                + self.dj() * operand.d() * self.dj()
                + self.di() * operand.dk() * self.dj())
                * inv_norm_sq,
            (-(self.k() * operand.di() * self.di()) + self.di() * operand.k() * self.di()
                - self.di() * operand.di() * self.k()
                - self.dj() * operand.dj() * self.k()
                - self.k() * operand.dj() * self.dj()
                - self.di() * operand.s() * self.dj()
                + self.dj() * operand.k() * self.dj()
                + self.dj() * operand.s() * self.di())
                * inv_norm_sq,
            (self.dj() * operand.di() * self.dj()
                - self.di() * operand.di() * self.di()
                - self.dj() * operand.dj() * self.di()
                - self.di() * operand.dj() * self.dj())
                * inv_norm_sq,
            (-(self.dj() * operand.dj() * self.dj()) + self.di() * operand.dj() * self.di()
                - self.dj() * operand.di() * self.di()
                - self.di() * operand.di() * self.dj())
                * inv_norm_sq,
            (self.di() * operand.d() * self.dj()
                - self.di() * operand.dk() * self.di()
                - self.dj() * operand.d() * self.di()
                - self.dj() * operand.dk() * self.dj())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (-(self.dj() * operand.s() * self.dj()) - self.di() * operand.s() * self.di())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Trivector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked(
            (-(self.di() * operand.dk() * self.di()) - self.dj() * operand.dk() * self.dj())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (-(self.k() * operand.d() * self.dj())
                + self.dj() * operand.j() * self.di()
                + self.di() * operand.i() * self.di()
                - self.dj() * operand.i() * self.dj()
                - self.dj() * operand.d() * self.k()
                + self.di() * operand.j() * self.dj())
                * inv_norm_sq,
            (self.dj() * operand.j() * self.dj()
                + self.dj() * operand.i() * self.di()
                + self.di() * operand.i() * self.dj()
                - self.di() * operand.j() * self.di()
                + self.di() * operand.d() * self.k()
                + self.k() * operand.d() * self.di())
                * inv_norm_sq,
            (self.dj() * operand.d() * self.dj() + self.di() * operand.d() * self.di())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<DualQuaternion<T>> for Scalar<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &DualQuaternion<T>) -> Option<DualQuaternion<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(DualQuaternion::new_unchecked(
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked((T::zero()) * inv_norm_sq))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked((T::zero()) * inv_norm_sq))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Bivector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (self.dk() * operand.k() * self.dk()) * inv_norm_sq,
            (self.dk() * operand.di() * self.dk()) * inv_norm_sq,
            (self.dk() * operand.dj() * self.dk()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<DualQuaternion<T>> for Trivector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &DualQuaternion<T>) -> Option<DualQuaternion<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(DualQuaternion::new_unchecked(
            (self.dk() * operand.s() * self.dk()) * inv_norm_sq,
            (self.dk() * operand.i() * self.dk()) * inv_norm_sq,
            (self.dk() * operand.j() * self.dk()) * inv_norm_sq,
            (self.dk() * operand.d() * self.dk()) * inv_norm_sq,
            (self.dk() * operand.k() * self.dk()) * inv_norm_sq,
            (self.dk() * operand.di() * self.dk()) * inv_norm_sq,
            (self.dk() * operand.dj() * self.dk()) * inv_norm_sq,
            (self.dk() * operand.dk() * self.dk()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.dk() * operand.s() * self.dk()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Trivector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked(
            (self.dk() * operand.dk() * self.dk()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Vector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (self.dk() * operand.i() * self.dk()) * inv_norm_sq,
            (self.dk() * operand.j() * self.dk()) * inv_norm_sq,
            (self.dk() * operand.d() * self.dk()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Bivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (self.i() * operand.dj() * self.d()
                + self.d() * operand.dj() * self.i()
                + self.d() * operand.k() * self.d()
                - self.j() * operand.di() * self.d()
                - self.d() * operand.di() * self.j())
                * inv_norm_sq,
            (-(self.d() * operand.di() * self.d())) * inv_norm_sq,
            (-(self.d() * operand.dj() * self.d())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<DualQuaternion<T>> for Vector<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &DualQuaternion<T>) -> Option<DualQuaternion<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(DualQuaternion::new_unchecked(
            (-(self.d() * operand.dj() * self.j())
                + self.j() * operand.dj() * self.d()
                + self.d() * operand.s() * self.d()
                - self.d() * operand.di() * self.i()
                + self.i() * operand.di() * self.d())
                * inv_norm_sq,
            (self.i() * operand.d() * self.d()
                - self.j() * operand.dk() * self.d()
                - self.d() * operand.i() * self.d()
                + self.d() * operand.d() * self.i()
                + self.d() * operand.dk() * self.j())
                * inv_norm_sq,
            (self.j() * operand.d() * self.d() - self.d() * operand.j() * self.d()
                + self.d() * operand.d() * self.j()
                + self.i() * operand.dk() * self.d()
                - self.d() * operand.dk() * self.i())
                * inv_norm_sq,
            (self.d() * operand.d() * self.d()) * inv_norm_sq,
            (self.d() * operand.dj() * self.i() + self.i() * operand.dj() * self.d()
                - self.d() * operand.di() * self.j()
                - self.j() * operand.di() * self.d()
                + self.d() * operand.k() * self.d())
                * inv_norm_sq,
            (-(self.d() * operand.di() * self.d())) * inv_norm_sq,
            (-(self.d() * operand.dj() * self.d())) * inv_norm_sq,
            (self.d() * operand.dk() * self.d()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.d() * operand.s() * self.d()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Trivector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked(
            (self.d() * operand.dk() * self.d()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Vector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (self.i() * operand.d() * self.d() + self.d() * operand.d() * self.i()
                - self.d() * operand.i() * self.d())
                * inv_norm_sq,
            (self.j() * operand.d() * self.d() + self.d() * operand.d() * self.j()
                - self.d() * operand.j() * self.d())
                * inv_norm_sq,
            (self.d() * operand.d() * self.d()) * inv_norm_sq,
        ))
    }
}
impl<T: Float> Versor<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Bivector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Trivector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn compose(&self, other: &Trivector<T>) -> Vector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn compose(&self, other: &Bivector<T>) -> Bivector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Scalar<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn compose(&self, other: &Trivector<T>) -> Trivector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn compose(&self, other: &Vector<T>) -> Vector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Bivector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn compose(&self, other: &Bivector<T>) -> Vector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Trivector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Vector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn compose(&self, other: &Vector<T>) -> Bivector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Vector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Trivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn compose(&self, other: &Trivector<T>) -> Bivector<T> {
        *self * *other
    }
}
impl<T: Float> ScalarProduct<Bivector<T>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Bivector<T>) -> T {
        -(self.k() * rhs.k())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Bivector<T>> for Unitized<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Bivector<T>) -> T {
        -(rhs.k() * self.as_inner().k())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unitized<Bivector<T>>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unitized<Bivector<T>>) -> T {
        -(rhs.as_inner().k() * self.k())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unitized<Bivector<T>>> for Unitized<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unitized<Bivector<T>>) -> T {
        -(rhs.as_inner().k() * self.as_inner().k())
    }
}
impl<T: Float> ScalarProduct<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Scalar<T>> for Unitized<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Scalar<T>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unitized<Scalar<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unitized<Scalar<T>>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unitized<Scalar<T>>) -> T {
        T::zero()
    }
}
impl<T: Float> ScalarProduct<Vector<T>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Vector<T>) -> T {
        -(self.i() * rhs.i()) - self.j() * rhs.j()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Vector<T>> for Unitized<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Vector<T>) -> T {
        -(rhs.i() * self.as_inner().i()) + -(rhs.j() * self.as_inner().j())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unitized<Vector<T>>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unitized<Vector<T>>) -> T {
        -(rhs.as_inner().i() * self.i()) + -(rhs.as_inner().j() * self.j())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unitized<Vector<T>>> for Unitized<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unitized<Vector<T>>) -> T {
        -(rhs.as_inner().i() * self.as_inner().i()) + -(rhs.as_inner().j() * self.as_inner().j())
    }
}
impl<T: Float> BulkContract<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.k() * self.k())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Bivector<T>> for Unitized<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.k() * self.as_inner().k())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Bivector<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().k() * self.k())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Bivector<T>>> for Unitized<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().k() * self.as_inner().k())
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.s() * self.k(), rhs.s() * self.di(), rhs.s() * self.dj())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.s() * self.as_inner().k(),
            rhs.s() * self.as_inner().di(),
            rhs.s() * self.as_inner().dj(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
impl<T: Float> BulkContract<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.j() * self.k(),
            -(rhs.i() * self.k()),
            -(rhs.i() * self.di()) + -(rhs.j() * self.dj()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Vector<T>> for Unitized<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.j() * self.as_inner().k(),
            -(rhs.i() * self.as_inner().k()),
            -(rhs.i() * self.as_inner().di()) + -(rhs.j() * self.as_inner().dj()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Vector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().j() * self.k(),
            -(rhs.as_inner().i() * self.k()),
            -(rhs.as_inner().i() * self.di()) + -(rhs.as_inner().j() * self.dj()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Vector<T>>> for Unitized<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().j() * self.as_inner().k(),
            -(rhs.as_inner().i() * self.as_inner().k()),
            -(rhs.as_inner().i() * self.as_inner().di())
                + -(rhs.as_inner().j() * self.as_inner().dj()),
        )
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
impl<T: Float> BulkContract<Bivector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), rhs.k() * self.dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Bivector<T>> for Unitized<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), rhs.k() * self.as_inner().dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Bivector<T>>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), rhs.as_inner().k() * self.dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Bivector<T>>> for Unitized<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            T::zero(),
            T::zero(),
            rhs.as_inner().k() * self.as_inner().dk(),
        )
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.s() * self.dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.s() * self.as_inner().dk())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
impl<T: Float> BulkContract<Vector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), rhs.j() * self.dk(), -(rhs.i() * self.dk()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Vector<T>> for Unitized<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            T::zero(),
            rhs.j() * self.as_inner().dk(),
            -(rhs.i() * self.as_inner().dk()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Vector<T>>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            T::zero(),
            rhs.as_inner().j() * self.dk(),
            -(rhs.as_inner().i() * self.dk()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Vector<T>>> for Unitized<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            T::zero(),
            rhs.as_inner().j() * self.as_inner().dk(),
            -(rhs.as_inner().i() * self.as_inner().dk()),
        )
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(rhs.s() * self.i(), rhs.s() * self.j(), rhs.s() * self.d())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.s() * self.as_inner().i(),
            rhs.s() * self.as_inner().j(),
            rhs.s() * self.as_inner().d(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
impl<T: Float> BulkContract<Vector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.i() * self.i()) + -(rhs.j() * self.j()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Vector<T>> for Unitized<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.i() * self.as_inner().i()) + -(rhs.j() * self.as_inner().j()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Vector<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().i() * self.i()) + -(rhs.as_inner().j() * self.j()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Vector<T>>> for Unitized<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().i() * self.as_inner().i())
                + -(rhs.as_inner().j() * self.as_inner().j()),
        )
    }
}
impl<T: Float> WeightContract<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.di() * self.di() + rhs.dj() * self.dj())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Bivector<T>> for Unitized<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.di() * self.as_inner().di() + rhs.dj() * self.as_inner().dj())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Bivector<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().di() * self.di() + rhs.as_inner().dj() * self.dj())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Bivector<T>>> for Unitized<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.as_inner().di() * self.as_inner().di() + rhs.as_inner().dj() * self.as_inner().dj(),
        )
    }
}
impl<T: Float> WeightContract<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(rhs.d() * self.di(), rhs.d() * self.dj(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Vector<T>> for Unitized<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.d() * self.as_inner().di(),
            rhs.d() * self.as_inner().dj(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Vector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().d() * self.di(),
            rhs.as_inner().d() * self.dj(),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Vector<T>>> for Unitized<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().d() * self.as_inner().di(),
            rhs.as_inner().d() * self.as_inner().dj(),
            T::zero(),
        )
    }
}
impl<T: Float> WeightContract<Bivector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(rhs.dj() * self.dk(), -(rhs.di() * self.dk()), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Bivector<T>> for Unitized<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.dj() * self.as_inner().dk(),
            -(rhs.di() * self.as_inner().dk()),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Bivector<T>>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().dj() * self.dk(),
            -(rhs.as_inner().di() * self.dk()),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Bivector<T>>> for Unitized<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().dj() * self.as_inner().dk(),
            -(rhs.as_inner().di() * self.as_inner().dk()),
            T::zero(),
        )
    }
}
impl<T: Float> WeightContract<Trivector<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Trivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.dk() * self.dk()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Trivector<T>> for Unitized<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Trivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.dk() * self.as_inner().dk()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Trivector<T>>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Trivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().dk() * self.dk()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Trivector<T>>> for Unitized<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Trivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().dk() * self.as_inner().dk()))
    }
}
impl<T: Float> WeightContract<Vector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(-(rhs.d() * self.dk()), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Vector<T>> for Unitized<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(-(rhs.d() * self.as_inner().dk()), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Vector<T>>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(-(rhs.as_inner().d() * self.dk()), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Vector<T>>> for Unitized<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().d() * self.as_inner().dk()),
            T::zero(),
            T::zero(),
        )
    }
}
impl<T: Float> WeightContract<Vector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.d() * self.d()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Vector<T>> for Unitized<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.d() * self.as_inner().d()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Vector<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().d() * self.d()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<Vector<T>>> for Unitized<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().d() * self.as_inner().d()))
    }
}
impl<T: Float> BulkExpand<Bivector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.k() * self.k())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Bivector<T>> for Unitized<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.k() * self.as_inner().k())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Bivector<T>>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Bivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.as_inner().k() * self.k())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Bivector<T>>> for Unitized<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Bivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.as_inner().k() * self.as_inner().k())
    }
}
impl<T: Float> BulkExpand<Bivector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), rhs.k() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Bivector<T>> for Unitized<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Bivector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), rhs.as_inner().k() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Bivector<T>>> for Unitized<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
impl<T: Float> BulkExpand<Scalar<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Scalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Scalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Scalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Scalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
impl<T: Float> BulkExpand<Vector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), rhs.j() * self.s(), -(rhs.i() * self.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Vector<T>> for Unitized<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Vector<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            T::zero(),
            rhs.as_inner().j() * self.s(),
            -(rhs.as_inner().i() * self.s()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Vector<T>>> for Unitized<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
impl<T: Float> BulkExpand<Bivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), rhs.k() * self.i(), rhs.k() * self.j())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Bivector<T>> for Unitized<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            T::zero(),
            rhs.k() * self.as_inner().i(),
            rhs.k() * self.as_inner().j(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Bivector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            T::zero(),
            rhs.as_inner().k() * self.i(),
            rhs.as_inner().k() * self.j(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Bivector<T>>> for Unitized<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            T::zero(),
            rhs.as_inner().k() * self.as_inner().i(),
            rhs.as_inner().k() * self.as_inner().j(),
        )
    }
}
impl<T: Float> BulkExpand<Vector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(-(rhs.i() * self.i()) + -(rhs.j() * self.j()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Vector<T>> for Unitized<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.i() * self.as_inner().i()) + -(rhs.j() * self.as_inner().j()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Vector<T>>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Vector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().i() * self.i()) + -(rhs.as_inner().j() * self.j()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Vector<T>>> for Unitized<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Vector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().i() * self.as_inner().i())
                + -(rhs.as_inner().j() * self.as_inner().j()),
        )
    }
}
impl<T: Float> WeightExpand<Bivector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.di() * self.di() + rhs.dj() * self.dj())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Bivector<T>> for Unitized<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.di() * self.as_inner().di() + rhs.dj() * self.as_inner().dj())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Bivector<T>>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Bivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(rhs.as_inner().di() * self.di() + rhs.as_inner().dj() * self.dj())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Bivector<T>>> for Unitized<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Bivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().di() * self.as_inner().di() + rhs.as_inner().dj() * self.as_inner().dj(),
        )
    }
}
impl<T: Float> WeightExpand<Trivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.dk() * self.k()),
            -(rhs.dk() * self.di()),
            -(rhs.dk() * self.dj()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Trivector<T>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.dk() * self.as_inner().k()),
            -(rhs.dk() * self.as_inner().di()),
            -(rhs.dk() * self.as_inner().dj()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Trivector<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Trivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().dk() * self.k()),
            -(rhs.as_inner().dk() * self.di()),
            -(rhs.as_inner().dk() * self.dj()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Trivector<T>>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Trivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().dk() * self.as_inner().k()),
            -(rhs.as_inner().dk() * self.as_inner().di()),
            -(rhs.as_inner().dk() * self.as_inner().dj()),
        )
    }
}
impl<T: Float> WeightExpand<Bivector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(rhs.dj() * self.s(), -(rhs.di() * self.s()), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Bivector<T>> for Unitized<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Bivector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().dj() * self.s(),
            -(rhs.as_inner().di() * self.s()),
            T::zero(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Bivector<T>>> for Unitized<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
impl<T: Float> WeightExpand<Trivector<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.dk() * self.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Trivector<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Trivector<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Trivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().dk() * self.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Trivector<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Trivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
impl<T: Float> WeightExpand<Vector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(-(rhs.d() * self.s()), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Vector<T>> for Unitized<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Vector<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(-(rhs.as_inner().d() * self.s()), T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Vector<T>>> for Unitized<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(T::zero(), T::zero(), T::zero())
    }
}
impl<T: Float> WeightExpand<Trivector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(-(rhs.dk() * self.dk()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Trivector<T>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(-(rhs.dk() * self.as_inner().dk()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Trivector<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(-(rhs.as_inner().dk() * self.dk()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Trivector<T>>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(-(rhs.as_inner().dk() * self.as_inner().dk()))
    }
}
impl<T: Float> WeightExpand<Bivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.di() * self.i()) + -(rhs.dj() * self.j()),
            -(rhs.dj() * self.d()),
            rhs.di() * self.d(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Bivector<T>> for Unitized<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.di() * self.as_inner().i()) + -(rhs.dj() * self.as_inner().j()),
            -(rhs.dj() * self.as_inner().d()),
            rhs.di() * self.as_inner().d(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Bivector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().di() * self.i()) + -(rhs.as_inner().dj() * self.j()),
            -(rhs.as_inner().dj() * self.d()),
            rhs.as_inner().di() * self.d(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Bivector<T>>> for Unitized<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().di() * self.as_inner().i())
                + -(rhs.as_inner().dj() * self.as_inner().j()),
            -(rhs.as_inner().dj() * self.as_inner().d()),
            rhs.as_inner().di() * self.as_inner().d(),
        )
    }
}
impl<T: Float> WeightExpand<Trivector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.dk() * self.i()),
            -(rhs.dk() * self.j()),
            -(rhs.dk() * self.d()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Trivector<T>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.dk() * self.as_inner().i()),
            -(rhs.dk() * self.as_inner().j()),
            -(rhs.dk() * self.as_inner().d()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Trivector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().dk() * self.i()),
            -(rhs.as_inner().dk() * self.j()),
            -(rhs.as_inner().dk() * self.d()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Trivector<T>>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().dk() * self.as_inner().i()),
            -(rhs.as_inner().dk() * self.as_inner().j()),
            -(rhs.as_inner().dk() * self.as_inner().d()),
        )
    }
}
impl<T: Float> WeightExpand<Vector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(-(rhs.d() * self.d()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Vector<T>> for Unitized<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(-(rhs.d() * self.as_inner().d()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Vector<T>>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Vector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(-(rhs.as_inner().d() * self.d()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<Vector<T>>> for Unitized<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<Vector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(-(rhs.as_inner().d() * self.as_inner().d()))
    }
}
impl<T: Float> Dot<Bivector<T>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Bivector<T>) -> T {
        -(self.k() * rhs.k())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Bivector<T>> for Unitized<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Bivector<T>) -> T {
        -(rhs.k() * self.as_inner().k())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Bivector<T>>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Bivector<T>>) -> T {
        -(rhs.as_inner().k() * self.k())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Bivector<T>>> for Unitized<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Bivector<T>>) -> T {
        -(rhs.as_inner().k() * self.as_inner().k())
    }
}
impl<T: Float> Dot<DualQuaternion<T>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &DualQuaternion<T>) -> T {
        -(self.k() * rhs.k())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<DualQuaternion<T>> for Unitized<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &DualQuaternion<T>) -> T {
        -(rhs.k() * self.as_inner().k())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<DualQuaternion<T>>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<DualQuaternion<T>>) -> T {
        -(rhs.as_inner().k() * self.k())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<DualQuaternion<T>>> for Unitized<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<DualQuaternion<T>>) -> T {
        -(rhs.as_inner().k() * self.as_inner().k())
    }
}
impl<T: Float> Dot<Bivector<T>> for DualQuaternion<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Bivector<T>) -> T {
        -(self.k() * rhs.k())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Bivector<T>> for Unitized<DualQuaternion<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Bivector<T>) -> T {
        -(rhs.k() * self.as_inner().k())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Bivector<T>>> for DualQuaternion<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Bivector<T>>) -> T {
        -(rhs.as_inner().k() * self.k())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Bivector<T>>> for Unitized<DualQuaternion<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Bivector<T>>) -> T {
        -(rhs.as_inner().k() * self.as_inner().k())
    }
}
impl<T: Float> Dot<DualQuaternion<T>> for DualQuaternion<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &DualQuaternion<T>) -> T {
        self.s() * rhs.s() - self.i() * rhs.i() - self.j() * rhs.j() - self.k() * rhs.k()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<DualQuaternion<T>> for Unitized<DualQuaternion<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &DualQuaternion<T>) -> T {
        -(rhs.i() * self.as_inner().i())
            + -(rhs.j() * self.as_inner().j())
            + -(rhs.k() * self.as_inner().k())
            + rhs.s() * self.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<DualQuaternion<T>>> for DualQuaternion<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<DualQuaternion<T>>) -> T {
        -(rhs.as_inner().i() * self.i())
            + -(rhs.as_inner().j() * self.j())
            + -(rhs.as_inner().k() * self.k())
            + rhs.as_inner().s() * self.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<DualQuaternion<T>>> for Unitized<DualQuaternion<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<DualQuaternion<T>>) -> T {
        -(rhs.as_inner().i() * self.as_inner().i())
            + -(rhs.as_inner().j() * self.as_inner().j())
            + -(rhs.as_inner().k() * self.as_inner().k())
            + rhs.as_inner().s() * self.as_inner().s()
    }
}
impl<T: Float> Dot<Scalar<T>> for DualQuaternion<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Scalar<T>> for Unitized<DualQuaternion<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        rhs.s() * self.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Scalar<T>>> for DualQuaternion<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Scalar<T>>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Scalar<T>>> for Unitized<DualQuaternion<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Scalar<T>>) -> T {
        T::zero()
    }
}
impl<T: Float> Dot<Vector<T>> for DualQuaternion<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Vector<T>) -> T {
        -(self.i() * rhs.i()) - self.j() * rhs.j()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Vector<T>> for Unitized<DualQuaternion<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Vector<T>) -> T {
        -(rhs.i() * self.as_inner().i()) + -(rhs.j() * self.as_inner().j())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Vector<T>>> for DualQuaternion<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Vector<T>>) -> T {
        -(rhs.as_inner().i() * self.i()) + -(rhs.as_inner().j() * self.j())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Vector<T>>> for Unitized<DualQuaternion<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Vector<T>>) -> T {
        -(rhs.as_inner().i() * self.as_inner().i()) + -(rhs.as_inner().j() * self.as_inner().j())
    }
}
impl<T: Float> Dot<DualQuaternion<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &DualQuaternion<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<DualQuaternion<T>> for Unitized<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &DualQuaternion<T>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<DualQuaternion<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<DualQuaternion<T>>) -> T {
        rhs.as_inner().s() * self.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<DualQuaternion<T>>> for Unitized<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<DualQuaternion<T>>) -> T {
        T::zero()
    }
}
impl<T: Float> Dot<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Scalar<T>> for Unitized<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Scalar<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Scalar<T>>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Scalar<T>>) -> T {
        T::zero()
    }
}
impl<T: Float> Dot<DualQuaternion<T>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &DualQuaternion<T>) -> T {
        -(self.i() * rhs.i()) - self.j() * rhs.j()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<DualQuaternion<T>> for Unitized<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &DualQuaternion<T>) -> T {
        -(rhs.i() * self.as_inner().i()) + -(rhs.j() * self.as_inner().j())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<DualQuaternion<T>>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<DualQuaternion<T>>) -> T {
        -(rhs.as_inner().i() * self.i()) + -(rhs.as_inner().j() * self.j())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<DualQuaternion<T>>> for Unitized<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<DualQuaternion<T>>) -> T {
        -(rhs.as_inner().i() * self.as_inner().i()) + -(rhs.as_inner().j() * self.as_inner().j())
    }
}
impl<T: Float> Dot<Vector<T>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Vector<T>) -> T {
        -(self.i() * rhs.i()) - self.j() * rhs.j()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Vector<T>> for Unitized<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Vector<T>) -> T {
        -(rhs.i() * self.as_inner().i()) + -(rhs.j() * self.as_inner().j())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Vector<T>>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Vector<T>>) -> T {
        -(rhs.as_inner().i() * self.i()) + -(rhs.as_inner().j() * self.j())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Vector<T>>> for Unitized<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Vector<T>>) -> T {
        -(rhs.as_inner().i() * self.as_inner().i()) + -(rhs.as_inner().j() * self.as_inner().j())
    }
}
impl<T: Float> Antidot<Bivector<T>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Bivector<T>) -> T {
        -(self.di() * rhs.di()) - self.dj() * rhs.dj()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Bivector<T>> for Unitized<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Bivector<T>) -> T {
        -(rhs.di() * self.as_inner().di()) + -(rhs.dj() * self.as_inner().dj())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Bivector<T>>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Bivector<T>>) -> T {
        -(rhs.as_inner().di() * self.di()) + -(rhs.as_inner().dj() * self.dj())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Bivector<T>>> for Unitized<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Bivector<T>>) -> T {
        -(rhs.as_inner().di() * self.as_inner().di())
            + -(rhs.as_inner().dj() * self.as_inner().dj())
    }
}
impl<T: Float> Antidot<DualQuaternion<T>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &DualQuaternion<T>) -> T {
        -(self.di() * rhs.di()) - self.dj() * rhs.dj()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<DualQuaternion<T>> for Unitized<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &DualQuaternion<T>) -> T {
        -(rhs.di() * self.as_inner().di()) + -(rhs.dj() * self.as_inner().dj())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<DualQuaternion<T>>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<DualQuaternion<T>>) -> T {
        -(rhs.as_inner().di() * self.di()) + -(rhs.as_inner().dj() * self.dj())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<DualQuaternion<T>>> for Unitized<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<DualQuaternion<T>>) -> T {
        -(rhs.as_inner().di() * self.as_inner().di())
            + -(rhs.as_inner().dj() * self.as_inner().dj())
    }
}
impl<T: Float> Antidot<Bivector<T>> for DualQuaternion<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Bivector<T>) -> T {
        -(self.di() * rhs.di()) - self.dj() * rhs.dj()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Bivector<T>> for Unitized<DualQuaternion<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Bivector<T>) -> T {
        -(rhs.di() * self.as_inner().di()) + -(rhs.dj() * self.as_inner().dj())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Bivector<T>>> for DualQuaternion<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Bivector<T>>) -> T {
        -(rhs.as_inner().di() * self.di()) + -(rhs.as_inner().dj() * self.dj())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Bivector<T>>> for Unitized<DualQuaternion<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Bivector<T>>) -> T {
        -(rhs.as_inner().di() * self.as_inner().di())
            + -(rhs.as_inner().dj() * self.as_inner().dj())
    }
}
impl<T: Float> Antidot<DualQuaternion<T>> for DualQuaternion<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &DualQuaternion<T>) -> T {
        -(self.d() * rhs.d()) - self.di() * rhs.di() - self.dj() * rhs.dj() + self.dk() * rhs.dk()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<DualQuaternion<T>> for Unitized<DualQuaternion<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &DualQuaternion<T>) -> T {
        -(rhs.d() * self.as_inner().d())
            + -(rhs.di() * self.as_inner().di())
            + -(rhs.dj() * self.as_inner().dj())
            + rhs.dk() * self.as_inner().dk()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<DualQuaternion<T>>> for DualQuaternion<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<DualQuaternion<T>>) -> T {
        -(rhs.as_inner().d() * self.d())
            + -(rhs.as_inner().di() * self.di())
            + -(rhs.as_inner().dj() * self.dj())
            + rhs.as_inner().dk() * self.dk()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<DualQuaternion<T>>> for Unitized<DualQuaternion<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<DualQuaternion<T>>) -> T {
        -(rhs.as_inner().d() * self.as_inner().d())
            + -(rhs.as_inner().di() * self.as_inner().di())
            + -(rhs.as_inner().dj() * self.as_inner().dj())
            + rhs.as_inner().dk() * self.as_inner().dk()
    }
}
impl<T: Float> Antidot<Trivector<T>> for DualQuaternion<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Trivector<T>) -> T {
        self.dk() * rhs.dk()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Trivector<T>> for Unitized<DualQuaternion<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Trivector<T>) -> T {
        rhs.dk() * self.as_inner().dk()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Trivector<T>>> for DualQuaternion<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Trivector<T>>) -> T {
        rhs.as_inner().dk() * self.dk()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Trivector<T>>> for Unitized<DualQuaternion<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Trivector<T>>) -> T {
        rhs.as_inner().dk() * self.as_inner().dk()
    }
}
impl<T: Float> Antidot<Vector<T>> for DualQuaternion<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Vector<T>) -> T {
        -(self.d() * rhs.d())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Vector<T>> for Unitized<DualQuaternion<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Vector<T>) -> T {
        -(rhs.d() * self.as_inner().d())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Vector<T>>> for DualQuaternion<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Vector<T>>) -> T {
        -(rhs.as_inner().d() * self.d())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Vector<T>>> for Unitized<DualQuaternion<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Vector<T>>) -> T {
        -(rhs.as_inner().d() * self.as_inner().d())
    }
}
impl<T: Float> Antidot<DualQuaternion<T>> for Trivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &DualQuaternion<T>) -> T {
        self.dk() * rhs.dk()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<DualQuaternion<T>> for Unitized<Trivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &DualQuaternion<T>) -> T {
        rhs.dk() * self.as_inner().dk()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<DualQuaternion<T>>> for Trivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<DualQuaternion<T>>) -> T {
        rhs.as_inner().dk() * self.dk()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<DualQuaternion<T>>> for Unitized<Trivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<DualQuaternion<T>>) -> T {
        rhs.as_inner().dk() * self.as_inner().dk()
    }
}
impl<T: Float> Antidot<Trivector<T>> for Trivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Trivector<T>) -> T {
        self.dk() * rhs.dk()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Trivector<T>> for Unitized<Trivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Trivector<T>) -> T {
        rhs.dk() * self.as_inner().dk()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Trivector<T>>> for Trivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Trivector<T>>) -> T {
        rhs.as_inner().dk() * self.dk()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Trivector<T>>> for Unitized<Trivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Trivector<T>>) -> T {
        rhs.as_inner().dk() * self.as_inner().dk()
    }
}
impl<T: Float> Antidot<DualQuaternion<T>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &DualQuaternion<T>) -> T {
        -(self.d() * rhs.d())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<DualQuaternion<T>> for Unitized<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &DualQuaternion<T>) -> T {
        -(rhs.d() * self.as_inner().d())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<DualQuaternion<T>>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<DualQuaternion<T>>) -> T {
        -(rhs.as_inner().d() * self.d())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<DualQuaternion<T>>> for Unitized<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<DualQuaternion<T>>) -> T {
        -(rhs.as_inner().d() * self.as_inner().d())
    }
}
impl<T: Float> Antidot<Vector<T>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Vector<T>) -> T {
        -(self.d() * rhs.d())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Vector<T>> for Unitized<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Vector<T>) -> T {
        -(rhs.d() * self.as_inner().d())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Vector<T>>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Vector<T>>) -> T {
        -(rhs.as_inner().d() * self.d())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Vector<T>>> for Unitized<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Vector<T>>) -> T {
        -(rhs.as_inner().d() * self.as_inner().d())
    }
}
impl<T: Float> Project<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn project(&self, target: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.dj() * target.dj() * target.k() + self.di() * target.di() * target.k(),
            self.di() * target.di() * target.di() + self.dj() * target.dj() * target.di(),
            self.dj() * target.dj() * target.dj() + self.di() * target.di() * target.dj(),
        )
    }
}
impl<T: Float> Project<Bivector<T>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn project(&self, target: &Bivector<T>) -> Bivector<T> {
        self.as_inner().project(target)
    }
}
impl<T: Float> Project<Unitized<Bivector<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn project(&self, target: &Unitized<Bivector<T>>) -> Bivector<T> {
        self.project(target.as_inner())
    }
}
impl<T: Float> Project<Unitized<Bivector<T>>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn project(&self, target: &Unitized<Bivector<T>>) -> Bivector<T> {
        self.as_inner().project(target.as_inner())
    }
}
impl<T: Float> Project<Trivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn project(&self, target: &Trivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(self.k() * target.dk() * target.dk()),
            -(self.di() * target.dk() * target.dk()),
            -(self.dj() * target.dk() * target.dk()),
        )
    }
}
impl<T: Float> Project<Trivector<T>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn project(&self, target: &Trivector<T>) -> Bivector<T> {
        self.as_inner().project(target)
    }
}
impl<T: Float> Project<Unitized<Trivector<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn project(&self, target: &Unitized<Trivector<T>>) -> Bivector<T> {
        self.project(target.as_inner())
    }
}
impl<T: Float> Project<Unitized<Trivector<T>>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn project(&self, target: &Unitized<Trivector<T>>) -> Bivector<T> {
        self.as_inner().project(target.as_inner())
    }
}
impl<T: Float> Project<Trivector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn project(&self, target: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(-(self.dk() * target.dk() * target.dk()))
    }
}
impl<T: Float> Project<Trivector<T>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn project(&self, target: &Trivector<T>) -> Trivector<T> {
        self.as_inner().project(target)
    }
}
impl<T: Float> Project<Unitized<Trivector<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn project(&self, target: &Unitized<Trivector<T>>) -> Trivector<T> {
        self.project(target.as_inner())
    }
}
impl<T: Float> Project<Unitized<Trivector<T>>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn project(&self, target: &Unitized<Trivector<T>>) -> Trivector<T> {
        self.as_inner().project(target.as_inner())
    }
}
impl<T: Float> Project<Bivector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn project(&self, target: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            self.i() * target.di() * target.di() + self.j() * target.dj() * target.di()
                - self.d() * target.dj() * target.k(),
            self.j() * target.dj() * target.dj()
                + self.d() * target.di() * target.k()
                + self.i() * target.di() * target.dj(),
            self.d() * target.dj() * target.dj() + self.d() * target.di() * target.di(),
        )
    }
}
impl<T: Float> Project<Bivector<T>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn project(&self, target: &Bivector<T>) -> Vector<T> {
        self.as_inner().project(target)
    }
}
impl<T: Float> Project<Unitized<Bivector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn project(&self, target: &Unitized<Bivector<T>>) -> Vector<T> {
        self.project(target.as_inner())
    }
}
impl<T: Float> Project<Unitized<Bivector<T>>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn project(&self, target: &Unitized<Bivector<T>>) -> Vector<T> {
        self.as_inner().project(target.as_inner())
    }
}
impl<T: Float> Project<Trivector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn project(&self, target: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.i() * target.dk() * target.dk()),
            -(self.j() * target.dk() * target.dk()),
            -(self.d() * target.dk() * target.dk()),
        )
    }
}
impl<T: Float> Project<Trivector<T>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn project(&self, target: &Trivector<T>) -> Vector<T> {
        self.as_inner().project(target)
    }
}
impl<T: Float> Project<Unitized<Trivector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn project(&self, target: &Unitized<Trivector<T>>) -> Vector<T> {
        self.project(target.as_inner())
    }
}
impl<T: Float> Project<Unitized<Trivector<T>>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn project(&self, target: &Unitized<Trivector<T>>) -> Vector<T> {
        self.as_inner().project(target.as_inner())
    }
}
impl<T: Float> Project<Vector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn project(&self, target: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.d() * target.d() * target.i()),
            -(self.d() * target.d() * target.j()),
            -(self.d() * target.d() * target.d()),
        )
    }
}
impl<T: Float> Project<Vector<T>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn project(&self, target: &Vector<T>) -> Vector<T> {
        self.as_inner().project(target)
    }
}
impl<T: Float> Project<Unitized<Vector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn project(&self, target: &Unitized<Vector<T>>) -> Vector<T> {
        self.project(target.as_inner())
    }
}
impl<T: Float> Project<Unitized<Vector<T>>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn project(&self, target: &Unitized<Vector<T>>) -> Vector<T> {
        self.as_inner().project(target.as_inner())
    }
}
impl<T: Float> Antiproject<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antiproject(&self, target: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.di() * target.di() * target.k() + self.dj() * target.dj() * target.k(),
            self.di() * target.di() * target.di() + self.dj() * target.dj() * target.di(),
            self.dj() * target.dj() * target.dj() + self.di() * target.di() * target.dj(),
        )
    }
}
impl<T: Float> Antiproject<Bivector<T>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antiproject(&self, target: &Bivector<T>) -> Bivector<T> {
        self.as_inner().antiproject(target)
    }
}
impl<T: Float> Antiproject<Unitized<Bivector<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Bivector<T>>) -> Bivector<T> {
        self.antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Unitized<Bivector<T>>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Bivector<T>>) -> Bivector<T> {
        self.as_inner().antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Vector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antiproject(&self, target: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.dj() * target.d() * target.i() - self.di() * target.d() * target.j(),
            -(self.di() * target.d() * target.d()),
            -(self.dj() * target.d() * target.d()),
        )
    }
}
impl<T: Float> Antiproject<Vector<T>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antiproject(&self, target: &Vector<T>) -> Bivector<T> {
        self.as_inner().antiproject(target)
    }
}
impl<T: Float> Antiproject<Unitized<Vector<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Vector<T>>) -> Bivector<T> {
        self.antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Unitized<Vector<T>>> for Unitized<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Vector<T>>) -> Bivector<T> {
        self.as_inner().antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Bivector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antiproject(&self, target: &Bivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            self.dk() * target.di() * target.di() + self.dk() * target.dj() * target.dj(),
        )
    }
}
impl<T: Float> Antiproject<Bivector<T>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antiproject(&self, target: &Bivector<T>) -> Trivector<T> {
        self.as_inner().antiproject(target)
    }
}
impl<T: Float> Antiproject<Unitized<Bivector<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Bivector<T>>) -> Trivector<T> {
        self.antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Unitized<Bivector<T>>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Bivector<T>>) -> Trivector<T> {
        self.as_inner().antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Trivector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antiproject(&self, target: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(-(self.dk() * target.dk() * target.dk()))
    }
}
impl<T: Float> Antiproject<Trivector<T>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antiproject(&self, target: &Trivector<T>) -> Trivector<T> {
        self.as_inner().antiproject(target)
    }
}
impl<T: Float> Antiproject<Unitized<Trivector<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Trivector<T>>) -> Trivector<T> {
        self.antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Unitized<Trivector<T>>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Trivector<T>>) -> Trivector<T> {
        self.as_inner().antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Vector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antiproject(&self, target: &Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(-(self.dk() * target.d() * target.d()))
    }
}
impl<T: Float> Antiproject<Vector<T>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antiproject(&self, target: &Vector<T>) -> Trivector<T> {
        self.as_inner().antiproject(target)
    }
}
impl<T: Float> Antiproject<Unitized<Vector<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Vector<T>>) -> Trivector<T> {
        self.antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Unitized<Vector<T>>> for Unitized<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Vector<T>>) -> Trivector<T> {
        self.as_inner().antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Vector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiproject(&self, target: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.d() * target.d() * target.i()),
            -(self.d() * target.d() * target.j()),
            -(self.d() * target.d() * target.d()),
        )
    }
}
impl<T: Float> Antiproject<Vector<T>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiproject(&self, target: &Vector<T>) -> Vector<T> {
        self.as_inner().antiproject(target)
    }
}
impl<T: Float> Antiproject<Unitized<Vector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Vector<T>>) -> Vector<T> {
        self.antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Unitized<Vector<T>>> for Unitized<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<Vector<T>>) -> Vector<T> {
        self.as_inner().antiproject(target.as_inner())
    }
}
impl<T: Float> Reverse for Bivector<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(-self.k(), -self.di(), -self.dj())
    }
}
impl<T: Float> Reverse for DualQuaternion<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(
            self.s(),
            self.i(),
            self.j(),
            self.d(),
            -self.k(),
            -self.di(),
            -self.dj(),
            -self.dk(),
        )
    }
}
impl<T: Float> Reverse for Scalar<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> Reverse for Trivector<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(-self.dk())
    }
}
impl<T: Float> Reverse for Vector<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.i(), self.j(), self.d())
    }
}
impl<T: Float> Antireverse for Bivector<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.k(), self.di(), self.dj())
    }
}
impl<T: Float> Antireverse for DualQuaternion<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(
            -self.s(),
            -self.i(),
            -self.j(),
            -self.d(),
            self.k(),
            self.di(),
            self.dj(),
            self.dk(),
        )
    }
}
impl<T: Float> Antireverse for Scalar<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(-self.s())
    }
}
impl<T: Float> Antireverse for Trivector<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.dk())
    }
}
impl<T: Float> Antireverse for Vector<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(-self.i(), -self.j(), -self.d())
    }
}
impl<T: Float> Involute for Bivector<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(-self.k(), -self.di(), -self.dj())
    }
}
impl<T: Float> Involute for DualQuaternion<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(
            self.s(),
            -self.i(),
            -self.j(),
            -self.d(),
            -self.k(),
            -self.di(),
            -self.dj(),
            self.dk(),
        )
    }
}
impl<T: Float> Involute for Scalar<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> Involute for Trivector<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.dk())
    }
}
impl<T: Float> Involute for Vector<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(-self.i(), -self.j(), -self.d())
    }
}
impl<T: Float> RightComplement for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_complement(&self) -> Vector<T> {
        Vector::new_unchecked(self.dj(), -self.di(), self.k())
    }
}
impl<T: Float> RightComplement for DualQuaternion<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn right_complement(&self) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            self.dk(),
            self.dj(),
            -self.di(),
            self.k(),
            self.d(),
            -self.j(),
            self.i(),
            self.s(),
        )
    }
}
impl<T: Float> RightComplement for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn right_complement(&self) -> Trivector<T> {
        Trivector::new_unchecked(self.s())
    }
}
impl<T: Float> RightComplement for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_complement(&self) -> Scalar<T> {
        Scalar::new_unchecked(self.dk())
    }
}
impl<T: Float> RightComplement for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn right_complement(&self) -> Bivector<T> {
        Bivector::new_unchecked(self.d(), -self.j(), self.i())
    }
}
impl<T: Float> WeightDual for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_dual(&self) -> Vector<T> {
        Vector::new_unchecked(self.dj(), -self.di(), T::zero())
    }
}
impl<T: Float> WeightDual for DualQuaternion<T> {
    type Output = DualQuaternion<T>;
    #[inline]
    fn weight_dual(&self) -> DualQuaternion<T> {
        DualQuaternion::new_unchecked(
            -self.dk(),
            self.dj(),
            -self.di(),
            T::zero(),
            -self.d(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
}
impl<T: Float> WeightDual for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_dual(&self) -> Trivector<T> {
        Trivector::new_unchecked(T::zero())
    }
}
impl<T: Float> WeightDual for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_dual(&self) -> Scalar<T> {
        Scalar::new_unchecked(-self.dk())
    }
}
impl<T: Float> WeightDual for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_dual(&self) -> Bivector<T> {
        Bivector::new_unchecked(-self.d(), T::zero(), T::zero())
    }
}
impl<T: Float> VersorInverse for Bivector<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(
            -self.k() * inv_norm_sq,
            -self.di() * inv_norm_sq,
            -self.dj() * inv_norm_sq,
        ))
    }
}
impl<T: Float> VersorInverse for Scalar<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(self.s() * inv_norm_sq))
    }
}
impl<T: Float> VersorInverse for Trivector<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(-self.dk() * inv_norm_sq))
    }
}
impl<T: Float> VersorInverse for Vector<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(
            self.i() * inv_norm_sq,
            self.j() * inv_norm_sq,
            self.d() * inv_norm_sq,
        ))
    }
}
impl<T: Float> crate::norm::Normed for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.k() * self.k()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.k() * factor, self.di() * factor, self.dj() * factor)
    }
}
impl<T: Float> crate::norm::Normed for DualQuaternion<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.s() * self.s() + self.i() * self.i() + self.j() * self.j() + self.k() * self.k()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(
            self.s() * factor,
            self.i() * factor,
            self.j() * factor,
            self.d() * factor,
            self.k() * factor,
            self.di() * factor,
            self.dj() * factor,
            self.dk() * factor,
        )
    }
}
impl<T: Float> crate::norm::Normed for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.s() * self.s()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.s() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Trivector<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        T::zero()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.dk() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Vector<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.i() * self.i() + self.j() * self.j()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.i() * factor, self.j() * factor, self.d() * factor)
    }
}
impl<T: Float> crate::norm::DegenerateNormed for Bivector<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        self.k() * self.k()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        self.di() * self.di() + self.dj() * self.dj()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new_unchecked(
                self.k() * inv_w,
                self.di() * inv_w,
                self.dj() * inv_w,
            ))
        }
    }
}
impl<T: Float> crate::norm::DegenerateNormed for DualQuaternion<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        self.s() * self.s() + self.i() * self.i() + self.j() * self.j() + self.k() * self.k()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        self.d() * self.d() + self.di() * self.di() + self.dj() * self.dj() + self.dk() * self.dk()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new_unchecked(
                self.s() * inv_w,
                self.i() * inv_w,
                self.j() * inv_w,
                self.d() * inv_w,
                self.k() * inv_w,
                self.di() * inv_w,
                self.dj() * inv_w,
                self.dk() * inv_w,
            ))
        }
    }
}
impl<T: Float> crate::norm::DegenerateNormed for Scalar<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        self.s() * self.s()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        T::zero()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new_unchecked(self.s() * inv_w))
        }
    }
}
impl<T: Float> crate::norm::DegenerateNormed for Trivector<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        T::zero()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        self.dk() * self.dk()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new_unchecked(self.dk() * inv_w))
        }
    }
}
impl<T: Float> crate::norm::DegenerateNormed for Vector<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        self.i() * self.i() + self.j() * self.j()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        self.d() * self.d()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new_unchecked(
                self.i() * inv_w,
                self.j() * inv_w,
                self.d() * inv_w,
            ))
        }
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Bivector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.k().abs_diff_eq(&other.k(), epsilon)
            && self.di().abs_diff_eq(&other.di(), epsilon)
            && self.dj().abs_diff_eq(&other.dj(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Bivector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.k().relative_eq(&other.k(), epsilon, max_relative)
            && self.di().relative_eq(&other.di(), epsilon, max_relative)
            && self.dj().relative_eq(&other.dj(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Bivector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.k().ulps_eq(&other.k(), epsilon, max_ulps)
            && self.di().ulps_eq(&other.di(), epsilon, max_ulps)
            && self.dj().ulps_eq(&other.dj(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for DualQuaternion<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon)
            && self.i().abs_diff_eq(&other.i(), epsilon)
            && self.j().abs_diff_eq(&other.j(), epsilon)
            && self.d().abs_diff_eq(&other.d(), epsilon)
            && self.k().abs_diff_eq(&other.k(), epsilon)
            && self.di().abs_diff_eq(&other.di(), epsilon)
            && self.dj().abs_diff_eq(&other.dj(), epsilon)
            && self.dk().abs_diff_eq(&other.dk(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for DualQuaternion<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
            && self.i().relative_eq(&other.i(), epsilon, max_relative)
            && self.j().relative_eq(&other.j(), epsilon, max_relative)
            && self.d().relative_eq(&other.d(), epsilon, max_relative)
            && self.k().relative_eq(&other.k(), epsilon, max_relative)
            && self.di().relative_eq(&other.di(), epsilon, max_relative)
            && self.dj().relative_eq(&other.dj(), epsilon, max_relative)
            && self.dk().relative_eq(&other.dk(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for DualQuaternion<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
            && self.i().ulps_eq(&other.i(), epsilon, max_ulps)
            && self.j().ulps_eq(&other.j(), epsilon, max_ulps)
            && self.d().ulps_eq(&other.d(), epsilon, max_ulps)
            && self.k().ulps_eq(&other.k(), epsilon, max_ulps)
            && self.di().ulps_eq(&other.di(), epsilon, max_ulps)
            && self.dj().ulps_eq(&other.dj(), epsilon, max_ulps)
            && self.dk().ulps_eq(&other.dk(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Scalar<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Scalar<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Scalar<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Trivector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.dk().abs_diff_eq(&other.dk(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Trivector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.dk().relative_eq(&other.dk(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Trivector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.dk().ulps_eq(&other.dk(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Vector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.i().abs_diff_eq(&other.i(), epsilon)
            && self.j().abs_diff_eq(&other.j(), epsilon)
            && self.d().abs_diff_eq(&other.d(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Vector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.i().relative_eq(&other.i(), epsilon, max_relative)
            && self.j().relative_eq(&other.j(), epsilon, max_relative)
            && self.d().relative_eq(&other.d(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Vector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.i().ulps_eq(&other.i(), epsilon, max_ulps)
            && self.j().ulps_eq(&other.j(), epsilon, max_ulps)
            && self.d().ulps_eq(&other.d(), epsilon, max_ulps)
    }
}
#[cfg(any(test, feature = "proptest-support"))]
#[allow(clippy::missing_docs_in_private_items)]
mod arbitrary_impls {
    use super::*;
    use proptest::prelude::*;
    use proptest::strategy::BoxedStrategy;
    use std::fmt::Debug;
    impl<T: Float + Debug + 'static> Arbitrary for Bivector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0, -100.0f64..100.0, -100.0f64..100.0)
                .prop_map(|(x0, x1, x2)| {
                    Bivector::new_unchecked(T::from_f64(x0), T::from_f64(x1), T::from_f64(x2))
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for DualQuaternion<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
            )
                .prop_filter("non-zero divisor", |(x0, _x1, _x2, _x3, _x4, _x5, _x6)| {
                    (x0).abs() > 0.1
                })
                .prop_map(|(x0, x1, x2, x3, x4, x5, x6)| {
                    DualQuaternion::new_unchecked(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64(x3),
                        T::from_f64(x4),
                        T::from_f64(x5),
                        T::from_f64(x6),
                        T::from_f64((x3 * x4 + x1 * x6 - x2 * x5) / (x0)),
                    )
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Scalar<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| Scalar::new_unchecked(T::from_f64(x0)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Trivector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| Trivector::new_unchecked(T::from_f64(x0)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Vector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0, -100.0f64..100.0, -100.0f64..100.0)
                .prop_map(|(x0, x1, x2)| {
                    Vector::new_unchecked(T::from_f64(x0), T::from_f64(x1), T::from_f64(x2))
                })
                .boxed()
        }
    }
}

// ============================================================
// Verification Tests (compare against Multivector)
// ============================================================

#[cfg(test)]
#[allow(clippy::missing_docs_in_private_items)]
mod verification_tests {
    use super::*;
    use crate::algebra::Multivector;
    #[allow(unused_imports)]
    use crate::norm::{DegenerateNormed, Normed};
    use crate::signature::Cl0_2_1;
    #[allow(unused_imports)]
    use crate::wrappers::{Bulk, Unit, Unitized};
    use approx::relative_eq;
    use proptest::prelude::*;

    /// Relative epsilon for floating-point comparisons in verification tests.
    /// Using relative comparison handles varying magnitudes better than absolute.
    const REL_EPSILON: f64 = 1e-10;

    proptest! {
        #[test]
        fn bivector_add_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn bivector_sub_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn bivector_neg_matches_multivector(a in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn dualquaternion_add_matches_multivector(a in any::<DualQuaternion<f64>>(), b in any::<DualQuaternion<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn dualquaternion_sub_matches_multivector(a in any::<DualQuaternion<f64>>(), b in any::<DualQuaternion<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn dualquaternion_neg_matches_multivector(a in any::<DualQuaternion<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn scalar_add_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn scalar_sub_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn scalar_neg_matches_multivector(a in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn trivector_add_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn trivector_sub_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn trivector_neg_matches_multivector(a in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn vector_add_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn vector_sub_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn vector_neg_matches_multivector(a in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_bivector_scalar_bivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Bivector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_bivector_vector_trivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Trivector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_scalar_bivector_bivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Bivector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_scalar_scalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Scalar<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_scalar_trivector_trivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Trivector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_scalar_vector_vector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Vector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_trivector_scalar_trivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Trivector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_vector_bivector_trivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Trivector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_vector_scalar_vector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Vector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_vector_vector_bivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Bivector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_bivector_bivector_scalar_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Scalar<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_bivector_scalar_bivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Bivector<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_bivector_vector_vector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Vector<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_scalar_scalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Scalar<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_trivector_bivector_vector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Vector<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_trivector_scalar_trivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Trivector<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_trivector_vector_bivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Bivector<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_vector_scalar_vector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Vector<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_vector_vector_scalar_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Scalar<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_bivector_bivector_scalar_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Scalar<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_bivector_vector_vector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Vector<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_trivector_bivector_vector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Vector<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_trivector_trivector_scalar_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Scalar<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_trivector_vector_bivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Bivector<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_vector_vector_scalar_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Scalar<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_bivector_bivector_trivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Trivector<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_scalar_bivector_vector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Vector<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_scalar_scalar_trivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Trivector<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_scalar_vector_bivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Bivector<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_vector_bivector_bivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Bivector<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_vector_vector_trivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Trivector<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_bivector_bivector_trivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Trivector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_bivector_trivector_bivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Bivector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_scalar_bivector_vector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Vector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_scalar_trivector_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Scalar<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_scalar_vector_bivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Bivector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_trivector_trivector_trivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Trivector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_vector_bivector_bivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Bivector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_vector_trivector_vector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Vector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_vector_vector_trivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            let specialized_result: Trivector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_2_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_bivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            // LHS: complement(a * b)
            let lhs = (mv_a * mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_bivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = mv_a.complement() * mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_scalar(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            // LHS: complement(a * b)
            let lhs = (mv_a * mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_scalar(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = mv_a.complement() * mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_trivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            // LHS: complement(a * b)
            let lhs = (mv_a * mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_trivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = mv_a.complement() * mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_vector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            // LHS: complement(a * b)
            let lhs = (mv_a * mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_vector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = mv_a.complement() * mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// Project idempotency with normalized target: project(project(a, unit_b), unit_b) == project(a, unit_b)
        #[test]
        fn project_idempotent_bivector_vector(a in any::<Bivector<f64>>(), unit_b in any::<Unitized<Vector<f64>>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = unit_b.into_inner().into();

            let first = mv_a.project(&mv_b);
            let second = first.project(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Project idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Project idempotency with normalized target: project(project(a, unit_b), unit_b) == project(a, unit_b)
        #[test]
        fn project_idempotent_trivector_bivector(a in any::<Trivector<f64>>(), unit_b in any::<Unitized<Bivector<f64>>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = unit_b.into_inner().into();

            let first = mv_a.project(&mv_b);
            let second = first.project(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Project idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Project idempotency with normalized target: project(project(a, unit_b), unit_b) == project(a, unit_b)
        #[test]
        fn project_idempotent_trivector_vector(a in any::<Trivector<f64>>(), unit_b in any::<Unitized<Vector<f64>>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = unit_b.into_inner().into();

            let first = mv_a.project(&mv_b);
            let second = first.project(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Project idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Antiproject idempotency with normalized target: antiproject(antiproject(a, unit_b), unit_b) == antiproject(a, unit_b)
        #[test]
        fn antiproject_idempotent_bivector_trivector(a in any::<Bivector<f64>>(), unit_b in any::<Unitized<Trivector<f64>>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = unit_b.into_inner().into();

            let first = mv_a.antiproject(&mv_b);
            let second = first.antiproject(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Antiproject idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Antiproject idempotency with normalized target: antiproject(antiproject(a, unit_b), unit_b) == antiproject(a, unit_b)
        #[test]
        fn antiproject_idempotent_vector_bivector(a in any::<Vector<f64>>(), unit_b in any::<Unitized<Bivector<f64>>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = unit_b.into_inner().into();

            let first = mv_a.antiproject(&mv_b);
            let second = first.antiproject(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Antiproject idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Antiproject idempotency with normalized target: antiproject(antiproject(a, unit_b), unit_b) == antiproject(a, unit_b)
        #[test]
        fn antiproject_idempotent_vector_trivector(a in any::<Vector<f64>>(), unit_b in any::<Unitized<Trivector<f64>>>()) {
            let mv_a: Multivector<f64, Cl0_2_1> = a.into();
            let mv_b: Multivector<f64, Cl0_2_1> = unit_b.into_inner().into();

            let first = mv_a.antiproject(&mv_b);
            let second = first.antiproject(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Antiproject idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Bulk<Bivector>.bulk_norm() should equal 1.0 (by definition of Bulk wrapper).
        #[test]
        fn bulk_bivector_bulk_norm_matches_inner(b in any::<Bulk<Bivector<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_bulk = <Bivector<f64> as DegenerateNormed>::bulk_norm(b.as_inner());
            let wrapper_bulk = <Bulk<Bivector<f64>> as DegenerateNormed>::bulk_norm(&b);

            prop_assert!(
                relative_eq!(inner_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Inner bulk_norm should be 1.0, got {}", inner_bulk
            );
            prop_assert!(
                relative_eq!(wrapper_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wrapper bulk_norm should be 1.0, got {}", wrapper_bulk
            );
        }

        /// Bulk<Bivector>.weight_norm() should match inner's weight_norm (delegation).
        #[test]
        fn bulk_bivector_weight_norm_delegates(b in any::<Bulk<Bivector<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_weight = <Bivector<f64> as DegenerateNormed>::weight_norm(b.as_inner());
            let wrapper_weight = <Bulk<Bivector<f64>> as DegenerateNormed>::weight_norm(&b);

            prop_assert!(
                relative_eq!(inner_weight, wrapper_weight, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight norms should match: {} vs {}", inner_weight, wrapper_weight
            );
        }
    }

    proptest! {
        /// Bulk<Scalar>.bulk_norm() should equal 1.0 (by definition of Bulk wrapper).
        #[test]
        fn bulk_scalar_bulk_norm_matches_inner(b in any::<Bulk<Scalar<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_bulk = <Scalar<f64> as DegenerateNormed>::bulk_norm(b.as_inner());
            let wrapper_bulk = <Bulk<Scalar<f64>> as DegenerateNormed>::bulk_norm(&b);

            prop_assert!(
                relative_eq!(inner_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Inner bulk_norm should be 1.0, got {}", inner_bulk
            );
            prop_assert!(
                relative_eq!(wrapper_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wrapper bulk_norm should be 1.0, got {}", wrapper_bulk
            );
        }

        /// Bulk<Scalar>.weight_norm() should match inner's weight_norm (delegation).
        #[test]
        fn bulk_scalar_weight_norm_delegates(b in any::<Bulk<Scalar<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_weight = <Scalar<f64> as DegenerateNormed>::weight_norm(b.as_inner());
            let wrapper_weight = <Bulk<Scalar<f64>> as DegenerateNormed>::weight_norm(&b);

            prop_assert!(
                relative_eq!(inner_weight, wrapper_weight, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight norms should match: {} vs {}", inner_weight, wrapper_weight
            );
        }
    }

    proptest! {
        /// Bulk<Vector>.bulk_norm() should equal 1.0 (by definition of Bulk wrapper).
        #[test]
        fn bulk_vector_bulk_norm_matches_inner(b in any::<Bulk<Vector<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_bulk = <Vector<f64> as DegenerateNormed>::bulk_norm(b.as_inner());
            let wrapper_bulk = <Bulk<Vector<f64>> as DegenerateNormed>::bulk_norm(&b);

            prop_assert!(
                relative_eq!(inner_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Inner bulk_norm should be 1.0, got {}", inner_bulk
            );
            prop_assert!(
                relative_eq!(wrapper_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wrapper bulk_norm should be 1.0, got {}", wrapper_bulk
            );
        }

        /// Bulk<Vector>.weight_norm() should match inner's weight_norm (delegation).
        #[test]
        fn bulk_vector_weight_norm_delegates(b in any::<Bulk<Vector<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_weight = <Vector<f64> as DegenerateNormed>::weight_norm(b.as_inner());
            let wrapper_weight = <Bulk<Vector<f64>> as DegenerateNormed>::weight_norm(&b);

            prop_assert!(
                relative_eq!(inner_weight, wrapper_weight, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight norms should match: {} vs {}", inner_weight, wrapper_weight
            );
        }
    }
}
