#![doc = " Trait implementations for complex."]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
use super::types::{Complex, ImagUnit, Scalar};
#[allow(unused_imports)]
use crate::ops::{
    Antidot, Antireverse, Antisandwich, Antiwedge, BulkContract, BulkExpand, Dot,
    InverseAntisandwich, InverseSandwich, Involute, LeftContract, Reverse, RightComplement,
    RightContract, Sandwich, ScalarProduct, Transform, Versor, VersorInverse, Wedge,
    WeightContract, WeightDual, WeightExpand,
};
use crate::scalar::Float;
#[allow(unused_imports)]
use crate::wrappers::Unit;
use approx::{AbsDiffEq, RelativeEq, UlpsEq};
use std::ops::{Add, Mul, Neg, Sub};
impl<T: Float> Add for Complex<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.real() + rhs.real(), self.imag() + rhs.imag())
    }
}
impl<T: Float> Sub for Complex<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.real() - rhs.real(), self.imag() - rhs.imag())
    }
}
impl<T: Float> Neg for Complex<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.real(), -self.imag())
    }
}
impl<T: Float> Mul<T> for Complex<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Complex<f32>> for f32 {
    type Output = Complex<f32>;
    #[inline]
    fn mul(self, v: Complex<f32>) -> Complex<f32> {
        v.scale(self)
    }
}
impl Mul<Complex<f64>> for f64 {
    type Output = Complex<f64>;
    #[inline]
    fn mul(self, v: Complex<f64>) -> Complex<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Complex<T>> for Complex<T> {
    type Output = Complex<T>;
    #[inline]
    fn mul(self, rhs: Complex<T>) -> Complex<T> {
        Complex::new_unchecked(
            self.real() * rhs.real() + -(self.imag() * rhs.imag()),
            self.real() * rhs.imag() + self.imag() * rhs.real(),
        )
    }
}
impl<T: Float> Mul<ImagUnit<T>> for Complex<T> {
    type Output = Complex<T>;
    #[inline]
    fn mul(self, rhs: ImagUnit<T>) -> Complex<T> {
        Complex::new_unchecked(-(self.imag() * rhs.i()), self.real() * rhs.i())
    }
}
impl<T: Float> Mul<Scalar<T>> for Complex<T> {
    type Output = Complex<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Complex<T> {
        Complex::new_unchecked(rhs.s() * self.real(), rhs.s() * self.imag())
    }
}
impl<T: Float> Add for ImagUnit<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.i() + rhs.i())
    }
}
impl<T: Float> Sub for ImagUnit<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.i() - rhs.i())
    }
}
impl<T: Float> Neg for ImagUnit<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.i())
    }
}
impl<T: Float> Mul<T> for ImagUnit<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<ImagUnit<f32>> for f32 {
    type Output = ImagUnit<f32>;
    #[inline]
    fn mul(self, v: ImagUnit<f32>) -> ImagUnit<f32> {
        v.scale(self)
    }
}
impl Mul<ImagUnit<f64>> for f64 {
    type Output = ImagUnit<f64>;
    #[inline]
    fn mul(self, v: ImagUnit<f64>) -> ImagUnit<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Complex<T>> for ImagUnit<T> {
    type Output = Complex<T>;
    #[inline]
    fn mul(self, rhs: Complex<T>) -> Complex<T> {
        Complex::new_unchecked(-(self.i() * rhs.imag()), self.i() * rhs.real())
    }
}
impl<T: Float> Mul<ImagUnit<T>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn mul(self, rhs: ImagUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.i() * rhs.i()))
    }
}
impl<T: Float> Mul<Scalar<T>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(rhs.s() * self.i())
    }
}
impl<T: Float> Add for Scalar<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.s() + rhs.s())
    }
}
impl<T: Float> Sub for Scalar<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.s() - rhs.s())
    }
}
impl<T: Float> Neg for Scalar<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.s())
    }
}
impl<T: Float> Mul<T> for Scalar<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Scalar<f32>> for f32 {
    type Output = Scalar<f32>;
    #[inline]
    fn mul(self, v: Scalar<f32>) -> Scalar<f32> {
        v.scale(self)
    }
}
impl Mul<Scalar<f64>> for f64 {
    type Output = Scalar<f64>;
    #[inline]
    fn mul(self, v: Scalar<f64>) -> Scalar<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Complex<T>> for Scalar<T> {
    type Output = Complex<T>;
    #[inline]
    fn mul(self, rhs: Complex<T>) -> Complex<T> {
        Complex::new_unchecked(self.s() * rhs.real(), self.s() * rhs.imag())
    }
}
impl<T: Float> Mul<ImagUnit<T>> for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn mul(self, rhs: ImagUnit<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.s() * rhs.i())
    }
}
impl<T: Float> Mul<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
impl<T: Float> Wedge<Scalar<T>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(rhs.s() * self.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(rhs.s() * self.as_inner().i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(rhs.as_inner().s() * self.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(rhs.as_inner().s() * self.as_inner().i())
    }
}
impl<T: Float> Wedge<ImagUnit<T>> for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn wedge(&self, rhs: &ImagUnit<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.s() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<ImagUnit<T>> for Unit<Scalar<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn wedge(&self, rhs: &ImagUnit<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.as_inner().s() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<ImagUnit<T>>> for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.s() * rhs.as_inner().i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<ImagUnit<T>>> for Unit<Scalar<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.as_inner().s() * rhs.as_inner().i())
    }
}
impl<T: Float> Wedge<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.as_inner().s())
    }
}
impl<T: Float> Antiwedge<ImagUnit<T>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn antiwedge(&self, rhs: &ImagUnit<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.i() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<ImagUnit<T>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn antiwedge(&self, rhs: &ImagUnit<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.as_inner().i() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<ImagUnit<T>>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.i() * rhs.as_inner().i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<ImagUnit<T>>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.as_inner().i() * rhs.as_inner().i())
    }
}
impl<T: Float> Antiwedge<Scalar<T>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Scalar<T>> for Unit<ImagUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.as_inner().i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Scalar<T>>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().s() * self.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Scalar<T>>> for Unit<ImagUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().s() * self.as_inner().i())
    }
}
impl<T: Float> Antiwedge<ImagUnit<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &ImagUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<ImagUnit<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &ImagUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<ImagUnit<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<ImagUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.as_inner().i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<ImagUnit<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<ImagUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.as_inner().i())
    }
}
impl<T: Float> LeftContract<ImagUnit<T>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &ImagUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.i() * rhs.i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<ImagUnit<T>> for Unit<ImagUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &ImagUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().i() * rhs.i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<ImagUnit<T>>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<ImagUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.i() * rhs.as_inner().i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<ImagUnit<T>>> for Unit<ImagUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<ImagUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().i() * rhs.as_inner().i()))
    }
}
impl<T: Float> LeftContract<ImagUnit<T>> for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn left_contract(&self, rhs: &ImagUnit<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.s() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<ImagUnit<T>> for Unit<Scalar<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn left_contract(&self, rhs: &ImagUnit<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.as_inner().s() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<ImagUnit<T>>> for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.s() * rhs.as_inner().i())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<ImagUnit<T>>> for Unit<Scalar<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.as_inner().s() * rhs.as_inner().i())
    }
}
impl<T: Float> LeftContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.as_inner().s())
    }
}
impl<T: Float> RightContract<ImagUnit<T>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &ImagUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.i() * rhs.i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<ImagUnit<T>> for Unit<ImagUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &ImagUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().i() * rhs.i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<ImagUnit<T>>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<ImagUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.i() * rhs.as_inner().i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<ImagUnit<T>>> for Unit<ImagUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<ImagUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().i() * rhs.as_inner().i()))
    }
}
impl<T: Float> RightContract<Scalar<T>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(rhs.s() * self.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(rhs.s() * self.as_inner().i())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(rhs.as_inner().s() * self.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(rhs.as_inner().s() * self.as_inner().i())
    }
}
impl<T: Float> RightContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Complex<T>> for ImagUnit<T> {
    type Output = Complex<T>;
    #[inline]
    fn sandwich(&self, operand: &Complex<T>) -> Complex<T> {
        Complex::new_unchecked(
            -(self.i() * operand.real() * self.i()),
            -(self.i() * operand.imag() * self.i()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Complex<T>> for Unit<ImagUnit<T>> {
    type Output = Complex<T>;
    #[inline]
    fn sandwich(&self, operand: &Complex<T>) -> Complex<T> {
        Complex::new_unchecked(-(operand.real()), -(operand.imag()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Complex<T>>> for ImagUnit<T> {
    type Output = Complex<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Complex<T>>) -> Complex<T> {
        Complex::new_unchecked(
            -(self.i() * self.i() * operand.as_inner().real()),
            -(self.i() * self.i() * operand.as_inner().imag()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Complex<T>>> for Unit<ImagUnit<T>> {
    type Output = Complex<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Complex<T>>) -> Complex<T> {
        Complex::new_unchecked(-(operand.as_inner().real()), -(operand.as_inner().imag()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<ImagUnit<T>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn sandwich(&self, operand: &ImagUnit<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(self.i() * operand.i() * self.i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<ImagUnit<T>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn sandwich(&self, operand: &ImagUnit<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(operand.i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<ImagUnit<T>>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(self.i() * self.i() * operand.as_inner().i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<ImagUnit<T>>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(operand.as_inner().i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.i() * operand.s() * self.i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unit<ImagUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.as_inner().s() * self.i() * self.i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Unit<ImagUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Complex<T>> for Scalar<T> {
    type Output = Complex<T>;
    #[inline]
    fn sandwich(&self, operand: &Complex<T>) -> Complex<T> {
        Complex::new_unchecked(
            self.s() * operand.real() * self.s(),
            self.s() * operand.imag() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Complex<T>> for Unit<Scalar<T>> {
    type Output = Complex<T>;
    #[inline]
    fn sandwich(&self, operand: &Complex<T>) -> Complex<T> {
        Complex::new_unchecked(operand.real(), operand.imag())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Complex<T>>> for Scalar<T> {
    type Output = Complex<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Complex<T>>) -> Complex<T> {
        Complex::new_unchecked(
            self.s() * self.s() * operand.as_inner().real(),
            self.s() * self.s() * operand.as_inner().imag(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Complex<T>>> for Unit<Scalar<T>> {
    type Output = Complex<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Complex<T>>) -> Complex<T> {
        Complex::new_unchecked(operand.as_inner().real(), operand.as_inner().imag())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<ImagUnit<T>> for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn sandwich(&self, operand: &ImagUnit<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.s() * operand.i() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<ImagUnit<T>> for Unit<Scalar<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn sandwich(&self, operand: &ImagUnit<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(operand.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<ImagUnit<T>>> for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.s() * self.s() * operand.as_inner().i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<ImagUnit<T>>> for Unit<Scalar<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(operand.as_inner().i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * operand.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * self.s() * operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Complex<T>> for ImagUnit<T> {
    type Output = Complex<T>;
    #[inline]
    fn antisandwich(&self, operand: &Complex<T>) -> Complex<T> {
        Complex::new_unchecked(
            self.i() * operand.real() * self.i(),
            self.i() * operand.imag() * self.i(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Complex<T>> for Unit<ImagUnit<T>> {
    type Output = Complex<T>;
    #[inline]
    fn antisandwich(&self, operand: &Complex<T>) -> Complex<T> {
        Complex::new_unchecked(operand.real(), operand.imag())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Complex<T>>> for ImagUnit<T> {
    type Output = Complex<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Complex<T>>) -> Complex<T> {
        Complex::new_unchecked(
            self.i() * self.i() * operand.as_inner().real(),
            self.i() * self.i() * operand.as_inner().imag(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Complex<T>>> for Unit<ImagUnit<T>> {
    type Output = Complex<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Complex<T>>) -> Complex<T> {
        Complex::new_unchecked(operand.as_inner().real(), operand.as_inner().imag())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<ImagUnit<T>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn antisandwich(&self, operand: &ImagUnit<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.i() * operand.i() * self.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<ImagUnit<T>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn antisandwich(&self, operand: &ImagUnit<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(operand.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<ImagUnit<T>>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.i() * self.i() * operand.as_inner().i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<ImagUnit<T>>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(operand.as_inner().i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.i() * operand.s() * self.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unit<ImagUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s() * self.i() * self.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Unit<ImagUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Complex<T>> for Scalar<T> {
    type Output = Complex<T>;
    #[inline]
    fn antisandwich(&self, operand: &Complex<T>) -> Complex<T> {
        Complex::new_unchecked(
            -(self.s() * operand.real() * self.s()),
            -(self.s() * operand.imag() * self.s()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Complex<T>> for Unit<Scalar<T>> {
    type Output = Complex<T>;
    #[inline]
    fn antisandwich(&self, operand: &Complex<T>) -> Complex<T> {
        Complex::new_unchecked(-(operand.real()), -(operand.imag()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Complex<T>>> for Scalar<T> {
    type Output = Complex<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Complex<T>>) -> Complex<T> {
        Complex::new_unchecked(
            -(self.s() * self.s() * operand.as_inner().real()),
            -(self.s() * self.s() * operand.as_inner().imag()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Complex<T>>> for Unit<Scalar<T>> {
    type Output = Complex<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Complex<T>>) -> Complex<T> {
        Complex::new_unchecked(-(operand.as_inner().real()), -(operand.as_inner().imag()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<ImagUnit<T>> for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn antisandwich(&self, operand: &ImagUnit<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(self.s() * operand.i() * self.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<ImagUnit<T>> for Unit<Scalar<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn antisandwich(&self, operand: &ImagUnit<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(operand.i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<ImagUnit<T>>> for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(self.s() * self.s() * operand.as_inner().i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<ImagUnit<T>>> for Unit<Scalar<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(operand.as_inner().i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.s() * operand.s() * self.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.s() * self.s() * operand.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.as_inner().s()))
    }
}
impl<T: Float> Transform<Complex<T>> for ImagUnit<T> {
    type Output = Complex<T>;
    #[inline]
    fn transform(&self, operand: &Complex<T>) -> Complex<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Complex<T>> for Unit<ImagUnit<T>> {
    type Output = Complex<T>;
    #[inline]
    fn transform(&self, operand: &Complex<T>) -> Complex<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Complex<T>>> for ImagUnit<T> {
    type Output = Complex<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Complex<T>>) -> Complex<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Complex<T>>> for Unit<ImagUnit<T>> {
    type Output = Complex<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Complex<T>>) -> Complex<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<ImagUnit<T>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn transform(&self, operand: &ImagUnit<T>) -> ImagUnit<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<ImagUnit<T>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn transform(&self, operand: &ImagUnit<T>) -> ImagUnit<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<ImagUnit<T>>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn transform(&self, operand: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<ImagUnit<T>>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn transform(&self, operand: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unit<ImagUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Unit<ImagUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Complex<T>> for Scalar<T> {
    type Output = Complex<T>;
    #[inline]
    fn transform(&self, operand: &Complex<T>) -> Complex<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Complex<T>> for Unit<Scalar<T>> {
    type Output = Complex<T>;
    #[inline]
    fn transform(&self, operand: &Complex<T>) -> Complex<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Complex<T>>> for Scalar<T> {
    type Output = Complex<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Complex<T>>) -> Complex<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Complex<T>>> for Unit<Scalar<T>> {
    type Output = Complex<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Complex<T>>) -> Complex<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<ImagUnit<T>> for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn transform(&self, operand: &ImagUnit<T>) -> ImagUnit<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<ImagUnit<T>> for Unit<Scalar<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn transform(&self, operand: &ImagUnit<T>) -> ImagUnit<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<ImagUnit<T>>> for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn transform(&self, operand: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<ImagUnit<T>>> for Unit<Scalar<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn transform(&self, operand: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Complex<T>> for ImagUnit<T> {
    type Output = Complex<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Complex<T>) -> Option<Complex<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Complex::new_unchecked(
            (-(self.i() * operand.real() * self.i())) * inv_norm_sq,
            (-(self.i() * operand.imag() * self.i())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<ImagUnit<T>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &ImagUnit<T>) -> Option<ImagUnit<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(ImagUnit::new_unchecked(
            (-(self.i() * operand.i() * self.i())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (-(self.i() * operand.s() * self.i())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Complex<T>> for Scalar<T> {
    type Output = Complex<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Complex<T>) -> Option<Complex<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Complex::new_unchecked(
            (self.s() * operand.real() * self.s()) * inv_norm_sq,
            (self.s() * operand.imag() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<ImagUnit<T>> for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &ImagUnit<T>) -> Option<ImagUnit<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(ImagUnit::new_unchecked(
            (self.s() * operand.i() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.s() * operand.s() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Complex<T>> for ImagUnit<T> {
    type Output = Complex<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Complex<T>) -> Option<Complex<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Complex::new_unchecked(
            (self.i() * operand.real() * self.i()) * inv_norm_sq,
            (self.i() * operand.imag() * self.i()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<ImagUnit<T>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &ImagUnit<T>) -> Option<ImagUnit<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(ImagUnit::new_unchecked(
            (self.i() * operand.i() * self.i()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.i() * operand.s() * self.i()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Complex<T>> for Scalar<T> {
    type Output = Complex<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Complex<T>) -> Option<Complex<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Complex::new_unchecked(
            (-(self.s() * operand.real() * self.s())) * inv_norm_sq,
            (-(self.s() * operand.imag() * self.s())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<ImagUnit<T>> for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &ImagUnit<T>) -> Option<ImagUnit<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(ImagUnit::new_unchecked(
            (-(self.s() * operand.i() * self.s())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (-(self.s() * operand.s() * self.s())) * inv_norm_sq,
        ))
    }
}
impl<T: Float> Versor<ImagUnit<T>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn compose(&self, other: &ImagUnit<T>) -> Scalar<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> ImagUnit<T> {
        *self * *other
    }
}
impl<T: Float> Versor<ImagUnit<T>> for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn compose(&self, other: &ImagUnit<T>) -> ImagUnit<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Scalar<T> {
        *self * *other
    }
}
impl<T: Float> ScalarProduct<ImagUnit<T>> for ImagUnit<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &ImagUnit<T>) -> T {
        -(self.i() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<ImagUnit<T>> for Unit<ImagUnit<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &ImagUnit<T>) -> T {
        -(self.as_inner().i() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<ImagUnit<T>>> for ImagUnit<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<ImagUnit<T>>) -> T {
        -(self.i() * rhs.as_inner().i())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<ImagUnit<T>>> for Unit<ImagUnit<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<ImagUnit<T>>) -> T {
        -(self.as_inner().i() * rhs.as_inner().i())
    }
}
impl<T: Float> ScalarProduct<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Scalar<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Scalar<T>) -> T {
        self.as_inner().s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Scalar<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.s() * rhs.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
    }
}
impl<T: Float> BulkContract<ImagUnit<T>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &ImagUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.i() * rhs.i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<ImagUnit<T>> for Unit<ImagUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &ImagUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().i() * rhs.i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<ImagUnit<T>>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<ImagUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.i() * rhs.as_inner().i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<ImagUnit<T>>> for Unit<ImagUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<ImagUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().i() * rhs.as_inner().i()))
    }
}
impl<T: Float> BulkContract<Scalar<T>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(rhs.s() * self.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(rhs.s() * self.as_inner().i())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(rhs.as_inner().s() * self.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(rhs.as_inner().s() * self.as_inner().i())
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.as_inner().s())
    }
}
impl<T: Float> WeightContract<ImagUnit<T>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &ImagUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.i() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<ImagUnit<T>> for Unit<ImagUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &ImagUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().i() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<ImagUnit<T>>> for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<ImagUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.i() * rhs.as_inner().i())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<ImagUnit<T>>> for Unit<ImagUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<ImagUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().i() * rhs.as_inner().i())
    }
}
impl<T: Float> WeightContract<Scalar<T>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(rhs.s() * self.i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Scalar<T>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(rhs.s() * self.as_inner().i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(rhs.as_inner().s() * self.i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(rhs.as_inner().s() * self.as_inner().i()))
    }
}
impl<T: Float> WeightContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.s() * rhs.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().s() * rhs.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.s() * rhs.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().s() * rhs.as_inner().s()))
    }
}
impl<T: Float> BulkExpand<ImagUnit<T>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &ImagUnit<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(self.i() * rhs.i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<ImagUnit<T>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &ImagUnit<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(self.as_inner().i() * rhs.i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<ImagUnit<T>>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(self.i() * rhs.as_inner().i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<ImagUnit<T>>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(self.as_inner().i() * rhs.as_inner().i()))
    }
}
impl<T: Float> BulkExpand<ImagUnit<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &ImagUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.s() * rhs.i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<ImagUnit<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &ImagUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().s() * rhs.i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<ImagUnit<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<ImagUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.s() * rhs.as_inner().i()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<ImagUnit<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<ImagUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().s() * rhs.as_inner().i()))
    }
}
impl<T: Float> BulkExpand<Scalar<T>> for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Scalar<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Scalar<T>> for Unit<Scalar<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Scalar<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Scalar<T>>> for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Scalar<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Scalar<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.as_inner().s() * rhs.as_inner().s())
    }
}
impl<T: Float> WeightExpand<ImagUnit<T>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn weight_expand(&self, rhs: &ImagUnit<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.i() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<ImagUnit<T>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn weight_expand(&self, rhs: &ImagUnit<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.as_inner().i() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<ImagUnit<T>>> for ImagUnit<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.i() * rhs.as_inner().i())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<ImagUnit<T>>> for Unit<ImagUnit<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<ImagUnit<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.as_inner().i() * rhs.as_inner().i())
    }
}
impl<T: Float> WeightExpand<ImagUnit<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &ImagUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<ImagUnit<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &ImagUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<ImagUnit<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<ImagUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.as_inner().i())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<ImagUnit<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<ImagUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.as_inner().i())
    }
}
impl<T: Float> WeightExpand<Scalar<T>> for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Scalar<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(self.s() * rhs.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Scalar<T>> for Unit<Scalar<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Scalar<T>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(self.as_inner().s() * rhs.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Scalar<T>>> for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Scalar<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(self.s() * rhs.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = ImagUnit<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Scalar<T>>) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-(self.as_inner().s() * rhs.as_inner().s()))
    }
}
impl<T: Float> Dot<Complex<T>> for Complex<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Complex<T>) -> T {
        self.real() * rhs.real() - self.imag() * rhs.imag()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Complex<T>> for Unit<Complex<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Complex<T>) -> T {
        self.as_inner().real() * rhs.real() + -(self.as_inner().imag() * rhs.imag())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Complex<T>>> for Complex<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Complex<T>>) -> T {
        self.real() * rhs.as_inner().real() + -(self.imag() * rhs.as_inner().imag())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Complex<T>>> for Unit<Complex<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Complex<T>>) -> T {
        self.as_inner().real() * rhs.as_inner().real()
            + -(self.as_inner().imag() * rhs.as_inner().imag())
    }
}
impl<T: Float> Dot<ImagUnit<T>> for Complex<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &ImagUnit<T>) -> T {
        -(self.imag() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<ImagUnit<T>> for Unit<Complex<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &ImagUnit<T>) -> T {
        -(self.as_inner().imag() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<ImagUnit<T>>> for Complex<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<ImagUnit<T>>) -> T {
        -(self.imag() * rhs.as_inner().i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<ImagUnit<T>>> for Unit<Complex<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<ImagUnit<T>>) -> T {
        -(self.as_inner().imag() * rhs.as_inner().i())
    }
}
impl<T: Float> Dot<Scalar<T>> for Complex<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.real() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Scalar<T>> for Unit<Complex<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        rhs.s() * self.as_inner().real()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Scalar<T>>> for Complex<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Scalar<T>>) -> T {
        rhs.as_inner().s() * self.real()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Scalar<T>>> for Unit<Complex<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Scalar<T>>) -> T {
        rhs.as_inner().s() * self.as_inner().real()
    }
}
impl<T: Float> Dot<Complex<T>> for ImagUnit<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Complex<T>) -> T {
        -(self.i() * rhs.imag())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Complex<T>> for Unit<ImagUnit<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Complex<T>) -> T {
        -(self.as_inner().i() * rhs.imag())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Complex<T>>> for ImagUnit<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Complex<T>>) -> T {
        -(self.i() * rhs.as_inner().imag())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Complex<T>>> for Unit<ImagUnit<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Complex<T>>) -> T {
        -(self.as_inner().i() * rhs.as_inner().imag())
    }
}
impl<T: Float> Dot<ImagUnit<T>> for ImagUnit<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &ImagUnit<T>) -> T {
        -(self.i() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<ImagUnit<T>> for Unit<ImagUnit<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &ImagUnit<T>) -> T {
        -(self.as_inner().i() * rhs.i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<ImagUnit<T>>> for ImagUnit<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<ImagUnit<T>>) -> T {
        -(self.i() * rhs.as_inner().i())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<ImagUnit<T>>> for Unit<ImagUnit<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<ImagUnit<T>>) -> T {
        -(self.as_inner().i() * rhs.as_inner().i())
    }
}
impl<T: Float> Dot<Complex<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Complex<T>) -> T {
        self.s() * rhs.real()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Complex<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Complex<T>) -> T {
        self.as_inner().s() * rhs.real()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Complex<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Complex<T>>) -> T {
        self.s() * rhs.as_inner().real()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Complex<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Complex<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().real()
    }
}
impl<T: Float> Dot<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Scalar<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.as_inner().s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Scalar<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.s() * rhs.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
    }
}
impl<T: Float> Antidot<Complex<T>> for Complex<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Complex<T>) -> T {
        -(self.real() * rhs.real()) + self.imag() * rhs.imag()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Complex<T>> for Unit<Complex<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Complex<T>) -> T {
        -(self.as_inner().real() * rhs.real()) + self.as_inner().imag() * rhs.imag()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Complex<T>>> for Complex<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Complex<T>>) -> T {
        -(self.real() * rhs.as_inner().real()) + self.imag() * rhs.as_inner().imag()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Complex<T>>> for Unit<Complex<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Complex<T>>) -> T {
        -(self.as_inner().real() * rhs.as_inner().real())
            + self.as_inner().imag() * rhs.as_inner().imag()
    }
}
impl<T: Float> Antidot<ImagUnit<T>> for Complex<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &ImagUnit<T>) -> T {
        self.imag() * rhs.i()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<ImagUnit<T>> for Unit<Complex<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &ImagUnit<T>) -> T {
        self.as_inner().imag() * rhs.i()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<ImagUnit<T>>> for Complex<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<ImagUnit<T>>) -> T {
        self.imag() * rhs.as_inner().i()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<ImagUnit<T>>> for Unit<Complex<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<ImagUnit<T>>) -> T {
        self.as_inner().imag() * rhs.as_inner().i()
    }
}
impl<T: Float> Antidot<Scalar<T>> for Complex<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        -(self.real() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Scalar<T>> for Unit<Complex<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        -(rhs.s() * self.as_inner().real())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Scalar<T>>> for Complex<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Scalar<T>>) -> T {
        -(rhs.as_inner().s() * self.real())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Scalar<T>>> for Unit<Complex<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Scalar<T>>) -> T {
        -(rhs.as_inner().s() * self.as_inner().real())
    }
}
impl<T: Float> Antidot<Complex<T>> for ImagUnit<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Complex<T>) -> T {
        self.i() * rhs.imag()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Complex<T>> for Unit<ImagUnit<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Complex<T>) -> T {
        self.as_inner().i() * rhs.imag()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Complex<T>>> for ImagUnit<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Complex<T>>) -> T {
        self.i() * rhs.as_inner().imag()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Complex<T>>> for Unit<ImagUnit<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Complex<T>>) -> T {
        self.as_inner().i() * rhs.as_inner().imag()
    }
}
impl<T: Float> Antidot<ImagUnit<T>> for ImagUnit<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &ImagUnit<T>) -> T {
        self.i() * rhs.i()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<ImagUnit<T>> for Unit<ImagUnit<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &ImagUnit<T>) -> T {
        self.as_inner().i() * rhs.i()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<ImagUnit<T>>> for ImagUnit<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<ImagUnit<T>>) -> T {
        self.i() * rhs.as_inner().i()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<ImagUnit<T>>> for Unit<ImagUnit<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<ImagUnit<T>>) -> T {
        self.as_inner().i() * rhs.as_inner().i()
    }
}
impl<T: Float> Antidot<Complex<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Complex<T>) -> T {
        -(self.s() * rhs.real())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Complex<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Complex<T>) -> T {
        -(self.as_inner().s() * rhs.real())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Complex<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Complex<T>>) -> T {
        -(self.s() * rhs.as_inner().real())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Complex<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Complex<T>>) -> T {
        -(self.as_inner().s() * rhs.as_inner().real())
    }
}
impl<T: Float> Antidot<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        -(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Scalar<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        -(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Scalar<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Scalar<T>>) -> T {
        -(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Scalar<T>>) -> T {
        -(self.as_inner().s() * rhs.as_inner().s())
    }
}
impl<T: Float> Reverse for Complex<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.real(), self.imag())
    }
}
impl<T: Float> Reverse for ImagUnit<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.i())
    }
}
impl<T: Float> Reverse for Scalar<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> Antireverse for Complex<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.real(), self.imag())
    }
}
impl<T: Float> Antireverse for ImagUnit<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.i())
    }
}
impl<T: Float> Antireverse for Scalar<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> Involute for Complex<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.real(), -self.imag())
    }
}
impl<T: Float> Involute for ImagUnit<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(-self.i())
    }
}
impl<T: Float> Involute for Scalar<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> RightComplement for Complex<T> {
    type Output = Complex<T>;
    #[inline]
    fn right_complement(&self) -> Complex<T> {
        Complex::new_unchecked(self.imag(), self.real())
    }
}
impl<T: Float> RightComplement for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_complement(&self) -> Scalar<T> {
        Scalar::new_unchecked(self.i())
    }
}
impl<T: Float> RightComplement for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn right_complement(&self) -> ImagUnit<T> {
        ImagUnit::new_unchecked(self.s())
    }
}
impl<T: Float> WeightDual for Complex<T> {
    type Output = Complex<T>;
    #[inline]
    fn weight_dual(&self) -> Complex<T> {
        Complex::new_unchecked(self.imag(), -self.real())
    }
}
impl<T: Float> WeightDual for ImagUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_dual(&self) -> Scalar<T> {
        Scalar::new_unchecked(self.i())
    }
}
impl<T: Float> WeightDual for Scalar<T> {
    type Output = ImagUnit<T>;
    #[inline]
    fn weight_dual(&self) -> ImagUnit<T> {
        ImagUnit::new_unchecked(-self.s())
    }
}
impl<T: Float> VersorInverse for ImagUnit<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(self.i() * inv_norm_sq))
    }
}
impl<T: Float> VersorInverse for Scalar<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(self.s() * inv_norm_sq))
    }
}
impl<T: Float> crate::norm::Normed for Complex<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.real() * self.real() + self.imag() * self.imag()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.real() * factor, self.imag() * factor)
    }
}
impl<T: Float> crate::norm::Normed for ImagUnit<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.i() * self.i()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.i() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.s() * self.s()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.s() * factor)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Complex<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.real().abs_diff_eq(&other.real(), epsilon)
            && self.imag().abs_diff_eq(&other.imag(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Complex<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.real()
            .relative_eq(&other.real(), epsilon, max_relative)
            && self
                .imag()
                .relative_eq(&other.imag(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Complex<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.real().ulps_eq(&other.real(), epsilon, max_ulps)
            && self.imag().ulps_eq(&other.imag(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for ImagUnit<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.i().abs_diff_eq(&other.i(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for ImagUnit<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.i().relative_eq(&other.i(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for ImagUnit<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.i().ulps_eq(&other.i(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Scalar<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Scalar<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Scalar<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
    }
}
#[cfg(any(test, feature = "proptest-support"))]
#[allow(clippy::missing_docs_in_private_items)]
mod arbitrary_impls {
    use super::*;
    use proptest::prelude::*;
    use proptest::strategy::BoxedStrategy;
    use std::fmt::Debug;
    impl<T: Float + Debug + 'static> Arbitrary for Complex<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0, -100.0f64..100.0)
                .prop_map(|(x0, x1)| Complex::new_unchecked(T::from_f64(x0), T::from_f64(x1)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for ImagUnit<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| ImagUnit::new_unchecked(T::from_f64(x0)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Scalar<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| Scalar::new_unchecked(T::from_f64(x0)))
                .boxed()
        }
    }
}
