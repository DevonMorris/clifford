#![doc = " Trait implementations for minkowski3."]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
use super::types::{Bivector, Eventor, Pseudoscalar, Scalar, Trivector, Vector};
#[allow(unused_imports)]
use crate::ops::{
    Antidot, Antireverse, Antisandwich, Antiwedge, BulkContract, BulkExpand, Dot,
    InverseAntisandwich, InverseSandwich, Involute, LeftContract, Reverse, RightComplement,
    RightContract, Sandwich, ScalarProduct, Transform, Versor, VersorInverse, Wedge,
    WeightContract, WeightDual, WeightExpand,
};
use crate::scalar::Float;
#[allow(unused_imports)]
use crate::wrappers::Unit;
use approx::{AbsDiffEq, RelativeEq, UlpsEq};
use std::ops::{Add, Mul, Neg, Sub};
impl<T: Float> Add for Bivector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.xy() + rhs.xy(),
            self.xz() + rhs.xz(),
            self.xt() + rhs.xt(),
            self.yz() + rhs.yz(),
            self.yt() + rhs.yt(),
            self.zt() + rhs.zt(),
        )
    }
}
impl<T: Float> Sub for Bivector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.xy() - rhs.xy(),
            self.xz() - rhs.xz(),
            self.xt() - rhs.xt(),
            self.yz() - rhs.yz(),
            self.yt() - rhs.yt(),
            self.zt() - rhs.zt(),
        )
    }
}
impl<T: Float> Neg for Bivector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(
            -self.xy(),
            -self.xz(),
            -self.xt(),
            -self.yz(),
            -self.yt(),
            -self.zt(),
        )
    }
}
impl<T: Float> Mul<T> for Bivector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Bivector<f32>> for f32 {
    type Output = Bivector<f32>;
    #[inline]
    fn mul(self, v: Bivector<f32>) -> Bivector<f32> {
        v.scale(self)
    }
}
impl Mul<Bivector<f64>> for f64 {
    type Output = Bivector<f64>;
    #[inline]
    fn mul(self, v: Bivector<f64>) -> Bivector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(rhs.xz() * self.yt())
                + -(rhs.yt() * self.xz())
                + rhs.xt() * self.yz()
                + rhs.xy() * self.zt()
                + rhs.yz() * self.xt()
                + rhs.zt() * self.xy(),
            -(rhs.xt() * self.xz())
                + -(rhs.yt() * self.yz())
                + rhs.xz() * self.xt()
                + rhs.yz() * self.yt(),
            -(rhs.xy() * self.xt())
                + -(rhs.zt() * self.yz())
                + rhs.xt() * self.xy()
                + rhs.yz() * self.zt(),
            -(rhs.xy() * self.xz())
                + -(rhs.zt() * self.yt())
                + rhs.xz() * self.xy()
                + rhs.yt() * self.zt(),
            -(rhs.xy() * self.yt())
                + -(rhs.xz() * self.zt())
                + rhs.yt() * self.xy()
                + rhs.zt() * self.xz(),
            -(rhs.xt() * self.zt())
                + -(rhs.xy() * self.yz())
                + rhs.yz() * self.xy()
                + rhs.zt() * self.xt(),
            -(rhs.xz() * self.yz())
                + -(rhs.yt() * self.xt())
                + rhs.xt() * self.yt()
                + rhs.yz() * self.xz(),
            -(rhs.xt() * self.xt())
                + -(rhs.yt() * self.yt())
                + -(rhs.zt() * self.zt())
                + rhs.xy() * self.xy()
                + rhs.xz() * self.xz()
                + rhs.yz() * self.yz(),
        )
    }
}
impl<T: Float> Mul<Eventor<T>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn mul(self, rhs: Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(rhs.xz() * self.yt())
                + -(rhs.yt() * self.xz())
                + rhs.xt() * self.yz()
                + rhs.xy() * self.zt()
                + rhs.yz() * self.xt()
                + rhs.zt() * self.xy(),
            -(rhs.s() * self.zt())
                + -(rhs.xt() * self.xz())
                + -(rhs.yt() * self.yz())
                + rhs.xyzt() * self.xy()
                + rhs.xz() * self.xt()
                + rhs.yz() * self.yt(),
            -(rhs.xy() * self.xt())
                + -(rhs.zt() * self.yz())
                + rhs.s() * self.yt()
                + rhs.xt() * self.xy()
                + rhs.xyzt() * self.xz()
                + rhs.yz() * self.zt(),
            -(rhs.xy() * self.xz())
                + -(rhs.zt() * self.yt())
                + rhs.s() * self.yz()
                + rhs.xyzt() * self.xt()
                + rhs.xz() * self.xy()
                + rhs.yt() * self.zt(),
            -(rhs.s() * self.xt())
                + -(rhs.xy() * self.yt())
                + -(rhs.xz() * self.zt())
                + rhs.xyzt() * self.yz()
                + rhs.yt() * self.xy()
                + rhs.zt() * self.xz(),
            -(rhs.s() * self.xz())
                + -(rhs.xt() * self.zt())
                + -(rhs.xy() * self.yz())
                + rhs.xyzt() * self.yt()
                + rhs.yz() * self.xy()
                + rhs.zt() * self.xt(),
            -(rhs.xz() * self.yz())
                + -(rhs.yt() * self.xt())
                + rhs.s() * self.xy()
                + rhs.xt() * self.yt()
                + rhs.xyzt() * self.zt()
                + rhs.yz() * self.xz(),
            -(rhs.xt() * self.xt())
                + -(rhs.yt() * self.yt())
                + -(rhs.zt() * self.zt())
                + rhs.xy() * self.xy()
                + rhs.xz() * self.xz()
                + rhs.yz() * self.yz(),
        )
    }
}
impl<T: Float> Mul<Pseudoscalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn mul(self, rhs: Pseudoscalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.xyzt() * self.zt(),
            -(rhs.xyzt() * self.yt()),
            -(rhs.xyzt() * self.yz()),
            rhs.xyzt() * self.xt(),
            rhs.xyzt() * self.xz(),
            -(rhs.xyzt() * self.xy()),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.s() * self.xy(),
            rhs.s() * self.xz(),
            rhs.s() * self.xt(),
            rhs.s() * self.yz(),
            rhs.s() * self.yt(),
            rhs.s() * self.zt(),
        )
    }
}
impl<T: Float> Add for Eventor<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.s() + rhs.s(),
            self.xy() + rhs.xy(),
            self.xz() + rhs.xz(),
            self.xt() + rhs.xt(),
            self.yz() + rhs.yz(),
            self.yt() + rhs.yt(),
            self.zt() + rhs.zt(),
            self.xyzt() + rhs.xyzt(),
        )
    }
}
impl<T: Float> Sub for Eventor<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.s() - rhs.s(),
            self.xy() - rhs.xy(),
            self.xz() - rhs.xz(),
            self.xt() - rhs.xt(),
            self.yz() - rhs.yz(),
            self.yt() - rhs.yt(),
            self.zt() - rhs.zt(),
            self.xyzt() - rhs.xyzt(),
        )
    }
}
impl<T: Float> Neg for Eventor<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(
            -self.s(),
            -self.xy(),
            -self.xz(),
            -self.xt(),
            -self.yz(),
            -self.yt(),
            -self.zt(),
            -self.xyzt(),
        )
    }
}
impl<T: Float> Mul<T> for Eventor<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Eventor<f32>> for f32 {
    type Output = Eventor<f32>;
    #[inline]
    fn mul(self, v: Eventor<f32>) -> Eventor<f32> {
        v.scale(self)
    }
}
impl Mul<Eventor<f64>> for f64 {
    type Output = Eventor<f64>;
    #[inline]
    fn mul(self, v: Eventor<f64>) -> Eventor<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(rhs.xz() * self.yt())
                + -(rhs.yt() * self.xz())
                + rhs.xt() * self.yz()
                + rhs.xy() * self.zt()
                + rhs.yz() * self.xt()
                + rhs.zt() * self.xy(),
            -(rhs.xt() * self.xz())
                + -(rhs.yt() * self.yz())
                + -(rhs.zt() * self.s())
                + rhs.xy() * self.xyzt()
                + rhs.xz() * self.xt()
                + rhs.yz() * self.yt(),
            -(rhs.xy() * self.xt())
                + -(rhs.zt() * self.yz())
                + rhs.xt() * self.xy()
                + rhs.xz() * self.xyzt()
                + rhs.yt() * self.s()
                + rhs.yz() * self.zt(),
            -(rhs.xy() * self.xz())
                + -(rhs.zt() * self.yt())
                + rhs.xt() * self.xyzt()
                + rhs.xz() * self.xy()
                + rhs.yt() * self.zt()
                + rhs.yz() * self.s(),
            -(rhs.xt() * self.s())
                + -(rhs.xy() * self.yt())
                + -(rhs.xz() * self.zt())
                + rhs.yt() * self.xy()
                + rhs.yz() * self.xyzt()
                + rhs.zt() * self.xz(),
            -(rhs.xt() * self.zt())
                + -(rhs.xy() * self.yz())
                + -(rhs.xz() * self.s())
                + rhs.yt() * self.xyzt()
                + rhs.yz() * self.xy()
                + rhs.zt() * self.xt(),
            -(rhs.xz() * self.yz())
                + -(rhs.yt() * self.xt())
                + rhs.xt() * self.yt()
                + rhs.xy() * self.s()
                + rhs.yz() * self.xz()
                + rhs.zt() * self.xyzt(),
            -(rhs.xt() * self.xt())
                + -(rhs.yt() * self.yt())
                + -(rhs.zt() * self.zt())
                + rhs.xy() * self.xy()
                + rhs.xz() * self.xz()
                + rhs.yz() * self.yz(),
        )
    }
}
impl<T: Float> Mul<Eventor<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn mul(self, rhs: Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(rhs.xz() * self.yt())
                + -(rhs.yt() * self.xz())
                + rhs.s() * self.xyzt()
                + rhs.xt() * self.yz()
                + rhs.xy() * self.zt()
                + rhs.xyzt() * self.s()
                + rhs.yz() * self.xt()
                + rhs.zt() * self.xy(),
            -(rhs.s() * self.zt())
                + -(rhs.xt() * self.xz())
                + -(rhs.yt() * self.yz())
                + -(rhs.zt() * self.s())
                + rhs.xy() * self.xyzt()
                + rhs.xyzt() * self.xy()
                + rhs.xz() * self.xt()
                + rhs.yz() * self.yt(),
            -(rhs.xy() * self.xt())
                + -(rhs.zt() * self.yz())
                + rhs.s() * self.yt()
                + rhs.xt() * self.xy()
                + rhs.xyzt() * self.xz()
                + rhs.xz() * self.xyzt()
                + rhs.yt() * self.s()
                + rhs.yz() * self.zt(),
            -(rhs.xy() * self.xz())
                + -(rhs.zt() * self.yt())
                + rhs.s() * self.yz()
                + rhs.xt() * self.xyzt()
                + rhs.xyzt() * self.xt()
                + rhs.xz() * self.xy()
                + rhs.yt() * self.zt()
                + rhs.yz() * self.s(),
            -(rhs.s() * self.xt())
                + -(rhs.xt() * self.s())
                + -(rhs.xy() * self.yt())
                + -(rhs.xz() * self.zt())
                + rhs.xyzt() * self.yz()
                + rhs.yt() * self.xy()
                + rhs.yz() * self.xyzt()
                + rhs.zt() * self.xz(),
            -(rhs.s() * self.xz())
                + -(rhs.xt() * self.zt())
                + -(rhs.xy() * self.yz())
                + -(rhs.xz() * self.s())
                + rhs.xyzt() * self.yt()
                + rhs.yt() * self.xyzt()
                + rhs.yz() * self.xy()
                + rhs.zt() * self.xt(),
            -(rhs.xz() * self.yz())
                + -(rhs.yt() * self.xt())
                + rhs.s() * self.xy()
                + rhs.xt() * self.yt()
                + rhs.xy() * self.s()
                + rhs.xyzt() * self.zt()
                + rhs.yz() * self.xz()
                + rhs.zt() * self.xyzt(),
            -(rhs.s() * self.s())
                + -(rhs.xt() * self.xt())
                + -(rhs.yt() * self.yt())
                + -(rhs.zt() * self.zt())
                + rhs.xy() * self.xy()
                + rhs.xyzt() * self.xyzt()
                + rhs.xz() * self.xz()
                + rhs.yz() * self.yz(),
        )
    }
}
impl<T: Float> Mul<Pseudoscalar<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn mul(self, rhs: Pseudoscalar<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(rhs.xyzt() * self.xyzt()),
            rhs.xyzt() * self.zt(),
            -(rhs.xyzt() * self.yt()),
            -(rhs.xyzt() * self.yz()),
            rhs.xyzt() * self.xt(),
            rhs.xyzt() * self.xz(),
            -(rhs.xyzt() * self.xy()),
            rhs.xyzt() * self.s(),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            rhs.s() * self.s(),
            rhs.s() * self.xy(),
            rhs.s() * self.xz(),
            rhs.s() * self.xt(),
            rhs.s() * self.yz(),
            rhs.s() * self.yt(),
            rhs.s() * self.zt(),
            rhs.s() * self.xyzt(),
        )
    }
}
impl<T: Float> Add for Pseudoscalar<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.xyzt() + rhs.xyzt())
    }
}
impl<T: Float> Sub for Pseudoscalar<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.xyzt() - rhs.xyzt())
    }
}
impl<T: Float> Neg for Pseudoscalar<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.xyzt())
    }
}
impl<T: Float> Mul<T> for Pseudoscalar<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Pseudoscalar<f32>> for f32 {
    type Output = Pseudoscalar<f32>;
    #[inline]
    fn mul(self, v: Pseudoscalar<f32>) -> Pseudoscalar<f32> {
        v.scale(self)
    }
}
impl Mul<Pseudoscalar<f64>> for f64 {
    type Output = Pseudoscalar<f64>;
    #[inline]
    fn mul(self, v: Pseudoscalar<f64>) -> Pseudoscalar<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Pseudoscalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.zt() * self.xyzt(),
            -(rhs.yt() * self.xyzt()),
            -(rhs.yz() * self.xyzt()),
            rhs.xt() * self.xyzt(),
            rhs.xz() * self.xyzt(),
            -(rhs.xy() * self.xyzt()),
        )
    }
}
impl<T: Float> Mul<Eventor<T>> for Pseudoscalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn mul(self, rhs: Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(rhs.xyzt() * self.xyzt()),
            rhs.zt() * self.xyzt(),
            -(rhs.yt() * self.xyzt()),
            -(rhs.yz() * self.xyzt()),
            rhs.xt() * self.xyzt(),
            rhs.xz() * self.xyzt(),
            -(rhs.xy() * self.xyzt()),
            rhs.s() * self.xyzt(),
        )
    }
}
impl<T: Float> Mul<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn mul(self, rhs: Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.xyzt() * self.xyzt()))
    }
}
impl<T: Float> Mul<Scalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.s() * self.xyzt())
    }
}
impl<T: Float> Mul<Trivector<T>> for Pseudoscalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.yzt() * self.xyzt(),
            -(rhs.xzt() * self.xyzt()),
            rhs.xyt() * self.xyzt(),
            rhs.xyz() * self.xyzt(),
        )
    }
}
impl<T: Float> Mul<Vector<T>> for Pseudoscalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn mul(self, rhs: Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.t() * self.xyzt()),
            -(rhs.z() * self.xyzt()),
            rhs.y() * self.xyzt(),
            -(rhs.x() * self.xyzt()),
        )
    }
}
impl<T: Float> Add for Scalar<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.s() + rhs.s())
    }
}
impl<T: Float> Sub for Scalar<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.s() - rhs.s())
    }
}
impl<T: Float> Neg for Scalar<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.s())
    }
}
impl<T: Float> Mul<T> for Scalar<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Scalar<f32>> for f32 {
    type Output = Scalar<f32>;
    #[inline]
    fn mul(self, v: Scalar<f32>) -> Scalar<f32> {
        v.scale(self)
    }
}
impl Mul<Scalar<f64>> for f64 {
    type Output = Scalar<f64>;
    #[inline]
    fn mul(self, v: Scalar<f64>) -> Scalar<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.xy() * self.s(),
            rhs.xz() * self.s(),
            rhs.xt() * self.s(),
            rhs.yz() * self.s(),
            rhs.yt() * self.s(),
            rhs.zt() * self.s(),
        )
    }
}
impl<T: Float> Mul<Eventor<T>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn mul(self, rhs: Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            rhs.s() * self.s(),
            rhs.xy() * self.s(),
            rhs.xz() * self.s(),
            rhs.xt() * self.s(),
            rhs.yz() * self.s(),
            rhs.yt() * self.s(),
            rhs.zt() * self.s(),
            rhs.xyzt() * self.s(),
        )
    }
}
impl<T: Float> Mul<Pseudoscalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn mul(self, rhs: Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.xyzt() * self.s())
    }
}
impl<T: Float> Mul<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
impl<T: Float> Mul<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn mul(self, rhs: Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.xyz() * self.s(),
            rhs.xyt() * self.s(),
            rhs.xzt() * self.s(),
            rhs.yzt() * self.s(),
        )
    }
}
impl<T: Float> Mul<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.x() * self.s(),
            rhs.y() * self.s(),
            rhs.z() * self.s(),
            rhs.t() * self.s(),
        )
    }
}
impl<T: Float> Add for Trivector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.xyz() + rhs.xyz(),
            self.xyt() + rhs.xyt(),
            self.xzt() + rhs.xzt(),
            self.yzt() + rhs.yzt(),
        )
    }
}
impl<T: Float> Sub for Trivector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.xyz() - rhs.xyz(),
            self.xyt() - rhs.xyt(),
            self.xzt() - rhs.xzt(),
            self.yzt() - rhs.yzt(),
        )
    }
}
impl<T: Float> Neg for Trivector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.xyz(), -self.xyt(), -self.xzt(), -self.yzt())
    }
}
impl<T: Float> Mul<T> for Trivector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Trivector<f32>> for f32 {
    type Output = Trivector<f32>;
    #[inline]
    fn mul(self, v: Trivector<f32>) -> Trivector<f32> {
        v.scale(self)
    }
}
impl Mul<Trivector<f64>> for f64 {
    type Output = Trivector<f64>;
    #[inline]
    fn mul(self, v: Trivector<f64>) -> Trivector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Pseudoscalar<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Pseudoscalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.xyzt() * self.yzt()),
            rhs.xyzt() * self.xzt(),
            -(rhs.xyzt() * self.xyt()),
            -(rhs.xyzt() * self.xyz()),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.s() * self.xyz(),
            rhs.s() * self.xyt(),
            rhs.s() * self.xzt(),
            rhs.s() * self.yzt(),
        )
    }
}
impl<T: Float> Add for Vector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.x() + rhs.x(),
            self.y() + rhs.y(),
            self.z() + rhs.z(),
            self.t() + rhs.t(),
        )
    }
}
impl<T: Float> Sub for Vector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.x() - rhs.x(),
            self.y() - rhs.y(),
            self.z() - rhs.z(),
            self.t() - rhs.t(),
        )
    }
}
impl<T: Float> Neg for Vector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.x(), -self.y(), -self.z(), -self.t())
    }
}
impl<T: Float> Mul<T> for Vector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Vector<f32>> for f32 {
    type Output = Vector<f32>;
    #[inline]
    fn mul(self, v: Vector<f32>) -> Vector<f32> {
        v.scale(self)
    }
}
impl Mul<Vector<f64>> for f64 {
    type Output = Vector<f64>;
    #[inline]
    fn mul(self, v: Vector<f64>) -> Vector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Pseudoscalar<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn mul(self, rhs: Pseudoscalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.xyzt() * self.t(),
            rhs.xyzt() * self.z(),
            -(rhs.xyzt() * self.y()),
            rhs.xyzt() * self.x(),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.s() * self.x(),
            rhs.s() * self.y(),
            rhs.s() * self.z(),
            rhs.s() * self.t(),
        )
    }
}
impl<T: Float> Wedge<Bivector<T>> for Bivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Bivector<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.xz() * self.yt())
                + -(rhs.yt() * self.xz())
                + rhs.xt() * self.yz()
                + rhs.xy() * self.zt()
                + rhs.yz() * self.xt()
                + rhs.zt() * self.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Bivector<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.xz() * self.as_inner().yt())
                + -(rhs.yt() * self.as_inner().xz())
                + rhs.xt() * self.as_inner().yz()
                + rhs.xy() * self.as_inner().zt()
                + rhs.yz() * self.as_inner().xt()
                + rhs.zt() * self.as_inner().xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Bivector<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.as_inner().xz() * self.yt())
                + -(rhs.as_inner().yt() * self.xz())
                + rhs.as_inner().xt() * self.yz()
                + rhs.as_inner().xy() * self.zt()
                + rhs.as_inner().yz() * self.xt()
                + rhs.as_inner().zt() * self.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Bivector<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.as_inner().xz() * self.as_inner().yt())
                + -(rhs.as_inner().yt() * self.as_inner().xz())
                + rhs.as_inner().xt() * self.as_inner().yz()
                + rhs.as_inner().xy() * self.as_inner().zt()
                + rhs.as_inner().yz() * self.as_inner().xt()
                + rhs.as_inner().zt() * self.as_inner().xy(),
        )
    }
}
impl<T: Float> Wedge<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.s() * self.xy(),
            rhs.s() * self.xz(),
            rhs.s() * self.xt(),
            rhs.s() * self.yz(),
            rhs.s() * self.yt(),
            rhs.s() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.s() * self.as_inner().xy(),
            rhs.s() * self.as_inner().xz(),
            rhs.s() * self.as_inner().xt(),
            rhs.s() * self.as_inner().yz(),
            rhs.s() * self.as_inner().yt(),
            rhs.s() * self.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().s() * self.xy(),
            rhs.as_inner().s() * self.xz(),
            rhs.as_inner().s() * self.xt(),
            rhs.as_inner().s() * self.yz(),
            rhs.as_inner().s() * self.yt(),
            rhs.as_inner().s() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().s() * self.as_inner().xy(),
            rhs.as_inner().s() * self.as_inner().xz(),
            rhs.as_inner().s() * self.as_inner().xt(),
            rhs.as_inner().s() * self.as_inner().yz(),
            rhs.as_inner().s() * self.as_inner().yt(),
            rhs.as_inner().s() * self.as_inner().zt(),
        )
    }
}
impl<T: Float> Wedge<Vector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.y() * self.xz()) + rhs.x() * self.yz() + rhs.z() * self.xy(),
            -(rhs.y() * self.xt()) + rhs.t() * self.xy() + rhs.x() * self.yt(),
            -(rhs.z() * self.xt()) + rhs.t() * self.xz() + rhs.x() * self.zt(),
            -(rhs.z() * self.yt()) + rhs.t() * self.yz() + rhs.y() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Vector<T>> for Unit<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.y() * self.as_inner().xz())
                + rhs.x() * self.as_inner().yz()
                + rhs.z() * self.as_inner().xy(),
            -(rhs.y() * self.as_inner().xt())
                + rhs.t() * self.as_inner().xy()
                + rhs.x() * self.as_inner().yt(),
            -(rhs.z() * self.as_inner().xt())
                + rhs.t() * self.as_inner().xz()
                + rhs.x() * self.as_inner().zt(),
            -(rhs.z() * self.as_inner().yt())
                + rhs.t() * self.as_inner().yz()
                + rhs.y() * self.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Vector<T>>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Vector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().y() * self.xz())
                + rhs.as_inner().x() * self.yz()
                + rhs.as_inner().z() * self.xy(),
            -(rhs.as_inner().y() * self.xt())
                + rhs.as_inner().t() * self.xy()
                + rhs.as_inner().x() * self.yt(),
            -(rhs.as_inner().z() * self.xt())
                + rhs.as_inner().t() * self.xz()
                + rhs.as_inner().x() * self.zt(),
            -(rhs.as_inner().z() * self.yt())
                + rhs.as_inner().t() * self.yz()
                + rhs.as_inner().y() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Vector<T>>> for Unit<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Vector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().y() * self.as_inner().xz())
                + rhs.as_inner().x() * self.as_inner().yz()
                + rhs.as_inner().z() * self.as_inner().xy(),
            -(rhs.as_inner().y() * self.as_inner().xt())
                + rhs.as_inner().t() * self.as_inner().xy()
                + rhs.as_inner().x() * self.as_inner().yt(),
            -(rhs.as_inner().z() * self.as_inner().xt())
                + rhs.as_inner().t() * self.as_inner().xz()
                + rhs.as_inner().x() * self.as_inner().zt(),
            -(rhs.as_inner().z() * self.as_inner().yt())
                + rhs.as_inner().t() * self.as_inner().yz()
                + rhs.as_inner().y() * self.as_inner().zt(),
        )
    }
}
impl<T: Float> Wedge<Scalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.s() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.s() * self.as_inner().xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().s() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().s() * self.as_inner().xyzt())
    }
}
impl<T: Float> Wedge<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.xy() * self.s(),
            rhs.xz() * self.s(),
            rhs.xt() * self.s(),
            rhs.yz() * self.s(),
            rhs.yt() * self.s(),
            rhs.zt() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Bivector<T>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.xy() * self.as_inner().s(),
            rhs.xz() * self.as_inner().s(),
            rhs.xt() * self.as_inner().s(),
            rhs.yz() * self.as_inner().s(),
            rhs.yt() * self.as_inner().s(),
            rhs.zt() * self.as_inner().s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Bivector<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().xy() * self.s(),
            rhs.as_inner().xz() * self.s(),
            rhs.as_inner().xt() * self.s(),
            rhs.as_inner().yz() * self.s(),
            rhs.as_inner().yt() * self.s(),
            rhs.as_inner().zt() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Bivector<T>>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().xy() * self.as_inner().s(),
            rhs.as_inner().xz() * self.as_inner().s(),
            rhs.as_inner().xt() * self.as_inner().s(),
            rhs.as_inner().yz() * self.as_inner().s(),
            rhs.as_inner().yt() * self.as_inner().s(),
            rhs.as_inner().zt() * self.as_inner().s(),
        )
    }
}
impl<T: Float> Wedge<Pseudoscalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.xyzt() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Pseudoscalar<T>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.xyzt() * self.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Pseudoscalar<T>>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().xyzt() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Pseudoscalar<T>>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().xyzt() * self.as_inner().s())
    }
}
impl<T: Float> Wedge<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().s() * self.as_inner().s())
    }
}
impl<T: Float> Wedge<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.xyz() * self.s(),
            rhs.xyt() * self.s(),
            rhs.xzt() * self.s(),
            rhs.yzt() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Trivector<T>> for Unit<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.xyz() * self.as_inner().s(),
            rhs.xyt() * self.as_inner().s(),
            rhs.xzt() * self.as_inner().s(),
            rhs.yzt() * self.as_inner().s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Trivector<T>>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().xyz() * self.s(),
            rhs.as_inner().xyt() * self.s(),
            rhs.as_inner().xzt() * self.s(),
            rhs.as_inner().yzt() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Trivector<T>>> for Unit<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().xyz() * self.as_inner().s(),
            rhs.as_inner().xyt() * self.as_inner().s(),
            rhs.as_inner().xzt() * self.as_inner().s(),
            rhs.as_inner().yzt() * self.as_inner().s(),
        )
    }
}
impl<T: Float> Wedge<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.x() * self.s(),
            rhs.y() * self.s(),
            rhs.z() * self.s(),
            rhs.t() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Vector<T>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.x() * self.as_inner().s(),
            rhs.y() * self.as_inner().s(),
            rhs.z() * self.as_inner().s(),
            rhs.t() * self.as_inner().s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Vector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().x() * self.s(),
            rhs.as_inner().y() * self.s(),
            rhs.as_inner().z() * self.s(),
            rhs.as_inner().t() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Vector<T>>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().x() * self.as_inner().s(),
            rhs.as_inner().y() * self.as_inner().s(),
            rhs.as_inner().z() * self.as_inner().s(),
            rhs.as_inner().t() * self.as_inner().s(),
        )
    }
}
impl<T: Float> Wedge<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.s() * self.xyz(),
            rhs.s() * self.xyt(),
            rhs.s() * self.xzt(),
            rhs.s() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.s() * self.as_inner().xyz(),
            rhs.s() * self.as_inner().xyt(),
            rhs.s() * self.as_inner().xzt(),
            rhs.s() * self.as_inner().yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().s() * self.xyz(),
            rhs.as_inner().s() * self.xyt(),
            rhs.as_inner().s() * self.xzt(),
            rhs.as_inner().s() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().s() * self.as_inner().xyz(),
            rhs.as_inner().s() * self.as_inner().xyt(),
            rhs.as_inner().s() * self.as_inner().xzt(),
            rhs.as_inner().s() * self.as_inner().yzt(),
        )
    }
}
impl<T: Float> Wedge<Vector<T>> for Trivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.x() * self.yzt())
                + -(rhs.z() * self.xyt())
                + rhs.t() * self.xyz()
                + rhs.y() * self.xzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Vector<T>> for Unit<Trivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.x() * self.as_inner().yzt())
                + -(rhs.z() * self.as_inner().xyt())
                + rhs.t() * self.as_inner().xyz()
                + rhs.y() * self.as_inner().xzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Vector<T>>> for Trivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Vector<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.as_inner().x() * self.yzt())
                + -(rhs.as_inner().z() * self.xyt())
                + rhs.as_inner().t() * self.xyz()
                + rhs.as_inner().y() * self.xzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Vector<T>>> for Unit<Trivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Vector<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.as_inner().x() * self.as_inner().yzt())
                + -(rhs.as_inner().z() * self.as_inner().xyt())
                + rhs.as_inner().t() * self.as_inner().xyz()
                + rhs.as_inner().y() * self.as_inner().xzt(),
        )
    }
}
impl<T: Float> Wedge<Bivector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Bivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.xz() * self.y()) + rhs.xy() * self.z() + rhs.yz() * self.x(),
            -(rhs.xt() * self.y()) + rhs.xy() * self.t() + rhs.yt() * self.x(),
            -(rhs.xt() * self.z()) + rhs.xz() * self.t() + rhs.zt() * self.x(),
            -(rhs.yt() * self.z()) + rhs.yz() * self.t() + rhs.zt() * self.y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Bivector<T>> for Unit<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Bivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.xz() * self.as_inner().y())
                + rhs.xy() * self.as_inner().z()
                + rhs.yz() * self.as_inner().x(),
            -(rhs.xt() * self.as_inner().y())
                + rhs.xy() * self.as_inner().t()
                + rhs.yt() * self.as_inner().x(),
            -(rhs.xt() * self.as_inner().z())
                + rhs.xz() * self.as_inner().t()
                + rhs.zt() * self.as_inner().x(),
            -(rhs.yt() * self.as_inner().z())
                + rhs.yz() * self.as_inner().t()
                + rhs.zt() * self.as_inner().y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Bivector<T>>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Bivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().xz() * self.y())
                + rhs.as_inner().xy() * self.z()
                + rhs.as_inner().yz() * self.x(),
            -(rhs.as_inner().xt() * self.y())
                + rhs.as_inner().xy() * self.t()
                + rhs.as_inner().yt() * self.x(),
            -(rhs.as_inner().xt() * self.z())
                + rhs.as_inner().xz() * self.t()
                + rhs.as_inner().zt() * self.x(),
            -(rhs.as_inner().yt() * self.z())
                + rhs.as_inner().yz() * self.t()
                + rhs.as_inner().zt() * self.y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Bivector<T>>> for Unit<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Bivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().xz() * self.as_inner().y())
                + rhs.as_inner().xy() * self.as_inner().z()
                + rhs.as_inner().yz() * self.as_inner().x(),
            -(rhs.as_inner().xt() * self.as_inner().y())
                + rhs.as_inner().xy() * self.as_inner().t()
                + rhs.as_inner().yt() * self.as_inner().x(),
            -(rhs.as_inner().xt() * self.as_inner().z())
                + rhs.as_inner().xz() * self.as_inner().t()
                + rhs.as_inner().zt() * self.as_inner().x(),
            -(rhs.as_inner().yt() * self.as_inner().z())
                + rhs.as_inner().yz() * self.as_inner().t()
                + rhs.as_inner().zt() * self.as_inner().y(),
        )
    }
}
impl<T: Float> Wedge<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.s() * self.x(),
            rhs.s() * self.y(),
            rhs.s() * self.z(),
            rhs.s() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.s() * self.as_inner().x(),
            rhs.s() * self.as_inner().y(),
            rhs.s() * self.as_inner().z(),
            rhs.s() * self.as_inner().t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().s() * self.x(),
            rhs.as_inner().s() * self.y(),
            rhs.as_inner().s() * self.z(),
            rhs.as_inner().s() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().s() * self.as_inner().x(),
            rhs.as_inner().s() * self.as_inner().y(),
            rhs.as_inner().s() * self.as_inner().z(),
            rhs.as_inner().s() * self.as_inner().t(),
        )
    }
}
impl<T: Float> Wedge<Trivector<T>> for Vector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Trivector<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.xyz() * self.t())
                + -(rhs.xzt() * self.y())
                + rhs.xyt() * self.z()
                + rhs.yzt() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Trivector<T>> for Unit<Vector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Trivector<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.xyz() * self.as_inner().t())
                + -(rhs.xzt() * self.as_inner().y())
                + rhs.xyt() * self.as_inner().z()
                + rhs.yzt() * self.as_inner().x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Trivector<T>>> for Vector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Trivector<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.as_inner().xyz() * self.t())
                + -(rhs.as_inner().xzt() * self.y())
                + rhs.as_inner().xyt() * self.z()
                + rhs.as_inner().yzt() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Trivector<T>>> for Unit<Vector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Trivector<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.as_inner().xyz() * self.as_inner().t())
                + -(rhs.as_inner().xzt() * self.as_inner().y())
                + rhs.as_inner().xyt() * self.as_inner().z()
                + rhs.as_inner().yzt() * self.as_inner().x(),
        )
    }
}
impl<T: Float> Wedge<Vector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.x() * self.y()) + rhs.y() * self.x(),
            -(rhs.x() * self.z()) + rhs.z() * self.x(),
            -(rhs.x() * self.t()) + rhs.t() * self.x(),
            -(rhs.y() * self.z()) + rhs.z() * self.y(),
            -(rhs.y() * self.t()) + rhs.t() * self.y(),
            -(rhs.z() * self.t()) + rhs.t() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Vector<T>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.x() * self.as_inner().y()) + rhs.y() * self.as_inner().x(),
            -(rhs.x() * self.as_inner().z()) + rhs.z() * self.as_inner().x(),
            -(rhs.x() * self.as_inner().t()) + rhs.t() * self.as_inner().x(),
            -(rhs.y() * self.as_inner().z()) + rhs.z() * self.as_inner().y(),
            -(rhs.y() * self.as_inner().t()) + rhs.t() * self.as_inner().y(),
            -(rhs.z() * self.as_inner().t()) + rhs.t() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Vector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().x() * self.y()) + rhs.as_inner().y() * self.x(),
            -(rhs.as_inner().x() * self.z()) + rhs.as_inner().z() * self.x(),
            -(rhs.as_inner().x() * self.t()) + rhs.as_inner().t() * self.x(),
            -(rhs.as_inner().y() * self.z()) + rhs.as_inner().z() * self.y(),
            -(rhs.as_inner().y() * self.t()) + rhs.as_inner().t() * self.y(),
            -(rhs.as_inner().z() * self.t()) + rhs.as_inner().t() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().x() * self.as_inner().y()) + rhs.as_inner().y() * self.as_inner().x(),
            -(rhs.as_inner().x() * self.as_inner().z()) + rhs.as_inner().z() * self.as_inner().x(),
            -(rhs.as_inner().x() * self.as_inner().t()) + rhs.as_inner().t() * self.as_inner().x(),
            -(rhs.as_inner().y() * self.as_inner().z()) + rhs.as_inner().z() * self.as_inner().y(),
            -(rhs.as_inner().y() * self.as_inner().t()) + rhs.as_inner().t() * self.as_inner().y(),
            -(rhs.as_inner().z() * self.as_inner().t()) + rhs.as_inner().t() * self.as_inner().z(),
        )
    }
}
impl<T: Float> Antiwedge<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xz() * self.yt())
                + -(rhs.yt() * self.xz())
                + rhs.xt() * self.yz()
                + rhs.xy() * self.zt()
                + rhs.yz() * self.xt()
                + rhs.zt() * self.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xz() * self.as_inner().yt())
                + -(rhs.yt() * self.as_inner().xz())
                + rhs.xt() * self.as_inner().yz()
                + rhs.xy() * self.as_inner().zt()
                + rhs.yz() * self.as_inner().xt()
                + rhs.zt() * self.as_inner().xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xz() * self.yt())
                + -(rhs.as_inner().yt() * self.xz())
                + rhs.as_inner().xt() * self.yz()
                + rhs.as_inner().xy() * self.zt()
                + rhs.as_inner().yz() * self.xt()
                + rhs.as_inner().zt() * self.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xz() * self.as_inner().yt())
                + -(rhs.as_inner().yt() * self.as_inner().xz())
                + rhs.as_inner().xt() * self.as_inner().yz()
                + rhs.as_inner().xy() * self.as_inner().zt()
                + rhs.as_inner().yz() * self.as_inner().xt()
                + rhs.as_inner().zt() * self.as_inner().xy(),
        )
    }
}
impl<T: Float> Antiwedge<Pseudoscalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Pseudoscalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.xyzt() * self.xy(),
            rhs.xyzt() * self.xz(),
            rhs.xyzt() * self.xt(),
            rhs.xyzt() * self.yz(),
            rhs.xyzt() * self.yt(),
            rhs.xyzt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Pseudoscalar<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Pseudoscalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.xyzt() * self.as_inner().xy(),
            rhs.xyzt() * self.as_inner().xz(),
            rhs.xyzt() * self.as_inner().xt(),
            rhs.xyzt() * self.as_inner().yz(),
            rhs.xyzt() * self.as_inner().yt(),
            rhs.xyzt() * self.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Pseudoscalar<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().xyzt() * self.xy(),
            rhs.as_inner().xyzt() * self.xz(),
            rhs.as_inner().xyzt() * self.xt(),
            rhs.as_inner().xyzt() * self.yz(),
            rhs.as_inner().xyzt() * self.yt(),
            rhs.as_inner().xyzt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Pseudoscalar<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().xyzt() * self.as_inner().xy(),
            rhs.as_inner().xyzt() * self.as_inner().xz(),
            rhs.as_inner().xyzt() * self.as_inner().xt(),
            rhs.as_inner().xyzt() * self.as_inner().yz(),
            rhs.as_inner().xyzt() * self.as_inner().yt(),
            rhs.as_inner().xyzt() * self.as_inner().zt(),
        )
    }
}
impl<T: Float> Antiwedge<Trivector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.xyz() * self.xt()) + -(rhs.xzt() * self.xy()) + rhs.xyt() * self.xz(),
            -(rhs.xyz() * self.yt()) + -(rhs.yzt() * self.xy()) + rhs.xyt() * self.yz(),
            -(rhs.xyz() * self.zt()) + -(rhs.yzt() * self.xz()) + rhs.xzt() * self.yz(),
            -(rhs.xyt() * self.zt()) + -(rhs.yzt() * self.xt()) + rhs.xzt() * self.yt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Trivector<T>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.xyz() * self.as_inner().xt())
                + -(rhs.xzt() * self.as_inner().xy())
                + rhs.xyt() * self.as_inner().xz(),
            -(rhs.xyz() * self.as_inner().yt())
                + -(rhs.yzt() * self.as_inner().xy())
                + rhs.xyt() * self.as_inner().yz(),
            -(rhs.xyz() * self.as_inner().zt())
                + -(rhs.yzt() * self.as_inner().xz())
                + rhs.xzt() * self.as_inner().yz(),
            -(rhs.xyt() * self.as_inner().zt())
                + -(rhs.yzt() * self.as_inner().xt())
                + rhs.xzt() * self.as_inner().yt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Trivector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().xyz() * self.xt())
                + -(rhs.as_inner().xzt() * self.xy())
                + rhs.as_inner().xyt() * self.xz(),
            -(rhs.as_inner().xyz() * self.yt())
                + -(rhs.as_inner().yzt() * self.xy())
                + rhs.as_inner().xyt() * self.yz(),
            -(rhs.as_inner().xyz() * self.zt())
                + -(rhs.as_inner().yzt() * self.xz())
                + rhs.as_inner().xzt() * self.yz(),
            -(rhs.as_inner().xyt() * self.zt())
                + -(rhs.as_inner().yzt() * self.xt())
                + rhs.as_inner().xzt() * self.yt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Trivector<T>>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().xyz() * self.as_inner().xt())
                + -(rhs.as_inner().xzt() * self.as_inner().xy())
                + rhs.as_inner().xyt() * self.as_inner().xz(),
            -(rhs.as_inner().xyz() * self.as_inner().yt())
                + -(rhs.as_inner().yzt() * self.as_inner().xy())
                + rhs.as_inner().xyt() * self.as_inner().yz(),
            -(rhs.as_inner().xyz() * self.as_inner().zt())
                + -(rhs.as_inner().yzt() * self.as_inner().xz())
                + rhs.as_inner().xzt() * self.as_inner().yz(),
            -(rhs.as_inner().xyt() * self.as_inner().zt())
                + -(rhs.as_inner().yzt() * self.as_inner().xt())
                + rhs.as_inner().xzt() * self.as_inner().yt(),
        )
    }
}
impl<T: Float> Antiwedge<Bivector<T>> for Pseudoscalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.xy() * self.xyzt(),
            rhs.xz() * self.xyzt(),
            rhs.xt() * self.xyzt(),
            rhs.yz() * self.xyzt(),
            rhs.yt() * self.xyzt(),
            rhs.zt() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Bivector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.xy() * self.as_inner().xyzt(),
            rhs.xz() * self.as_inner().xyzt(),
            rhs.xt() * self.as_inner().xyzt(),
            rhs.yz() * self.as_inner().xyzt(),
            rhs.yt() * self.as_inner().xyzt(),
            rhs.zt() * self.as_inner().xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Bivector<T>>> for Pseudoscalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().xy() * self.xyzt(),
            rhs.as_inner().xz() * self.xyzt(),
            rhs.as_inner().xt() * self.xyzt(),
            rhs.as_inner().yz() * self.xyzt(),
            rhs.as_inner().yt() * self.xyzt(),
            rhs.as_inner().zt() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Bivector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().xy() * self.as_inner().xyzt(),
            rhs.as_inner().xz() * self.as_inner().xyzt(),
            rhs.as_inner().xt() * self.as_inner().xyzt(),
            rhs.as_inner().yz() * self.as_inner().xyzt(),
            rhs.as_inner().yt() * self.as_inner().xyzt(),
            rhs.as_inner().zt() * self.as_inner().xyzt(),
        )
    }
}
impl<T: Float> Antiwedge<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.xyzt() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.xyzt() * self.as_inner().xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().xyzt() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().xyzt() * self.as_inner().xyzt())
    }
}
impl<T: Float> Antiwedge<Scalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Scalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.as_inner().xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Scalar<T>>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().s() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Scalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().s() * self.as_inner().xyzt())
    }
}
impl<T: Float> Antiwedge<Trivector<T>> for Pseudoscalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.xyz() * self.xyzt()),
            -(rhs.xyt() * self.xyzt()),
            -(rhs.xzt() * self.xyzt()),
            -(rhs.yzt() * self.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Trivector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.xyz() * self.as_inner().xyzt()),
            -(rhs.xyt() * self.as_inner().xyzt()),
            -(rhs.xzt() * self.as_inner().xyzt()),
            -(rhs.yzt() * self.as_inner().xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Trivector<T>>> for Pseudoscalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().xyz() * self.xyzt()),
            -(rhs.as_inner().xyt() * self.xyzt()),
            -(rhs.as_inner().xzt() * self.xyzt()),
            -(rhs.as_inner().yzt() * self.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Trivector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().xyz() * self.as_inner().xyzt()),
            -(rhs.as_inner().xyt() * self.as_inner().xyzt()),
            -(rhs.as_inner().xzt() * self.as_inner().xyzt()),
            -(rhs.as_inner().yzt() * self.as_inner().xyzt()),
        )
    }
}
impl<T: Float> Antiwedge<Vector<T>> for Pseudoscalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.x() * self.xyzt()),
            -(rhs.y() * self.xyzt()),
            -(rhs.z() * self.xyzt()),
            -(rhs.t() * self.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Vector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.x() * self.as_inner().xyzt()),
            -(rhs.y() * self.as_inner().xyzt()),
            -(rhs.z() * self.as_inner().xyzt()),
            -(rhs.t() * self.as_inner().xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Vector<T>>> for Pseudoscalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().x() * self.xyzt()),
            -(rhs.as_inner().y() * self.xyzt()),
            -(rhs.as_inner().z() * self.xyzt()),
            -(rhs.as_inner().t() * self.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Vector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().x() * self.as_inner().xyzt()),
            -(rhs.as_inner().y() * self.as_inner().xyzt()),
            -(rhs.as_inner().z() * self.as_inner().xyzt()),
            -(rhs.as_inner().t() * self.as_inner().xyzt()),
        )
    }
}
impl<T: Float> Antiwedge<Pseudoscalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.xyzt() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Pseudoscalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.xyzt() * self.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Pseudoscalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().xyzt() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Pseudoscalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().xyzt() * self.as_inner().s())
    }
}
impl<T: Float> Antiwedge<Bivector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.xt() * self.xyz()) + -(rhs.xy() * self.xzt()) + rhs.xz() * self.xyt(),
            -(rhs.xy() * self.yzt()) + -(rhs.yt() * self.xyz()) + rhs.yz() * self.xyt(),
            -(rhs.xz() * self.yzt()) + -(rhs.zt() * self.xyz()) + rhs.yz() * self.xzt(),
            -(rhs.xt() * self.yzt()) + -(rhs.zt() * self.xyt()) + rhs.yt() * self.xzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Bivector<T>> for Unit<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.xt() * self.as_inner().xyz())
                + -(rhs.xy() * self.as_inner().xzt())
                + rhs.xz() * self.as_inner().xyt(),
            -(rhs.xy() * self.as_inner().yzt())
                + -(rhs.yt() * self.as_inner().xyz())
                + rhs.yz() * self.as_inner().xyt(),
            -(rhs.xz() * self.as_inner().yzt())
                + -(rhs.zt() * self.as_inner().xyz())
                + rhs.yz() * self.as_inner().xzt(),
            -(rhs.xt() * self.as_inner().yzt())
                + -(rhs.zt() * self.as_inner().xyt())
                + rhs.yt() * self.as_inner().xzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Bivector<T>>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().xt() * self.xyz())
                + -(rhs.as_inner().xy() * self.xzt())
                + rhs.as_inner().xz() * self.xyt(),
            -(rhs.as_inner().xy() * self.yzt())
                + -(rhs.as_inner().yt() * self.xyz())
                + rhs.as_inner().yz() * self.xyt(),
            -(rhs.as_inner().xz() * self.yzt())
                + -(rhs.as_inner().zt() * self.xyz())
                + rhs.as_inner().yz() * self.xzt(),
            -(rhs.as_inner().xt() * self.yzt())
                + -(rhs.as_inner().zt() * self.xyt())
                + rhs.as_inner().yt() * self.xzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Bivector<T>>> for Unit<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().xt() * self.as_inner().xyz())
                + -(rhs.as_inner().xy() * self.as_inner().xzt())
                + rhs.as_inner().xz() * self.as_inner().xyt(),
            -(rhs.as_inner().xy() * self.as_inner().yzt())
                + -(rhs.as_inner().yt() * self.as_inner().xyz())
                + rhs.as_inner().yz() * self.as_inner().xyt(),
            -(rhs.as_inner().xz() * self.as_inner().yzt())
                + -(rhs.as_inner().zt() * self.as_inner().xyz())
                + rhs.as_inner().yz() * self.as_inner().xzt(),
            -(rhs.as_inner().xt() * self.as_inner().yzt())
                + -(rhs.as_inner().zt() * self.as_inner().xyt())
                + rhs.as_inner().yt() * self.as_inner().xzt(),
        )
    }
}
impl<T: Float> Antiwedge<Pseudoscalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Pseudoscalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.xyzt() * self.xyz()),
            -(rhs.xyzt() * self.xyt()),
            -(rhs.xyzt() * self.xzt()),
            -(rhs.xyzt() * self.yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Pseudoscalar<T>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Pseudoscalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.xyzt() * self.as_inner().xyz()),
            -(rhs.xyzt() * self.as_inner().xyt()),
            -(rhs.xyzt() * self.as_inner().xzt()),
            -(rhs.xyzt() * self.as_inner().yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Pseudoscalar<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().xyzt() * self.xyz()),
            -(rhs.as_inner().xyzt() * self.xyt()),
            -(rhs.as_inner().xyzt() * self.xzt()),
            -(rhs.as_inner().xyzt() * self.yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Pseudoscalar<T>>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().xyzt() * self.as_inner().xyz()),
            -(rhs.as_inner().xyzt() * self.as_inner().xyt()),
            -(rhs.as_inner().xyzt() * self.as_inner().xzt()),
            -(rhs.as_inner().xyzt() * self.as_inner().yzt()),
        )
    }
}
impl<T: Float> Antiwedge<Trivector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.xyz() * self.xyt()) + rhs.xyt() * self.xyz(),
            -(rhs.xyz() * self.xzt()) + rhs.xzt() * self.xyz(),
            -(rhs.xyt() * self.xzt()) + rhs.xzt() * self.xyt(),
            -(rhs.xyz() * self.yzt()) + rhs.yzt() * self.xyz(),
            -(rhs.xyt() * self.yzt()) + rhs.yzt() * self.xyt(),
            -(rhs.xzt() * self.yzt()) + rhs.yzt() * self.xzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Trivector<T>> for Unit<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.xyz() * self.as_inner().xyt()) + rhs.xyt() * self.as_inner().xyz(),
            -(rhs.xyz() * self.as_inner().xzt()) + rhs.xzt() * self.as_inner().xyz(),
            -(rhs.xyt() * self.as_inner().xzt()) + rhs.xzt() * self.as_inner().xyt(),
            -(rhs.xyz() * self.as_inner().yzt()) + rhs.yzt() * self.as_inner().xyz(),
            -(rhs.xyt() * self.as_inner().yzt()) + rhs.yzt() * self.as_inner().xyt(),
            -(rhs.xzt() * self.as_inner().yzt()) + rhs.yzt() * self.as_inner().xzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Trivector<T>>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Trivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().xyz() * self.xyt()) + rhs.as_inner().xyt() * self.xyz(),
            -(rhs.as_inner().xyz() * self.xzt()) + rhs.as_inner().xzt() * self.xyz(),
            -(rhs.as_inner().xyt() * self.xzt()) + rhs.as_inner().xzt() * self.xyt(),
            -(rhs.as_inner().xyz() * self.yzt()) + rhs.as_inner().yzt() * self.xyz(),
            -(rhs.as_inner().xyt() * self.yzt()) + rhs.as_inner().yzt() * self.xyt(),
            -(rhs.as_inner().xzt() * self.yzt()) + rhs.as_inner().yzt() * self.xzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Trivector<T>>> for Unit<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Trivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().xyz() * self.as_inner().xyt())
                + rhs.as_inner().xyt() * self.as_inner().xyz(),
            -(rhs.as_inner().xyz() * self.as_inner().xzt())
                + rhs.as_inner().xzt() * self.as_inner().xyz(),
            -(rhs.as_inner().xyt() * self.as_inner().xzt())
                + rhs.as_inner().xzt() * self.as_inner().xyt(),
            -(rhs.as_inner().xyz() * self.as_inner().yzt())
                + rhs.as_inner().yzt() * self.as_inner().xyz(),
            -(rhs.as_inner().xyt() * self.as_inner().yzt())
                + rhs.as_inner().yzt() * self.as_inner().xyt(),
            -(rhs.as_inner().xzt() * self.as_inner().yzt())
                + rhs.as_inner().yzt() * self.as_inner().xzt(),
        )
    }
}
impl<T: Float> Antiwedge<Vector<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.x() * self.yzt())
                + -(rhs.z() * self.xyt())
                + rhs.t() * self.xyz()
                + rhs.y() * self.xzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Vector<T>> for Unit<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.x() * self.as_inner().yzt())
                + -(rhs.z() * self.as_inner().xyt())
                + rhs.t() * self.as_inner().xyz()
                + rhs.y() * self.as_inner().xzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Vector<T>>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().x() * self.yzt())
                + -(rhs.as_inner().z() * self.xyt())
                + rhs.as_inner().t() * self.xyz()
                + rhs.as_inner().y() * self.xzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Vector<T>>> for Unit<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().x() * self.as_inner().yzt())
                + -(rhs.as_inner().z() * self.as_inner().xyt())
                + rhs.as_inner().t() * self.as_inner().xyz()
                + rhs.as_inner().y() * self.as_inner().xzt(),
        )
    }
}
impl<T: Float> Antiwedge<Pseudoscalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Pseudoscalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.xyzt() * self.x()),
            -(rhs.xyzt() * self.y()),
            -(rhs.xyzt() * self.z()),
            -(rhs.xyzt() * self.t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Pseudoscalar<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Pseudoscalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.xyzt() * self.as_inner().x()),
            -(rhs.xyzt() * self.as_inner().y()),
            -(rhs.xyzt() * self.as_inner().z()),
            -(rhs.xyzt() * self.as_inner().t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Pseudoscalar<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().xyzt() * self.x()),
            -(rhs.as_inner().xyzt() * self.y()),
            -(rhs.as_inner().xyzt() * self.z()),
            -(rhs.as_inner().xyzt() * self.t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Pseudoscalar<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().xyzt() * self.as_inner().x()),
            -(rhs.as_inner().xyzt() * self.as_inner().y()),
            -(rhs.as_inner().xyzt() * self.as_inner().z()),
            -(rhs.as_inner().xyzt() * self.as_inner().t()),
        )
    }
}
impl<T: Float> Antiwedge<Trivector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xyz() * self.t())
                + -(rhs.xzt() * self.y())
                + rhs.xyt() * self.z()
                + rhs.yzt() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Trivector<T>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Trivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xyz() * self.as_inner().t())
                + -(rhs.xzt() * self.as_inner().y())
                + rhs.xyt() * self.as_inner().z()
                + rhs.yzt() * self.as_inner().x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Trivector<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Trivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xyz() * self.t())
                + -(rhs.as_inner().xzt() * self.y())
                + rhs.as_inner().xyt() * self.z()
                + rhs.as_inner().yzt() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Trivector<T>>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Trivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xyz() * self.as_inner().t())
                + -(rhs.as_inner().xzt() * self.as_inner().y())
                + rhs.as_inner().xyt() * self.as_inner().z()
                + rhs.as_inner().yzt() * self.as_inner().x(),
        )
    }
}
impl<T: Float> LeftContract<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xy() * self.xy())
                + -(rhs.xz() * self.xz())
                + -(rhs.yz() * self.yz())
                + rhs.xt() * self.xt()
                + rhs.yt() * self.yt()
                + rhs.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xy() * self.as_inner().xy())
                + -(rhs.xz() * self.as_inner().xz())
                + -(rhs.yz() * self.as_inner().yz())
                + rhs.xt() * self.as_inner().xt()
                + rhs.yt() * self.as_inner().yt()
                + rhs.zt() * self.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xy() * self.xy())
                + -(rhs.as_inner().xz() * self.xz())
                + -(rhs.as_inner().yz() * self.yz())
                + rhs.as_inner().xt() * self.xt()
                + rhs.as_inner().yt() * self.yt()
                + rhs.as_inner().zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xy() * self.as_inner().xy())
                + -(rhs.as_inner().xz() * self.as_inner().xz())
                + -(rhs.as_inner().yz() * self.as_inner().yz())
                + rhs.as_inner().xt() * self.as_inner().xt()
                + rhs.as_inner().yt() * self.as_inner().yt()
                + rhs.as_inner().zt() * self.as_inner().zt(),
        )
    }
}
impl<T: Float> LeftContract<Pseudoscalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Pseudoscalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.xyzt() * self.zt(),
            -(rhs.xyzt() * self.yt()),
            -(rhs.xyzt() * self.yz()),
            rhs.xyzt() * self.xt(),
            rhs.xyzt() * self.xz(),
            -(rhs.xyzt() * self.xy()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Pseudoscalar<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Pseudoscalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.xyzt() * self.as_inner().zt(),
            -(rhs.xyzt() * self.as_inner().yt()),
            -(rhs.xyzt() * self.as_inner().yz()),
            rhs.xyzt() * self.as_inner().xt(),
            rhs.xyzt() * self.as_inner().xz(),
            -(rhs.xyzt() * self.as_inner().xy()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Pseudoscalar<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().xyzt() * self.zt(),
            -(rhs.as_inner().xyzt() * self.yt()),
            -(rhs.as_inner().xyzt() * self.yz()),
            rhs.as_inner().xyzt() * self.xt(),
            rhs.as_inner().xyzt() * self.xz(),
            -(rhs.as_inner().xyzt() * self.xy()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Pseudoscalar<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().xyzt() * self.as_inner().zt(),
            -(rhs.as_inner().xyzt() * self.as_inner().yt()),
            -(rhs.as_inner().xyzt() * self.as_inner().yz()),
            rhs.as_inner().xyzt() * self.as_inner().xt(),
            rhs.as_inner().xyzt() * self.as_inner().xz(),
            -(rhs.as_inner().xyzt() * self.as_inner().xy()),
        )
    }
}
impl<T: Float> LeftContract<Trivector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.xyz() * self.yz()) + rhs.xyt() * self.yt() + rhs.xzt() * self.zt(),
            -(rhs.xyt() * self.xt()) + rhs.xyz() * self.xz() + rhs.yzt() * self.zt(),
            -(rhs.xyz() * self.xy()) + -(rhs.xzt() * self.xt()) + -(rhs.yzt() * self.yt()),
            -(rhs.xyt() * self.xy()) + -(rhs.xzt() * self.xz()) + -(rhs.yzt() * self.yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Trivector<T>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.xyz() * self.as_inner().yz())
                + rhs.xyt() * self.as_inner().yt()
                + rhs.xzt() * self.as_inner().zt(),
            -(rhs.xyt() * self.as_inner().xt())
                + rhs.xyz() * self.as_inner().xz()
                + rhs.yzt() * self.as_inner().zt(),
            -(rhs.xyz() * self.as_inner().xy())
                + -(rhs.xzt() * self.as_inner().xt())
                + -(rhs.yzt() * self.as_inner().yt()),
            -(rhs.xyt() * self.as_inner().xy())
                + -(rhs.xzt() * self.as_inner().xz())
                + -(rhs.yzt() * self.as_inner().yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Trivector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().xyz() * self.yz())
                + rhs.as_inner().xyt() * self.yt()
                + rhs.as_inner().xzt() * self.zt(),
            -(rhs.as_inner().xyt() * self.xt())
                + rhs.as_inner().xyz() * self.xz()
                + rhs.as_inner().yzt() * self.zt(),
            -(rhs.as_inner().xyz() * self.xy())
                + -(rhs.as_inner().xzt() * self.xt())
                + -(rhs.as_inner().yzt() * self.yt()),
            -(rhs.as_inner().xyt() * self.xy())
                + -(rhs.as_inner().xzt() * self.xz())
                + -(rhs.as_inner().yzt() * self.yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Trivector<T>>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().xyz() * self.as_inner().yz())
                + rhs.as_inner().xyt() * self.as_inner().yt()
                + rhs.as_inner().xzt() * self.as_inner().zt(),
            -(rhs.as_inner().xyt() * self.as_inner().xt())
                + rhs.as_inner().xyz() * self.as_inner().xz()
                + rhs.as_inner().yzt() * self.as_inner().zt(),
            -(rhs.as_inner().xyz() * self.as_inner().xy())
                + -(rhs.as_inner().xzt() * self.as_inner().xt())
                + -(rhs.as_inner().yzt() * self.as_inner().yt()),
            -(rhs.as_inner().xyt() * self.as_inner().xy())
                + -(rhs.as_inner().xzt() * self.as_inner().xz())
                + -(rhs.as_inner().yzt() * self.as_inner().yz()),
        )
    }
}
impl<T: Float> LeftContract<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.xyzt() * self.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.xyzt() * self.as_inner().xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().xyzt() * self.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().xyzt() * self.as_inner().xyzt()))
    }
}
impl<T: Float> LeftContract<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.xy() * self.s(),
            rhs.xz() * self.s(),
            rhs.xt() * self.s(),
            rhs.yz() * self.s(),
            rhs.yt() * self.s(),
            rhs.zt() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Bivector<T>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.xy() * self.as_inner().s(),
            rhs.xz() * self.as_inner().s(),
            rhs.xt() * self.as_inner().s(),
            rhs.yz() * self.as_inner().s(),
            rhs.yt() * self.as_inner().s(),
            rhs.zt() * self.as_inner().s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Bivector<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().xy() * self.s(),
            rhs.as_inner().xz() * self.s(),
            rhs.as_inner().xt() * self.s(),
            rhs.as_inner().yz() * self.s(),
            rhs.as_inner().yt() * self.s(),
            rhs.as_inner().zt() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Bivector<T>>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().xy() * self.as_inner().s(),
            rhs.as_inner().xz() * self.as_inner().s(),
            rhs.as_inner().xt() * self.as_inner().s(),
            rhs.as_inner().yz() * self.as_inner().s(),
            rhs.as_inner().yt() * self.as_inner().s(),
            rhs.as_inner().zt() * self.as_inner().s(),
        )
    }
}
impl<T: Float> LeftContract<Pseudoscalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.xyzt() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Pseudoscalar<T>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.xyzt() * self.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Pseudoscalar<T>>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().xyzt() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Pseudoscalar<T>>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().xyzt() * self.as_inner().s())
    }
}
impl<T: Float> LeftContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().s() * self.as_inner().s())
    }
}
impl<T: Float> LeftContract<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.xyz() * self.s(),
            rhs.xyt() * self.s(),
            rhs.xzt() * self.s(),
            rhs.yzt() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Trivector<T>> for Unit<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.xyz() * self.as_inner().s(),
            rhs.xyt() * self.as_inner().s(),
            rhs.xzt() * self.as_inner().s(),
            rhs.yzt() * self.as_inner().s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Trivector<T>>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().xyz() * self.s(),
            rhs.as_inner().xyt() * self.s(),
            rhs.as_inner().xzt() * self.s(),
            rhs.as_inner().yzt() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Trivector<T>>> for Unit<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().xyz() * self.as_inner().s(),
            rhs.as_inner().xyt() * self.as_inner().s(),
            rhs.as_inner().xzt() * self.as_inner().s(),
            rhs.as_inner().yzt() * self.as_inner().s(),
        )
    }
}
impl<T: Float> LeftContract<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.x() * self.s(),
            rhs.y() * self.s(),
            rhs.z() * self.s(),
            rhs.t() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Vector<T>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.x() * self.as_inner().s(),
            rhs.y() * self.as_inner().s(),
            rhs.z() * self.as_inner().s(),
            rhs.t() * self.as_inner().s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Vector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().x() * self.s(),
            rhs.as_inner().y() * self.s(),
            rhs.as_inner().z() * self.s(),
            rhs.as_inner().t() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Vector<T>>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().x() * self.as_inner().s(),
            rhs.as_inner().y() * self.as_inner().s(),
            rhs.as_inner().z() * self.as_inner().s(),
            rhs.as_inner().t() * self.as_inner().s(),
        )
    }
}
impl<T: Float> LeftContract<Pseudoscalar<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Pseudoscalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.xyzt() * self.yzt()),
            rhs.xyzt() * self.xzt(),
            -(rhs.xyzt() * self.xyt()),
            -(rhs.xyzt() * self.xyz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Pseudoscalar<T>> for Unit<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Pseudoscalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.xyzt() * self.as_inner().yzt()),
            rhs.xyzt() * self.as_inner().xzt(),
            -(rhs.xyzt() * self.as_inner().xyt()),
            -(rhs.xyzt() * self.as_inner().xyz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Pseudoscalar<T>>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().xyzt() * self.yzt()),
            rhs.as_inner().xyzt() * self.xzt(),
            -(rhs.as_inner().xyzt() * self.xyt()),
            -(rhs.as_inner().xyzt() * self.xyz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Pseudoscalar<T>>> for Unit<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().xyzt() * self.as_inner().yzt()),
            rhs.as_inner().xyzt() * self.as_inner().xzt(),
            -(rhs.as_inner().xyzt() * self.as_inner().xyt()),
            -(rhs.as_inner().xyzt() * self.as_inner().xyz()),
        )
    }
}
impl<T: Float> LeftContract<Trivector<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Trivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xyz() * self.xyz())
                + rhs.xyt() * self.xyt()
                + rhs.xzt() * self.xzt()
                + rhs.yzt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Trivector<T>> for Unit<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Trivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xyz() * self.as_inner().xyz())
                + rhs.xyt() * self.as_inner().xyt()
                + rhs.xzt() * self.as_inner().xzt()
                + rhs.yzt() * self.as_inner().yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Trivector<T>>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Trivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xyz() * self.xyz())
                + rhs.as_inner().xyt() * self.xyt()
                + rhs.as_inner().xzt() * self.xzt()
                + rhs.as_inner().yzt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Trivector<T>>> for Unit<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Trivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xyz() * self.as_inner().xyz())
                + rhs.as_inner().xyt() * self.as_inner().xyt()
                + rhs.as_inner().xzt() * self.as_inner().xzt()
                + rhs.as_inner().yzt() * self.as_inner().yzt(),
        )
    }
}
impl<T: Float> LeftContract<Bivector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.xy() * self.y()) + -(rhs.xz() * self.z()) + rhs.xt() * self.t(),
            -(rhs.yz() * self.z()) + rhs.xy() * self.x() + rhs.yt() * self.t(),
            rhs.xz() * self.x() + rhs.yz() * self.y() + rhs.zt() * self.t(),
            rhs.xt() * self.x() + rhs.yt() * self.y() + rhs.zt() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Bivector<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.xy() * self.as_inner().y())
                + -(rhs.xz() * self.as_inner().z())
                + rhs.xt() * self.as_inner().t(),
            -(rhs.yz() * self.as_inner().z())
                + rhs.xy() * self.as_inner().x()
                + rhs.yt() * self.as_inner().t(),
            rhs.xz() * self.as_inner().x()
                + rhs.yz() * self.as_inner().y()
                + rhs.zt() * self.as_inner().t(),
            rhs.xt() * self.as_inner().x()
                + rhs.yt() * self.as_inner().y()
                + rhs.zt() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Bivector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().xy() * self.y())
                + -(rhs.as_inner().xz() * self.z())
                + rhs.as_inner().xt() * self.t(),
            -(rhs.as_inner().yz() * self.z())
                + rhs.as_inner().xy() * self.x()
                + rhs.as_inner().yt() * self.t(),
            rhs.as_inner().xz() * self.x()
                + rhs.as_inner().yz() * self.y()
                + rhs.as_inner().zt() * self.t(),
            rhs.as_inner().xt() * self.x()
                + rhs.as_inner().yt() * self.y()
                + rhs.as_inner().zt() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Bivector<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().xy() * self.as_inner().y())
                + -(rhs.as_inner().xz() * self.as_inner().z())
                + rhs.as_inner().xt() * self.as_inner().t(),
            -(rhs.as_inner().yz() * self.as_inner().z())
                + rhs.as_inner().xy() * self.as_inner().x()
                + rhs.as_inner().yt() * self.as_inner().t(),
            rhs.as_inner().xz() * self.as_inner().x()
                + rhs.as_inner().yz() * self.as_inner().y()
                + rhs.as_inner().zt() * self.as_inner().t(),
            rhs.as_inner().xt() * self.as_inner().x()
                + rhs.as_inner().yt() * self.as_inner().y()
                + rhs.as_inner().zt() * self.as_inner().z(),
        )
    }
}
impl<T: Float> LeftContract<Pseudoscalar<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Pseudoscalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.xyzt() * self.t(),
            rhs.xyzt() * self.z(),
            -(rhs.xyzt() * self.y()),
            rhs.xyzt() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Pseudoscalar<T>> for Unit<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Pseudoscalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.xyzt() * self.as_inner().t(),
            rhs.xyzt() * self.as_inner().z(),
            -(rhs.xyzt() * self.as_inner().y()),
            rhs.xyzt() * self.as_inner().x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Pseudoscalar<T>>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().xyzt() * self.t(),
            rhs.as_inner().xyzt() * self.z(),
            -(rhs.as_inner().xyzt() * self.y()),
            rhs.as_inner().xyzt() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Pseudoscalar<T>>> for Unit<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().xyzt() * self.as_inner().t(),
            rhs.as_inner().xyzt() * self.as_inner().z(),
            -(rhs.as_inner().xyzt() * self.as_inner().y()),
            rhs.as_inner().xyzt() * self.as_inner().x(),
        )
    }
}
impl<T: Float> LeftContract<Trivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Trivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.xyt() * self.t()) + rhs.xyz() * self.z(),
            -(rhs.xyz() * self.y()) + -(rhs.xzt() * self.t()),
            -(rhs.xyt() * self.y()) + -(rhs.xzt() * self.z()),
            -(rhs.yzt() * self.t()) + rhs.xyz() * self.x(),
            -(rhs.yzt() * self.z()) + rhs.xyt() * self.x(),
            rhs.xzt() * self.x() + rhs.yzt() * self.y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Trivector<T>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Trivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.xyt() * self.as_inner().t()) + rhs.xyz() * self.as_inner().z(),
            -(rhs.xyz() * self.as_inner().y()) + -(rhs.xzt() * self.as_inner().t()),
            -(rhs.xyt() * self.as_inner().y()) + -(rhs.xzt() * self.as_inner().z()),
            -(rhs.yzt() * self.as_inner().t()) + rhs.xyz() * self.as_inner().x(),
            -(rhs.yzt() * self.as_inner().z()) + rhs.xyt() * self.as_inner().x(),
            rhs.xzt() * self.as_inner().x() + rhs.yzt() * self.as_inner().y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Trivector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Trivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().xyt() * self.t()) + rhs.as_inner().xyz() * self.z(),
            -(rhs.as_inner().xyz() * self.y()) + -(rhs.as_inner().xzt() * self.t()),
            -(rhs.as_inner().xyt() * self.y()) + -(rhs.as_inner().xzt() * self.z()),
            -(rhs.as_inner().yzt() * self.t()) + rhs.as_inner().xyz() * self.x(),
            -(rhs.as_inner().yzt() * self.z()) + rhs.as_inner().xyt() * self.x(),
            rhs.as_inner().xzt() * self.x() + rhs.as_inner().yzt() * self.y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Trivector<T>>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Trivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().xyt() * self.as_inner().t())
                + rhs.as_inner().xyz() * self.as_inner().z(),
            -(rhs.as_inner().xyz() * self.as_inner().y())
                + -(rhs.as_inner().xzt() * self.as_inner().t()),
            -(rhs.as_inner().xyt() * self.as_inner().y())
                + -(rhs.as_inner().xzt() * self.as_inner().z()),
            -(rhs.as_inner().yzt() * self.as_inner().t())
                + rhs.as_inner().xyz() * self.as_inner().x(),
            -(rhs.as_inner().yzt() * self.as_inner().z())
                + rhs.as_inner().xyt() * self.as_inner().x(),
            rhs.as_inner().xzt() * self.as_inner().x() + rhs.as_inner().yzt() * self.as_inner().y(),
        )
    }
}
impl<T: Float> LeftContract<Vector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.t() * self.t()) + rhs.x() * self.x() + rhs.y() * self.y() + rhs.z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Vector<T>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.t() * self.as_inner().t())
                + rhs.x() * self.as_inner().x()
                + rhs.y() * self.as_inner().y()
                + rhs.z() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Vector<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().t() * self.t())
                + rhs.as_inner().x() * self.x()
                + rhs.as_inner().y() * self.y()
                + rhs.as_inner().z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().t() * self.as_inner().t())
                + rhs.as_inner().x() * self.as_inner().x()
                + rhs.as_inner().y() * self.as_inner().y()
                + rhs.as_inner().z() * self.as_inner().z(),
        )
    }
}
impl<T: Float> RightContract<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xy() * self.xy())
                + -(rhs.xz() * self.xz())
                + -(rhs.yz() * self.yz())
                + rhs.xt() * self.xt()
                + rhs.yt() * self.yt()
                + rhs.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xy() * self.as_inner().xy())
                + -(rhs.xz() * self.as_inner().xz())
                + -(rhs.yz() * self.as_inner().yz())
                + rhs.xt() * self.as_inner().xt()
                + rhs.yt() * self.as_inner().yt()
                + rhs.zt() * self.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xy() * self.xy())
                + -(rhs.as_inner().xz() * self.xz())
                + -(rhs.as_inner().yz() * self.yz())
                + rhs.as_inner().xt() * self.xt()
                + rhs.as_inner().yt() * self.yt()
                + rhs.as_inner().zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xy() * self.as_inner().xy())
                + -(rhs.as_inner().xz() * self.as_inner().xz())
                + -(rhs.as_inner().yz() * self.as_inner().yz())
                + rhs.as_inner().xt() * self.as_inner().xt()
                + rhs.as_inner().yt() * self.as_inner().yt()
                + rhs.as_inner().zt() * self.as_inner().zt(),
        )
    }
}
impl<T: Float> RightContract<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.s() * self.xy(),
            rhs.s() * self.xz(),
            rhs.s() * self.xt(),
            rhs.s() * self.yz(),
            rhs.s() * self.yt(),
            rhs.s() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.s() * self.as_inner().xy(),
            rhs.s() * self.as_inner().xz(),
            rhs.s() * self.as_inner().xt(),
            rhs.s() * self.as_inner().yz(),
            rhs.s() * self.as_inner().yt(),
            rhs.s() * self.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().s() * self.xy(),
            rhs.as_inner().s() * self.xz(),
            rhs.as_inner().s() * self.xt(),
            rhs.as_inner().s() * self.yz(),
            rhs.as_inner().s() * self.yt(),
            rhs.as_inner().s() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().s() * self.as_inner().xy(),
            rhs.as_inner().s() * self.as_inner().xz(),
            rhs.as_inner().s() * self.as_inner().xt(),
            rhs.as_inner().s() * self.as_inner().yz(),
            rhs.as_inner().s() * self.as_inner().yt(),
            rhs.as_inner().s() * self.as_inner().zt(),
        )
    }
}
impl<T: Float> RightContract<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.t() * self.xt()) + rhs.y() * self.xy() + rhs.z() * self.xz(),
            -(rhs.t() * self.yt()) + -(rhs.x() * self.xy()) + rhs.z() * self.yz(),
            -(rhs.t() * self.zt()) + -(rhs.x() * self.xz()) + -(rhs.y() * self.yz()),
            -(rhs.x() * self.xt()) + -(rhs.y() * self.yt()) + -(rhs.z() * self.zt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Vector<T>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.t() * self.as_inner().xt())
                + rhs.y() * self.as_inner().xy()
                + rhs.z() * self.as_inner().xz(),
            -(rhs.t() * self.as_inner().yt())
                + -(rhs.x() * self.as_inner().xy())
                + rhs.z() * self.as_inner().yz(),
            -(rhs.t() * self.as_inner().zt())
                + -(rhs.x() * self.as_inner().xz())
                + -(rhs.y() * self.as_inner().yz()),
            -(rhs.x() * self.as_inner().xt())
                + -(rhs.y() * self.as_inner().yt())
                + -(rhs.z() * self.as_inner().zt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Vector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().t() * self.xt())
                + rhs.as_inner().y() * self.xy()
                + rhs.as_inner().z() * self.xz(),
            -(rhs.as_inner().t() * self.yt())
                + -(rhs.as_inner().x() * self.xy())
                + rhs.as_inner().z() * self.yz(),
            -(rhs.as_inner().t() * self.zt())
                + -(rhs.as_inner().x() * self.xz())
                + -(rhs.as_inner().y() * self.yz()),
            -(rhs.as_inner().x() * self.xt())
                + -(rhs.as_inner().y() * self.yt())
                + -(rhs.as_inner().z() * self.zt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Vector<T>>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().t() * self.as_inner().xt())
                + rhs.as_inner().y() * self.as_inner().xy()
                + rhs.as_inner().z() * self.as_inner().xz(),
            -(rhs.as_inner().t() * self.as_inner().yt())
                + -(rhs.as_inner().x() * self.as_inner().xy())
                + rhs.as_inner().z() * self.as_inner().yz(),
            -(rhs.as_inner().t() * self.as_inner().zt())
                + -(rhs.as_inner().x() * self.as_inner().xz())
                + -(rhs.as_inner().y() * self.as_inner().yz()),
            -(rhs.as_inner().x() * self.as_inner().xt())
                + -(rhs.as_inner().y() * self.as_inner().yt())
                + -(rhs.as_inner().z() * self.as_inner().zt()),
        )
    }
}
impl<T: Float> RightContract<Bivector<T>> for Pseudoscalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.zt() * self.xyzt(),
            -(rhs.yt() * self.xyzt()),
            -(rhs.yz() * self.xyzt()),
            rhs.xt() * self.xyzt(),
            rhs.xz() * self.xyzt(),
            -(rhs.xy() * self.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Bivector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.zt() * self.as_inner().xyzt(),
            -(rhs.yt() * self.as_inner().xyzt()),
            -(rhs.yz() * self.as_inner().xyzt()),
            rhs.xt() * self.as_inner().xyzt(),
            rhs.xz() * self.as_inner().xyzt(),
            -(rhs.xy() * self.as_inner().xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Bivector<T>>> for Pseudoscalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().zt() * self.xyzt(),
            -(rhs.as_inner().yt() * self.xyzt()),
            -(rhs.as_inner().yz() * self.xyzt()),
            rhs.as_inner().xt() * self.xyzt(),
            rhs.as_inner().xz() * self.xyzt(),
            -(rhs.as_inner().xy() * self.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Bivector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().zt() * self.as_inner().xyzt(),
            -(rhs.as_inner().yt() * self.as_inner().xyzt()),
            -(rhs.as_inner().yz() * self.as_inner().xyzt()),
            rhs.as_inner().xt() * self.as_inner().xyzt(),
            rhs.as_inner().xz() * self.as_inner().xyzt(),
            -(rhs.as_inner().xy() * self.as_inner().xyzt()),
        )
    }
}
impl<T: Float> RightContract<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.xyzt() * self.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.xyzt() * self.as_inner().xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().xyzt() * self.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().xyzt() * self.as_inner().xyzt()))
    }
}
impl<T: Float> RightContract<Scalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.s() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.s() * self.as_inner().xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().s() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().s() * self.as_inner().xyzt())
    }
}
impl<T: Float> RightContract<Trivector<T>> for Pseudoscalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.yzt() * self.xyzt(),
            -(rhs.xzt() * self.xyzt()),
            rhs.xyt() * self.xyzt(),
            rhs.xyz() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Trivector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.yzt() * self.as_inner().xyzt(),
            -(rhs.xzt() * self.as_inner().xyzt()),
            rhs.xyt() * self.as_inner().xyzt(),
            rhs.xyz() * self.as_inner().xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Trivector<T>>> for Pseudoscalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().yzt() * self.xyzt(),
            -(rhs.as_inner().xzt() * self.xyzt()),
            rhs.as_inner().xyt() * self.xyzt(),
            rhs.as_inner().xyz() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Trivector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().yzt() * self.as_inner().xyzt(),
            -(rhs.as_inner().xzt() * self.as_inner().xyzt()),
            rhs.as_inner().xyt() * self.as_inner().xyzt(),
            rhs.as_inner().xyz() * self.as_inner().xyzt(),
        )
    }
}
impl<T: Float> RightContract<Vector<T>> for Pseudoscalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.t() * self.xyzt()),
            -(rhs.z() * self.xyzt()),
            rhs.y() * self.xyzt(),
            -(rhs.x() * self.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Vector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.t() * self.as_inner().xyzt()),
            -(rhs.z() * self.as_inner().xyzt()),
            rhs.y() * self.as_inner().xyzt(),
            -(rhs.x() * self.as_inner().xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Vector<T>>> for Pseudoscalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Vector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().t() * self.xyzt()),
            -(rhs.as_inner().z() * self.xyzt()),
            rhs.as_inner().y() * self.xyzt(),
            -(rhs.as_inner().x() * self.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Vector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Vector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().t() * self.as_inner().xyzt()),
            -(rhs.as_inner().z() * self.as_inner().xyzt()),
            rhs.as_inner().y() * self.as_inner().xyzt(),
            -(rhs.as_inner().x() * self.as_inner().xyzt()),
        )
    }
}
impl<T: Float> RightContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().s() * self.as_inner().s())
    }
}
impl<T: Float> RightContract<Bivector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.yz() * self.xyz()) + rhs.yt() * self.xyt() + rhs.zt() * self.xzt(),
            -(rhs.xt() * self.xyt()) + rhs.xz() * self.xyz() + rhs.zt() * self.yzt(),
            -(rhs.xt() * self.xzt()) + -(rhs.xy() * self.xyz()) + -(rhs.yt() * self.yzt()),
            -(rhs.xy() * self.xyt()) + -(rhs.xz() * self.xzt()) + -(rhs.yz() * self.yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Bivector<T>> for Unit<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.yz() * self.as_inner().xyz())
                + rhs.yt() * self.as_inner().xyt()
                + rhs.zt() * self.as_inner().xzt(),
            -(rhs.xt() * self.as_inner().xyt())
                + rhs.xz() * self.as_inner().xyz()
                + rhs.zt() * self.as_inner().yzt(),
            -(rhs.xt() * self.as_inner().xzt())
                + -(rhs.xy() * self.as_inner().xyz())
                + -(rhs.yt() * self.as_inner().yzt()),
            -(rhs.xy() * self.as_inner().xyt())
                + -(rhs.xz() * self.as_inner().xzt())
                + -(rhs.yz() * self.as_inner().yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Bivector<T>>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().yz() * self.xyz())
                + rhs.as_inner().yt() * self.xyt()
                + rhs.as_inner().zt() * self.xzt(),
            -(rhs.as_inner().xt() * self.xyt())
                + rhs.as_inner().xz() * self.xyz()
                + rhs.as_inner().zt() * self.yzt(),
            -(rhs.as_inner().xt() * self.xzt())
                + -(rhs.as_inner().xy() * self.xyz())
                + -(rhs.as_inner().yt() * self.yzt()),
            -(rhs.as_inner().xy() * self.xyt())
                + -(rhs.as_inner().xz() * self.xzt())
                + -(rhs.as_inner().yz() * self.yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Bivector<T>>> for Unit<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().yz() * self.as_inner().xyz())
                + rhs.as_inner().yt() * self.as_inner().xyt()
                + rhs.as_inner().zt() * self.as_inner().xzt(),
            -(rhs.as_inner().xt() * self.as_inner().xyt())
                + rhs.as_inner().xz() * self.as_inner().xyz()
                + rhs.as_inner().zt() * self.as_inner().yzt(),
            -(rhs.as_inner().xt() * self.as_inner().xzt())
                + -(rhs.as_inner().xy() * self.as_inner().xyz())
                + -(rhs.as_inner().yt() * self.as_inner().yzt()),
            -(rhs.as_inner().xy() * self.as_inner().xyt())
                + -(rhs.as_inner().xz() * self.as_inner().xzt())
                + -(rhs.as_inner().yz() * self.as_inner().yzt()),
        )
    }
}
impl<T: Float> RightContract<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.s() * self.xyz(),
            rhs.s() * self.xyt(),
            rhs.s() * self.xzt(),
            rhs.s() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.s() * self.as_inner().xyz(),
            rhs.s() * self.as_inner().xyt(),
            rhs.s() * self.as_inner().xzt(),
            rhs.s() * self.as_inner().yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().s() * self.xyz(),
            rhs.as_inner().s() * self.xyt(),
            rhs.as_inner().s() * self.xzt(),
            rhs.as_inner().s() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().s() * self.as_inner().xyz(),
            rhs.as_inner().s() * self.as_inner().xyt(),
            rhs.as_inner().s() * self.as_inner().xzt(),
            rhs.as_inner().s() * self.as_inner().yzt(),
        )
    }
}
impl<T: Float> RightContract<Trivector<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Trivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xyz() * self.xyz())
                + rhs.xyt() * self.xyt()
                + rhs.xzt() * self.xzt()
                + rhs.yzt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Trivector<T>> for Unit<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Trivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xyz() * self.as_inner().xyz())
                + rhs.xyt() * self.as_inner().xyt()
                + rhs.xzt() * self.as_inner().xzt()
                + rhs.yzt() * self.as_inner().yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Trivector<T>>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Trivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xyz() * self.xyz())
                + rhs.as_inner().xyt() * self.xyt()
                + rhs.as_inner().xzt() * self.xzt()
                + rhs.as_inner().yzt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Trivector<T>>> for Unit<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Trivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xyz() * self.as_inner().xyz())
                + rhs.as_inner().xyt() * self.as_inner().xyt()
                + rhs.as_inner().xzt() * self.as_inner().xzt()
                + rhs.as_inner().yzt() * self.as_inner().yzt(),
        )
    }
}
impl<T: Float> RightContract<Vector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.t() * self.xyt()) + rhs.z() * self.xyz(),
            -(rhs.t() * self.xzt()) + -(rhs.y() * self.xyz()),
            -(rhs.y() * self.xyt()) + -(rhs.z() * self.xzt()),
            -(rhs.t() * self.yzt()) + rhs.x() * self.xyz(),
            -(rhs.z() * self.yzt()) + rhs.x() * self.xyt(),
            rhs.x() * self.xzt() + rhs.y() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Vector<T>> for Unit<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.t() * self.as_inner().xyt()) + rhs.z() * self.as_inner().xyz(),
            -(rhs.t() * self.as_inner().xzt()) + -(rhs.y() * self.as_inner().xyz()),
            -(rhs.y() * self.as_inner().xyt()) + -(rhs.z() * self.as_inner().xzt()),
            -(rhs.t() * self.as_inner().yzt()) + rhs.x() * self.as_inner().xyz(),
            -(rhs.z() * self.as_inner().yzt()) + rhs.x() * self.as_inner().xyt(),
            rhs.x() * self.as_inner().xzt() + rhs.y() * self.as_inner().yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Vector<T>>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().t() * self.xyt()) + rhs.as_inner().z() * self.xyz(),
            -(rhs.as_inner().t() * self.xzt()) + -(rhs.as_inner().y() * self.xyz()),
            -(rhs.as_inner().y() * self.xyt()) + -(rhs.as_inner().z() * self.xzt()),
            -(rhs.as_inner().t() * self.yzt()) + rhs.as_inner().x() * self.xyz(),
            -(rhs.as_inner().z() * self.yzt()) + rhs.as_inner().x() * self.xyt(),
            rhs.as_inner().x() * self.xzt() + rhs.as_inner().y() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Vector<T>>> for Unit<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().t() * self.as_inner().xyt())
                + rhs.as_inner().z() * self.as_inner().xyz(),
            -(rhs.as_inner().t() * self.as_inner().xzt())
                + -(rhs.as_inner().y() * self.as_inner().xyz()),
            -(rhs.as_inner().y() * self.as_inner().xyt())
                + -(rhs.as_inner().z() * self.as_inner().xzt()),
            -(rhs.as_inner().t() * self.as_inner().yzt())
                + rhs.as_inner().x() * self.as_inner().xyz(),
            -(rhs.as_inner().z() * self.as_inner().yzt())
                + rhs.as_inner().x() * self.as_inner().xyt(),
            rhs.as_inner().x() * self.as_inner().xzt() + rhs.as_inner().y() * self.as_inner().yzt(),
        )
    }
}
impl<T: Float> RightContract<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.s() * self.x(),
            rhs.s() * self.y(),
            rhs.s() * self.z(),
            rhs.s() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.s() * self.as_inner().x(),
            rhs.s() * self.as_inner().y(),
            rhs.s() * self.as_inner().z(),
            rhs.s() * self.as_inner().t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().s() * self.x(),
            rhs.as_inner().s() * self.y(),
            rhs.as_inner().s() * self.z(),
            rhs.as_inner().s() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().s() * self.as_inner().x(),
            rhs.as_inner().s() * self.as_inner().y(),
            rhs.as_inner().s() * self.as_inner().z(),
            rhs.as_inner().s() * self.as_inner().t(),
        )
    }
}
impl<T: Float> RightContract<Vector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.t() * self.t()) + rhs.x() * self.x() + rhs.y() * self.y() + rhs.z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Vector<T>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.t() * self.as_inner().t())
                + rhs.x() * self.as_inner().x()
                + rhs.y() * self.as_inner().y()
                + rhs.z() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Vector<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().t() * self.t())
                + rhs.as_inner().x() * self.x()
                + rhs.as_inner().y() * self.y()
                + rhs.as_inner().z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().t() * self.as_inner().t())
                + rhs.as_inner().x() * self.as_inner().x()
                + rhs.as_inner().y() * self.as_inner().y()
                + rhs.as_inner().z() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(self.xt() * operand.xt() * self.xy()) + self.xt() * operand.xy() * self.xt()
                - self.xt() * operand.yz() * self.zt()
                + self.xt() * operand.zt() * self.yz()
                - self.xy() * operand.xt() * self.xt()
                + self.xy() * operand.xy() * self.xy()
                + self.xy() * operand.xz() * self.xz()
                - self.xy() * operand.yt() * self.yt()
                + self.xy() * operand.yz() * self.yz()
                - self.xy() * operand.zt() * self.zt()
                - self.xz() * operand.xy() * self.xz()
                + self.xz() * operand.xz() * self.xy()
                + self.xz() * operand.yt() * self.zt()
                - self.xz() * operand.zt() * self.yt()
                + self.yt() * operand.xy() * self.yt()
                + self.yt() * operand.xz() * self.zt()
                - self.yt() * operand.yt() * self.xy()
                - self.yt() * operand.zt() * self.xz()
                - self.yz() * operand.xt() * self.zt()
                - self.yz() * operand.xy() * self.yz()
                + self.yz() * operand.yz() * self.xy()
                + self.yz() * operand.zt() * self.xt()
                - self.zt() * operand.xt() * self.yz()
                - self.zt() * operand.xy() * self.zt()
                + self.zt() * operand.xz() * self.yt()
                + self.zt() * operand.yt() * self.xz()
                - self.zt() * operand.yz() * self.xt()
                - self.zt() * operand.zt() * self.xy(),
            -(self.xt() * operand.xt() * self.xz()) + self.xt() * operand.xz() * self.xt()
                - self.xt() * operand.yt() * self.yz()
                + self.xt() * operand.yz() * self.yt()
                + self.xy() * operand.xy() * self.xz()
                - self.xy() * operand.xz() * self.xy()
                - self.xy() * operand.yt() * self.zt()
                + self.xy() * operand.zt() * self.yt()
                - self.xz() * operand.xt() * self.xt()
                + self.xz() * operand.xy() * self.xy()
                + self.xz() * operand.xz() * self.xz()
                - self.xz() * operand.yt() * self.yt()
                + self.xz() * operand.yz() * self.yz()
                - self.xz() * operand.zt() * self.zt()
                + self.yt() * operand.xt() * self.yz()
                + self.yt() * operand.xy() * self.zt()
                - self.yt() * operand.xz() * self.yt()
                - self.yt() * operand.yt() * self.xz()
                + self.yt() * operand.yz() * self.xt()
                + self.yt() * operand.zt() * self.xy()
                + self.yz() * operand.xt() * self.yt()
                - self.yz() * operand.xz() * self.yz()
                - self.yz() * operand.yt() * self.xt()
                + self.yz() * operand.yz() * self.xz()
                + self.zt() * operand.xy() * self.yt()
                + self.zt() * operand.xz() * self.zt()
                - self.zt() * operand.yt() * self.xy()
                - self.zt() * operand.zt() * self.xz(),
            -(self.xt() * operand.xt() * self.xt())
                + self.xt() * operand.xy() * self.xy()
                + self.xt() * operand.xz() * self.xz()
                - self.xt() * operand.yt() * self.yt()
                + self.xt() * operand.yz() * self.yz()
                - self.xt() * operand.zt() * self.zt()
                - self.xy() * operand.xt() * self.xy()
                + self.xy() * operand.xy() * self.xt()
                - self.xy() * operand.yz() * self.zt()
                + self.xy() * operand.zt() * self.yz()
                - self.xz() * operand.xt() * self.xz()
                + self.xz() * operand.xz() * self.xt()
                - self.xz() * operand.yt() * self.yz()
                + self.xz() * operand.yz() * self.yt()
                + self.yt() * operand.xt() * self.yt()
                - self.yt() * operand.xz() * self.yz()
                - self.yt() * operand.yt() * self.xt()
                + self.yt() * operand.yz() * self.xz()
                + self.yz() * operand.xt() * self.yz()
                + self.yz() * operand.xy() * self.zt()
                - self.yz() * operand.xz() * self.yt()
                - self.yz() * operand.yt() * self.xz()
                + self.yz() * operand.yz() * self.xt()
                + self.yz() * operand.zt() * self.xy()
                + self.zt() * operand.xt() * self.zt()
                + self.zt() * operand.xy() * self.yz()
                - self.zt() * operand.yz() * self.xy()
                - self.zt() * operand.zt() * self.xt(),
            -(self.xt() * operand.xt() * self.yz()) - self.xt() * operand.xy() * self.zt()
                + self.xt() * operand.xz() * self.yt()
                + self.xt() * operand.yt() * self.xz()
                - self.xt() * operand.yz() * self.xt()
                - self.xt() * operand.zt() * self.xy()
                + self.xy() * operand.xt() * self.zt()
                + self.xy() * operand.xy() * self.yz()
                - self.xy() * operand.yz() * self.xy()
                - self.xy() * operand.zt() * self.xt()
                - self.xz() * operand.xt() * self.yt()
                + self.xz() * operand.xz() * self.yz()
                + self.xz() * operand.yt() * self.xt()
                - self.xz() * operand.yz() * self.xz()
                - self.yt() * operand.xt() * self.xz()
                + self.yt() * operand.xz() * self.xt()
                - self.yt() * operand.yt() * self.yz()
                + self.yt() * operand.yz() * self.yt()
                - self.yz() * operand.xt() * self.xt()
                + self.yz() * operand.xy() * self.xy()
                + self.yz() * operand.xz() * self.xz()
                - self.yz() * operand.yt() * self.yt()
                + self.yz() * operand.yz() * self.yz()
                - self.yz() * operand.zt() * self.zt()
                + self.zt() * operand.xt() * self.xy()
                - self.zt() * operand.xy() * self.xt()
                + self.zt() * operand.yz() * self.zt()
                - self.zt() * operand.zt() * self.yz(),
            -(self.xt() * operand.xt() * self.yt())
                + self.xt() * operand.xz() * self.yz()
                + self.xt() * operand.yt() * self.xt()
                - self.xt() * operand.yz() * self.xz()
                + self.xy() * operand.xy() * self.yt()
                + self.xy() * operand.xz() * self.zt()
                - self.xy() * operand.yt() * self.xy()
                - self.xy() * operand.zt() * self.xz()
                - self.xz() * operand.xt() * self.yz()
                - self.xz() * operand.xy() * self.zt()
                + self.xz() * operand.xz() * self.yt()
                + self.xz() * operand.yt() * self.xz()
                - self.xz() * operand.yz() * self.xt()
                - self.xz() * operand.zt() * self.xy()
                - self.yt() * operand.xt() * self.xt()
                + self.yt() * operand.xy() * self.xy()
                + self.yt() * operand.xz() * self.xz()
                - self.yt() * operand.yt() * self.yt()
                + self.yt() * operand.yz() * self.yz()
                - self.yt() * operand.zt() * self.zt()
                - self.yz() * operand.xt() * self.xz()
                + self.yz() * operand.xz() * self.xt()
                - self.yz() * operand.yt() * self.yz()
                + self.yz() * operand.yz() * self.yt()
                - self.zt() * operand.xy() * self.xz()
                + self.zt() * operand.xz() * self.xy()
                + self.zt() * operand.yt() * self.zt()
                - self.zt() * operand.zt() * self.yt(),
            -(self.xt() * operand.xt() * self.zt()) - self.xt() * operand.xy() * self.yz()
                + self.xt() * operand.yz() * self.xy()
                + self.xt() * operand.zt() * self.xt()
                + self.xy() * operand.xt() * self.yz()
                + self.xy() * operand.xy() * self.zt()
                - self.xy() * operand.xz() * self.yt()
                - self.xy() * operand.yt() * self.xz()
                + self.xy() * operand.yz() * self.xt()
                + self.xy() * operand.zt() * self.xy()
                + self.xz() * operand.xy() * self.yt()
                + self.xz() * operand.xz() * self.zt()
                - self.xz() * operand.yt() * self.xy()
                - self.xz() * operand.zt() * self.xz()
                + self.yt() * operand.xy() * self.xz()
                - self.yt() * operand.xz() * self.xy()
                - self.yt() * operand.yt() * self.zt()
                + self.yt() * operand.zt() * self.yt()
                + self.yz() * operand.xt() * self.xy()
                - self.yz() * operand.xy() * self.xt()
                + self.yz() * operand.yz() * self.zt()
                - self.yz() * operand.zt() * self.yz()
                - self.zt() * operand.xt() * self.xt()
                + self.zt() * operand.xy() * self.xy()
                + self.zt() * operand.xz() * self.xz()
                - self.zt() * operand.yt() * self.yt()
                + self.zt() * operand.yz() * self.yz()
                - self.zt() * operand.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.xy())
                + -T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.xt() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.xy() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().yz()
                + T::from_i8(-4i8) * operand.zt() * self.as_inner().xy() * self.as_inner().zt(),
            -(operand.xz())
                + -T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.zt() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.xt() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.xy() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.yz() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().yt()
                + T::from_i8(-4i8) * operand.yt() * self.as_inner().xz() * self.as_inner().yt(),
            -T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.xt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.xt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.xt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.xy() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().yz()
                + T::from_i8(-4i8) * operand.yz() * self.as_inner().xy() * self.as_inner().zt()
                + T::from_i8(4i8) * operand.yz() * self.as_inner().xz() * self.as_inner().yt()
                + operand.xt(),
            -T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.yz() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.zt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.yz() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.yz() * self.as_inner().zt() * self.as_inner().zt()
                + T::from_i8(-4i8) * operand.xt() * self.as_inner().xz() * self.as_inner().yt()
                + T::from_i8(4i8) * operand.xt() * self.as_inner().xy() * self.as_inner().zt()
                + operand.yz(),
            -(operand.yt())
                + -T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.xt() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.xy() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.zt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.yz() * self.as_inner().yt() * self.as_inner().yz()
                + T::from_i8(4i8) * operand.xz() * self.as_inner().xz() * self.as_inner().yt(),
            -(operand.zt())
                + -T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.zt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.yz() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().xy()
                + T::from_i8(4i8) * operand.xy() * self.as_inner().xy() * self.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.as_inner().xy() * self.xz() * self.xz())
                + -(operand.as_inner().xy() * self.yz() * self.yz())
                + -(operand.as_inner().xy() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xt() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().xt() * self.yz() * self.zt()
                + -T::TWO * operand.as_inner().yt() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().yz() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().xz() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().xz() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().yt() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.xy() * self.yz()
                + T::from_i8(-4i8) * operand.as_inner().zt() * self.xy() * self.zt()
                + operand.as_inner().xy() * self.xt() * self.xt()
                + operand.as_inner().xy() * self.xy() * self.xy()
                + operand.as_inner().xy() * self.yt() * self.yt(),
            -(operand.as_inner().xz() * self.xy() * self.xy())
                + -(operand.as_inner().xz() * self.yt() * self.yt())
                + -(operand.as_inner().xz() * self.yz() * self.yz())
                + -T::TWO * operand.as_inner().xt() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().zt() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().xt() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().xy() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().xy() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().yz() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().zt() * self.xy() * self.yt()
                + T::from_i8(-4i8) * operand.as_inner().yt() * self.xz() * self.yt()
                + operand.as_inner().xz() * self.xt() * self.xt()
                + operand.as_inner().xz() * self.xz() * self.xz()
                + operand.as_inner().xz() * self.zt() * self.zt(),
            -(operand.as_inner().xt() * self.xt() * self.xt())
                + -(operand.as_inner().xt() * self.xy() * self.xy())
                + -(operand.as_inner().xt() * self.xz() * self.xz())
                + -T::TWO * operand.as_inner().xz() * self.yt() * self.yz()
                + -T::TWO * operand.as_inner().yt() * self.xt() * self.yt()
                + -T::TWO * operand.as_inner().yt() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().zt() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().xy() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().xy() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().xz() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().zt() * self.xy() * self.yz()
                + T::from_i8(-4i8) * operand.as_inner().yz() * self.xy() * self.zt()
                + T::from_i8(4i8) * operand.as_inner().yz() * self.xz() * self.yt()
                + operand.as_inner().xt() * self.yt() * self.yt()
                + operand.as_inner().xt() * self.yz() * self.yz()
                + operand.as_inner().xt() * self.zt() * self.zt(),
            -(operand.as_inner().yz() * self.xt() * self.xt())
                + -(operand.as_inner().yz() * self.xy() * self.xy())
                + -(operand.as_inner().yz() * self.xz() * self.xz())
                + -T::TWO * operand.as_inner().xy() * self.xt() * self.zt()
                + -T::TWO * operand.as_inner().yt() * self.yt() * self.yz()
                + -T::TWO * operand.as_inner().zt() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().zt() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().xy() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().xz() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().xz() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().yt() * self.xt() * self.xz()
                + T::from_i8(-4i8) * operand.as_inner().xt() * self.xz() * self.yt()
                + T::from_i8(4i8) * operand.as_inner().xt() * self.xy() * self.zt()
                + operand.as_inner().yz() * self.yt() * self.yt()
                + operand.as_inner().yz() * self.yz() * self.yz()
                + operand.as_inner().yz() * self.zt() * self.zt(),
            -(operand.as_inner().yt() * self.xy() * self.xy())
                + -(operand.as_inner().yt() * self.yt() * self.yt())
                + -(operand.as_inner().yt() * self.yz() * self.yz())
                + -T::TWO * operand.as_inner().xt() * self.xt() * self.yt()
                + -T::TWO * operand.as_inner().xt() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().xy() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().yz() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().zt() * self.xy() * self.xz()
                + -T::TWO * operand.as_inner().zt() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().xy() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().yz() * self.yt() * self.yz()
                + T::from_i8(4i8) * operand.as_inner().xz() * self.xz() * self.yt()
                + operand.as_inner().yt() * self.xt() * self.xt()
                + operand.as_inner().yt() * self.xz() * self.xz()
                + operand.as_inner().yt() * self.zt() * self.zt(),
            -(operand.as_inner().zt() * self.xz() * self.xz())
                + -(operand.as_inner().zt() * self.yz() * self.yz())
                + -(operand.as_inner().zt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xt() * self.xt() * self.zt()
                + -T::TWO * operand.as_inner().xz() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().yt() * self.xy() * self.xz()
                + -T::TWO * operand.as_inner().yt() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().xt() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().xz() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().yz() * self.yz() * self.zt()
                + T::from_i8(4i8) * operand.as_inner().xy() * self.xy() * self.zt()
                + operand.as_inner().zt() * self.xt() * self.xt()
                + operand.as_inner().zt() * self.xy() * self.xy()
                + operand.as_inner().zt() * self.yt() * self.yt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.as_inner().xy())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().yz()
                + T::from_i8(-4i8)
                    * operand.as_inner().zt()
                    * self.as_inner().xy()
                    * self.as_inner().zt(),
            -(operand.as_inner().xz())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().yt()
                + T::from_i8(-4i8)
                    * operand.as_inner().yt()
                    * self.as_inner().xz()
                    * self.as_inner().yt(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xy() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().yz()
                + T::from_i8(-4i8)
                    * operand.as_inner().yz()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + T::from_i8(4i8)
                    * operand.as_inner().yz()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + operand.as_inner().xt(),
            -T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().zt() * self.as_inner().zt()
                + T::from_i8(-4i8)
                    * operand.as_inner().xt()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + T::from_i8(4i8)
                    * operand.as_inner().xt()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + operand.as_inner().yz(),
            -(operand.as_inner().yt())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().yt() * self.as_inner().yz()
                + T::from_i8(4i8)
                    * operand.as_inner().xz()
                    * self.as_inner().xz()
                    * self.as_inner().yt(),
            -(operand.as_inner().zt())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yz() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().xy()
                + T::from_i8(4i8)
                    * operand.as_inner().xy()
                    * self.as_inner().xy()
                    * self.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(self.xt() * operand.s() * self.xt()) - self.xt() * operand.xy() * self.yt()
                + self.xt() * operand.xyzt() * self.yz()
                - self.xt() * operand.xz() * self.zt()
                + self.xt() * operand.yt() * self.xy()
                + self.xt() * operand.zt() * self.xz()
                + self.xy() * operand.s() * self.xy()
                + self.xy() * operand.xt() * self.yt()
                + self.xy() * operand.xyzt() * self.zt()
                - self.xy() * operand.xz() * self.yz()
                - self.xy() * operand.yt() * self.xt()
                + self.xy() * operand.yz() * self.xz()
                + self.xz() * operand.s() * self.xz()
                + self.xz() * operand.xt() * self.zt()
                + self.xz() * operand.xy() * self.yz()
                - self.xz() * operand.xyzt() * self.yt()
                - self.xz() * operand.yz() * self.xy()
                - self.xz() * operand.zt() * self.xt()
                - self.yt() * operand.s() * self.yt()
                - self.yt() * operand.xt() * self.xy()
                + self.yt() * operand.xy() * self.xt()
                - self.yt() * operand.xyzt() * self.xz()
                - self.yt() * operand.yz() * self.zt()
                + self.yt() * operand.zt() * self.yz()
                + self.yz() * operand.s() * self.yz()
                - self.yz() * operand.xy() * self.xz()
                + self.yz() * operand.xyzt() * self.xt()
                + self.yz() * operand.xz() * self.xy()
                + self.yz() * operand.yt() * self.zt()
                - self.yz() * operand.zt() * self.yt()
                - self.zt() * operand.s() * self.zt()
                - self.zt() * operand.xt() * self.xz()
                + self.zt() * operand.xyzt() * self.xy()
                + self.zt() * operand.xz() * self.xt()
                - self.zt() * operand.yt() * self.yz()
                + self.zt() * operand.yz() * self.yt(),
            -(self.xt() * operand.s() * self.yt()) - self.xt() * operand.xt() * self.xy()
                + self.xt() * operand.xy() * self.xt()
                - self.xt() * operand.xyzt() * self.xz()
                - self.xt() * operand.yz() * self.zt()
                + self.xt() * operand.zt() * self.yz()
                - self.xy() * operand.xt() * self.xt()
                + self.xy() * operand.xy() * self.xy()
                + self.xy() * operand.xz() * self.xz()
                - self.xy() * operand.yt() * self.yt()
                + self.xy() * operand.yz() * self.yz()
                - self.xy() * operand.zt() * self.zt()
                + self.xz() * operand.s() * self.yz()
                - self.xz() * operand.xy() * self.xz()
                + self.xz() * operand.xyzt() * self.xt()
                + self.xz() * operand.xz() * self.xy()
                + self.xz() * operand.yt() * self.zt()
                - self.xz() * operand.zt() * self.yt()
                + self.yt() * operand.s() * self.xt()
                + self.yt() * operand.xy() * self.yt()
                - self.yt() * operand.xyzt() * self.yz()
                + self.yt() * operand.xz() * self.zt()
                - self.yt() * operand.yt() * self.xy()
                - self.yt() * operand.zt() * self.xz()
                - self.yz() * operand.s() * self.xz()
                - self.yz() * operand.xt() * self.zt()
                - self.yz() * operand.xy() * self.yz()
                + self.yz() * operand.xyzt() * self.yt()
                + self.yz() * operand.yz() * self.xy()
                + self.yz() * operand.zt() * self.xt()
                - self.zt() * operand.xt() * self.yz()
                - self.zt() * operand.xy() * self.zt()
                + self.zt() * operand.xz() * self.yt()
                + self.zt() * operand.yt() * self.xz()
                - self.zt() * operand.yz() * self.xt()
                - self.zt() * operand.zt() * self.xy(),
            -(self.xt() * operand.s() * self.zt()) - self.xt() * operand.xt() * self.xz()
                + self.xt() * operand.xyzt() * self.xy()
                + self.xt() * operand.xz() * self.xt()
                - self.xt() * operand.yt() * self.yz()
                + self.xt() * operand.yz() * self.yt()
                - self.xy() * operand.s() * self.yz()
                + self.xy() * operand.xy() * self.xz()
                - self.xy() * operand.xyzt() * self.xt()
                - self.xy() * operand.xz() * self.xy()
                - self.xy() * operand.yt() * self.zt()
                + self.xy() * operand.zt() * self.yt()
                - self.xz() * operand.xt() * self.xt()
                + self.xz() * operand.xy() * self.xy()
                + self.xz() * operand.xz() * self.xz()
                - self.xz() * operand.yt() * self.yt()
                + self.xz() * operand.yz() * self.yz()
                - self.xz() * operand.zt() * self.zt()
                + self.yt() * operand.xt() * self.yz()
                + self.yt() * operand.xy() * self.zt()
                - self.yt() * operand.xz() * self.yt()
                - self.yt() * operand.yt() * self.xz()
                + self.yt() * operand.yz() * self.xt()
                + self.yt() * operand.zt() * self.xy()
                + self.yz() * operand.s() * self.xy()
                + self.yz() * operand.xt() * self.yt()
                + self.yz() * operand.xyzt() * self.zt()
                - self.yz() * operand.xz() * self.yz()
                - self.yz() * operand.yt() * self.xt()
                + self.yz() * operand.yz() * self.xz()
                + self.zt() * operand.s() * self.xt()
                + self.zt() * operand.xy() * self.yt()
                - self.zt() * operand.xyzt() * self.yz()
                + self.zt() * operand.xz() * self.zt()
                - self.zt() * operand.yt() * self.xy()
                - self.zt() * operand.zt() * self.xz(),
            -(self.xt() * operand.xt() * self.xt())
                + self.xt() * operand.xy() * self.xy()
                + self.xt() * operand.xz() * self.xz()
                - self.xt() * operand.yt() * self.yt()
                + self.xt() * operand.yz() * self.yz()
                - self.xt() * operand.zt() * self.zt()
                - self.xy() * operand.s() * self.yt()
                - self.xy() * operand.xt() * self.xy()
                + self.xy() * operand.xy() * self.xt()
                - self.xy() * operand.xyzt() * self.xz()
                - self.xy() * operand.yz() * self.zt()
                + self.xy() * operand.zt() * self.yz()
                - self.xz() * operand.s() * self.zt()
                - self.xz() * operand.xt() * self.xz()
                + self.xz() * operand.xyzt() * self.xy()
                + self.xz() * operand.xz() * self.xt()
                - self.xz() * operand.yt() * self.yz()
                + self.xz() * operand.yz() * self.yt()
                + self.yt() * operand.s() * self.xy()
                + self.yt() * operand.xt() * self.yt()
                + self.yt() * operand.xyzt() * self.zt()
                - self.yt() * operand.xz() * self.yz()
                - self.yt() * operand.yt() * self.xt()
                + self.yt() * operand.yz() * self.xz()
                + self.yz() * operand.xt() * self.yz()
                + self.yz() * operand.xy() * self.zt()
                - self.yz() * operand.xz() * self.yt()
                - self.yz() * operand.yt() * self.xz()
                + self.yz() * operand.yz() * self.xt()
                + self.yz() * operand.zt() * self.xy()
                + self.zt() * operand.s() * self.xz()
                + self.zt() * operand.xt() * self.zt()
                + self.zt() * operand.xy() * self.yz()
                - self.zt() * operand.xyzt() * self.yt()
                - self.zt() * operand.yz() * self.xy()
                - self.zt() * operand.zt() * self.xt(),
            -(self.xt() * operand.xt() * self.yz()) - self.xt() * operand.xy() * self.zt()
                + self.xt() * operand.xz() * self.yt()
                + self.xt() * operand.yt() * self.xz()
                - self.xt() * operand.yz() * self.xt()
                - self.xt() * operand.zt() * self.xy()
                + self.xy() * operand.s() * self.xz()
                + self.xy() * operand.xt() * self.zt()
                + self.xy() * operand.xy() * self.yz()
                - self.xy() * operand.xyzt() * self.yt()
                - self.xy() * operand.yz() * self.xy()
                - self.xy() * operand.zt() * self.xt()
                - self.xz() * operand.s() * self.xy()
                - self.xz() * operand.xt() * self.yt()
                - self.xz() * operand.xyzt() * self.zt()
                + self.xz() * operand.xz() * self.yz()
                + self.xz() * operand.yt() * self.xt()
                - self.xz() * operand.yz() * self.xz()
                - self.yt() * operand.s() * self.zt()
                - self.yt() * operand.xt() * self.xz()
                + self.yt() * operand.xyzt() * self.xy()
                + self.yt() * operand.xz() * self.xt()
                - self.yt() * operand.yt() * self.yz()
                + self.yt() * operand.yz() * self.yt()
                - self.yz() * operand.xt() * self.xt()
                + self.yz() * operand.xy() * self.xy()
                + self.yz() * operand.xz() * self.xz()
                - self.yz() * operand.yt() * self.yt()
                + self.yz() * operand.yz() * self.yz()
                - self.yz() * operand.zt() * self.zt()
                + self.zt() * operand.s() * self.yt()
                + self.zt() * operand.xt() * self.xy()
                - self.zt() * operand.xy() * self.xt()
                + self.zt() * operand.xyzt() * self.xz()
                + self.zt() * operand.yz() * self.zt()
                - self.zt() * operand.zt() * self.yz(),
            -(self.xt() * operand.s() * self.xy())
                - self.xt() * operand.xt() * self.yt()
                - self.xt() * operand.xyzt() * self.zt()
                + self.xt() * operand.xz() * self.yz()
                + self.xt() * operand.yt() * self.xt()
                - self.xt() * operand.yz() * self.xz()
                + self.xy() * operand.s() * self.xt()
                + self.xy() * operand.xy() * self.yt()
                - self.xy() * operand.xyzt() * self.yz()
                + self.xy() * operand.xz() * self.zt()
                - self.xy() * operand.yt() * self.xy()
                - self.xy() * operand.zt() * self.xz()
                - self.xz() * operand.xt() * self.yz()
                - self.xz() * operand.xy() * self.zt()
                + self.xz() * operand.xz() * self.yt()
                + self.xz() * operand.yt() * self.xz()
                - self.xz() * operand.yz() * self.xt()
                - self.xz() * operand.zt() * self.xy()
                - self.yt() * operand.xt() * self.xt()
                + self.yt() * operand.xy() * self.xy()
                + self.yt() * operand.xz() * self.xz()
                - self.yt() * operand.yt() * self.yt()
                + self.yt() * operand.yz() * self.yz()
                - self.yt() * operand.zt() * self.zt()
                - self.yz() * operand.s() * self.zt()
                - self.yz() * operand.xt() * self.xz()
                + self.yz() * operand.xyzt() * self.xy()
                + self.yz() * operand.xz() * self.xt()
                - self.yz() * operand.yt() * self.yz()
                + self.yz() * operand.yz() * self.yt()
                + self.zt() * operand.s() * self.yz()
                - self.zt() * operand.xy() * self.xz()
                + self.zt() * operand.xyzt() * self.xt()
                + self.zt() * operand.xz() * self.xy()
                + self.zt() * operand.yt() * self.zt()
                - self.zt() * operand.zt() * self.yt(),
            -(self.xt() * operand.s() * self.xz())
                - self.xt() * operand.xt() * self.zt()
                - self.xt() * operand.xy() * self.yz()
                + self.xt() * operand.xyzt() * self.yt()
                + self.xt() * operand.yz() * self.xy()
                + self.xt() * operand.zt() * self.xt()
                + self.xy() * operand.xt() * self.yz()
                + self.xy() * operand.xy() * self.zt()
                - self.xy() * operand.xz() * self.yt()
                - self.xy() * operand.yt() * self.xz()
                + self.xy() * operand.yz() * self.xt()
                + self.xy() * operand.zt() * self.xy()
                + self.xz() * operand.s() * self.xt()
                + self.xz() * operand.xy() * self.yt()
                - self.xz() * operand.xyzt() * self.yz()
                + self.xz() * operand.xz() * self.zt()
                - self.xz() * operand.yt() * self.xy()
                - self.xz() * operand.zt() * self.xz()
                - self.yt() * operand.s() * self.yz()
                + self.yt() * operand.xy() * self.xz()
                - self.yt() * operand.xyzt() * self.xt()
                - self.yt() * operand.xz() * self.xy()
                - self.yt() * operand.yt() * self.zt()
                + self.yt() * operand.zt() * self.yt()
                + self.yz() * operand.s() * self.yt()
                + self.yz() * operand.xt() * self.xy()
                - self.yz() * operand.xy() * self.xt()
                + self.yz() * operand.xyzt() * self.xz()
                + self.yz() * operand.yz() * self.zt()
                - self.yz() * operand.zt() * self.yz()
                - self.zt() * operand.xt() * self.xt()
                + self.zt() * operand.xy() * self.xy()
                + self.zt() * operand.xz() * self.xz()
                - self.zt() * operand.yt() * self.yt()
                + self.zt() * operand.yz() * self.yz()
                - self.zt() * operand.zt() * self.zt(),
            -(self.xt() * operand.s() * self.yz()) + self.xt() * operand.xy() * self.xz()
                - self.xt() * operand.xyzt() * self.xt()
                - self.xt() * operand.xz() * self.xy()
                - self.xt() * operand.yt() * self.zt()
                + self.xt() * operand.zt() * self.yt()
                - self.xy() * operand.s() * self.zt()
                - self.xy() * operand.xt() * self.xz()
                + self.xy() * operand.xyzt() * self.xy()
                + self.xy() * operand.xz() * self.xt()
                - self.xy() * operand.yt() * self.yz()
                + self.xy() * operand.yz() * self.yt()
                + self.xz() * operand.s() * self.yt()
                + self.xz() * operand.xt() * self.xy()
                - self.xz() * operand.xy() * self.xt()
                + self.xz() * operand.xyzt() * self.xz()
                + self.xz() * operand.yz() * self.zt()
                - self.xz() * operand.zt() * self.yz()
                + self.yt() * operand.s() * self.xz()
                + self.yt() * operand.xt() * self.zt()
                + self.yt() * operand.xy() * self.yz()
                - self.yt() * operand.xyzt() * self.yt()
                - self.yt() * operand.yz() * self.xy()
                - self.yt() * operand.zt() * self.xt()
                - self.yz() * operand.s() * self.xt()
                - self.yz() * operand.xy() * self.yt()
                + self.yz() * operand.xyzt() * self.yz()
                - self.yz() * operand.xz() * self.zt()
                + self.yz() * operand.yt() * self.xy()
                + self.yz() * operand.zt() * self.xz()
                - self.zt() * operand.s() * self.xy()
                - self.zt() * operand.xt() * self.yt()
                - self.zt() * operand.xyzt() * self.zt()
                + self.zt() * operand.xz() * self.yz()
                + self.zt() * operand.yt() * self.xt()
                - self.zt() * operand.yz() * self.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Unit<Bivector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            operand.s(),
            -(operand.xy())
                + -T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.xt() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.xy() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().yz()
                + T::from_i8(-4i8) * operand.zt() * self.as_inner().xy() * self.as_inner().zt(),
            -(operand.xz())
                + -T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.zt() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.xt() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.xy() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.yz() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().yt()
                + T::from_i8(-4i8) * operand.yt() * self.as_inner().xz() * self.as_inner().yt(),
            -T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.xt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.xt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.xt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.xy() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().yz()
                + T::from_i8(-4i8) * operand.yz() * self.as_inner().xy() * self.as_inner().zt()
                + T::from_i8(4i8) * operand.yz() * self.as_inner().xz() * self.as_inner().yt()
                + operand.xt(),
            -T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.yz() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.zt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.yz() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.yz() * self.as_inner().zt() * self.as_inner().zt()
                + T::from_i8(-4i8) * operand.xt() * self.as_inner().xz() * self.as_inner().yt()
                + T::from_i8(4i8) * operand.xt() * self.as_inner().xy() * self.as_inner().zt()
                + operand.yz(),
            -(operand.yt())
                + -T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.xt() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.xy() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.zt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.yz() * self.as_inner().yt() * self.as_inner().yz()
                + T::from_i8(4i8) * operand.xz() * self.as_inner().xz() * self.as_inner().yt(),
            -(operand.zt())
                + -T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.zt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.yz() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().xy()
                + T::from_i8(4i8) * operand.xy() * self.as_inner().xy() * self.as_inner().zt(),
            operand.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.as_inner().s() * self.xt() * self.xt())
                + -(operand.as_inner().s() * self.yt() * self.yt())
                + -(operand.as_inner().s() * self.zt() * self.zt())
                + operand.as_inner().s() * self.xy() * self.xy()
                + operand.as_inner().s() * self.xz() * self.xz()
                + operand.as_inner().s() * self.yz() * self.yz(),
            -(operand.as_inner().xy() * self.xz() * self.xz())
                + -(operand.as_inner().xy() * self.yz() * self.yz())
                + -(operand.as_inner().xy() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xt() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().xt() * self.yz() * self.zt()
                + -T::TWO * operand.as_inner().yt() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().yz() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().xz() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().xz() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().yt() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.xy() * self.yz()
                + T::from_i8(-4i8) * operand.as_inner().zt() * self.xy() * self.zt()
                + operand.as_inner().xy() * self.xt() * self.xt()
                + operand.as_inner().xy() * self.xy() * self.xy()
                + operand.as_inner().xy() * self.yt() * self.yt(),
            -(operand.as_inner().xz() * self.xy() * self.xy())
                + -(operand.as_inner().xz() * self.yt() * self.yt())
                + -(operand.as_inner().xz() * self.yz() * self.yz())
                + -T::TWO * operand.as_inner().xt() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().zt() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().xt() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().xy() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().xy() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().yz() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().zt() * self.xy() * self.yt()
                + T::from_i8(-4i8) * operand.as_inner().yt() * self.xz() * self.yt()
                + operand.as_inner().xz() * self.xt() * self.xt()
                + operand.as_inner().xz() * self.xz() * self.xz()
                + operand.as_inner().xz() * self.zt() * self.zt(),
            -(operand.as_inner().xt() * self.xt() * self.xt())
                + -(operand.as_inner().xt() * self.xy() * self.xy())
                + -(operand.as_inner().xt() * self.xz() * self.xz())
                + -T::TWO * operand.as_inner().xz() * self.yt() * self.yz()
                + -T::TWO * operand.as_inner().yt() * self.xt() * self.yt()
                + -T::TWO * operand.as_inner().yt() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().zt() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().xy() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().xy() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().xz() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().zt() * self.xy() * self.yz()
                + T::from_i8(-4i8) * operand.as_inner().yz() * self.xy() * self.zt()
                + T::from_i8(4i8) * operand.as_inner().yz() * self.xz() * self.yt()
                + operand.as_inner().xt() * self.yt() * self.yt()
                + operand.as_inner().xt() * self.yz() * self.yz()
                + operand.as_inner().xt() * self.zt() * self.zt(),
            -(operand.as_inner().yz() * self.xt() * self.xt())
                + -(operand.as_inner().yz() * self.xy() * self.xy())
                + -(operand.as_inner().yz() * self.xz() * self.xz())
                + -T::TWO * operand.as_inner().xy() * self.xt() * self.zt()
                + -T::TWO * operand.as_inner().yt() * self.yt() * self.yz()
                + -T::TWO * operand.as_inner().zt() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().zt() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().xy() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().xz() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().xz() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().yt() * self.xt() * self.xz()
                + T::from_i8(-4i8) * operand.as_inner().xt() * self.xz() * self.yt()
                + T::from_i8(4i8) * operand.as_inner().xt() * self.xy() * self.zt()
                + operand.as_inner().yz() * self.yt() * self.yt()
                + operand.as_inner().yz() * self.yz() * self.yz()
                + operand.as_inner().yz() * self.zt() * self.zt(),
            -(operand.as_inner().yt() * self.xy() * self.xy())
                + -(operand.as_inner().yt() * self.yt() * self.yt())
                + -(operand.as_inner().yt() * self.yz() * self.yz())
                + -T::TWO * operand.as_inner().xt() * self.xt() * self.yt()
                + -T::TWO * operand.as_inner().xt() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().xy() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().yz() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().zt() * self.xy() * self.xz()
                + -T::TWO * operand.as_inner().zt() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().xy() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().yz() * self.yt() * self.yz()
                + T::from_i8(4i8) * operand.as_inner().xz() * self.xz() * self.yt()
                + operand.as_inner().yt() * self.xt() * self.xt()
                + operand.as_inner().yt() * self.xz() * self.xz()
                + operand.as_inner().yt() * self.zt() * self.zt(),
            -(operand.as_inner().zt() * self.xz() * self.xz())
                + -(operand.as_inner().zt() * self.yz() * self.yz())
                + -(operand.as_inner().zt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xt() * self.xt() * self.zt()
                + -T::TWO * operand.as_inner().xz() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().yt() * self.xy() * self.xz()
                + -T::TWO * operand.as_inner().yt() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().xt() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().xz() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().yz() * self.yz() * self.zt()
                + T::from_i8(4i8) * operand.as_inner().xy() * self.xy() * self.zt()
                + operand.as_inner().zt() * self.xt() * self.xt()
                + operand.as_inner().zt() * self.xy() * self.xy()
                + operand.as_inner().zt() * self.yt() * self.yt(),
            -(operand.as_inner().xyzt() * self.xt() * self.xt())
                + -(operand.as_inner().xyzt() * self.yt() * self.yt())
                + -(operand.as_inner().xyzt() * self.zt() * self.zt())
                + operand.as_inner().xyzt() * self.xy() * self.xy()
                + operand.as_inner().xyzt() * self.xz() * self.xz()
                + operand.as_inner().xyzt() * self.yz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Unit<Bivector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            operand.as_inner().s(),
            -(operand.as_inner().xy())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().yz()
                + T::from_i8(-4i8)
                    * operand.as_inner().zt()
                    * self.as_inner().xy()
                    * self.as_inner().zt(),
            -(operand.as_inner().xz())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().yt()
                + T::from_i8(-4i8)
                    * operand.as_inner().yt()
                    * self.as_inner().xz()
                    * self.as_inner().yt(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xy() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().yz()
                + T::from_i8(-4i8)
                    * operand.as_inner().yz()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + T::from_i8(4i8)
                    * operand.as_inner().yz()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + operand.as_inner().xt(),
            -T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().zt() * self.as_inner().zt()
                + T::from_i8(-4i8)
                    * operand.as_inner().xt()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + T::from_i8(4i8)
                    * operand.as_inner().xt()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + operand.as_inner().yz(),
            -(operand.as_inner().yt())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().yt() * self.as_inner().yz()
                + T::from_i8(4i8)
                    * operand.as_inner().xz()
                    * self.as_inner().xz()
                    * self.as_inner().yt(),
            -(operand.as_inner().zt())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yz() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().xy()
                + T::from_i8(4i8)
                    * operand.as_inner().xy()
                    * self.as_inner().xy()
                    * self.as_inner().zt(),
            operand.as_inner().xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Bivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(self.xt() * operand.xyzt() * self.xt())
                + self.xy() * operand.xyzt() * self.xy()
                + self.xz() * operand.xyzt() * self.xz()
                - self.yt() * operand.xyzt() * self.yt()
                + self.yz() * operand.xyzt() * self.yz()
                - self.zt() * operand.xyzt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Unit<Bivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Bivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(operand.as_inner().xyzt() * self.xt() * self.xt())
                + -(operand.as_inner().xyzt() * self.yt() * self.yt())
                + -(operand.as_inner().xyzt() * self.zt() * self.zt())
                + operand.as_inner().xyzt() * self.xy() * self.xy()
                + operand.as_inner().xyzt() * self.xz() * self.xz()
                + operand.as_inner().xyzt() * self.yz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Unit<Bivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.as_inner().xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.xt() * operand.s() * self.xt())
                + self.xy() * operand.s() * self.xy()
                + self.xz() * operand.s() * self.xz()
                - self.yt() * operand.s() * self.yt()
                + self.yz() * operand.s() * self.yz()
                - self.zt() * operand.s() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(operand.as_inner().s() * self.xt() * self.xt())
                + -(operand.as_inner().s() * self.yt() * self.yt())
                + -(operand.as_inner().s() * self.zt() * self.zt())
                + operand.as_inner().s() * self.xy() * self.xy()
                + operand.as_inner().s() * self.xz() * self.xz()
                + operand.as_inner().s() * self.yz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(self.xt() * operand.xyt() * self.xz())
                + self.xt() * operand.xyz() * self.xt()
                + self.xt() * operand.xzt() * self.xy()
                + self.xy() * operand.xyz() * self.xy()
                + self.xy() * operand.xzt() * self.xt()
                + self.xy() * operand.yzt() * self.yt()
                - self.xz() * operand.xyt() * self.xt()
                + self.xz() * operand.xyz() * self.xz()
                + self.xz() * operand.yzt() * self.zt()
                - self.yt() * operand.xyt() * self.yz()
                + self.yt() * operand.xyz() * self.yt()
                + self.yt() * operand.yzt() * self.xy()
                - self.yz() * operand.xyt() * self.yt()
                + self.yz() * operand.xyz() * self.yz()
                - self.yz() * operand.xzt() * self.zt()
                + self.zt() * operand.xyz() * self.zt()
                - self.zt() * operand.xzt() * self.yz()
                + self.zt() * operand.yzt() * self.xz(),
            -(self.xt() * operand.xyt() * self.xt())
                + self.xt() * operand.xyz() * self.xz()
                + self.xt() * operand.yzt() * self.zt()
                + self.xy() * operand.xyt() * self.xy()
                + self.xy() * operand.xzt() * self.xz()
                + self.xy() * operand.yzt() * self.yz()
                - self.xz() * operand.xyt() * self.xz()
                + self.xz() * operand.xyz() * self.xt()
                + self.xz() * operand.xzt() * self.xy()
                - self.yt() * operand.xyt() * self.yt()
                + self.yt() * operand.xyz() * self.yz()
                - self.yt() * operand.xzt() * self.zt()
                - self.yz() * operand.xyt() * self.yz()
                + self.yz() * operand.xyz() * self.yt()
                + self.yz() * operand.yzt() * self.xy()
                + self.zt() * operand.xyt() * self.zt()
                - self.zt() * operand.xzt() * self.yt()
                + self.zt() * operand.yzt() * self.xt(),
            -(self.xt() * operand.xyz() * self.xy())
                - self.xt() * operand.xzt() * self.xt()
                - self.xt() * operand.yzt() * self.yt()
                + self.xy() * operand.xyt() * self.xz()
                - self.xy() * operand.xyz() * self.xt()
                - self.xy() * operand.xzt() * self.xy()
                + self.xz() * operand.xyt() * self.xy()
                + self.xz() * operand.xzt() * self.xz()
                + self.xz() * operand.yzt() * self.yz()
                - self.yt() * operand.xyt() * self.zt()
                + self.yt() * operand.xzt() * self.yt()
                - self.yt() * operand.yzt() * self.xt()
                + self.yz() * operand.xyz() * self.zt()
                - self.yz() * operand.xzt() * self.yz()
                + self.yz() * operand.yzt() * self.xz()
                - self.zt() * operand.xyt() * self.yt()
                + self.zt() * operand.xyz() * self.yz()
                - self.zt() * operand.xzt() * self.zt(),
            self.xt() * operand.xyt() * self.zt() - self.xt() * operand.xzt() * self.yt()
                + self.xt() * operand.yzt() * self.xt()
                + self.xy() * operand.xyt() * self.yz()
                - self.xy() * operand.xyz() * self.yt()
                - self.xy() * operand.yzt() * self.xy()
                - self.xz() * operand.xyz() * self.zt()
                + self.xz() * operand.xzt() * self.yz()
                - self.xz() * operand.yzt() * self.xz()
                - self.yt() * operand.xyz() * self.xy()
                - self.yt() * operand.xzt() * self.xt()
                - self.yt() * operand.yzt() * self.yt()
                + self.yz() * operand.xyt() * self.xy()
                + self.yz() * operand.xzt() * self.xz()
                + self.yz() * operand.yzt() * self.yz()
                + self.zt() * operand.xyt() * self.xt()
                - self.zt() * operand.xyz() * self.xz()
                - self.zt() * operand.yzt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Unit<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(operand.xyz())
                + -T::TWO * operand.xyt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.xyt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.xzt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.xyz() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.xyz() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.xyz() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.xzt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.yzt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.yzt() * self.as_inner().xz() * self.as_inner().zt(),
            -T::TWO * operand.xyt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.xyt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.xzt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.xyt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.xyz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.xyz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.xzt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.yzt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.yzt() * self.as_inner().xy() * self.as_inner().yz()
                + operand.xyt(),
            -T::TWO * operand.xyt() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.xyz() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.xzt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.xzt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.yzt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.xyt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.xyz() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.xzt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.yzt() * self.as_inner().xz() * self.as_inner().yz()
                + operand.xzt(),
            -(operand.yzt())
                + -T::TWO * operand.xyz() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.xyz() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.xzt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.yzt() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.yzt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.xyt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.xyt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.xzt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.yzt() * self.as_inner().yz() * self.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Trivector<T>>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.as_inner().xyt() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().xyt() * self.yt() * self.yz()
                + -T::TWO * operand.as_inner().xzt() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().xzt() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().yzt() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().yzt() * self.xz() * self.zt()
                + operand.as_inner().xyz() * self.xt() * self.xt()
                + operand.as_inner().xyz() * self.xy() * self.xy()
                + operand.as_inner().xyz() * self.xz() * self.xz()
                + operand.as_inner().xyz() * self.yt() * self.yt()
                + operand.as_inner().xyz() * self.yz() * self.yz()
                + operand.as_inner().xyz() * self.zt() * self.zt(),
            -(operand.as_inner().xyt() * self.xt() * self.xt())
                + -(operand.as_inner().xyt() * self.xz() * self.xz())
                + -(operand.as_inner().xyt() * self.yt() * self.yt())
                + -(operand.as_inner().xyt() * self.yz() * self.yz())
                + -T::TWO * operand.as_inner().xzt() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().xyz() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().xyz() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().xzt() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().yzt() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().yzt() * self.xy() * self.yz()
                + operand.as_inner().xyt() * self.xy() * self.xy()
                + operand.as_inner().xyt() * self.zt() * self.zt(),
            -(operand.as_inner().xzt() * self.xt() * self.xt())
                + -(operand.as_inner().xzt() * self.xy() * self.xy())
                + -(operand.as_inner().xzt() * self.yz() * self.yz())
                + -(operand.as_inner().xzt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xyt() * self.yt() * self.zt()
                + -T::TWO * operand.as_inner().xyz() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().yzt() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().xyt() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().xyz() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().yzt() * self.xz() * self.yz()
                + operand.as_inner().xzt() * self.xz() * self.xz()
                + operand.as_inner().xzt() * self.yt() * self.yt(),
            -(operand.as_inner().yzt() * self.xy() * self.xy())
                + -(operand.as_inner().yzt() * self.xz() * self.xz())
                + -(operand.as_inner().yzt() * self.yt() * self.yt())
                + -(operand.as_inner().yzt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xyz() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().xyz() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().xzt() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().xyt() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().xyt() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().xzt() * self.xz() * self.yz()
                + operand.as_inner().yzt() * self.xt() * self.xt()
                + operand.as_inner().yzt() * self.yz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Trivector<T>>> for Unit<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(operand.as_inner().xyz())
                + -T::TWO * operand.as_inner().xyt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xyt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xz() * self.as_inner().zt(),
            -T::TWO * operand.as_inner().xyt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xyt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xy() * self.as_inner().yz()
                + operand.as_inner().xyt(),
            -T::TWO * operand.as_inner().xyt() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xyz() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xz() * self.as_inner().yz()
                + operand.as_inner().xzt(),
            -(operand.as_inner().yzt())
                + -T::TWO * operand.as_inner().xyz() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xyz() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().yz() * self.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            self.xt() * operand.x() * self.xt()
                + self.xt() * operand.y() * self.yt()
                + self.xt() * operand.z() * self.zt()
                - self.xy() * operand.t() * self.yt()
                - self.xy() * operand.x() * self.xy()
                + self.xy() * operand.z() * self.yz()
                - self.xz() * operand.t() * self.zt()
                - self.xz() * operand.x() * self.xz()
                - self.xz() * operand.y() * self.yz()
                - self.yt() * operand.t() * self.xy()
                - self.yt() * operand.x() * self.yt()
                + self.yt() * operand.y() * self.xt()
                + self.yz() * operand.x() * self.yz()
                - self.yz() * operand.y() * self.xz()
                + self.yz() * operand.z() * self.xy()
                - self.zt() * operand.t() * self.xz()
                - self.zt() * operand.x() * self.zt()
                + self.zt() * operand.z() * self.xt(),
            self.xt() * operand.t() * self.xy() + self.xt() * operand.x() * self.yt()
                - self.xt() * operand.y() * self.xt()
                + self.xy() * operand.t() * self.xt()
                - self.xy() * operand.y() * self.xy()
                - self.xy() * operand.z() * self.xz()
                - self.xz() * operand.x() * self.yz()
                + self.xz() * operand.y() * self.xz()
                - self.xz() * operand.z() * self.xy()
                + self.yt() * operand.x() * self.xt()
                + self.yt() * operand.y() * self.yt()
                + self.yt() * operand.z() * self.zt()
                - self.yz() * operand.t() * self.zt()
                - self.yz() * operand.x() * self.xz()
                - self.yz() * operand.y() * self.yz()
                - self.zt() * operand.t() * self.yz()
                - self.zt() * operand.y() * self.zt()
                + self.zt() * operand.z() * self.yt(),
            self.xt() * operand.t() * self.xz() + self.xt() * operand.x() * self.zt()
                - self.xt() * operand.z() * self.xt()
                + self.xy() * operand.x() * self.yz()
                - self.xy() * operand.y() * self.xz()
                + self.xy() * operand.z() * self.xy()
                + self.xz() * operand.t() * self.xt()
                - self.xz() * operand.y() * self.xy()
                - self.xz() * operand.z() * self.xz()
                + self.yt() * operand.t() * self.yz()
                + self.yt() * operand.y() * self.zt()
                - self.yt() * operand.z() * self.yt()
                + self.yz() * operand.t() * self.yt()
                + self.yz() * operand.x() * self.xy()
                - self.yz() * operand.z() * self.yz()
                + self.zt() * operand.x() * self.xt()
                + self.zt() * operand.y() * self.yt()
                + self.zt() * operand.z() * self.zt(),
            self.xt() * operand.t() * self.xt()
                - self.xt() * operand.y() * self.xy()
                - self.xt() * operand.z() * self.xz()
                + self.xy() * operand.t() * self.xy()
                + self.xy() * operand.x() * self.yt()
                - self.xy() * operand.y() * self.xt()
                + self.xz() * operand.t() * self.xz()
                + self.xz() * operand.x() * self.zt()
                - self.xz() * operand.z() * self.xt()
                + self.yt() * operand.t() * self.yt()
                + self.yt() * operand.x() * self.xy()
                - self.yt() * operand.z() * self.yz()
                + self.yz() * operand.t() * self.yz()
                + self.yz() * operand.y() * self.zt()
                - self.yz() * operand.z() * self.yt()
                + self.zt() * operand.t() * self.zt()
                + self.zt() * operand.x() * self.xz()
                + self.zt() * operand.y() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.x())
                + -T::TWO * operand.t() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.t() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.x() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.x() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.y() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.x() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.y() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.z() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.z() * self.as_inner().xy() * self.as_inner().yz(),
            -T::TWO * operand.t() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.x() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.y() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.y() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.z() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.t() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.x() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.y() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.z() * self.as_inner().yt() * self.as_inner().zt()
                + operand.y(),
            -T::TWO * operand.y() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.z() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.z() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.t() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.t() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.x() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.x() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.y() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.z() * self.as_inner().zt() * self.as_inner().zt()
                + operand.z(),
            -(operand.t())
                + -T::TWO * operand.y() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.z() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.z() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.t() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.t() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.t() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.x() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.x() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.y() * self.as_inner().yz() * self.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.as_inner().x() * self.xy() * self.xy())
                + -(operand.as_inner().x() * self.xz() * self.xz())
                + -(operand.as_inner().x() * self.yt() * self.yt())
                + -(operand.as_inner().x() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().t() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().t() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().y() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().y() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().z() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().z() * self.xy() * self.yz()
                + operand.as_inner().x() * self.xt() * self.xt()
                + operand.as_inner().x() * self.yz() * self.yz(),
            -(operand.as_inner().y() * self.xt() * self.xt())
                + -(operand.as_inner().y() * self.xy() * self.xy())
                + -(operand.as_inner().y() * self.yz() * self.yz())
                + -(operand.as_inner().y() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().t() * self.yz() * self.zt()
                + -T::TWO * operand.as_inner().x() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().z() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().t() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().x() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().z() * self.yt() * self.zt()
                + operand.as_inner().y() * self.xz() * self.xz()
                + operand.as_inner().y() * self.yt() * self.yt(),
            -(operand.as_inner().z() * self.xt() * self.xt())
                + -(operand.as_inner().z() * self.xz() * self.xz())
                + -(operand.as_inner().z() * self.yt() * self.yt())
                + -(operand.as_inner().z() * self.yz() * self.yz())
                + -T::TWO * operand.as_inner().y() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().t() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().t() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().x() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().x() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().y() * self.yt() * self.zt()
                + operand.as_inner().z() * self.xy() * self.xy()
                + operand.as_inner().z() * self.zt() * self.zt(),
            -T::TWO * operand.as_inner().y() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().z() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().z() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().x() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().x() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().y() * self.yz() * self.zt()
                + operand.as_inner().t() * self.xt() * self.xt()
                + operand.as_inner().t() * self.xy() * self.xy()
                + operand.as_inner().t() * self.xz() * self.xz()
                + operand.as_inner().t() * self.yt() * self.yt()
                + operand.as_inner().t() * self.yz() * self.yz()
                + operand.as_inner().t() * self.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.as_inner().x())
                + -T::TWO * operand.as_inner().t() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().t() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().x() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().x() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().x() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().y() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().z() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().z() * self.as_inner().xy() * self.as_inner().yz(),
            -T::TWO * operand.as_inner().t() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().x() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().y() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().t() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().x() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().y() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().z() * self.as_inner().yt() * self.as_inner().zt()
                + operand.as_inner().y(),
            -T::TWO * operand.as_inner().y() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().t() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().t() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().x() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().x() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().y() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().z() * self.as_inner().zt() * self.as_inner().zt()
                + operand.as_inner().z(),
            -(operand.as_inner().t())
                + -T::TWO * operand.as_inner().y() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().t() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().t() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().t() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().x() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().x() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().y() * self.as_inner().yz() * self.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Eventor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(self.s() * operand.xt() * self.yt())
                + self.s() * operand.xy() * self.s()
                + self.s() * operand.xz() * self.yz()
                + self.s() * operand.yt() * self.xt()
                - self.s() * operand.yz() * self.xz()
                + self.s() * operand.zt() * self.xyzt()
                - self.xt() * operand.xt() * self.xy()
                + self.xt() * operand.xy() * self.xt()
                + self.xt() * operand.xz() * self.xyzt()
                + self.xt() * operand.yt() * self.s()
                - self.xt() * operand.yz() * self.zt()
                + self.xt() * operand.zt() * self.yz()
                - self.xy() * operand.xt() * self.xt()
                + self.xy() * operand.xy() * self.xy()
                + self.xy() * operand.xz() * self.xz()
                - self.xy() * operand.yt() * self.yt()
                + self.xy() * operand.yz() * self.yz()
                - self.xy() * operand.zt() * self.zt()
                - self.xyzt() * operand.xt() * self.xz()
                - self.xyzt() * operand.xy() * self.xyzt()
                + self.xyzt() * operand.xz() * self.xt()
                - self.xyzt() * operand.yt() * self.yz()
                + self.xyzt() * operand.yz() * self.yt()
                + self.xyzt() * operand.zt() * self.s()
                - self.xz() * operand.xt() * self.xyzt()
                - self.xz() * operand.xy() * self.xz()
                + self.xz() * operand.xz() * self.xy()
                + self.xz() * operand.yt() * self.zt()
                - self.xz() * operand.yz() * self.s()
                - self.xz() * operand.zt() * self.yt()
                - self.yt() * operand.xt() * self.s()
                + self.yt() * operand.xy() * self.yt()
                + self.yt() * operand.xz() * self.zt()
                - self.yt() * operand.yt() * self.xy()
                + self.yt() * operand.yz() * self.xyzt()
                - self.yt() * operand.zt() * self.xz()
                - self.yz() * operand.xt() * self.zt()
                - self.yz() * operand.xy() * self.yz()
                + self.yz() * operand.xz() * self.s()
                - self.yz() * operand.yt() * self.xyzt()
                + self.yz() * operand.yz() * self.xy()
                + self.yz() * operand.zt() * self.xt()
                - self.zt() * operand.xt() * self.yz()
                - self.zt() * operand.xy() * self.zt()
                + self.zt() * operand.xz() * self.yt()
                + self.zt() * operand.yt() * self.xz()
                - self.zt() * operand.yz() * self.xt()
                - self.zt() * operand.zt() * self.xy(),
            -(self.s() * operand.xt() * self.zt()) - self.s() * operand.xy() * self.yz()
                + self.s() * operand.xz() * self.s()
                - self.s() * operand.yt() * self.xyzt()
                + self.s() * operand.yz() * self.xy()
                + self.s() * operand.zt() * self.xt()
                - self.xt() * operand.xt() * self.xz()
                - self.xt() * operand.xy() * self.xyzt()
                + self.xt() * operand.xz() * self.xt()
                - self.xt() * operand.yt() * self.yz()
                + self.xt() * operand.yz() * self.yt()
                + self.xt() * operand.zt() * self.s()
                + self.xy() * operand.xt() * self.xyzt()
                + self.xy() * operand.xy() * self.xz()
                - self.xy() * operand.xz() * self.xy()
                - self.xy() * operand.yt() * self.zt()
                + self.xy() * operand.yz() * self.s()
                + self.xy() * operand.zt() * self.yt()
                + self.xyzt() * operand.xt() * self.xy()
                - self.xyzt() * operand.xy() * self.xt()
                - self.xyzt() * operand.xz() * self.xyzt()
                - self.xyzt() * operand.yt() * self.s()
                + self.xyzt() * operand.yz() * self.zt()
                - self.xyzt() * operand.zt() * self.yz()
                - self.xz() * operand.xt() * self.xt()
                + self.xz() * operand.xy() * self.xy()
                + self.xz() * operand.xz() * self.xz()
                - self.xz() * operand.yt() * self.yt()
                + self.xz() * operand.yz() * self.yz()
                - self.xz() * operand.zt() * self.zt()
                + self.yt() * operand.xt() * self.yz()
                + self.yt() * operand.xy() * self.zt()
                - self.yt() * operand.xz() * self.yt()
                - self.yt() * operand.yt() * self.xz()
                + self.yt() * operand.yz() * self.xt()
                + self.yt() * operand.zt() * self.xy()
                + self.yz() * operand.xt() * self.yt()
                - self.yz() * operand.xy() * self.s()
                - self.yz() * operand.xz() * self.yz()
                - self.yz() * operand.yt() * self.xt()
                + self.yz() * operand.yz() * self.xz()
                - self.yz() * operand.zt() * self.xyzt()
                - self.zt() * operand.xt() * self.s()
                + self.zt() * operand.xy() * self.yt()
                + self.zt() * operand.xz() * self.zt()
                - self.zt() * operand.yt() * self.xy()
                + self.zt() * operand.yz() * self.xyzt()
                - self.zt() * operand.zt() * self.xz(),
            self.s() * operand.xt() * self.s()
                - self.s() * operand.xy() * self.yt()
                - self.s() * operand.xz() * self.zt()
                + self.s() * operand.yt() * self.xy()
                - self.s() * operand.yz() * self.xyzt()
                + self.s() * operand.zt() * self.xz()
                - self.xt() * operand.xt() * self.xt()
                + self.xt() * operand.xy() * self.xy()
                + self.xt() * operand.xz() * self.xz()
                - self.xt() * operand.yt() * self.yt()
                + self.xt() * operand.yz() * self.yz()
                - self.xt() * operand.zt() * self.zt()
                - self.xy() * operand.xt() * self.xy()
                + self.xy() * operand.xy() * self.xt()
                + self.xy() * operand.xz() * self.xyzt()
                + self.xy() * operand.yt() * self.s()
                - self.xy() * operand.yz() * self.zt()
                + self.xy() * operand.zt() * self.yz()
                - self.xyzt() * operand.xt() * self.xyzt()
                - self.xyzt() * operand.xy() * self.xz()
                + self.xyzt() * operand.xz() * self.xy()
                + self.xyzt() * operand.yt() * self.zt()
                - self.xyzt() * operand.yz() * self.s()
                - self.xyzt() * operand.zt() * self.yt()
                - self.xz() * operand.xt() * self.xz()
                - self.xz() * operand.xy() * self.xyzt()
                + self.xz() * operand.xz() * self.xt()
                - self.xz() * operand.yt() * self.yz()
                + self.xz() * operand.yz() * self.yt()
                + self.xz() * operand.zt() * self.s()
                + self.yt() * operand.xt() * self.yt()
                - self.yt() * operand.xy() * self.s()
                - self.yt() * operand.xz() * self.yz()
                - self.yt() * operand.yt() * self.xt()
                + self.yt() * operand.yz() * self.xz()
                - self.yt() * operand.zt() * self.xyzt()
                + self.yz() * operand.xt() * self.yz()
                + self.yz() * operand.xy() * self.zt()
                - self.yz() * operand.xz() * self.yt()
                - self.yz() * operand.yt() * self.xz()
                + self.yz() * operand.yz() * self.xt()
                + self.yz() * operand.zt() * self.xy()
                + self.zt() * operand.xt() * self.zt()
                + self.zt() * operand.xy() * self.yz()
                - self.zt() * operand.xz() * self.s()
                + self.zt() * operand.yt() * self.xyzt()
                - self.zt() * operand.yz() * self.xy()
                - self.zt() * operand.zt() * self.xt(),
            self.s() * operand.xt() * self.xyzt() + self.s() * operand.xy() * self.xz()
                - self.s() * operand.xz() * self.xy()
                - self.s() * operand.yt() * self.zt()
                + self.s() * operand.yz() * self.s()
                + self.s() * operand.zt() * self.yt()
                - self.xt() * operand.xt() * self.yz()
                - self.xt() * operand.xy() * self.zt()
                + self.xt() * operand.xz() * self.yt()
                + self.xt() * operand.yt() * self.xz()
                - self.xt() * operand.yz() * self.xt()
                - self.xt() * operand.zt() * self.xy()
                + self.xy() * operand.xt() * self.zt()
                + self.xy() * operand.xy() * self.yz()
                - self.xy() * operand.xz() * self.s()
                + self.xy() * operand.yt() * self.xyzt()
                - self.xy() * operand.yz() * self.xy()
                - self.xy() * operand.zt() * self.xt()
                + self.xyzt() * operand.xt() * self.s()
                - self.xyzt() * operand.xy() * self.yt()
                - self.xyzt() * operand.xz() * self.zt()
                + self.xyzt() * operand.yt() * self.xy()
                - self.xyzt() * operand.yz() * self.xyzt()
                + self.xyzt() * operand.zt() * self.xz()
                - self.xz() * operand.xt() * self.yt()
                + self.xz() * operand.xy() * self.s()
                + self.xz() * operand.xz() * self.yz()
                + self.xz() * operand.yt() * self.xt()
                - self.xz() * operand.yz() * self.xz()
                + self.xz() * operand.zt() * self.xyzt()
                - self.yt() * operand.xt() * self.xz()
                - self.yt() * operand.xy() * self.xyzt()
                + self.yt() * operand.xz() * self.xt()
                - self.yt() * operand.yt() * self.yz()
                + self.yt() * operand.yz() * self.yt()
                + self.yt() * operand.zt() * self.s()
                - self.yz() * operand.xt() * self.xt()
                + self.yz() * operand.xy() * self.xy()
                + self.yz() * operand.xz() * self.xz()
                - self.yz() * operand.yt() * self.yt()
                + self.yz() * operand.yz() * self.yz()
                - self.yz() * operand.zt() * self.zt()
                + self.zt() * operand.xt() * self.xy()
                - self.zt() * operand.xy() * self.xt()
                - self.zt() * operand.xz() * self.xyzt()
                - self.zt() * operand.yt() * self.s()
                + self.zt() * operand.yz() * self.zt()
                - self.zt() * operand.zt() * self.yz(),
            -(self.s() * operand.xt() * self.xy())
                + self.s() * operand.xy() * self.xt()
                + self.s() * operand.xz() * self.xyzt()
                + self.s() * operand.yt() * self.s()
                - self.s() * operand.yz() * self.zt()
                + self.s() * operand.zt() * self.yz()
                - self.xt() * operand.xt() * self.yt()
                + self.xt() * operand.xy() * self.s()
                + self.xt() * operand.xz() * self.yz()
                + self.xt() * operand.yt() * self.xt()
                - self.xt() * operand.yz() * self.xz()
                + self.xt() * operand.zt() * self.xyzt()
                - self.xy() * operand.xt() * self.s()
                + self.xy() * operand.xy() * self.yt()
                + self.xy() * operand.xz() * self.zt()
                - self.xy() * operand.yt() * self.xy()
                + self.xy() * operand.yz() * self.xyzt()
                - self.xy() * operand.zt() * self.xz()
                - self.xyzt() * operand.xt() * self.zt()
                - self.xyzt() * operand.xy() * self.yz()
                + self.xyzt() * operand.xz() * self.s()
                - self.xyzt() * operand.yt() * self.xyzt()
                + self.xyzt() * operand.yz() * self.xy()
                + self.xyzt() * operand.zt() * self.xt()
                - self.xz() * operand.xt() * self.yz()
                - self.xz() * operand.xy() * self.zt()
                + self.xz() * operand.xz() * self.yt()
                + self.xz() * operand.yt() * self.xz()
                - self.xz() * operand.yz() * self.xt()
                - self.xz() * operand.zt() * self.xy()
                - self.yt() * operand.xt() * self.xt()
                + self.yt() * operand.xy() * self.xy()
                + self.yt() * operand.xz() * self.xz()
                - self.yt() * operand.yt() * self.yt()
                + self.yt() * operand.yz() * self.yz()
                - self.yt() * operand.zt() * self.zt()
                - self.yz() * operand.xt() * self.xz()
                - self.yz() * operand.xy() * self.xyzt()
                + self.yz() * operand.xz() * self.xt()
                - self.yz() * operand.yt() * self.yz()
                + self.yz() * operand.yz() * self.yt()
                + self.yz() * operand.zt() * self.s()
                - self.zt() * operand.xt() * self.xyzt()
                - self.zt() * operand.xy() * self.xz()
                + self.zt() * operand.xz() * self.xy()
                + self.zt() * operand.yt() * self.zt()
                - self.zt() * operand.yz() * self.s()
                - self.zt() * operand.zt() * self.yt(),
            -(self.s() * operand.xt() * self.xz()) - self.s() * operand.xy() * self.xyzt()
                + self.s() * operand.xz() * self.xt()
                - self.s() * operand.yt() * self.yz()
                + self.s() * operand.yz() * self.yt()
                + self.s() * operand.zt() * self.s()
                - self.xt() * operand.xt() * self.zt()
                - self.xt() * operand.xy() * self.yz()
                + self.xt() * operand.xz() * self.s()
                - self.xt() * operand.yt() * self.xyzt()
                + self.xt() * operand.yz() * self.xy()
                + self.xt() * operand.zt() * self.xt()
                + self.xy() * operand.xt() * self.yz()
                + self.xy() * operand.xy() * self.zt()
                - self.xy() * operand.xz() * self.yt()
                - self.xy() * operand.yt() * self.xz()
                + self.xy() * operand.yz() * self.xt()
                + self.xy() * operand.zt() * self.xy()
                + self.xyzt() * operand.xt() * self.yt()
                - self.xyzt() * operand.xy() * self.s()
                - self.xyzt() * operand.xz() * self.yz()
                - self.xyzt() * operand.yt() * self.xt()
                + self.xyzt() * operand.yz() * self.xz()
                - self.xyzt() * operand.zt() * self.xyzt()
                - self.xz() * operand.xt() * self.s()
                + self.xz() * operand.xy() * self.yt()
                + self.xz() * operand.xz() * self.zt()
                - self.xz() * operand.yt() * self.xy()
                + self.xz() * operand.yz() * self.xyzt()
                - self.xz() * operand.zt() * self.xz()
                + self.yt() * operand.xt() * self.xyzt()
                + self.yt() * operand.xy() * self.xz()
                - self.yt() * operand.xz() * self.xy()
                - self.yt() * operand.yt() * self.zt()
                + self.yt() * operand.yz() * self.s()
                + self.yt() * operand.zt() * self.yt()
                + self.yz() * operand.xt() * self.xy()
                - self.yz() * operand.xy() * self.xt()
                - self.yz() * operand.xz() * self.xyzt()
                - self.yz() * operand.yt() * self.s()
                + self.yz() * operand.yz() * self.zt()
                - self.yz() * operand.zt() * self.yz()
                - self.zt() * operand.xt() * self.xt()
                + self.zt() * operand.xy() * self.xy()
                + self.zt() * operand.xz() * self.xz()
                - self.zt() * operand.yt() * self.yt()
                + self.zt() * operand.yz() * self.yz()
                - self.zt() * operand.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Unit<Eventor<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -T::TWO * operand.xt() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.xt() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.xt() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.xy() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.xy() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.yt() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.yz() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.xy() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.xz() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.yt() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.yz() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::from_i8(-4i8) * operand.zt() * self.as_inner().xz() * self.as_inner().yt()
                + T::from_i8(4i8) * operand.zt() * self.as_inner().xt() * self.as_inner().yz()
                + operand.xy(),
            -T::TWO * operand.xt() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.xy() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.xz() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.zt() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.zt() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.xt() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.xy() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.xz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.yz() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.yz() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.yz() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.zt() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().yt()
                + T::from_i8(-4i8) * operand.yt() * self.as_inner().xt() * self.as_inner().yz()
                + T::from_i8(-4i8) * operand.yt() * self.as_inner().xy() * self.as_inner().zt()
                + operand.xz(),
            -T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.xt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.xy() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.xy() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.xz() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.zt() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.xt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.xt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.xy() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.yt() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.yt() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.zt() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().yz()
                + T::from_i8(-4i8) * operand.yz() * self.as_inner().xy() * self.as_inner().zt()
                + T::from_i8(4i8) * operand.yz() * self.as_inner().xz() * self.as_inner().yt()
                + operand.xt(),
            -T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.xy() * self.as_inner().xyzt() * self.as_inner().yt()
                + -T::TWO * operand.xz() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.xz() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.yz() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.zt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.yz() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.yz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.zt() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.zt() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::from_i8(-4i8) * operand.xt() * self.as_inner().xz() * self.as_inner().yt()
                + T::from_i8(4i8) * operand.xt() * self.as_inner().xy() * self.as_inner().zt()
                + operand.yz(),
            -T::TWO * operand.xt() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.xt() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.xt() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.xy() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.xy() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.yt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.yz() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.zt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.yt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.yz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.zt() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::from_i8(4i8) * operand.xz() * self.as_inner().xt() * self.as_inner().yz()
                + T::from_i8(4i8) * operand.xz() * self.as_inner().xy() * self.as_inner().zt()
                + operand.yt(),
            -T::TWO * operand.xt() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.xz() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.zt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.zt() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.xt() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.xz() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.yz() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.yz() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.yz() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.zt() * self.as_inner().yt() * self.as_inner().yt()
                + T::from_i8(-4i8) * operand.xy() * self.as_inner().xt() * self.as_inner().yz()
                + T::from_i8(4i8) * operand.xy() * self.as_inner().xz() * self.as_inner().yt()
                + operand.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Eventor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.as_inner().xy() * self.xyzt() * self.xyzt())
                + -(operand.as_inner().xy() * self.xz() * self.xz())
                + -(operand.as_inner().xy() * self.yz() * self.yz())
                + -(operand.as_inner().xy() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xt() * self.s() * self.yt()
                + -T::TWO * operand.as_inner().xt() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().xt() * self.xyzt() * self.xz()
                + -T::TWO * operand.as_inner().xt() * self.yz() * self.zt()
                + -T::TWO * operand.as_inner().yt() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().yt() * self.xyzt() * self.yz()
                + -T::TWO * operand.as_inner().yz() * self.s() * self.xz()
                + -T::TWO * operand.as_inner().yz() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().xz() * self.s() * self.yz()
                + T::TWO * operand.as_inner().xz() * self.xt() * self.xyzt()
                + T::TWO * operand.as_inner().xz() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().xz() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().yt() * self.s() * self.xt()
                + T::TWO * operand.as_inner().yt() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().yz() * self.xyzt() * self.yt()
                + T::from_i8(-4i8) * operand.as_inner().zt() * self.xz() * self.yt()
                + T::from_i8(4i8) * operand.as_inner().zt() * self.xt() * self.yz()
                + operand.as_inner().xy() * self.s() * self.s()
                + operand.as_inner().xy() * self.xt() * self.xt()
                + operand.as_inner().xy() * self.xy() * self.xy()
                + operand.as_inner().xy() * self.yt() * self.yt(),
            -(operand.as_inner().xz() * self.xy() * self.xy())
                + -(operand.as_inner().xz() * self.xyzt() * self.xyzt())
                + -(operand.as_inner().xz() * self.yt() * self.yt())
                + -(operand.as_inner().xz() * self.yz() * self.yz())
                + -T::TWO * operand.as_inner().xt() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().xt() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().xy() * self.s() * self.yz()
                + -T::TWO * operand.as_inner().xy() * self.xt() * self.xyzt()
                + -T::TWO * operand.as_inner().zt() * self.xyzt() * self.yz()
                + -T::TWO * operand.as_inner().zt() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().xt() * self.xy() * self.xyzt()
                + T::TWO * operand.as_inner().xt() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().xy() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().xy() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.s() * self.xy()
                + T::TWO * operand.as_inner().yz() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().yz() * self.xyzt() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().zt() * self.s() * self.xt()
                + T::TWO * operand.as_inner().zt() * self.xy() * self.yt()
                + T::from_i8(-4i8) * operand.as_inner().yt() * self.xt() * self.yz()
                + T::from_i8(-4i8) * operand.as_inner().yt() * self.xy() * self.zt()
                + operand.as_inner().xz() * self.s() * self.s()
                + operand.as_inner().xz() * self.xt() * self.xt()
                + operand.as_inner().xz() * self.xz() * self.xz()
                + operand.as_inner().xz() * self.zt() * self.zt(),
            -(operand.as_inner().xt() * self.xt() * self.xt())
                + -(operand.as_inner().xt() * self.xy() * self.xy())
                + -(operand.as_inner().xt() * self.xyzt() * self.xyzt())
                + -(operand.as_inner().xt() * self.xz() * self.xz())
                + -T::TWO * operand.as_inner().xy() * self.s() * self.yt()
                + -T::TWO * operand.as_inner().xy() * self.xyzt() * self.xz()
                + -T::TWO * operand.as_inner().xz() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().xz() * self.yt() * self.yz()
                + -T::TWO * operand.as_inner().yt() * self.xt() * self.yt()
                + -T::TWO * operand.as_inner().yt() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().zt() * self.xt() * self.zt()
                + -T::TWO * operand.as_inner().zt() * self.xyzt() * self.yt()
                + T::TWO * operand.as_inner().xy() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().xy() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().xz() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().xz() * self.xy() * self.xyzt()
                + T::TWO * operand.as_inner().yt() * self.s() * self.xy()
                + T::TWO * operand.as_inner().yt() * self.xyzt() * self.zt()
                + T::TWO * operand.as_inner().zt() * self.s() * self.xz()
                + T::TWO * operand.as_inner().zt() * self.xy() * self.yz()
                + T::from_i8(-4i8) * operand.as_inner().yz() * self.xy() * self.zt()
                + T::from_i8(4i8) * operand.as_inner().yz() * self.xz() * self.yt()
                + operand.as_inner().xt() * self.s() * self.s()
                + operand.as_inner().xt() * self.yt() * self.yt()
                + operand.as_inner().xt() * self.yz() * self.yz()
                + operand.as_inner().xt() * self.zt() * self.zt(),
            -(operand.as_inner().yz() * self.xt() * self.xt())
                + -(operand.as_inner().yz() * self.xy() * self.xy())
                + -(operand.as_inner().yz() * self.xyzt() * self.xyzt())
                + -(operand.as_inner().yz() * self.xz() * self.xz())
                + -T::TWO * operand.as_inner().xy() * self.xt() * self.zt()
                + -T::TWO * operand.as_inner().xy() * self.xyzt() * self.yt()
                + -T::TWO * operand.as_inner().xz() * self.s() * self.xy()
                + -T::TWO * operand.as_inner().xz() * self.xyzt() * self.zt()
                + -T::TWO * operand.as_inner().yt() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().yt() * self.yt() * self.yz()
                + -T::TWO * operand.as_inner().zt() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().zt() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().xy() * self.s() * self.xz()
                + T::TWO * operand.as_inner().xy() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().xz() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().xz() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().yt() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().yt() * self.xy() * self.xyzt()
                + T::TWO * operand.as_inner().zt() * self.s() * self.yt()
                + T::TWO * operand.as_inner().zt() * self.xyzt() * self.xz()
                + T::from_i8(-4i8) * operand.as_inner().xt() * self.xz() * self.yt()
                + T::from_i8(4i8) * operand.as_inner().xt() * self.xy() * self.zt()
                + operand.as_inner().yz() * self.s() * self.s()
                + operand.as_inner().yz() * self.yt() * self.yt()
                + operand.as_inner().yz() * self.yz() * self.yz()
                + operand.as_inner().yz() * self.zt() * self.zt(),
            -(operand.as_inner().yt() * self.xy() * self.xy())
                + -(operand.as_inner().yt() * self.xyzt() * self.xyzt())
                + -(operand.as_inner().yt() * self.yt() * self.yt())
                + -(operand.as_inner().yt() * self.yz() * self.yz())
                + -T::TWO * operand.as_inner().xt() * self.s() * self.xy()
                + -T::TWO * operand.as_inner().xt() * self.xt() * self.yt()
                + -T::TWO * operand.as_inner().xt() * self.xyzt() * self.zt()
                + -T::TWO * operand.as_inner().xt() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().xy() * self.xyzt() * self.yz()
                + -T::TWO * operand.as_inner().xy() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().yz() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().yz() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().zt() * self.xy() * self.xz()
                + -T::TWO * operand.as_inner().zt() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().xy() * self.s() * self.xt()
                + T::TWO * operand.as_inner().xy() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().yz() * self.xy() * self.xyzt()
                + T::TWO * operand.as_inner().yz() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().zt() * self.s() * self.yz()
                + T::TWO * operand.as_inner().zt() * self.xt() * self.xyzt()
                + T::from_i8(4i8) * operand.as_inner().xz() * self.xt() * self.yz()
                + T::from_i8(4i8) * operand.as_inner().xz() * self.xy() * self.zt()
                + operand.as_inner().yt() * self.s() * self.s()
                + operand.as_inner().yt() * self.xt() * self.xt()
                + operand.as_inner().yt() * self.xz() * self.xz()
                + operand.as_inner().yt() * self.zt() * self.zt(),
            -(operand.as_inner().zt() * self.xyzt() * self.xyzt())
                + -(operand.as_inner().zt() * self.xz() * self.xz())
                + -(operand.as_inner().zt() * self.yz() * self.yz())
                + -(operand.as_inner().zt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xt() * self.s() * self.xz()
                + -T::TWO * operand.as_inner().xt() * self.xt() * self.zt()
                + -T::TWO * operand.as_inner().xz() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().xz() * self.xyzt() * self.yz()
                + -T::TWO * operand.as_inner().yt() * self.s() * self.yz()
                + -T::TWO * operand.as_inner().yt() * self.xt() * self.xyzt()
                + -T::TWO * operand.as_inner().yt() * self.xy() * self.xz()
                + -T::TWO * operand.as_inner().yt() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().xt() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().xt() * self.xyzt() * self.yt()
                + T::TWO * operand.as_inner().xz() * self.s() * self.xt()
                + T::TWO * operand.as_inner().xz() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.s() * self.yt()
                + T::TWO * operand.as_inner().yz() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().yz() * self.xyzt() * self.xz()
                + T::TWO * operand.as_inner().yz() * self.yz() * self.zt()
                + T::from_i8(-4i8) * operand.as_inner().xy() * self.xt() * self.yz()
                + T::from_i8(4i8) * operand.as_inner().xy() * self.xz() * self.yt()
                + operand.as_inner().zt() * self.s() * self.s()
                + operand.as_inner().zt() * self.xt() * self.xt()
                + operand.as_inner().zt() * self.xy() * self.xy()
                + operand.as_inner().zt() * self.yt() * self.yt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Unit<Eventor<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -T::TWO * operand.as_inner().xt() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::from_i8(-4i8)
                    * operand.as_inner().zt()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + T::from_i8(4i8)
                    * operand.as_inner().zt()
                    * self.as_inner().xt()
                    * self.as_inner().yz()
                + operand.as_inner().xy(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().yt()
                + T::from_i8(-4i8)
                    * operand.as_inner().yt()
                    * self.as_inner().xt()
                    * self.as_inner().yz()
                + T::from_i8(-4i8)
                    * operand.as_inner().yt()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + operand.as_inner().xz(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xy() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().yz()
                + T::from_i8(-4i8)
                    * operand.as_inner().yz()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + T::from_i8(4i8)
                    * operand.as_inner().yz()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + operand.as_inner().xt(),
            -T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xyzt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::from_i8(-4i8)
                    * operand.as_inner().xt()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + T::from_i8(4i8)
                    * operand.as_inner().xt()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + operand.as_inner().yz(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::from_i8(4i8)
                    * operand.as_inner().xz()
                    * self.as_inner().xt()
                    * self.as_inner().yz()
                + T::from_i8(4i8)
                    * operand.as_inner().xz()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + operand.as_inner().yt(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().yt() * self.as_inner().yt()
                + T::from_i8(-4i8)
                    * operand.as_inner().xy()
                    * self.as_inner().xt()
                    * self.as_inner().yz()
                + T::from_i8(4i8)
                    * operand.as_inner().xy()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + operand.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            self.s() * operand.s() * self.s() - self.s() * operand.xt() * self.xt()
                + self.s() * operand.xy() * self.xy()
                - self.s() * operand.xyzt() * self.xyzt()
                + self.s() * operand.xz() * self.xz()
                - self.s() * operand.yt() * self.yt()
                + self.s() * operand.yz() * self.yz()
                - self.s() * operand.zt() * self.zt()
                - self.xt() * operand.s() * self.xt()
                + self.xt() * operand.xt() * self.s()
                - self.xt() * operand.xy() * self.yt()
                + self.xt() * operand.xyzt() * self.yz()
                - self.xt() * operand.xz() * self.zt()
                + self.xt() * operand.yt() * self.xy()
                - self.xt() * operand.yz() * self.xyzt()
                + self.xt() * operand.zt() * self.xz()
                + self.xy() * operand.s() * self.xy()
                + self.xy() * operand.xt() * self.yt()
                - self.xy() * operand.xy() * self.s()
                + self.xy() * operand.xyzt() * self.zt()
                - self.xy() * operand.xz() * self.yz()
                - self.xy() * operand.yt() * self.xt()
                + self.xy() * operand.yz() * self.xz()
                - self.xy() * operand.zt() * self.xyzt()
                - self.xyzt() * operand.s() * self.xyzt()
                + self.xyzt() * operand.xt() * self.yz()
                + self.xyzt() * operand.xy() * self.zt()
                - self.xyzt() * operand.xyzt() * self.s()
                - self.xyzt() * operand.xz() * self.yt()
                - self.xyzt() * operand.yt() * self.xz()
                + self.xyzt() * operand.yz() * self.xt()
                + self.xyzt() * operand.zt() * self.xy()
                + self.xz() * operand.s() * self.xz()
                + self.xz() * operand.xt() * self.zt()
                + self.xz() * operand.xy() * self.yz()
                - self.xz() * operand.xyzt() * self.yt()
                - self.xz() * operand.xz() * self.s()
                + self.xz() * operand.yt() * self.xyzt()
                - self.xz() * operand.yz() * self.xy()
                - self.xz() * operand.zt() * self.xt()
                - self.yt() * operand.s() * self.yt()
                - self.yt() * operand.xt() * self.xy()
                + self.yt() * operand.xy() * self.xt()
                - self.yt() * operand.xyzt() * self.xz()
                + self.yt() * operand.xz() * self.xyzt()
                + self.yt() * operand.yt() * self.s()
                - self.yt() * operand.yz() * self.zt()
                + self.yt() * operand.zt() * self.yz()
                + self.yz() * operand.s() * self.yz()
                - self.yz() * operand.xt() * self.xyzt()
                - self.yz() * operand.xy() * self.xz()
                + self.yz() * operand.xyzt() * self.xt()
                + self.yz() * operand.xz() * self.xy()
                + self.yz() * operand.yt() * self.zt()
                - self.yz() * operand.yz() * self.s()
                - self.yz() * operand.zt() * self.yt()
                - self.zt() * operand.s() * self.zt()
                - self.zt() * operand.xt() * self.xz()
                - self.zt() * operand.xy() * self.xyzt()
                + self.zt() * operand.xyzt() * self.xy()
                + self.zt() * operand.xz() * self.xt()
                - self.zt() * operand.yt() * self.yz()
                + self.zt() * operand.yz() * self.yt()
                + self.zt() * operand.zt() * self.s(),
            -(self.s() * operand.s() * self.xy()) - self.s() * operand.xt() * self.yt()
                + self.s() * operand.xy() * self.s()
                - self.s() * operand.xyzt() * self.zt()
                + self.s() * operand.xz() * self.yz()
                + self.s() * operand.yt() * self.xt()
                - self.s() * operand.yz() * self.xz()
                + self.s() * operand.zt() * self.xyzt()
                - self.xt() * operand.s() * self.yt()
                - self.xt() * operand.xt() * self.xy()
                + self.xt() * operand.xy() * self.xt()
                - self.xt() * operand.xyzt() * self.xz()
                + self.xt() * operand.xz() * self.xyzt()
                + self.xt() * operand.yt() * self.s()
                - self.xt() * operand.yz() * self.zt()
                + self.xt() * operand.zt() * self.yz()
                + self.xy() * operand.s() * self.s()
                - self.xy() * operand.xt() * self.xt()
                + self.xy() * operand.xy() * self.xy()
                - self.xy() * operand.xyzt() * self.xyzt()
                + self.xy() * operand.xz() * self.xz()
                - self.xy() * operand.yt() * self.yt()
                + self.xy() * operand.yz() * self.yz()
                - self.xy() * operand.zt() * self.zt()
                - self.xyzt() * operand.s() * self.zt()
                - self.xyzt() * operand.xt() * self.xz()
                - self.xyzt() * operand.xy() * self.xyzt()
                + self.xyzt() * operand.xyzt() * self.xy()
                + self.xyzt() * operand.xz() * self.xt()
                - self.xyzt() * operand.yt() * self.yz()
                + self.xyzt() * operand.yz() * self.yt()
                + self.xyzt() * operand.zt() * self.s()
                + self.xz() * operand.s() * self.yz()
                - self.xz() * operand.xt() * self.xyzt()
                - self.xz() * operand.xy() * self.xz()
                + self.xz() * operand.xyzt() * self.xt()
                + self.xz() * operand.xz() * self.xy()
                + self.xz() * operand.yt() * self.zt()
                - self.xz() * operand.yz() * self.s()
                - self.xz() * operand.zt() * self.yt()
                + self.yt() * operand.s() * self.xt()
                - self.yt() * operand.xt() * self.s()
                + self.yt() * operand.xy() * self.yt()
                - self.yt() * operand.xyzt() * self.yz()
                + self.yt() * operand.xz() * self.zt()
                - self.yt() * operand.yt() * self.xy()
                + self.yt() * operand.yz() * self.xyzt()
                - self.yt() * operand.zt() * self.xz()
                - self.yz() * operand.s() * self.xz()
                - self.yz() * operand.xt() * self.zt()
                - self.yz() * operand.xy() * self.yz()
                + self.yz() * operand.xyzt() * self.yt()
                + self.yz() * operand.xz() * self.s()
                - self.yz() * operand.yt() * self.xyzt()
                + self.yz() * operand.yz() * self.xy()
                + self.yz() * operand.zt() * self.xt()
                + self.zt() * operand.s() * self.xyzt()
                - self.zt() * operand.xt() * self.yz()
                - self.zt() * operand.xy() * self.zt()
                + self.zt() * operand.xyzt() * self.s()
                + self.zt() * operand.xz() * self.yt()
                + self.zt() * operand.yt() * self.xz()
                - self.zt() * operand.yz() * self.xt()
                - self.zt() * operand.zt() * self.xy(),
            -(self.s() * operand.s() * self.xz())
                - self.s() * operand.xt() * self.zt()
                - self.s() * operand.xy() * self.yz()
                + self.s() * operand.xyzt() * self.yt()
                + self.s() * operand.xz() * self.s()
                - self.s() * operand.yt() * self.xyzt()
                + self.s() * operand.yz() * self.xy()
                + self.s() * operand.zt() * self.xt()
                - self.xt() * operand.s() * self.zt()
                - self.xt() * operand.xt() * self.xz()
                - self.xt() * operand.xy() * self.xyzt()
                + self.xt() * operand.xyzt() * self.xy()
                + self.xt() * operand.xz() * self.xt()
                - self.xt() * operand.yt() * self.yz()
                + self.xt() * operand.yz() * self.yt()
                + self.xt() * operand.zt() * self.s()
                - self.xy() * operand.s() * self.yz()
                + self.xy() * operand.xt() * self.xyzt()
                + self.xy() * operand.xy() * self.xz()
                - self.xy() * operand.xyzt() * self.xt()
                - self.xy() * operand.xz() * self.xy()
                - self.xy() * operand.yt() * self.zt()
                + self.xy() * operand.yz() * self.s()
                + self.xy() * operand.zt() * self.yt()
                + self.xyzt() * operand.s() * self.yt()
                + self.xyzt() * operand.xt() * self.xy()
                - self.xyzt() * operand.xy() * self.xt()
                + self.xyzt() * operand.xyzt() * self.xz()
                - self.xyzt() * operand.xz() * self.xyzt()
                - self.xyzt() * operand.yt() * self.s()
                + self.xyzt() * operand.yz() * self.zt()
                - self.xyzt() * operand.zt() * self.yz()
                + self.xz() * operand.s() * self.s()
                - self.xz() * operand.xt() * self.xt()
                + self.xz() * operand.xy() * self.xy()
                - self.xz() * operand.xyzt() * self.xyzt()
                + self.xz() * operand.xz() * self.xz()
                - self.xz() * operand.yt() * self.yt()
                + self.xz() * operand.yz() * self.yz()
                - self.xz() * operand.zt() * self.zt()
                - self.yt() * operand.s() * self.xyzt()
                + self.yt() * operand.xt() * self.yz()
                + self.yt() * operand.xy() * self.zt()
                - self.yt() * operand.xyzt() * self.s()
                - self.yt() * operand.xz() * self.yt()
                - self.yt() * operand.yt() * self.xz()
                + self.yt() * operand.yz() * self.xt()
                + self.yt() * operand.zt() * self.xy()
                + self.yz() * operand.s() * self.xy()
                + self.yz() * operand.xt() * self.yt()
                - self.yz() * operand.xy() * self.s()
                + self.yz() * operand.xyzt() * self.zt()
                - self.yz() * operand.xz() * self.yz()
                - self.yz() * operand.yt() * self.xt()
                + self.yz() * operand.yz() * self.xz()
                - self.yz() * operand.zt() * self.xyzt()
                + self.zt() * operand.s() * self.xt()
                - self.zt() * operand.xt() * self.s()
                + self.zt() * operand.xy() * self.yt()
                - self.zt() * operand.xyzt() * self.yz()
                + self.zt() * operand.xz() * self.zt()
                - self.zt() * operand.yt() * self.xy()
                + self.zt() * operand.yz() * self.xyzt()
                - self.zt() * operand.zt() * self.xz(),
            -(self.s() * operand.s() * self.xt()) + self.s() * operand.xt() * self.s()
                - self.s() * operand.xy() * self.yt()
                + self.s() * operand.xyzt() * self.yz()
                - self.s() * operand.xz() * self.zt()
                + self.s() * operand.yt() * self.xy()
                - self.s() * operand.yz() * self.xyzt()
                + self.s() * operand.zt() * self.xz()
                + self.xt() * operand.s() * self.s()
                - self.xt() * operand.xt() * self.xt()
                + self.xt() * operand.xy() * self.xy()
                - self.xt() * operand.xyzt() * self.xyzt()
                + self.xt() * operand.xz() * self.xz()
                - self.xt() * operand.yt() * self.yt()
                + self.xt() * operand.yz() * self.yz()
                - self.xt() * operand.zt() * self.zt()
                - self.xy() * operand.s() * self.yt()
                - self.xy() * operand.xt() * self.xy()
                + self.xy() * operand.xy() * self.xt()
                - self.xy() * operand.xyzt() * self.xz()
                + self.xy() * operand.xz() * self.xyzt()
                + self.xy() * operand.yt() * self.s()
                - self.xy() * operand.yz() * self.zt()
                + self.xy() * operand.zt() * self.yz()
                + self.xyzt() * operand.s() * self.yz()
                - self.xyzt() * operand.xt() * self.xyzt()
                - self.xyzt() * operand.xy() * self.xz()
                + self.xyzt() * operand.xyzt() * self.xt()
                + self.xyzt() * operand.xz() * self.xy()
                + self.xyzt() * operand.yt() * self.zt()
                - self.xyzt() * operand.yz() * self.s()
                - self.xyzt() * operand.zt() * self.yt()
                - self.xz() * operand.s() * self.zt()
                - self.xz() * operand.xt() * self.xz()
                - self.xz() * operand.xy() * self.xyzt()
                + self.xz() * operand.xyzt() * self.xy()
                + self.xz() * operand.xz() * self.xt()
                - self.xz() * operand.yt() * self.yz()
                + self.xz() * operand.yz() * self.yt()
                + self.xz() * operand.zt() * self.s()
                + self.yt() * operand.s() * self.xy()
                + self.yt() * operand.xt() * self.yt()
                - self.yt() * operand.xy() * self.s()
                + self.yt() * operand.xyzt() * self.zt()
                - self.yt() * operand.xz() * self.yz()
                - self.yt() * operand.yt() * self.xt()
                + self.yt() * operand.yz() * self.xz()
                - self.yt() * operand.zt() * self.xyzt()
                - self.yz() * operand.s() * self.xyzt()
                + self.yz() * operand.xt() * self.yz()
                + self.yz() * operand.xy() * self.zt()
                - self.yz() * operand.xyzt() * self.s()
                - self.yz() * operand.xz() * self.yt()
                - self.yz() * operand.yt() * self.xz()
                + self.yz() * operand.yz() * self.xt()
                + self.yz() * operand.zt() * self.xy()
                + self.zt() * operand.s() * self.xz()
                + self.zt() * operand.xt() * self.zt()
                + self.zt() * operand.xy() * self.yz()
                - self.zt() * operand.xyzt() * self.yt()
                - self.zt() * operand.xz() * self.s()
                + self.zt() * operand.yt() * self.xyzt()
                - self.zt() * operand.yz() * self.xy()
                - self.zt() * operand.zt() * self.xt(),
            -(self.s() * operand.s() * self.yz())
                + self.s() * operand.xt() * self.xyzt()
                + self.s() * operand.xy() * self.xz()
                - self.s() * operand.xyzt() * self.xt()
                - self.s() * operand.xz() * self.xy()
                - self.s() * operand.yt() * self.zt()
                + self.s() * operand.yz() * self.s()
                + self.s() * operand.zt() * self.yt()
                + self.xt() * operand.s() * self.xyzt()
                - self.xt() * operand.xt() * self.yz()
                - self.xt() * operand.xy() * self.zt()
                + self.xt() * operand.xyzt() * self.s()
                + self.xt() * operand.xz() * self.yt()
                + self.xt() * operand.yt() * self.xz()
                - self.xt() * operand.yz() * self.xt()
                - self.xt() * operand.zt() * self.xy()
                + self.xy() * operand.s() * self.xz()
                + self.xy() * operand.xt() * self.zt()
                + self.xy() * operand.xy() * self.yz()
                - self.xy() * operand.xyzt() * self.yt()
                - self.xy() * operand.xz() * self.s()
                + self.xy() * operand.yt() * self.xyzt()
                - self.xy() * operand.yz() * self.xy()
                - self.xy() * operand.zt() * self.xt()
                - self.xyzt() * operand.s() * self.xt()
                + self.xyzt() * operand.xt() * self.s()
                - self.xyzt() * operand.xy() * self.yt()
                + self.xyzt() * operand.xyzt() * self.yz()
                - self.xyzt() * operand.xz() * self.zt()
                + self.xyzt() * operand.yt() * self.xy()
                - self.xyzt() * operand.yz() * self.xyzt()
                + self.xyzt() * operand.zt() * self.xz()
                - self.xz() * operand.s() * self.xy()
                - self.xz() * operand.xt() * self.yt()
                + self.xz() * operand.xy() * self.s()
                - self.xz() * operand.xyzt() * self.zt()
                + self.xz() * operand.xz() * self.yz()
                + self.xz() * operand.yt() * self.xt()
                - self.xz() * operand.yz() * self.xz()
                + self.xz() * operand.zt() * self.xyzt()
                - self.yt() * operand.s() * self.zt()
                - self.yt() * operand.xt() * self.xz()
                - self.yt() * operand.xy() * self.xyzt()
                + self.yt() * operand.xyzt() * self.xy()
                + self.yt() * operand.xz() * self.xt()
                - self.yt() * operand.yt() * self.yz()
                + self.yt() * operand.yz() * self.yt()
                + self.yt() * operand.zt() * self.s()
                + self.yz() * operand.s() * self.s()
                - self.yz() * operand.xt() * self.xt()
                + self.yz() * operand.xy() * self.xy()
                - self.yz() * operand.xyzt() * self.xyzt()
                + self.yz() * operand.xz() * self.xz()
                - self.yz() * operand.yt() * self.yt()
                + self.yz() * operand.yz() * self.yz()
                - self.yz() * operand.zt() * self.zt()
                + self.zt() * operand.s() * self.yt()
                + self.zt() * operand.xt() * self.xy()
                - self.zt() * operand.xy() * self.xt()
                + self.zt() * operand.xyzt() * self.xz()
                - self.zt() * operand.xz() * self.xyzt()
                - self.zt() * operand.yt() * self.s()
                + self.zt() * operand.yz() * self.zt()
                - self.zt() * operand.zt() * self.yz(),
            -(self.s() * operand.s() * self.yt()) - self.s() * operand.xt() * self.xy()
                + self.s() * operand.xy() * self.xt()
                - self.s() * operand.xyzt() * self.xz()
                + self.s() * operand.xz() * self.xyzt()
                + self.s() * operand.yt() * self.s()
                - self.s() * operand.yz() * self.zt()
                + self.s() * operand.zt() * self.yz()
                - self.xt() * operand.s() * self.xy()
                - self.xt() * operand.xt() * self.yt()
                + self.xt() * operand.xy() * self.s()
                - self.xt() * operand.xyzt() * self.zt()
                + self.xt() * operand.xz() * self.yz()
                + self.xt() * operand.yt() * self.xt()
                - self.xt() * operand.yz() * self.xz()
                + self.xt() * operand.zt() * self.xyzt()
                + self.xy() * operand.s() * self.xt()
                - self.xy() * operand.xt() * self.s()
                + self.xy() * operand.xy() * self.yt()
                - self.xy() * operand.xyzt() * self.yz()
                + self.xy() * operand.xz() * self.zt()
                - self.xy() * operand.yt() * self.xy()
                + self.xy() * operand.yz() * self.xyzt()
                - self.xy() * operand.zt() * self.xz()
                - self.xyzt() * operand.s() * self.xz()
                - self.xyzt() * operand.xt() * self.zt()
                - self.xyzt() * operand.xy() * self.yz()
                + self.xyzt() * operand.xyzt() * self.yt()
                + self.xyzt() * operand.xz() * self.s()
                - self.xyzt() * operand.yt() * self.xyzt()
                + self.xyzt() * operand.yz() * self.xy()
                + self.xyzt() * operand.zt() * self.xt()
                + self.xz() * operand.s() * self.xyzt()
                - self.xz() * operand.xt() * self.yz()
                - self.xz() * operand.xy() * self.zt()
                + self.xz() * operand.xyzt() * self.s()
                + self.xz() * operand.xz() * self.yt()
                + self.xz() * operand.yt() * self.xz()
                - self.xz() * operand.yz() * self.xt()
                - self.xz() * operand.zt() * self.xy()
                + self.yt() * operand.s() * self.s()
                - self.yt() * operand.xt() * self.xt()
                + self.yt() * operand.xy() * self.xy()
                - self.yt() * operand.xyzt() * self.xyzt()
                + self.yt() * operand.xz() * self.xz()
                - self.yt() * operand.yt() * self.yt()
                + self.yt() * operand.yz() * self.yz()
                - self.yt() * operand.zt() * self.zt()
                - self.yz() * operand.s() * self.zt()
                - self.yz() * operand.xt() * self.xz()
                - self.yz() * operand.xy() * self.xyzt()
                + self.yz() * operand.xyzt() * self.xy()
                + self.yz() * operand.xz() * self.xt()
                - self.yz() * operand.yt() * self.yz()
                + self.yz() * operand.yz() * self.yt()
                + self.yz() * operand.zt() * self.s()
                + self.zt() * operand.s() * self.yz()
                - self.zt() * operand.xt() * self.xyzt()
                - self.zt() * operand.xy() * self.xz()
                + self.zt() * operand.xyzt() * self.xt()
                + self.zt() * operand.xz() * self.xy()
                + self.zt() * operand.yt() * self.zt()
                - self.zt() * operand.yz() * self.s()
                - self.zt() * operand.zt() * self.yt(),
            -(self.s() * operand.s() * self.zt())
                - self.s() * operand.xt() * self.xz()
                - self.s() * operand.xy() * self.xyzt()
                + self.s() * operand.xyzt() * self.xy()
                + self.s() * operand.xz() * self.xt()
                - self.s() * operand.yt() * self.yz()
                + self.s() * operand.yz() * self.yt()
                + self.s() * operand.zt() * self.s()
                - self.xt() * operand.s() * self.xz()
                - self.xt() * operand.xt() * self.zt()
                - self.xt() * operand.xy() * self.yz()
                + self.xt() * operand.xyzt() * self.yt()
                + self.xt() * operand.xz() * self.s()
                - self.xt() * operand.yt() * self.xyzt()
                + self.xt() * operand.yz() * self.xy()
                + self.xt() * operand.zt() * self.xt()
                - self.xy() * operand.s() * self.xyzt()
                + self.xy() * operand.xt() * self.yz()
                + self.xy() * operand.xy() * self.zt()
                - self.xy() * operand.xyzt() * self.s()
                - self.xy() * operand.xz() * self.yt()
                - self.xy() * operand.yt() * self.xz()
                + self.xy() * operand.yz() * self.xt()
                + self.xy() * operand.zt() * self.xy()
                + self.xyzt() * operand.s() * self.xy()
                + self.xyzt() * operand.xt() * self.yt()
                - self.xyzt() * operand.xy() * self.s()
                + self.xyzt() * operand.xyzt() * self.zt()
                - self.xyzt() * operand.xz() * self.yz()
                - self.xyzt() * operand.yt() * self.xt()
                + self.xyzt() * operand.yz() * self.xz()
                - self.xyzt() * operand.zt() * self.xyzt()
                + self.xz() * operand.s() * self.xt()
                - self.xz() * operand.xt() * self.s()
                + self.xz() * operand.xy() * self.yt()
                - self.xz() * operand.xyzt() * self.yz()
                + self.xz() * operand.xz() * self.zt()
                - self.xz() * operand.yt() * self.xy()
                + self.xz() * operand.yz() * self.xyzt()
                - self.xz() * operand.zt() * self.xz()
                - self.yt() * operand.s() * self.yz()
                + self.yt() * operand.xt() * self.xyzt()
                + self.yt() * operand.xy() * self.xz()
                - self.yt() * operand.xyzt() * self.xt()
                - self.yt() * operand.xz() * self.xy()
                - self.yt() * operand.yt() * self.zt()
                + self.yt() * operand.yz() * self.s()
                + self.yt() * operand.zt() * self.yt()
                + self.yz() * operand.s() * self.yt()
                + self.yz() * operand.xt() * self.xy()
                - self.yz() * operand.xy() * self.xt()
                + self.yz() * operand.xyzt() * self.xz()
                - self.yz() * operand.xz() * self.xyzt()
                - self.yz() * operand.yt() * self.s()
                + self.yz() * operand.yz() * self.zt()
                - self.yz() * operand.zt() * self.yz()
                + self.zt() * operand.s() * self.s()
                - self.zt() * operand.xt() * self.xt()
                + self.zt() * operand.xy() * self.xy()
                - self.zt() * operand.xyzt() * self.xyzt()
                + self.zt() * operand.xz() * self.xz()
                - self.zt() * operand.yt() * self.yt()
                + self.zt() * operand.yz() * self.yz()
                - self.zt() * operand.zt() * self.zt(),
            self.s() * operand.s() * self.xyzt()
                - self.s() * operand.xt() * self.yz()
                - self.s() * operand.xy() * self.zt()
                + self.s() * operand.xyzt() * self.s()
                + self.s() * operand.xz() * self.yt()
                + self.s() * operand.yt() * self.xz()
                - self.s() * operand.yz() * self.xt()
                - self.s() * operand.zt() * self.xy()
                - self.xt() * operand.s() * self.yz()
                + self.xt() * operand.xt() * self.xyzt()
                + self.xt() * operand.xy() * self.xz()
                - self.xt() * operand.xyzt() * self.xt()
                - self.xt() * operand.xz() * self.xy()
                - self.xt() * operand.yt() * self.zt()
                + self.xt() * operand.yz() * self.s()
                + self.xt() * operand.zt() * self.yt()
                - self.xy() * operand.s() * self.zt()
                - self.xy() * operand.xt() * self.xz()
                - self.xy() * operand.xy() * self.xyzt()
                + self.xy() * operand.xyzt() * self.xy()
                + self.xy() * operand.xz() * self.xt()
                - self.xy() * operand.yt() * self.yz()
                + self.xy() * operand.yz() * self.yt()
                + self.xy() * operand.zt() * self.s()
                + self.xyzt() * operand.s() * self.s()
                - self.xyzt() * operand.xt() * self.xt()
                + self.xyzt() * operand.xy() * self.xy()
                - self.xyzt() * operand.xyzt() * self.xyzt()
                + self.xyzt() * operand.xz() * self.xz()
                - self.xyzt() * operand.yt() * self.yt()
                + self.xyzt() * operand.yz() * self.yz()
                - self.xyzt() * operand.zt() * self.zt()
                + self.xz() * operand.s() * self.yt()
                + self.xz() * operand.xt() * self.xy()
                - self.xz() * operand.xy() * self.xt()
                + self.xz() * operand.xyzt() * self.xz()
                - self.xz() * operand.xz() * self.xyzt()
                - self.xz() * operand.yt() * self.s()
                + self.xz() * operand.yz() * self.zt()
                - self.xz() * operand.zt() * self.yz()
                + self.yt() * operand.s() * self.xz()
                + self.yt() * operand.xt() * self.zt()
                + self.yt() * operand.xy() * self.yz()
                - self.yt() * operand.xyzt() * self.yt()
                - self.yt() * operand.xz() * self.s()
                + self.yt() * operand.yt() * self.xyzt()
                - self.yt() * operand.yz() * self.xy()
                - self.yt() * operand.zt() * self.xt()
                - self.yz() * operand.s() * self.xt()
                + self.yz() * operand.xt() * self.s()
                - self.yz() * operand.xy() * self.yt()
                + self.yz() * operand.xyzt() * self.yz()
                - self.yz() * operand.xz() * self.zt()
                + self.yz() * operand.yt() * self.xy()
                - self.yz() * operand.yz() * self.xyzt()
                + self.yz() * operand.zt() * self.xz()
                - self.zt() * operand.s() * self.xy()
                - self.zt() * operand.xt() * self.yt()
                + self.zt() * operand.xy() * self.s()
                - self.zt() * operand.xyzt() * self.zt()
                + self.zt() * operand.xz() * self.yz()
                + self.zt() * operand.yt() * self.xt()
                - self.zt() * operand.yz() * self.xz()
                + self.zt() * operand.zt() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Unit<Eventor<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            operand.s(),
            -T::TWO * operand.xt() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.xt() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.xt() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.xy() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.xy() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.yt() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.yz() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.xy() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.xz() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.yt() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.yz() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::from_i8(-4i8) * operand.zt() * self.as_inner().xz() * self.as_inner().yt()
                + T::from_i8(4i8) * operand.zt() * self.as_inner().xt() * self.as_inner().yz()
                + operand.xy(),
            -T::TWO * operand.xt() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.xy() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.xz() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.zt() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.zt() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.xt() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.xy() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.xz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.yz() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.yz() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.yz() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.zt() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().yt()
                + T::from_i8(-4i8) * operand.yt() * self.as_inner().xt() * self.as_inner().yz()
                + T::from_i8(-4i8) * operand.yt() * self.as_inner().xy() * self.as_inner().zt()
                + operand.xz(),
            -T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.xt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.xy() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.xy() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.xz() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.zt() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.xt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.xt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.xy() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.yt() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.yt() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.zt() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().yz()
                + T::from_i8(-4i8) * operand.yz() * self.as_inner().xy() * self.as_inner().zt()
                + T::from_i8(4i8) * operand.yz() * self.as_inner().xz() * self.as_inner().yt()
                + operand.xt(),
            -T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.xy() * self.as_inner().xyzt() * self.as_inner().yt()
                + -T::TWO * operand.xz() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.xz() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.yz() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.zt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.yz() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.yz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.zt() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.zt() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::from_i8(-4i8) * operand.xt() * self.as_inner().xz() * self.as_inner().yt()
                + T::from_i8(4i8) * operand.xt() * self.as_inner().xy() * self.as_inner().zt()
                + operand.yz(),
            -T::TWO * operand.xt() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.xt() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.xt() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.xy() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.xy() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.yt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.yz() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.zt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.yt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.yz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.zt() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::from_i8(4i8) * operand.xz() * self.as_inner().xt() * self.as_inner().yz()
                + T::from_i8(4i8) * operand.xz() * self.as_inner().xy() * self.as_inner().zt()
                + operand.yt(),
            -T::TWO * operand.xt() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.xz() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.zt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.zt() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.xt() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.xz() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.yz() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.yz() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.yz() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.zt() * self.as_inner().yt() * self.as_inner().yt()
                + T::from_i8(-4i8) * operand.xy() * self.as_inner().xt() * self.as_inner().yz()
                + T::from_i8(4i8) * operand.xy() * self.as_inner().xz() * self.as_inner().yt()
                + operand.zt(),
            operand.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.as_inner().s() * self.xt() * self.xt())
                + -(operand.as_inner().s() * self.xyzt() * self.xyzt())
                + -(operand.as_inner().s() * self.yt() * self.yt())
                + -(operand.as_inner().s() * self.zt() * self.zt())
                + operand.as_inner().s() * self.s() * self.s()
                + operand.as_inner().s() * self.xy() * self.xy()
                + operand.as_inner().s() * self.xz() * self.xz()
                + operand.as_inner().s() * self.yz() * self.yz(),
            -(operand.as_inner().xy() * self.xyzt() * self.xyzt())
                + -(operand.as_inner().xy() * self.xz() * self.xz())
                + -(operand.as_inner().xy() * self.yz() * self.yz())
                + -(operand.as_inner().xy() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xt() * self.s() * self.yt()
                + -T::TWO * operand.as_inner().xt() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().xt() * self.xyzt() * self.xz()
                + -T::TWO * operand.as_inner().xt() * self.yz() * self.zt()
                + -T::TWO * operand.as_inner().yt() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().yt() * self.xyzt() * self.yz()
                + -T::TWO * operand.as_inner().yz() * self.s() * self.xz()
                + -T::TWO * operand.as_inner().yz() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().xz() * self.s() * self.yz()
                + T::TWO * operand.as_inner().xz() * self.xt() * self.xyzt()
                + T::TWO * operand.as_inner().xz() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().xz() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().yt() * self.s() * self.xt()
                + T::TWO * operand.as_inner().yt() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().yz() * self.xyzt() * self.yt()
                + T::from_i8(-4i8) * operand.as_inner().zt() * self.xz() * self.yt()
                + T::from_i8(4i8) * operand.as_inner().zt() * self.xt() * self.yz()
                + operand.as_inner().xy() * self.s() * self.s()
                + operand.as_inner().xy() * self.xt() * self.xt()
                + operand.as_inner().xy() * self.xy() * self.xy()
                + operand.as_inner().xy() * self.yt() * self.yt(),
            -(operand.as_inner().xz() * self.xy() * self.xy())
                + -(operand.as_inner().xz() * self.xyzt() * self.xyzt())
                + -(operand.as_inner().xz() * self.yt() * self.yt())
                + -(operand.as_inner().xz() * self.yz() * self.yz())
                + -T::TWO * operand.as_inner().xt() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().xt() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().xy() * self.s() * self.yz()
                + -T::TWO * operand.as_inner().xy() * self.xt() * self.xyzt()
                + -T::TWO * operand.as_inner().zt() * self.xyzt() * self.yz()
                + -T::TWO * operand.as_inner().zt() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().xt() * self.xy() * self.xyzt()
                + T::TWO * operand.as_inner().xt() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().xy() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().xy() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.s() * self.xy()
                + T::TWO * operand.as_inner().yz() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().yz() * self.xyzt() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().zt() * self.s() * self.xt()
                + T::TWO * operand.as_inner().zt() * self.xy() * self.yt()
                + T::from_i8(-4i8) * operand.as_inner().yt() * self.xt() * self.yz()
                + T::from_i8(-4i8) * operand.as_inner().yt() * self.xy() * self.zt()
                + operand.as_inner().xz() * self.s() * self.s()
                + operand.as_inner().xz() * self.xt() * self.xt()
                + operand.as_inner().xz() * self.xz() * self.xz()
                + operand.as_inner().xz() * self.zt() * self.zt(),
            -(operand.as_inner().xt() * self.xt() * self.xt())
                + -(operand.as_inner().xt() * self.xy() * self.xy())
                + -(operand.as_inner().xt() * self.xyzt() * self.xyzt())
                + -(operand.as_inner().xt() * self.xz() * self.xz())
                + -T::TWO * operand.as_inner().xy() * self.s() * self.yt()
                + -T::TWO * operand.as_inner().xy() * self.xyzt() * self.xz()
                + -T::TWO * operand.as_inner().xz() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().xz() * self.yt() * self.yz()
                + -T::TWO * operand.as_inner().yt() * self.xt() * self.yt()
                + -T::TWO * operand.as_inner().yt() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().zt() * self.xt() * self.zt()
                + -T::TWO * operand.as_inner().zt() * self.xyzt() * self.yt()
                + T::TWO * operand.as_inner().xy() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().xy() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().xz() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().xz() * self.xy() * self.xyzt()
                + T::TWO * operand.as_inner().yt() * self.s() * self.xy()
                + T::TWO * operand.as_inner().yt() * self.xyzt() * self.zt()
                + T::TWO * operand.as_inner().zt() * self.s() * self.xz()
                + T::TWO * operand.as_inner().zt() * self.xy() * self.yz()
                + T::from_i8(-4i8) * operand.as_inner().yz() * self.xy() * self.zt()
                + T::from_i8(4i8) * operand.as_inner().yz() * self.xz() * self.yt()
                + operand.as_inner().xt() * self.s() * self.s()
                + operand.as_inner().xt() * self.yt() * self.yt()
                + operand.as_inner().xt() * self.yz() * self.yz()
                + operand.as_inner().xt() * self.zt() * self.zt(),
            -(operand.as_inner().yz() * self.xt() * self.xt())
                + -(operand.as_inner().yz() * self.xy() * self.xy())
                + -(operand.as_inner().yz() * self.xyzt() * self.xyzt())
                + -(operand.as_inner().yz() * self.xz() * self.xz())
                + -T::TWO * operand.as_inner().xy() * self.xt() * self.zt()
                + -T::TWO * operand.as_inner().xy() * self.xyzt() * self.yt()
                + -T::TWO * operand.as_inner().xz() * self.s() * self.xy()
                + -T::TWO * operand.as_inner().xz() * self.xyzt() * self.zt()
                + -T::TWO * operand.as_inner().yt() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().yt() * self.yt() * self.yz()
                + -T::TWO * operand.as_inner().zt() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().zt() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().xy() * self.s() * self.xz()
                + T::TWO * operand.as_inner().xy() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().xz() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().xz() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().yt() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().yt() * self.xy() * self.xyzt()
                + T::TWO * operand.as_inner().zt() * self.s() * self.yt()
                + T::TWO * operand.as_inner().zt() * self.xyzt() * self.xz()
                + T::from_i8(-4i8) * operand.as_inner().xt() * self.xz() * self.yt()
                + T::from_i8(4i8) * operand.as_inner().xt() * self.xy() * self.zt()
                + operand.as_inner().yz() * self.s() * self.s()
                + operand.as_inner().yz() * self.yt() * self.yt()
                + operand.as_inner().yz() * self.yz() * self.yz()
                + operand.as_inner().yz() * self.zt() * self.zt(),
            -(operand.as_inner().yt() * self.xy() * self.xy())
                + -(operand.as_inner().yt() * self.xyzt() * self.xyzt())
                + -(operand.as_inner().yt() * self.yt() * self.yt())
                + -(operand.as_inner().yt() * self.yz() * self.yz())
                + -T::TWO * operand.as_inner().xt() * self.s() * self.xy()
                + -T::TWO * operand.as_inner().xt() * self.xt() * self.yt()
                + -T::TWO * operand.as_inner().xt() * self.xyzt() * self.zt()
                + -T::TWO * operand.as_inner().xt() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().xy() * self.xyzt() * self.yz()
                + -T::TWO * operand.as_inner().xy() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().yz() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().yz() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().zt() * self.xy() * self.xz()
                + -T::TWO * operand.as_inner().zt() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().xy() * self.s() * self.xt()
                + T::TWO * operand.as_inner().xy() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().yz() * self.xy() * self.xyzt()
                + T::TWO * operand.as_inner().yz() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().zt() * self.s() * self.yz()
                + T::TWO * operand.as_inner().zt() * self.xt() * self.xyzt()
                + T::from_i8(4i8) * operand.as_inner().xz() * self.xt() * self.yz()
                + T::from_i8(4i8) * operand.as_inner().xz() * self.xy() * self.zt()
                + operand.as_inner().yt() * self.s() * self.s()
                + operand.as_inner().yt() * self.xt() * self.xt()
                + operand.as_inner().yt() * self.xz() * self.xz()
                + operand.as_inner().yt() * self.zt() * self.zt(),
            -(operand.as_inner().zt() * self.xyzt() * self.xyzt())
                + -(operand.as_inner().zt() * self.xz() * self.xz())
                + -(operand.as_inner().zt() * self.yz() * self.yz())
                + -(operand.as_inner().zt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xt() * self.s() * self.xz()
                + -T::TWO * operand.as_inner().xt() * self.xt() * self.zt()
                + -T::TWO * operand.as_inner().xz() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().xz() * self.xyzt() * self.yz()
                + -T::TWO * operand.as_inner().yt() * self.s() * self.yz()
                + -T::TWO * operand.as_inner().yt() * self.xt() * self.xyzt()
                + -T::TWO * operand.as_inner().yt() * self.xy() * self.xz()
                + -T::TWO * operand.as_inner().yt() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().xt() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().xt() * self.xyzt() * self.yt()
                + T::TWO * operand.as_inner().xz() * self.s() * self.xt()
                + T::TWO * operand.as_inner().xz() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.s() * self.yt()
                + T::TWO * operand.as_inner().yz() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().yz() * self.xyzt() * self.xz()
                + T::TWO * operand.as_inner().yz() * self.yz() * self.zt()
                + T::from_i8(-4i8) * operand.as_inner().xy() * self.xt() * self.yz()
                + T::from_i8(4i8) * operand.as_inner().xy() * self.xz() * self.yt()
                + operand.as_inner().zt() * self.s() * self.s()
                + operand.as_inner().zt() * self.xt() * self.xt()
                + operand.as_inner().zt() * self.xy() * self.xy()
                + operand.as_inner().zt() * self.yt() * self.yt(),
            -(operand.as_inner().xyzt() * self.xt() * self.xt())
                + -(operand.as_inner().xyzt() * self.xyzt() * self.xyzt())
                + -(operand.as_inner().xyzt() * self.yt() * self.yt())
                + -(operand.as_inner().xyzt() * self.zt() * self.zt())
                + operand.as_inner().xyzt() * self.s() * self.s()
                + operand.as_inner().xyzt() * self.xy() * self.xy()
                + operand.as_inner().xyzt() * self.xz() * self.xz()
                + operand.as_inner().xyzt() * self.yz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Unit<Eventor<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            operand.as_inner().s(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::from_i8(-4i8)
                    * operand.as_inner().zt()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + T::from_i8(4i8)
                    * operand.as_inner().zt()
                    * self.as_inner().xt()
                    * self.as_inner().yz()
                + operand.as_inner().xy(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().yt()
                + T::from_i8(-4i8)
                    * operand.as_inner().yt()
                    * self.as_inner().xt()
                    * self.as_inner().yz()
                + T::from_i8(-4i8)
                    * operand.as_inner().yt()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + operand.as_inner().xz(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xy() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().yz()
                + T::from_i8(-4i8)
                    * operand.as_inner().yz()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + T::from_i8(4i8)
                    * operand.as_inner().yz()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + operand.as_inner().xt(),
            -T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xyzt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::from_i8(-4i8)
                    * operand.as_inner().xt()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + T::from_i8(4i8)
                    * operand.as_inner().xt()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + operand.as_inner().yz(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::from_i8(4i8)
                    * operand.as_inner().xz()
                    * self.as_inner().xt()
                    * self.as_inner().yz()
                + T::from_i8(4i8)
                    * operand.as_inner().xz()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + operand.as_inner().yt(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().yt() * self.as_inner().yt()
                + T::from_i8(-4i8)
                    * operand.as_inner().xy()
                    * self.as_inner().xt()
                    * self.as_inner().yz()
                + T::from_i8(4i8)
                    * operand.as_inner().xy()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + operand.as_inner().zt(),
            operand.as_inner().xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Eventor<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.s() * operand.xyzt() * self.s() - self.xt() * operand.xyzt() * self.xt()
                + self.xy() * operand.xyzt() * self.xy()
                - self.xyzt() * operand.xyzt() * self.xyzt()
                + self.xz() * operand.xyzt() * self.xz()
                - self.yt() * operand.xyzt() * self.yt()
                + self.yz() * operand.xyzt() * self.yz()
                - self.zt() * operand.xyzt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Unit<Eventor<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Eventor<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(operand.as_inner().xyzt() * self.xt() * self.xt())
                + -(operand.as_inner().xyzt() * self.xyzt() * self.xyzt())
                + -(operand.as_inner().xyzt() * self.yt() * self.yt())
                + -(operand.as_inner().xyzt() * self.zt() * self.zt())
                + operand.as_inner().xyzt() * self.s() * self.s()
                + operand.as_inner().xyzt() * self.xy() * self.xy()
                + operand.as_inner().xyzt() * self.xz() * self.xz()
                + operand.as_inner().xyzt() * self.yz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Unit<Eventor<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.as_inner().xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Eventor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.s() * operand.s() * self.s() - self.xt() * operand.s() * self.xt()
                + self.xy() * operand.s() * self.xy()
                - self.xyzt() * operand.s() * self.xyzt()
                + self.xz() * operand.s() * self.xz()
                - self.yt() * operand.s() * self.yt()
                + self.yz() * operand.s() * self.yz()
                - self.zt() * operand.s() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unit<Eventor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Eventor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(operand.as_inner().s() * self.xt() * self.xt())
                + -(operand.as_inner().s() * self.xyzt() * self.xyzt())
                + -(operand.as_inner().s() * self.yt() * self.yt())
                + -(operand.as_inner().s() * self.zt() * self.zt())
                + operand.as_inner().s() * self.s() * self.s()
                + operand.as_inner().s() * self.xy() * self.xy()
                + operand.as_inner().s() * self.xz() * self.xz()
                + operand.as_inner().s() * self.yz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Unit<Eventor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Eventor<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(self.s() * operand.xyt() * self.zt())
                + self.s() * operand.xyz() * self.s()
                + self.s() * operand.xzt() * self.yt()
                - self.s() * operand.yzt() * self.xt()
                - self.xt() * operand.xyt() * self.xz()
                + self.xt() * operand.xyz() * self.xt()
                + self.xt() * operand.xzt() * self.xy()
                - self.xt() * operand.yzt() * self.s()
                - self.xy() * operand.xyt() * self.xyzt()
                + self.xy() * operand.xyz() * self.xy()
                + self.xy() * operand.xzt() * self.xt()
                + self.xy() * operand.yzt() * self.yt()
                - self.xyzt() * operand.xyt() * self.xy()
                + self.xyzt() * operand.xyz() * self.xyzt()
                - self.xyzt() * operand.xzt() * self.xz()
                - self.xyzt() * operand.yzt() * self.yz()
                - self.xz() * operand.xyt() * self.xt()
                + self.xz() * operand.xyz() * self.xz()
                - self.xz() * operand.xzt() * self.xyzt()
                + self.xz() * operand.yzt() * self.zt()
                - self.yt() * operand.xyt() * self.yz()
                + self.yt() * operand.xyz() * self.yt()
                + self.yt() * operand.xzt() * self.s()
                + self.yt() * operand.yzt() * self.xy()
                - self.yz() * operand.xyt() * self.yt()
                + self.yz() * operand.xyz() * self.yz()
                - self.yz() * operand.xzt() * self.zt()
                - self.yz() * operand.yzt() * self.xyzt()
                - self.zt() * operand.xyt() * self.s()
                + self.zt() * operand.xyz() * self.zt()
                - self.zt() * operand.xzt() * self.yz()
                + self.zt() * operand.yzt() * self.xz(),
            self.s() * operand.xyt() * self.s() - self.s() * operand.xyz() * self.zt()
                + self.s() * operand.xzt() * self.yz()
                - self.s() * operand.yzt() * self.xz()
                - self.xt() * operand.xyt() * self.xt()
                + self.xt() * operand.xyz() * self.xz()
                - self.xt() * operand.xzt() * self.xyzt()
                + self.xt() * operand.yzt() * self.zt()
                + self.xy() * operand.xyt() * self.xy()
                - self.xy() * operand.xyz() * self.xyzt()
                + self.xy() * operand.xzt() * self.xz()
                + self.xy() * operand.yzt() * self.yz()
                + self.xyzt() * operand.xyt() * self.xyzt()
                - self.xyzt() * operand.xyz() * self.xy()
                - self.xyzt() * operand.xzt() * self.xt()
                - self.xyzt() * operand.yzt() * self.yt()
                - self.xz() * operand.xyt() * self.xz()
                + self.xz() * operand.xyz() * self.xt()
                + self.xz() * operand.xzt() * self.xy()
                - self.xz() * operand.yzt() * self.s()
                - self.yt() * operand.xyt() * self.yt()
                + self.yt() * operand.xyz() * self.yz()
                - self.yt() * operand.xzt() * self.zt()
                - self.yt() * operand.yzt() * self.xyzt()
                - self.yz() * operand.xyt() * self.yz()
                + self.yz() * operand.xyz() * self.yt()
                + self.yz() * operand.xzt() * self.s()
                + self.yz() * operand.yzt() * self.xy()
                + self.zt() * operand.xyt() * self.zt()
                - self.zt() * operand.xyz() * self.s()
                - self.zt() * operand.xzt() * self.yt()
                + self.zt() * operand.yzt() * self.xt(),
            -(self.s() * operand.xyt() * self.yz())
                + self.s() * operand.xyz() * self.yt()
                + self.s() * operand.xzt() * self.s()
                + self.s() * operand.yzt() * self.xy()
                + self.xt() * operand.xyt() * self.xyzt()
                - self.xt() * operand.xyz() * self.xy()
                - self.xt() * operand.xzt() * self.xt()
                - self.xt() * operand.yzt() * self.yt()
                + self.xy() * operand.xyt() * self.xz()
                - self.xy() * operand.xyz() * self.xt()
                - self.xy() * operand.xzt() * self.xy()
                + self.xy() * operand.yzt() * self.s()
                + self.xyzt() * operand.xyt() * self.xt()
                - self.xyzt() * operand.xyz() * self.xz()
                + self.xyzt() * operand.xzt() * self.xyzt()
                - self.xyzt() * operand.yzt() * self.zt()
                + self.xz() * operand.xyt() * self.xy()
                - self.xz() * operand.xyz() * self.xyzt()
                + self.xz() * operand.xzt() * self.xz()
                + self.xz() * operand.yzt() * self.yz()
                - self.yt() * operand.xyt() * self.zt()
                + self.yt() * operand.xyz() * self.s()
                + self.yt() * operand.xzt() * self.yt()
                - self.yt() * operand.yzt() * self.xt()
                - self.yz() * operand.xyt() * self.s()
                + self.yz() * operand.xyz() * self.zt()
                - self.yz() * operand.xzt() * self.yz()
                + self.yz() * operand.yzt() * self.xz()
                - self.zt() * operand.xyt() * self.yt()
                + self.zt() * operand.xyz() * self.yz()
                - self.zt() * operand.xzt() * self.zt()
                - self.zt() * operand.yzt() * self.xyzt(),
            self.s() * operand.xyt() * self.xz()
                - self.s() * operand.xyz() * self.xt()
                - self.s() * operand.xzt() * self.xy()
                + self.s() * operand.yzt() * self.s()
                + self.xt() * operand.xyt() * self.zt()
                - self.xt() * operand.xyz() * self.s()
                - self.xt() * operand.xzt() * self.yt()
                + self.xt() * operand.yzt() * self.xt()
                + self.xy() * operand.xyt() * self.yz()
                - self.xy() * operand.xyz() * self.yt()
                - self.xy() * operand.xzt() * self.s()
                - self.xy() * operand.yzt() * self.xy()
                + self.xyzt() * operand.xyt() * self.yt()
                - self.xyzt() * operand.xyz() * self.yz()
                + self.xyzt() * operand.xzt() * self.zt()
                + self.xyzt() * operand.yzt() * self.xyzt()
                + self.xz() * operand.xyt() * self.s()
                - self.xz() * operand.xyz() * self.zt()
                + self.xz() * operand.xzt() * self.yz()
                - self.xz() * operand.yzt() * self.xz()
                + self.yt() * operand.xyt() * self.xyzt()
                - self.yt() * operand.xyz() * self.xy()
                - self.yt() * operand.xzt() * self.xt()
                - self.yt() * operand.yzt() * self.yt()
                + self.yz() * operand.xyt() * self.xy()
                - self.yz() * operand.xyz() * self.xyzt()
                + self.yz() * operand.xzt() * self.xz()
                + self.yz() * operand.yzt() * self.yz()
                + self.zt() * operand.xyt() * self.xt()
                - self.zt() * operand.xyz() * self.xz()
                + self.zt() * operand.xzt() * self.xyzt()
                - self.zt() * operand.yzt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Unit<Eventor<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.xyt() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.xyt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.xyt() * self.as_inner().xy() * self.as_inner().xyzt()
                + -T::TWO * operand.xyt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.xzt() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.xzt() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.yzt() * self.as_inner().s() * self.as_inner().xt()
                + -T::TWO * operand.yzt() * self.as_inner().xyzt() * self.as_inner().yz()
                + T::TWO * operand.xyz() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.xyz() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.xyz() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.xyz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.xzt() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.xzt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.yzt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.yzt() * self.as_inner().xz() * self.as_inner().zt()
                + operand.xyz(),
            -T::TWO * operand.xyt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.xyt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.xyz() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.xyz() * self.as_inner().xy() * self.as_inner().xyzt()
                + -T::TWO * operand.xzt() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.xzt() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.yzt() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.yzt() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.xyt() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.xyt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.xyz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.xyz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.xzt() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.xzt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.yzt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.yzt() * self.as_inner().xy() * self.as_inner().yz()
                + operand.xyt(),
            -T::TWO * operand.xyt() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.xyt() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.xyz() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.xyz() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.xzt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.xzt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.yzt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.yzt() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.xyt() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.xyt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.xyz() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.xyz() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.xzt() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.xzt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.yzt() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.yzt() * self.as_inner().xz() * self.as_inner().yz()
                + operand.xzt(),
            -T::TWO * operand.xyz() * self.as_inner().s() * self.as_inner().xt()
                + -T::TWO * operand.xyz() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.xyz() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.xyz() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.xzt() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.xzt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.yzt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.yzt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.xyt() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.xyt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.xyt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.xyt() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.xzt() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.xzt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.yzt() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.yzt() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + operand.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Trivector<T>>> for Eventor<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.as_inner().xyt() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().xyt() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().xyt() * self.xy() * self.xyzt()
                + -T::TWO * operand.as_inner().xyt() * self.yt() * self.yz()
                + -T::TWO * operand.as_inner().xzt() * self.xyzt() * self.xz()
                + -T::TWO * operand.as_inner().xzt() * self.yz() * self.zt()
                + -T::TWO * operand.as_inner().yzt() * self.s() * self.xt()
                + -T::TWO * operand.as_inner().yzt() * self.xyzt() * self.yz()
                + T::TWO * operand.as_inner().xzt() * self.s() * self.yt()
                + T::TWO * operand.as_inner().xzt() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().yzt() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().yzt() * self.xz() * self.zt()
                + operand.as_inner().xyz() * self.s() * self.s()
                + operand.as_inner().xyz() * self.xt() * self.xt()
                + operand.as_inner().xyz() * self.xy() * self.xy()
                + operand.as_inner().xyz() * self.xyzt() * self.xyzt()
                + operand.as_inner().xyz() * self.xz() * self.xz()
                + operand.as_inner().xyz() * self.yt() * self.yt()
                + operand.as_inner().xyz() * self.yz() * self.yz()
                + operand.as_inner().xyz() * self.zt() * self.zt(),
            -(operand.as_inner().xyt() * self.xt() * self.xt())
                + -(operand.as_inner().xyt() * self.xz() * self.xz())
                + -(operand.as_inner().xyt() * self.yt() * self.yt())
                + -(operand.as_inner().xyt() * self.yz() * self.yz())
                + -T::TWO * operand.as_inner().xyz() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().xyz() * self.xy() * self.xyzt()
                + -T::TWO * operand.as_inner().xzt() * self.xt() * self.xyzt()
                + -T::TWO * operand.as_inner().xzt() * self.yt() * self.zt()
                + -T::TWO * operand.as_inner().yzt() * self.s() * self.xz()
                + -T::TWO * operand.as_inner().yzt() * self.xyzt() * self.yt()
                + T::TWO * operand.as_inner().xyz() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().xyz() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().xzt() * self.s() * self.yz()
                + T::TWO * operand.as_inner().xzt() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().yzt() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().yzt() * self.xy() * self.yz()
                + operand.as_inner().xyt() * self.s() * self.s()
                + operand.as_inner().xyt() * self.xy() * self.xy()
                + operand.as_inner().xyt() * self.xyzt() * self.xyzt()
                + operand.as_inner().xyt() * self.zt() * self.zt(),
            -(operand.as_inner().xzt() * self.xt() * self.xt())
                + -(operand.as_inner().xzt() * self.xy() * self.xy())
                + -(operand.as_inner().xzt() * self.yz() * self.yz())
                + -(operand.as_inner().xzt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xyt() * self.s() * self.yz()
                + -T::TWO * operand.as_inner().xyt() * self.yt() * self.zt()
                + -T::TWO * operand.as_inner().xyz() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().xyz() * self.xyzt() * self.xz()
                + -T::TWO * operand.as_inner().yzt() * self.xt() * self.yt()
                + -T::TWO * operand.as_inner().yzt() * self.xyzt() * self.zt()
                + T::TWO * operand.as_inner().xyt() * self.xt() * self.xyzt()
                + T::TWO * operand.as_inner().xyt() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().xyz() * self.s() * self.yt()
                + T::TWO * operand.as_inner().xyz() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().yzt() * self.s() * self.xy()
                + T::TWO * operand.as_inner().yzt() * self.xz() * self.yz()
                + operand.as_inner().xzt() * self.s() * self.s()
                + operand.as_inner().xzt() * self.xyzt() * self.xyzt()
                + operand.as_inner().xzt() * self.xz() * self.xz()
                + operand.as_inner().xzt() * self.yt() * self.yt(),
            -(operand.as_inner().yzt() * self.xy() * self.xy())
                + -(operand.as_inner().yzt() * self.xz() * self.xz())
                + -(operand.as_inner().yzt() * self.yt() * self.yt())
                + -(operand.as_inner().yzt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xyz() * self.s() * self.xt()
                + -T::TWO * operand.as_inner().xyz() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().xyz() * self.xyzt() * self.yz()
                + -T::TWO * operand.as_inner().xyz() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().xzt() * self.s() * self.xy()
                + -T::TWO * operand.as_inner().xzt() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().xyt() * self.s() * self.xz()
                + T::TWO * operand.as_inner().xyt() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().xyt() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().xyt() * self.xyzt() * self.yt()
                + T::TWO * operand.as_inner().xzt() * self.xyzt() * self.zt()
                + T::TWO * operand.as_inner().xzt() * self.xz() * self.yz()
                + operand.as_inner().yzt() * self.s() * self.s()
                + operand.as_inner().yzt() * self.xt() * self.xt()
                + operand.as_inner().yzt() * self.xyzt() * self.xyzt()
                + operand.as_inner().yzt() * self.yz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Trivector<T>>> for Unit<Eventor<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.as_inner().xyt() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xyt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO
                    * operand.as_inner().xyt()
                    * self.as_inner().xy()
                    * self.as_inner().xyzt()
                + -T::TWO * operand.as_inner().xyt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO
                    * operand.as_inner().xzt()
                    * self.as_inner().xyzt()
                    * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().s() * self.as_inner().xt()
                + -T::TWO
                    * operand.as_inner().yzt()
                    * self.as_inner().xyzt()
                    * self.as_inner().yz()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO
                    * operand.as_inner().xyz()
                    * self.as_inner().xyzt()
                    * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xz() * self.as_inner().zt()
                + operand.as_inner().xyz(),
            -T::TWO * operand.as_inner().xyt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xyt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xyz() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO
                    * operand.as_inner().xyz()
                    * self.as_inner().xy()
                    * self.as_inner().xyzt()
                + -T::TWO
                    * operand.as_inner().xzt()
                    * self.as_inner().xt()
                    * self.as_inner().xyzt()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO
                    * operand.as_inner().yzt()
                    * self.as_inner().xyzt()
                    * self.as_inner().yt()
                + T::TWO
                    * operand.as_inner().xyt()
                    * self.as_inner().xyzt()
                    * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xy() * self.as_inner().yz()
                + operand.as_inner().xyt(),
            -T::TWO * operand.as_inner().xyt() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xyt() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xyz() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO
                    * operand.as_inner().xyz()
                    * self.as_inner().xyzt()
                    * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO
                    * operand.as_inner().yzt()
                    * self.as_inner().xyzt()
                    * self.as_inner().zt()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO
                    * operand.as_inner().xzt()
                    * self.as_inner().xyzt()
                    * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xz() * self.as_inner().yz()
                + operand.as_inner().xzt(),
            -T::TWO * operand.as_inner().xyz() * self.as_inner().s() * self.as_inner().xt()
                + -T::TWO * operand.as_inner().xyz() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO
                    * operand.as_inner().xyz()
                    * self.as_inner().xyzt()
                    * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xyz() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO
                    * operand.as_inner().yzt()
                    * self.as_inner().xyzt()
                    * self.as_inner().xyzt()
                + operand.as_inner().yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Eventor<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.s() * operand.t() * self.xt())
                + self.s() * operand.x() * self.s()
                + self.s() * operand.y() * self.xy()
                + self.s() * operand.z() * self.xz()
                - self.xt() * operand.t() * self.s()
                + self.xt() * operand.x() * self.xt()
                + self.xt() * operand.y() * self.yt()
                + self.xt() * operand.z() * self.zt()
                - self.xy() * operand.t() * self.yt()
                - self.xy() * operand.x() * self.xy()
                + self.xy() * operand.y() * self.s()
                + self.xy() * operand.z() * self.yz()
                - self.xyzt() * operand.t() * self.yz()
                + self.xyzt() * operand.x() * self.xyzt()
                - self.xyzt() * operand.y() * self.zt()
                + self.xyzt() * operand.z() * self.yt()
                - self.xz() * operand.t() * self.zt()
                - self.xz() * operand.x() * self.xz()
                - self.xz() * operand.y() * self.yz()
                + self.xz() * operand.z() * self.s()
                - self.yt() * operand.t() * self.xy()
                - self.yt() * operand.x() * self.yt()
                + self.yt() * operand.y() * self.xt()
                + self.yt() * operand.z() * self.xyzt()
                - self.yz() * operand.t() * self.xyzt()
                + self.yz() * operand.x() * self.yz()
                - self.yz() * operand.y() * self.xz()
                + self.yz() * operand.z() * self.xy()
                - self.zt() * operand.t() * self.xz()
                - self.zt() * operand.x() * self.zt()
                - self.zt() * operand.y() * self.xyzt()
                + self.zt() * operand.z() * self.xt(),
            -(self.s() * operand.t() * self.yt()) - self.s() * operand.x() * self.xy()
                + self.s() * operand.y() * self.s()
                + self.s() * operand.z() * self.yz()
                + self.xt() * operand.t() * self.xy()
                + self.xt() * operand.x() * self.yt()
                - self.xt() * operand.y() * self.xt()
                - self.xt() * operand.z() * self.xyzt()
                + self.xy() * operand.t() * self.xt()
                - self.xy() * operand.x() * self.s()
                - self.xy() * operand.y() * self.xy()
                - self.xy() * operand.z() * self.xz()
                + self.xyzt() * operand.t() * self.xz()
                + self.xyzt() * operand.x() * self.zt()
                + self.xyzt() * operand.y() * self.xyzt()
                - self.xyzt() * operand.z() * self.xt()
                + self.xz() * operand.t() * self.xyzt()
                - self.xz() * operand.x() * self.yz()
                + self.xz() * operand.y() * self.xz()
                - self.xz() * operand.z() * self.xy()
                - self.yt() * operand.t() * self.s()
                + self.yt() * operand.x() * self.xt()
                + self.yt() * operand.y() * self.yt()
                + self.yt() * operand.z() * self.zt()
                - self.yz() * operand.t() * self.zt()
                - self.yz() * operand.x() * self.xz()
                - self.yz() * operand.y() * self.yz()
                + self.yz() * operand.z() * self.s()
                - self.zt() * operand.t() * self.yz()
                + self.zt() * operand.x() * self.xyzt()
                - self.zt() * operand.y() * self.zt()
                + self.zt() * operand.z() * self.yt(),
            -(self.s() * operand.t() * self.zt())
                - self.s() * operand.x() * self.xz()
                - self.s() * operand.y() * self.yz()
                + self.s() * operand.z() * self.s()
                + self.xt() * operand.t() * self.xz()
                + self.xt() * operand.x() * self.zt()
                + self.xt() * operand.y() * self.xyzt()
                - self.xt() * operand.z() * self.xt()
                - self.xy() * operand.t() * self.xyzt()
                + self.xy() * operand.x() * self.yz()
                - self.xy() * operand.y() * self.xz()
                + self.xy() * operand.z() * self.xy()
                - self.xyzt() * operand.t() * self.xy()
                - self.xyzt() * operand.x() * self.yt()
                + self.xyzt() * operand.y() * self.xt()
                + self.xyzt() * operand.z() * self.xyzt()
                + self.xz() * operand.t() * self.xt()
                - self.xz() * operand.x() * self.s()
                - self.xz() * operand.y() * self.xy()
                - self.xz() * operand.z() * self.xz()
                + self.yt() * operand.t() * self.yz()
                - self.yt() * operand.x() * self.xyzt()
                + self.yt() * operand.y() * self.zt()
                - self.yt() * operand.z() * self.yt()
                + self.yz() * operand.t() * self.yt()
                + self.yz() * operand.x() * self.xy()
                - self.yz() * operand.y() * self.s()
                - self.yz() * operand.z() * self.yz()
                - self.zt() * operand.t() * self.s()
                + self.zt() * operand.x() * self.xt()
                + self.zt() * operand.y() * self.yt()
                + self.zt() * operand.z() * self.zt(),
            self.s() * operand.t() * self.s()
                - self.s() * operand.x() * self.xt()
                - self.s() * operand.y() * self.yt()
                - self.s() * operand.z() * self.zt()
                + self.xt() * operand.t() * self.xt()
                - self.xt() * operand.x() * self.s()
                - self.xt() * operand.y() * self.xy()
                - self.xt() * operand.z() * self.xz()
                + self.xy() * operand.t() * self.xy()
                + self.xy() * operand.x() * self.yt()
                - self.xy() * operand.y() * self.xt()
                - self.xy() * operand.z() * self.xyzt()
                + self.xyzt() * operand.t() * self.xyzt()
                - self.xyzt() * operand.x() * self.yz()
                + self.xyzt() * operand.y() * self.xz()
                - self.xyzt() * operand.z() * self.xy()
                + self.xz() * operand.t() * self.xz()
                + self.xz() * operand.x() * self.zt()
                + self.xz() * operand.y() * self.xyzt()
                - self.xz() * operand.z() * self.xt()
                + self.yt() * operand.t() * self.yt()
                + self.yt() * operand.x() * self.xy()
                - self.yt() * operand.y() * self.s()
                - self.yt() * operand.z() * self.yz()
                + self.yz() * operand.t() * self.yz()
                - self.yz() * operand.x() * self.xyzt()
                + self.yz() * operand.y() * self.zt()
                - self.yz() * operand.z() * self.yt()
                + self.zt() * operand.t() * self.zt()
                + self.zt() * operand.x() * self.xz()
                + self.zt() * operand.y() * self.yz()
                - self.zt() * operand.z() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Unit<Eventor<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -T::TWO * operand.t() * self.as_inner().s() * self.as_inner().xt()
                + -T::TWO * operand.t() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.t() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.t() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.x() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.x() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.y() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.y() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.x() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.x() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.y() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.y() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.z() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.z() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.z() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.z() * self.as_inner().xyzt() * self.as_inner().yt()
                + operand.x(),
            -T::TWO * operand.t() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.t() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.x() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.x() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.y() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.y() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.z() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.z() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.t() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.t() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.x() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.x() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.y() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.y() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.z() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.z() * self.as_inner().yt() * self.as_inner().zt()
                + operand.y(),
            -T::TWO * operand.t() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.t() * self.as_inner().xy() * self.as_inner().xyzt()
                + -T::TWO * operand.x() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.x() * self.as_inner().xyzt() * self.as_inner().yt()
                + -T::TWO * operand.y() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.y() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.z() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.z() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.t() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.t() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.x() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.x() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.y() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.y() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.z() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.z() * self.as_inner().zt() * self.as_inner().zt()
                + operand.z(),
            -T::TWO * operand.x() * self.as_inner().s() * self.as_inner().xt()
                + -T::TWO * operand.x() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.y() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.y() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.z() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.z() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.z() * self.as_inner().xy() * self.as_inner().xyzt()
                + -T::TWO * operand.z() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.t() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.t() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.t() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.t() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.x() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.x() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.y() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.y() * self.as_inner().yz() * self.as_inner().zt()
                + operand.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Eventor<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.as_inner().x() * self.xy() * self.xy())
                + -(operand.as_inner().x() * self.xz() * self.xz())
                + -(operand.as_inner().x() * self.yt() * self.yt())
                + -(operand.as_inner().x() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().t() * self.s() * self.xt()
                + -T::TWO * operand.as_inner().t() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().t() * self.xyzt() * self.yz()
                + -T::TWO * operand.as_inner().t() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().y() * self.xyzt() * self.zt()
                + -T::TWO * operand.as_inner().y() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().y() * self.s() * self.xy()
                + T::TWO * operand.as_inner().y() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().z() * self.s() * self.xz()
                + T::TWO * operand.as_inner().z() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().z() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().z() * self.xyzt() * self.yt()
                + operand.as_inner().x() * self.s() * self.s()
                + operand.as_inner().x() * self.xt() * self.xt()
                + operand.as_inner().x() * self.xyzt() * self.xyzt()
                + operand.as_inner().x() * self.yz() * self.yz(),
            -(operand.as_inner().y() * self.xt() * self.xt())
                + -(operand.as_inner().y() * self.xy() * self.xy())
                + -(operand.as_inner().y() * self.yz() * self.yz())
                + -(operand.as_inner().y() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().t() * self.s() * self.yt()
                + -T::TWO * operand.as_inner().t() * self.yz() * self.zt()
                + -T::TWO * operand.as_inner().x() * self.s() * self.xy()
                + -T::TWO * operand.as_inner().x() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().z() * self.xt() * self.xyzt()
                + -T::TWO * operand.as_inner().z() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().t() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().t() * self.xyzt() * self.xz()
                + T::TWO * operand.as_inner().x() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().x() * self.xyzt() * self.zt()
                + T::TWO * operand.as_inner().z() * self.s() * self.yz()
                + T::TWO * operand.as_inner().z() * self.yt() * self.zt()
                + operand.as_inner().y() * self.s() * self.s()
                + operand.as_inner().y() * self.xyzt() * self.xyzt()
                + operand.as_inner().y() * self.xz() * self.xz()
                + operand.as_inner().y() * self.yt() * self.yt(),
            -(operand.as_inner().z() * self.xt() * self.xt())
                + -(operand.as_inner().z() * self.xz() * self.xz())
                + -(operand.as_inner().z() * self.yt() * self.yt())
                + -(operand.as_inner().z() * self.yz() * self.yz())
                + -T::TWO * operand.as_inner().t() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().t() * self.xy() * self.xyzt()
                + -T::TWO * operand.as_inner().x() * self.s() * self.xz()
                + -T::TWO * operand.as_inner().x() * self.xyzt() * self.yt()
                + -T::TWO * operand.as_inner().y() * self.s() * self.yz()
                + -T::TWO * operand.as_inner().y() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().t() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().t() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().x() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().x() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().y() * self.xt() * self.xyzt()
                + T::TWO * operand.as_inner().y() * self.yt() * self.zt()
                + operand.as_inner().z() * self.s() * self.s()
                + operand.as_inner().z() * self.xy() * self.xy()
                + operand.as_inner().z() * self.xyzt() * self.xyzt()
                + operand.as_inner().z() * self.zt() * self.zt(),
            -T::TWO * operand.as_inner().x() * self.s() * self.xt()
                + -T::TWO * operand.as_inner().x() * self.xyzt() * self.yz()
                + -T::TWO * operand.as_inner().y() * self.s() * self.yt()
                + -T::TWO * operand.as_inner().y() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().z() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().z() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().z() * self.xy() * self.xyzt()
                + -T::TWO * operand.as_inner().z() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().x() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().x() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().y() * self.xyzt() * self.xz()
                + T::TWO * operand.as_inner().y() * self.yz() * self.zt()
                + operand.as_inner().t() * self.s() * self.s()
                + operand.as_inner().t() * self.xt() * self.xt()
                + operand.as_inner().t() * self.xy() * self.xy()
                + operand.as_inner().t() * self.xyzt() * self.xyzt()
                + operand.as_inner().t() * self.xz() * self.xz()
                + operand.as_inner().t() * self.yt() * self.yt()
                + operand.as_inner().t() * self.yz() * self.yz()
                + operand.as_inner().t() * self.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Unit<Eventor<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -T::TWO * operand.as_inner().t() * self.as_inner().s() * self.as_inner().xt()
                + -T::TWO * operand.as_inner().t() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().t() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().t() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().x() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().x() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().x() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.as_inner().x() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().y() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.as_inner().y() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().z() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.as_inner().z() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().z() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().z() * self.as_inner().xyzt() * self.as_inner().yt()
                + operand.as_inner().x(),
            -T::TWO * operand.as_inner().t() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().t() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().x() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().x() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().y() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().t() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().t() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().x() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().x() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().y() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().y() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().z() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.as_inner().z() * self.as_inner().yt() * self.as_inner().zt()
                + operand.as_inner().y(),
            -T::TWO * operand.as_inner().t() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().t() * self.as_inner().xy() * self.as_inner().xyzt()
                + -T::TWO * operand.as_inner().x() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().x() * self.as_inner().xyzt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().y() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().t() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().t() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().x() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().x() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().y() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().y() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().z() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().z() * self.as_inner().zt() * self.as_inner().zt()
                + operand.as_inner().z(),
            -T::TWO * operand.as_inner().x() * self.as_inner().s() * self.as_inner().xt()
                + -T::TWO * operand.as_inner().x() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().z() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xy() * self.as_inner().xyzt()
                + -T::TWO * operand.as_inner().z() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().t() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.as_inner().t() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().t() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().t() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().x() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().x() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().y() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().y() * self.as_inner().yz() * self.as_inner().zt()
                + operand.as_inner().t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Pseudoscalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(self.xyzt() * operand.xy() * self.xyzt()),
            -(self.xyzt() * operand.xz() * self.xyzt()),
            -(self.xyzt() * operand.xt() * self.xyzt()),
            -(self.xyzt() * operand.yz() * self.xyzt()),
            -(self.xyzt() * operand.yt() * self.xyzt()),
            -(self.xyzt() * operand.zt() * self.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            operand.xy(),
            operand.xz(),
            operand.xt(),
            operand.yz(),
            operand.yt(),
            operand.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Pseudoscalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.as_inner().xy() * self.xyzt() * self.xyzt()),
            -(operand.as_inner().xz() * self.xyzt() * self.xyzt()),
            -(operand.as_inner().xt() * self.xyzt() * self.xyzt()),
            -(operand.as_inner().yz() * self.xyzt() * self.xyzt()),
            -(operand.as_inner().yt() * self.xyzt() * self.xyzt()),
            -(operand.as_inner().zt() * self.xyzt() * self.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            operand.as_inner().xy(),
            operand.as_inner().xz(),
            operand.as_inner().xt(),
            operand.as_inner().yz(),
            operand.as_inner().yt(),
            operand.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Pseudoscalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(self.xyzt() * operand.s() * self.xyzt()),
            -(self.xyzt() * operand.xy() * self.xyzt()),
            -(self.xyzt() * operand.xz() * self.xyzt()),
            -(self.xyzt() * operand.xt() * self.xyzt()),
            -(self.xyzt() * operand.yz() * self.xyzt()),
            -(self.xyzt() * operand.yt() * self.xyzt()),
            -(self.xyzt() * operand.zt() * self.xyzt()),
            -(self.xyzt() * operand.xyzt() * self.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Unit<Pseudoscalar<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            operand.s(),
            operand.xy(),
            operand.xz(),
            operand.xt(),
            operand.yz(),
            operand.yt(),
            operand.zt(),
            operand.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Pseudoscalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.as_inner().s() * self.xyzt() * self.xyzt()),
            -(operand.as_inner().xy() * self.xyzt() * self.xyzt()),
            -(operand.as_inner().xz() * self.xyzt() * self.xyzt()),
            -(operand.as_inner().xt() * self.xyzt() * self.xyzt()),
            -(operand.as_inner().yz() * self.xyzt() * self.xyzt()),
            -(operand.as_inner().yt() * self.xyzt() * self.xyzt()),
            -(operand.as_inner().zt() * self.xyzt() * self.xyzt()),
            -(operand.as_inner().xyzt() * self.xyzt() * self.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            operand.as_inner().s(),
            operand.as_inner().xy(),
            operand.as_inner().xz(),
            operand.as_inner().xt(),
            operand.as_inner().yz(),
            operand.as_inner().yt(),
            operand.as_inner().zt(),
            operand.as_inner().xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(self.xyzt() * operand.xyzt() * self.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(operand.as_inner().xyzt() * self.xyzt() * self.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.as_inner().xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.xyzt() * operand.s() * self.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.as_inner().s() * self.xyzt() * self.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Pseudoscalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            self.xyzt() * operand.xyz() * self.xyzt(),
            self.xyzt() * operand.xyt() * self.xyzt(),
            self.xyzt() * operand.xzt() * self.xyzt(),
            self.xyzt() * operand.yzt() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(operand.xyz()),
            -(operand.xyt()),
            -(operand.xzt()),
            -(operand.yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Trivector<T>>> for Pseudoscalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            operand.as_inner().xyz() * self.xyzt() * self.xyzt(),
            operand.as_inner().xyt() * self.xyzt() * self.xyzt(),
            operand.as_inner().xzt() * self.xyzt() * self.xyzt(),
            operand.as_inner().yzt() * self.xyzt() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Trivector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(operand.as_inner().xyz()),
            -(operand.as_inner().xyt()),
            -(operand.as_inner().xzt()),
            -(operand.as_inner().yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Pseudoscalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            self.xyzt() * operand.x() * self.xyzt(),
            self.xyzt() * operand.y() * self.xyzt(),
            self.xyzt() * operand.z() * self.xyzt(),
            self.xyzt() * operand.t() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.x()),
            -(operand.y()),
            -(operand.z()),
            -(operand.t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Pseudoscalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            operand.as_inner().x() * self.xyzt() * self.xyzt(),
            operand.as_inner().y() * self.xyzt() * self.xyzt(),
            operand.as_inner().z() * self.xyzt() * self.xyzt(),
            operand.as_inner().t() * self.xyzt() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.as_inner().x()),
            -(operand.as_inner().y()),
            -(operand.as_inner().z()),
            -(operand.as_inner().t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.s() * operand.xy() * self.s(),
            self.s() * operand.xz() * self.s(),
            self.s() * operand.xt() * self.s(),
            self.s() * operand.yz() * self.s(),
            self.s() * operand.yt() * self.s(),
            self.s() * operand.zt() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            operand.xy(),
            operand.xz(),
            operand.xt(),
            operand.yz(),
            operand.yt(),
            operand.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            operand.as_inner().xy() * self.s() * self.s(),
            operand.as_inner().xz() * self.s() * self.s(),
            operand.as_inner().xt() * self.s() * self.s(),
            operand.as_inner().yz() * self.s() * self.s(),
            operand.as_inner().yt() * self.s() * self.s(),
            operand.as_inner().zt() * self.s() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            operand.as_inner().xy(),
            operand.as_inner().xz(),
            operand.as_inner().xt(),
            operand.as_inner().yz(),
            operand.as_inner().yt(),
            operand.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            self.s() * operand.s() * self.s(),
            self.s() * operand.xy() * self.s(),
            self.s() * operand.xz() * self.s(),
            self.s() * operand.xt() * self.s(),
            self.s() * operand.yz() * self.s(),
            self.s() * operand.yt() * self.s(),
            self.s() * operand.zt() * self.s(),
            self.s() * operand.xyzt() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Unit<Scalar<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            operand.s(),
            operand.xy(),
            operand.xz(),
            operand.xt(),
            operand.yz(),
            operand.yt(),
            operand.zt(),
            operand.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            operand.as_inner().s() * self.s() * self.s(),
            operand.as_inner().xy() * self.s() * self.s(),
            operand.as_inner().xz() * self.s() * self.s(),
            operand.as_inner().xt() * self.s() * self.s(),
            operand.as_inner().yz() * self.s() * self.s(),
            operand.as_inner().yt() * self.s() * self.s(),
            operand.as_inner().zt() * self.s() * self.s(),
            operand.as_inner().xyzt() * self.s() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Unit<Scalar<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            operand.as_inner().s(),
            operand.as_inner().xy(),
            operand.as_inner().xz(),
            operand.as_inner().xt(),
            operand.as_inner().yz(),
            operand.as_inner().yt(),
            operand.as_inner().zt(),
            operand.as_inner().xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.s() * operand.xyzt() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.as_inner().xyzt() * self.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.as_inner().xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * operand.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s() * self.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            self.s() * operand.xyz() * self.s(),
            self.s() * operand.xyt() * self.s(),
            self.s() * operand.xzt() * self.s(),
            self.s() * operand.yzt() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Unit<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(operand.xyz(), operand.xyt(), operand.xzt(), operand.yzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Trivector<T>>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            operand.as_inner().xyz() * self.s() * self.s(),
            operand.as_inner().xyt() * self.s() * self.s(),
            operand.as_inner().xzt() * self.s() * self.s(),
            operand.as_inner().yzt() * self.s() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Trivector<T>>> for Unit<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            operand.as_inner().xyz(),
            operand.as_inner().xyt(),
            operand.as_inner().xzt(),
            operand.as_inner().yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            self.s() * operand.x() * self.s(),
            self.s() * operand.y() * self.s(),
            self.s() * operand.z() * self.s(),
            self.s() * operand.t() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(operand.x(), operand.y(), operand.z(), operand.t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            operand.as_inner().x() * self.s() * self.s(),
            operand.as_inner().y() * self.s() * self.s(),
            operand.as_inner().z() * self.s() * self.s(),
            operand.as_inner().t() * self.s() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            operand.as_inner().x(),
            operand.as_inner().y(),
            operand.as_inner().z(),
            operand.as_inner().t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(self.xyt() * operand.xy() * self.xyt())
                - self.xyt() * operand.xz() * self.xzt()
                - self.xyt() * operand.yz() * self.yzt()
                + self.xyz() * operand.xt() * self.xzt()
                + self.xyz() * operand.xy() * self.xyz()
                + self.xyz() * operand.yt() * self.yzt()
                + self.xzt() * operand.xt() * self.xyz()
                + self.xzt() * operand.xy() * self.xzt()
                - self.xzt() * operand.xz() * self.xyt()
                + self.yzt() * operand.xy() * self.yzt()
                + self.yzt() * operand.yt() * self.xyz()
                - self.yzt() * operand.yz() * self.xyt(),
            -(self.xyt() * operand.xt() * self.xyz()) - self.xyt() * operand.xy() * self.xzt()
                + self.xyt() * operand.xz() * self.xyt()
                - self.xyz() * operand.xt() * self.xyt()
                + self.xyz() * operand.xz() * self.xyz()
                + self.xyz() * operand.zt() * self.yzt()
                - self.xzt() * operand.xy() * self.xyt()
                - self.xzt() * operand.xz() * self.xzt()
                - self.xzt() * operand.yz() * self.yzt()
                + self.yzt() * operand.xz() * self.yzt()
                - self.yzt() * operand.yz() * self.xzt()
                + self.yzt() * operand.zt() * self.xyz(),
            -(self.xyt() * operand.xt() * self.xyt())
                + self.xyt() * operand.xz() * self.xyz()
                + self.xyt() * operand.zt() * self.yzt()
                - self.xyz() * operand.xt() * self.xyz()
                - self.xyz() * operand.xy() * self.xzt()
                + self.xyz() * operand.xz() * self.xyt()
                - self.xzt() * operand.xt() * self.xzt()
                - self.xzt() * operand.xy() * self.xyz()
                - self.xzt() * operand.yt() * self.yzt()
                + self.yzt() * operand.xt() * self.yzt()
                - self.yzt() * operand.yt() * self.xzt()
                + self.yzt() * operand.zt() * self.xyt(),
            -(self.xyt() * operand.xy() * self.yzt()) - self.xyt() * operand.yt() * self.xyz()
                + self.xyt() * operand.yz() * self.xyt()
                - self.xyz() * operand.yt() * self.xyt()
                + self.xyz() * operand.yz() * self.xyz()
                - self.xyz() * operand.zt() * self.xzt()
                - self.xzt() * operand.xz() * self.yzt()
                + self.xzt() * operand.yz() * self.xzt()
                - self.xzt() * operand.zt() * self.xyz()
                - self.yzt() * operand.xy() * self.xyt()
                - self.yzt() * operand.xz() * self.xzt()
                - self.yzt() * operand.yz() * self.yzt(),
            -(self.xyt() * operand.yt() * self.xyt()) + self.xyt() * operand.yz() * self.xyz()
                - self.xyt() * operand.zt() * self.xzt()
                - self.xyz() * operand.xy() * self.yzt()
                - self.xyz() * operand.yt() * self.xyz()
                + self.xyz() * operand.yz() * self.xyt()
                - self.xzt() * operand.xt() * self.yzt()
                + self.xzt() * operand.yt() * self.xzt()
                - self.xzt() * operand.zt() * self.xyt()
                - self.yzt() * operand.xt() * self.xzt()
                - self.yzt() * operand.xy() * self.xyz()
                - self.yzt() * operand.yt() * self.yzt(),
            self.xyt() * operand.xt() * self.yzt() - self.xyt() * operand.yt() * self.xzt()
                + self.xyt() * operand.zt() * self.xyt()
                - self.xyz() * operand.xz() * self.yzt()
                + self.xyz() * operand.yz() * self.xzt()
                - self.xyz() * operand.zt() * self.xyz()
                - self.xzt() * operand.yt() * self.xyt()
                + self.xzt() * operand.yz() * self.xyz()
                - self.xzt() * operand.zt() * self.xzt()
                + self.yzt() * operand.xt() * self.xyt()
                - self.yzt() * operand.xz() * self.xyz()
                - self.yzt() * operand.zt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Unit<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -T::TWO * operand.xz() * self.as_inner().xyt() * self.as_inner().xzt()
                + -T::TWO * operand.yz() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.xt() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.xy() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.xy() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.yt() * self.as_inner().xyz() * self.as_inner().yzt()
                + operand.xy(),
            -T::TWO * operand.xt() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO * operand.xy() * self.as_inner().xyt() * self.as_inner().xzt()
                + -T::TWO * operand.yz() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.xz() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.xz() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.zt() * self.as_inner().xyz() * self.as_inner().yzt()
                + operand.xz(),
            -(operand.xt())
                + -T::TWO * operand.xt() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.xt() * self.as_inner().xzt() * self.as_inner().xzt()
                + -T::TWO * operand.xy() * self.as_inner().xyz() * self.as_inner().xzt()
                + -T::TWO * operand.yt() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.xz() * self.as_inner().xyt() * self.as_inner().xyz()
                + T::TWO * operand.zt() * self.as_inner().xyt() * self.as_inner().yzt(),
            -T::TWO * operand.xy() * self.as_inner().xyt() * self.as_inner().yzt()
                + -T::TWO * operand.xz() * self.as_inner().xzt() * self.as_inner().yzt()
                + -T::TWO * operand.yt() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO * operand.zt() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.yz() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.yz() * self.as_inner().xzt() * self.as_inner().xzt()
                + operand.yz(),
            -(operand.yt())
                + -T::TWO * operand.xt() * self.as_inner().xzt() * self.as_inner().yzt()
                + -T::TWO * operand.xy() * self.as_inner().xyz() * self.as_inner().yzt()
                + -T::TWO * operand.yt() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.yt() * self.as_inner().yzt() * self.as_inner().yzt()
                + -T::TWO * operand.zt() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.yz() * self.as_inner().xyt() * self.as_inner().xyz(),
            -(operand.zt())
                + -T::TWO * operand.xz() * self.as_inner().xyz() * self.as_inner().yzt()
                + -T::TWO * operand.yt() * self.as_inner().xyt() * self.as_inner().xzt()
                + -T::TWO * operand.zt() * self.as_inner().xzt() * self.as_inner().xzt()
                + -T::TWO * operand.zt() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.xt() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.yz() * self.as_inner().xyz() * self.as_inner().xzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.as_inner().xy() * self.xyt() * self.xyt())
                + -T::TWO * operand.as_inner().xz() * self.xyt() * self.xzt()
                + -T::TWO * operand.as_inner().yz() * self.xyt() * self.yzt()
                + T::TWO * operand.as_inner().xt() * self.xyz() * self.xzt()
                + T::TWO * operand.as_inner().yt() * self.xyz() * self.yzt()
                + operand.as_inner().xy() * self.xyz() * self.xyz()
                + operand.as_inner().xy() * self.xzt() * self.xzt()
                + operand.as_inner().xy() * self.yzt() * self.yzt(),
            -(operand.as_inner().xz() * self.xzt() * self.xzt())
                + -T::TWO * operand.as_inner().xt() * self.xyt() * self.xyz()
                + -T::TWO * operand.as_inner().xy() * self.xyt() * self.xzt()
                + -T::TWO * operand.as_inner().yz() * self.xzt() * self.yzt()
                + T::TWO * operand.as_inner().zt() * self.xyz() * self.yzt()
                + operand.as_inner().xz() * self.xyt() * self.xyt()
                + operand.as_inner().xz() * self.xyz() * self.xyz()
                + operand.as_inner().xz() * self.yzt() * self.yzt(),
            -(operand.as_inner().xt() * self.xyt() * self.xyt())
                + -(operand.as_inner().xt() * self.xyz() * self.xyz())
                + -(operand.as_inner().xt() * self.xzt() * self.xzt())
                + -T::TWO * operand.as_inner().xy() * self.xyz() * self.xzt()
                + -T::TWO * operand.as_inner().yt() * self.xzt() * self.yzt()
                + T::TWO * operand.as_inner().xz() * self.xyt() * self.xyz()
                + T::TWO * operand.as_inner().zt() * self.xyt() * self.yzt()
                + operand.as_inner().xt() * self.yzt() * self.yzt(),
            -(operand.as_inner().yz() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().xy() * self.xyt() * self.yzt()
                + -T::TWO * operand.as_inner().xz() * self.xzt() * self.yzt()
                + -T::TWO * operand.as_inner().yt() * self.xyt() * self.xyz()
                + -T::TWO * operand.as_inner().zt() * self.xyz() * self.xzt()
                + operand.as_inner().yz() * self.xyt() * self.xyt()
                + operand.as_inner().yz() * self.xyz() * self.xyz()
                + operand.as_inner().yz() * self.xzt() * self.xzt(),
            -(operand.as_inner().yt() * self.xyt() * self.xyt())
                + -(operand.as_inner().yt() * self.xyz() * self.xyz())
                + -(operand.as_inner().yt() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().xt() * self.xzt() * self.yzt()
                + -T::TWO * operand.as_inner().xy() * self.xyz() * self.yzt()
                + -T::TWO * operand.as_inner().zt() * self.xyt() * self.xzt()
                + T::TWO * operand.as_inner().yz() * self.xyt() * self.xyz()
                + operand.as_inner().yt() * self.xzt() * self.xzt(),
            -(operand.as_inner().zt() * self.xyz() * self.xyz())
                + -(operand.as_inner().zt() * self.xzt() * self.xzt())
                + -(operand.as_inner().zt() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().xz() * self.xyz() * self.yzt()
                + -T::TWO * operand.as_inner().yt() * self.xyt() * self.xzt()
                + T::TWO * operand.as_inner().xt() * self.xyt() * self.yzt()
                + T::TWO * operand.as_inner().yz() * self.xyz() * self.xzt()
                + operand.as_inner().zt() * self.xyt() * self.xyt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Unit<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -T::TWO * operand.as_inner().xz() * self.as_inner().xyt() * self.as_inner().xzt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xyz() * self.as_inner().yzt()
                + operand.as_inner().xy(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xyt() * self.as_inner().xzt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xyz() * self.as_inner().yzt()
                + operand.as_inner().xz(),
            -(operand.as_inner().xt())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xzt() * self.as_inner().xzt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xyz() * self.as_inner().xzt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xyt() * self.as_inner().xyz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xyt() * self.as_inner().yzt(),
            -T::TWO * operand.as_inner().xy() * self.as_inner().xyt() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xzt() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xzt() * self.as_inner().xzt()
                + operand.as_inner().yz(),
            -(operand.as_inner().yt())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xzt() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xyz() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().yzt() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyt() * self.as_inner().xyz(),
            -(operand.as_inner().zt())
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xyz() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xyt() * self.as_inner().xzt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xzt() * self.as_inner().xzt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyz() * self.as_inner().xzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Trivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(self.xyt() * operand.s() * self.xyt()) + self.xyt() * operand.xz() * self.yzt()
                - self.xyt() * operand.yz() * self.xzt()
                + self.xyt() * operand.zt() * self.xyz()
                + self.xyz() * operand.s() * self.xyz()
                - self.xyz() * operand.xt() * self.yzt()
                + self.xyz() * operand.yt() * self.xzt()
                - self.xyz() * operand.zt() * self.xyt()
                - self.xzt() * operand.s() * self.xzt()
                - self.xzt() * operand.xy() * self.yzt()
                - self.xzt() * operand.yt() * self.xyz()
                + self.xzt() * operand.yz() * self.xyt()
                - self.yzt() * operand.s() * self.yzt()
                + self.yzt() * operand.xt() * self.xyz()
                + self.yzt() * operand.xy() * self.xzt()
                - self.yzt() * operand.xz() * self.xyt(),
            -(self.xyt() * operand.xy() * self.xyt()) + self.xyt() * operand.xyzt() * self.xyz()
                - self.xyt() * operand.xz() * self.xzt()
                - self.xyt() * operand.yz() * self.yzt()
                + self.xyz() * operand.xt() * self.xzt()
                + self.xyz() * operand.xy() * self.xyz()
                - self.xyz() * operand.xyzt() * self.xyt()
                + self.xyz() * operand.yt() * self.yzt()
                - self.xzt() * operand.s() * self.yzt()
                + self.xzt() * operand.xt() * self.xyz()
                + self.xzt() * operand.xy() * self.xzt()
                - self.xzt() * operand.xz() * self.xyt()
                + self.yzt() * operand.s() * self.xzt()
                + self.yzt() * operand.xy() * self.yzt()
                + self.yzt() * operand.yt() * self.xyz()
                - self.yzt() * operand.yz() * self.xyt(),
            self.xyt() * operand.s() * self.yzt()
                - self.xyt() * operand.xt() * self.xyz()
                - self.xyt() * operand.xy() * self.xzt()
                + self.xyt() * operand.xz() * self.xyt()
                - self.xyz() * operand.xt() * self.xyt()
                - self.xyz() * operand.xyzt() * self.xzt()
                + self.xyz() * operand.xz() * self.xyz()
                + self.xyz() * operand.zt() * self.yzt()
                - self.xzt() * operand.xy() * self.xyt()
                + self.xzt() * operand.xyzt() * self.xyz()
                - self.xzt() * operand.xz() * self.xzt()
                - self.xzt() * operand.yz() * self.yzt()
                - self.yzt() * operand.s() * self.xyt()
                + self.yzt() * operand.xz() * self.yzt()
                - self.yzt() * operand.yz() * self.xzt()
                + self.yzt() * operand.zt() * self.xyz(),
            -(self.xyt() * operand.xt() * self.xyt()) - self.xyt() * operand.xyzt() * self.xzt()
                + self.xyt() * operand.xz() * self.xyz()
                + self.xyt() * operand.zt() * self.yzt()
                + self.xyz() * operand.s() * self.yzt()
                - self.xyz() * operand.xt() * self.xyz()
                - self.xyz() * operand.xy() * self.xzt()
                + self.xyz() * operand.xz() * self.xyt()
                - self.xzt() * operand.xt() * self.xzt()
                - self.xzt() * operand.xy() * self.xyz()
                + self.xzt() * operand.xyzt() * self.xyt()
                - self.xzt() * operand.yt() * self.yzt()
                - self.yzt() * operand.s() * self.xyz()
                + self.yzt() * operand.xt() * self.yzt()
                - self.yzt() * operand.yt() * self.xzt()
                + self.yzt() * operand.zt() * self.xyt(),
            -(self.xyt() * operand.s() * self.xzt())
                - self.xyt() * operand.xy() * self.yzt()
                - self.xyt() * operand.yt() * self.xyz()
                + self.xyt() * operand.yz() * self.xyt()
                - self.xyz() * operand.xyzt() * self.yzt()
                - self.xyz() * operand.yt() * self.xyt()
                + self.xyz() * operand.yz() * self.xyz()
                - self.xyz() * operand.zt() * self.xzt()
                + self.xzt() * operand.s() * self.xyt()
                - self.xzt() * operand.xz() * self.yzt()
                + self.xzt() * operand.yz() * self.xzt()
                - self.xzt() * operand.zt() * self.xyz()
                - self.yzt() * operand.xy() * self.xyt()
                + self.yzt() * operand.xyzt() * self.xyz()
                - self.yzt() * operand.xz() * self.xzt()
                - self.yzt() * operand.yz() * self.yzt(),
            -(self.xyt() * operand.xyzt() * self.yzt()) - self.xyt() * operand.yt() * self.xyt()
                + self.xyt() * operand.yz() * self.xyz()
                - self.xyt() * operand.zt() * self.xzt()
                - self.xyz() * operand.s() * self.xzt()
                - self.xyz() * operand.xy() * self.yzt()
                - self.xyz() * operand.yt() * self.xyz()
                + self.xyz() * operand.yz() * self.xyt()
                + self.xzt() * operand.s() * self.xyz()
                - self.xzt() * operand.xt() * self.yzt()
                + self.xzt() * operand.yt() * self.xzt()
                - self.xzt() * operand.zt() * self.xyt()
                - self.yzt() * operand.xt() * self.xzt()
                - self.yzt() * operand.xy() * self.xyz()
                + self.yzt() * operand.xyzt() * self.xyt()
                - self.yzt() * operand.yt() * self.yzt(),
            -(self.xyt() * operand.s() * self.xyz()) + self.xyt() * operand.xt() * self.yzt()
                - self.xyt() * operand.yt() * self.xzt()
                + self.xyt() * operand.zt() * self.xyt()
                + self.xyz() * operand.s() * self.xyt()
                - self.xyz() * operand.xz() * self.yzt()
                + self.xyz() * operand.yz() * self.xzt()
                - self.xyz() * operand.zt() * self.xyz()
                - self.xzt() * operand.xyzt() * self.yzt()
                - self.xzt() * operand.yt() * self.xyt()
                + self.xzt() * operand.yz() * self.xyz()
                - self.xzt() * operand.zt() * self.xzt()
                + self.yzt() * operand.xt() * self.xyt()
                + self.yzt() * operand.xyzt() * self.xzt()
                - self.yzt() * operand.xz() * self.xyz()
                - self.yzt() * operand.zt() * self.yzt(),
            -(self.xyt() * operand.xt() * self.xzt()) - self.xyt() * operand.xy() * self.xyz()
                + self.xyt() * operand.xyzt() * self.xyt()
                - self.xyt() * operand.yt() * self.yzt()
                + self.xyz() * operand.xy() * self.xyt()
                - self.xyz() * operand.xyzt() * self.xyz()
                + self.xyz() * operand.xz() * self.xzt()
                + self.xyz() * operand.yz() * self.yzt()
                + self.xzt() * operand.xt() * self.xyt()
                + self.xzt() * operand.xyzt() * self.xzt()
                - self.xzt() * operand.xz() * self.xyz()
                - self.xzt() * operand.zt() * self.yzt()
                + self.yzt() * operand.xyzt() * self.yzt()
                + self.yzt() * operand.yt() * self.xyt()
                - self.yzt() * operand.yz() * self.xyz()
                + self.yzt() * operand.zt() * self.xzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Unit<Trivector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            operand.s(),
            -T::TWO * operand.xz() * self.as_inner().xyt() * self.as_inner().xzt()
                + -T::TWO * operand.yz() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.xt() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.xy() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.xy() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.yt() * self.as_inner().xyz() * self.as_inner().yzt()
                + operand.xy(),
            -T::TWO * operand.xt() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO * operand.xy() * self.as_inner().xyt() * self.as_inner().xzt()
                + -T::TWO * operand.yz() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.xz() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.xz() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.zt() * self.as_inner().xyz() * self.as_inner().yzt()
                + operand.xz(),
            -(operand.xt())
                + -T::TWO * operand.xt() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.xt() * self.as_inner().xzt() * self.as_inner().xzt()
                + -T::TWO * operand.xy() * self.as_inner().xyz() * self.as_inner().xzt()
                + -T::TWO * operand.yt() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.xz() * self.as_inner().xyt() * self.as_inner().xyz()
                + T::TWO * operand.zt() * self.as_inner().xyt() * self.as_inner().yzt(),
            -T::TWO * operand.xy() * self.as_inner().xyt() * self.as_inner().yzt()
                + -T::TWO * operand.xz() * self.as_inner().xzt() * self.as_inner().yzt()
                + -T::TWO * operand.yt() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO * operand.zt() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.yz() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.yz() * self.as_inner().xzt() * self.as_inner().xzt()
                + operand.yz(),
            -(operand.yt())
                + -T::TWO * operand.xt() * self.as_inner().xzt() * self.as_inner().yzt()
                + -T::TWO * operand.xy() * self.as_inner().xyz() * self.as_inner().yzt()
                + -T::TWO * operand.yt() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.yt() * self.as_inner().yzt() * self.as_inner().yzt()
                + -T::TWO * operand.zt() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.yz() * self.as_inner().xyt() * self.as_inner().xyz(),
            -(operand.zt())
                + -T::TWO * operand.xz() * self.as_inner().xyz() * self.as_inner().yzt()
                + -T::TWO * operand.yt() * self.as_inner().xyt() * self.as_inner().xzt()
                + -T::TWO * operand.zt() * self.as_inner().xzt() * self.as_inner().xzt()
                + -T::TWO * operand.zt() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.xt() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.yz() * self.as_inner().xyz() * self.as_inner().xzt(),
            -(operand.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Trivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.as_inner().s() * self.xyt() * self.xyt())
                + -(operand.as_inner().s() * self.xzt() * self.xzt())
                + -(operand.as_inner().s() * self.yzt() * self.yzt())
                + operand.as_inner().s() * self.xyz() * self.xyz(),
            -(operand.as_inner().xy() * self.xyt() * self.xyt())
                + -T::TWO * operand.as_inner().xz() * self.xyt() * self.xzt()
                + -T::TWO * operand.as_inner().yz() * self.xyt() * self.yzt()
                + T::TWO * operand.as_inner().xt() * self.xyz() * self.xzt()
                + T::TWO * operand.as_inner().yt() * self.xyz() * self.yzt()
                + operand.as_inner().xy() * self.xyz() * self.xyz()
                + operand.as_inner().xy() * self.xzt() * self.xzt()
                + operand.as_inner().xy() * self.yzt() * self.yzt(),
            -(operand.as_inner().xz() * self.xzt() * self.xzt())
                + -T::TWO * operand.as_inner().xt() * self.xyt() * self.xyz()
                + -T::TWO * operand.as_inner().xy() * self.xyt() * self.xzt()
                + -T::TWO * operand.as_inner().yz() * self.xzt() * self.yzt()
                + T::TWO * operand.as_inner().zt() * self.xyz() * self.yzt()
                + operand.as_inner().xz() * self.xyt() * self.xyt()
                + operand.as_inner().xz() * self.xyz() * self.xyz()
                + operand.as_inner().xz() * self.yzt() * self.yzt(),
            -(operand.as_inner().xt() * self.xyt() * self.xyt())
                + -(operand.as_inner().xt() * self.xyz() * self.xyz())
                + -(operand.as_inner().xt() * self.xzt() * self.xzt())
                + -T::TWO * operand.as_inner().xy() * self.xyz() * self.xzt()
                + -T::TWO * operand.as_inner().yt() * self.xzt() * self.yzt()
                + T::TWO * operand.as_inner().xz() * self.xyt() * self.xyz()
                + T::TWO * operand.as_inner().zt() * self.xyt() * self.yzt()
                + operand.as_inner().xt() * self.yzt() * self.yzt(),
            -(operand.as_inner().yz() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().xy() * self.xyt() * self.yzt()
                + -T::TWO * operand.as_inner().xz() * self.xzt() * self.yzt()
                + -T::TWO * operand.as_inner().yt() * self.xyt() * self.xyz()
                + -T::TWO * operand.as_inner().zt() * self.xyz() * self.xzt()
                + operand.as_inner().yz() * self.xyt() * self.xyt()
                + operand.as_inner().yz() * self.xyz() * self.xyz()
                + operand.as_inner().yz() * self.xzt() * self.xzt(),
            -(operand.as_inner().yt() * self.xyt() * self.xyt())
                + -(operand.as_inner().yt() * self.xyz() * self.xyz())
                + -(operand.as_inner().yt() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().xt() * self.xzt() * self.yzt()
                + -T::TWO * operand.as_inner().xy() * self.xyz() * self.yzt()
                + -T::TWO * operand.as_inner().zt() * self.xyt() * self.xzt()
                + T::TWO * operand.as_inner().yz() * self.xyt() * self.xyz()
                + operand.as_inner().yt() * self.xzt() * self.xzt(),
            -(operand.as_inner().zt() * self.xyz() * self.xyz())
                + -(operand.as_inner().zt() * self.xzt() * self.xzt())
                + -(operand.as_inner().zt() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().xz() * self.xyz() * self.yzt()
                + -T::TWO * operand.as_inner().yt() * self.xyt() * self.xzt()
                + T::TWO * operand.as_inner().xt() * self.xyt() * self.yzt()
                + T::TWO * operand.as_inner().yz() * self.xyz() * self.xzt()
                + operand.as_inner().zt() * self.xyt() * self.xyt(),
            -(operand.as_inner().xyzt() * self.xyz() * self.xyz())
                + operand.as_inner().xyzt() * self.xyt() * self.xyt()
                + operand.as_inner().xyzt() * self.xzt() * self.xzt()
                + operand.as_inner().xyzt() * self.yzt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Unit<Trivector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            operand.as_inner().s(),
            -T::TWO * operand.as_inner().xz() * self.as_inner().xyt() * self.as_inner().xzt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xyz() * self.as_inner().yzt()
                + operand.as_inner().xy(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xyt() * self.as_inner().xzt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xyz() * self.as_inner().yzt()
                + operand.as_inner().xz(),
            -(operand.as_inner().xt())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xzt() * self.as_inner().xzt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xyz() * self.as_inner().xzt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xyt() * self.as_inner().xyz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xyt() * self.as_inner().yzt(),
            -T::TWO * operand.as_inner().xy() * self.as_inner().xyt() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xzt() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xzt() * self.as_inner().xzt()
                + operand.as_inner().yz(),
            -(operand.as_inner().yt())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xzt() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xyz() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().yzt() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyt() * self.as_inner().xyz(),
            -(operand.as_inner().zt())
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xyz() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xyt() * self.as_inner().xzt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xzt() * self.as_inner().xzt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyz() * self.as_inner().xzt(),
            -(operand.as_inner().xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Trivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.xyt() * operand.xyzt() * self.xyt() - self.xyz() * operand.xyzt() * self.xyz()
                + self.xzt() * operand.xyzt() * self.xzt()
                + self.yzt() * operand.xyzt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Unit<Trivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(operand.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Trivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(operand.as_inner().xyzt() * self.xyz() * self.xyz())
                + operand.as_inner().xyzt() * self.xyt() * self.xyt()
                + operand.as_inner().xyzt() * self.xzt() * self.xzt()
                + operand.as_inner().xyzt() * self.yzt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Unit<Trivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(operand.as_inner().xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.xyt() * operand.s() * self.xyt()) + self.xyz() * operand.s() * self.xyz()
                - self.xzt() * operand.s() * self.xzt()
                - self.yzt() * operand.s() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unit<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(operand.as_inner().s() * self.xyt() * self.xyt())
                + -(operand.as_inner().s() * self.xzt() * self.xzt())
                + -(operand.as_inner().s() * self.yzt() * self.yzt())
                + operand.as_inner().s() * self.xyz() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Unit<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(self.xyt() * operand.xyt() * self.xyz()) + self.xyt() * operand.xyz() * self.xyt()
                - self.xyz() * operand.xyt() * self.xyt()
                + self.xyz() * operand.xyz() * self.xyz()
                - self.xyz() * operand.xzt() * self.xzt()
                - self.xyz() * operand.yzt() * self.yzt()
                + self.xzt() * operand.xyz() * self.xzt()
                - self.xzt() * operand.xzt() * self.xyz()
                + self.yzt() * operand.xyz() * self.yzt()
                - self.yzt() * operand.yzt() * self.xyz(),
            -(self.xyt() * operand.xyt() * self.xyt()) + self.xyt() * operand.xyz() * self.xyz()
                - self.xyt() * operand.xzt() * self.xzt()
                - self.xyt() * operand.yzt() * self.yzt()
                - self.xyz() * operand.xyt() * self.xyz()
                + self.xyz() * operand.xyz() * self.xyt()
                + self.xzt() * operand.xyt() * self.xzt()
                - self.xzt() * operand.xzt() * self.xyt()
                + self.yzt() * operand.xyt() * self.yzt()
                - self.yzt() * operand.yzt() * self.xyt(),
            -(self.xyt() * operand.xyt() * self.xzt())
                + self.xyt() * operand.xzt() * self.xyt()
                + self.xyz() * operand.xyz() * self.xzt()
                - self.xyz() * operand.xzt() * self.xyz()
                - self.xzt() * operand.xyt() * self.xyt()
                + self.xzt() * operand.xyz() * self.xyz()
                - self.xzt() * operand.xzt() * self.xzt()
                - self.xzt() * operand.yzt() * self.yzt()
                + self.yzt() * operand.xzt() * self.yzt()
                - self.yzt() * operand.yzt() * self.xzt(),
            -(self.xyt() * operand.xyt() * self.yzt())
                + self.xyt() * operand.yzt() * self.xyt()
                + self.xyz() * operand.xyz() * self.yzt()
                - self.xyz() * operand.yzt() * self.xyz()
                - self.xzt() * operand.xzt() * self.yzt()
                + self.xzt() * operand.yzt() * self.xzt()
                - self.yzt() * operand.xyt() * self.xyt()
                + self.yzt() * operand.xyz() * self.xyz()
                - self.yzt() * operand.xzt() * self.xzt()
                - self.yzt() * operand.yzt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.xyt() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO * operand.xzt() * self.as_inner().xyz() * self.as_inner().xzt()
                + -T::TWO * operand.yzt() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.xyz() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.xyz() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.xyz() * self.as_inner().yzt() * self.as_inner().yzt()
                + operand.xyz(),
            -(operand.xyt())
                + -T::TWO * operand.xyt() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.xzt() * self.as_inner().xyt() * self.as_inner().xzt()
                + -T::TWO * operand.yzt() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.xyz() * self.as_inner().xyt() * self.as_inner().xyz(),
            -(operand.xzt())
                + -T::TWO * operand.xyt() * self.as_inner().xyt() * self.as_inner().xzt()
                + -T::TWO * operand.xzt() * self.as_inner().xzt() * self.as_inner().xzt()
                + -T::TWO * operand.yzt() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.xyz() * self.as_inner().xyz() * self.as_inner().xzt(),
            -(operand.yzt())
                + -T::TWO * operand.xyt() * self.as_inner().xyt() * self.as_inner().yzt()
                + -T::TWO * operand.xzt() * self.as_inner().xzt() * self.as_inner().yzt()
                + -T::TWO * operand.yzt() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.xyz() * self.as_inner().xyz() * self.as_inner().yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Trivector<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.as_inner().xyt() * self.xyt() * self.xyz()
                + -T::TWO * operand.as_inner().xzt() * self.xyz() * self.xzt()
                + -T::TWO * operand.as_inner().yzt() * self.xyz() * self.yzt()
                + operand.as_inner().xyz() * self.xyt() * self.xyt()
                + operand.as_inner().xyz() * self.xyz() * self.xyz()
                + operand.as_inner().xyz() * self.xzt() * self.xzt()
                + operand.as_inner().xyz() * self.yzt() * self.yzt(),
            -(operand.as_inner().xyt() * self.xyt() * self.xyt())
                + -(operand.as_inner().xyt() * self.xyz() * self.xyz())
                + -T::TWO * operand.as_inner().xzt() * self.xyt() * self.xzt()
                + -T::TWO * operand.as_inner().yzt() * self.xyt() * self.yzt()
                + T::TWO * operand.as_inner().xyz() * self.xyt() * self.xyz()
                + operand.as_inner().xyt() * self.xzt() * self.xzt()
                + operand.as_inner().xyt() * self.yzt() * self.yzt(),
            -(operand.as_inner().xzt() * self.xyz() * self.xyz())
                + -(operand.as_inner().xzt() * self.xzt() * self.xzt())
                + -T::TWO * operand.as_inner().xyt() * self.xyt() * self.xzt()
                + -T::TWO * operand.as_inner().yzt() * self.xzt() * self.yzt()
                + T::TWO * operand.as_inner().xyz() * self.xyz() * self.xzt()
                + operand.as_inner().xzt() * self.xyt() * self.xyt()
                + operand.as_inner().xzt() * self.yzt() * self.yzt(),
            -(operand.as_inner().yzt() * self.xyz() * self.xyz())
                + -(operand.as_inner().yzt() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().xyt() * self.xyt() * self.yzt()
                + -T::TWO * operand.as_inner().xzt() * self.xzt() * self.yzt()
                + T::TWO * operand.as_inner().xyz() * self.xyz() * self.yzt()
                + operand.as_inner().yzt() * self.xyt() * self.xyt()
                + operand.as_inner().yzt() * self.xzt() * self.xzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Trivector<T>>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.as_inner().xyt() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO
                    * operand.as_inner().xzt()
                    * self.as_inner().xyz()
                    * self.as_inner().xzt()
                + -T::TWO
                    * operand.as_inner().yzt()
                    * self.as_inner().xyz()
                    * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().yzt() * self.as_inner().yzt()
                + operand.as_inner().xyz(),
            -(operand.as_inner().xyt())
                + -T::TWO
                    * operand.as_inner().xyt()
                    * self.as_inner().xyt()
                    * self.as_inner().xyt()
                + -T::TWO
                    * operand.as_inner().xzt()
                    * self.as_inner().xyt()
                    * self.as_inner().xzt()
                + -T::TWO
                    * operand.as_inner().yzt()
                    * self.as_inner().xyt()
                    * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xyt() * self.as_inner().xyz(),
            -(operand.as_inner().xzt())
                + -T::TWO
                    * operand.as_inner().xyt()
                    * self.as_inner().xyt()
                    * self.as_inner().xzt()
                + -T::TWO
                    * operand.as_inner().xzt()
                    * self.as_inner().xzt()
                    * self.as_inner().xzt()
                + -T::TWO
                    * operand.as_inner().yzt()
                    * self.as_inner().xzt()
                    * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xyz() * self.as_inner().xzt(),
            -(operand.as_inner().yzt())
                + -T::TWO
                    * operand.as_inner().xyt()
                    * self.as_inner().xyt()
                    * self.as_inner().yzt()
                + -T::TWO
                    * operand.as_inner().xzt()
                    * self.as_inner().xzt()
                    * self.as_inner().yzt()
                + -T::TWO
                    * operand.as_inner().yzt()
                    * self.as_inner().yzt()
                    * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xyz() * self.as_inner().yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.xyt() * operand.x() * self.xyt()) + self.xyt() * operand.z() * self.yzt()
                - self.xyz() * operand.t() * self.yzt()
                + self.xyz() * operand.x() * self.xyz()
                - self.xzt() * operand.x() * self.xzt()
                - self.xzt() * operand.y() * self.yzt()
                - self.yzt() * operand.t() * self.xyz()
                + self.yzt() * operand.x() * self.yzt()
                - self.yzt() * operand.y() * self.xzt()
                + self.yzt() * operand.z() * self.xyt(),
            -(self.xyt() * operand.y() * self.xyt()) - self.xyt() * operand.z() * self.xzt()
                + self.xyz() * operand.t() * self.xzt()
                + self.xyz() * operand.y() * self.xyz()
                + self.xzt() * operand.t() * self.xyz()
                - self.xzt() * operand.x() * self.yzt()
                + self.xzt() * operand.y() * self.xzt()
                - self.xzt() * operand.z() * self.xyt()
                - self.yzt() * operand.x() * self.xzt()
                - self.yzt() * operand.y() * self.yzt(),
            -(self.xyt() * operand.t() * self.xyz()) + self.xyt() * operand.x() * self.yzt()
                - self.xyt() * operand.y() * self.xzt()
                + self.xyt() * operand.z() * self.xyt()
                - self.xyz() * operand.t() * self.xyt()
                + self.xyz() * operand.z() * self.xyz()
                - self.xzt() * operand.y() * self.xyt()
                - self.xzt() * operand.z() * self.xzt()
                + self.yzt() * operand.x() * self.xyt()
                - self.yzt() * operand.z() * self.yzt(),
            -(self.xyt() * operand.t() * self.xyt()) + self.xyt() * operand.z() * self.xyz()
                - self.xyz() * operand.t() * self.xyz()
                + self.xyz() * operand.x() * self.yzt()
                - self.xyz() * operand.y() * self.xzt()
                + self.xyz() * operand.z() * self.xyt()
                - self.xzt() * operand.t() * self.xzt()
                - self.xzt() * operand.y() * self.xyz()
                - self.yzt() * operand.t() * self.yzt()
                + self.yzt() * operand.x() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Unit<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -T::TWO * operand.t() * self.as_inner().xyz() * self.as_inner().yzt()
                + -T::TWO * operand.y() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.x() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.z() * self.as_inner().xyt() * self.as_inner().yzt()
                + operand.x(),
            -T::TWO * operand.x() * self.as_inner().xzt() * self.as_inner().yzt()
                + -T::TWO * operand.z() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.t() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.y() * self.as_inner().xzt() * self.as_inner().xzt()
                + operand.y(),
            -T::TWO * operand.t() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO * operand.y() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.x() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.z() * self.as_inner().xyt() * self.as_inner().xyt()
                + operand.z(),
            -(operand.t())
                + -T::TWO * operand.t() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.t() * self.as_inner().xzt() * self.as_inner().xzt()
                + -T::TWO * operand.t() * self.as_inner().yzt() * self.as_inner().yzt()
                + -T::TWO * operand.y() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.x() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.z() * self.as_inner().xyt() * self.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.as_inner().x() * self.xyt() * self.xyt())
                + -(operand.as_inner().x() * self.xzt() * self.xzt())
                + -T::TWO * operand.as_inner().t() * self.xyz() * self.yzt()
                + -T::TWO * operand.as_inner().y() * self.xzt() * self.yzt()
                + T::TWO * operand.as_inner().z() * self.xyt() * self.yzt()
                + operand.as_inner().x() * self.xyz() * self.xyz()
                + operand.as_inner().x() * self.yzt() * self.yzt(),
            -(operand.as_inner().y() * self.xyt() * self.xyt())
                + -(operand.as_inner().y() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().x() * self.xzt() * self.yzt()
                + -T::TWO * operand.as_inner().z() * self.xyt() * self.xzt()
                + T::TWO * operand.as_inner().t() * self.xyz() * self.xzt()
                + operand.as_inner().y() * self.xyz() * self.xyz()
                + operand.as_inner().y() * self.xzt() * self.xzt(),
            -(operand.as_inner().z() * self.xzt() * self.xzt())
                + -(operand.as_inner().z() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().t() * self.xyt() * self.xyz()
                + -T::TWO * operand.as_inner().y() * self.xyt() * self.xzt()
                + T::TWO * operand.as_inner().x() * self.xyt() * self.yzt()
                + operand.as_inner().z() * self.xyt() * self.xyt()
                + operand.as_inner().z() * self.xyz() * self.xyz(),
            -(operand.as_inner().t() * self.xyt() * self.xyt())
                + -(operand.as_inner().t() * self.xyz() * self.xyz())
                + -(operand.as_inner().t() * self.xzt() * self.xzt())
                + -(operand.as_inner().t() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().y() * self.xyz() * self.xzt()
                + T::TWO * operand.as_inner().x() * self.xyz() * self.yzt()
                + T::TWO * operand.as_inner().z() * self.xyt() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Unit<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -T::TWO * operand.as_inner().t() * self.as_inner().xyz() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().x() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().z() * self.as_inner().xyt() * self.as_inner().yzt()
                + operand.as_inner().x(),
            -T::TWO * operand.as_inner().x() * self.as_inner().xzt() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().t() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().y() * self.as_inner().xzt() * self.as_inner().xzt()
                + operand.as_inner().y(),
            -T::TWO * operand.as_inner().t() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().x() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().z() * self.as_inner().xyt() * self.as_inner().xyt()
                + operand.as_inner().z(),
            -(operand.as_inner().t())
                + -T::TWO * operand.as_inner().t() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.as_inner().t() * self.as_inner().xzt() * self.as_inner().xzt()
                + -T::TWO * operand.as_inner().t() * self.as_inner().yzt() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().x() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().z() * self.as_inner().xyt() * self.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.t() * operand.xt() * self.y()
                - self.t() * operand.xy() * self.t()
                - self.t() * operand.yt() * self.x()
                - self.x() * operand.xy() * self.x()
                - self.x() * operand.yt() * self.t()
                + self.x() * operand.yz() * self.z()
                + self.y() * operand.xt() * self.t()
                - self.y() * operand.xy() * self.y()
                - self.y() * operand.xz() * self.z()
                + self.z() * operand.xy() * self.z()
                - self.z() * operand.xz() * self.y()
                + self.z() * operand.yz() * self.x(),
            self.t() * operand.xt() * self.z()
                - self.t() * operand.xz() * self.t()
                - self.t() * operand.zt() * self.x()
                - self.x() * operand.xz() * self.x()
                - self.x() * operand.yz() * self.y()
                - self.x() * operand.zt() * self.t()
                - self.y() * operand.xy() * self.z()
                + self.y() * operand.xz() * self.y()
                - self.y() * operand.yz() * self.x()
                + self.z() * operand.xt() * self.t()
                - self.z() * operand.xy() * self.y()
                - self.z() * operand.xz() * self.z(),
            self.t() * operand.xt() * self.t()
                - self.t() * operand.xy() * self.y()
                - self.t() * operand.xz() * self.z()
                - self.x() * operand.xt() * self.x()
                - self.x() * operand.yt() * self.y()
                - self.x() * operand.zt() * self.z()
                + self.y() * operand.xt() * self.y()
                - self.y() * operand.xy() * self.t()
                - self.y() * operand.yt() * self.x()
                + self.z() * operand.xt() * self.z()
                - self.z() * operand.xz() * self.t()
                - self.z() * operand.zt() * self.x(),
            self.t() * operand.yt() * self.z()
                - self.t() * operand.yz() * self.t()
                - self.t() * operand.zt() * self.y()
                + self.x() * operand.xy() * self.z()
                - self.x() * operand.xz() * self.y()
                + self.x() * operand.yz() * self.x()
                - self.y() * operand.xz() * self.x()
                - self.y() * operand.yz() * self.y()
                - self.y() * operand.zt() * self.t()
                + self.z() * operand.xy() * self.x()
                + self.z() * operand.yt() * self.t()
                - self.z() * operand.yz() * self.z(),
            self.t() * operand.xy() * self.x() + self.t() * operand.yt() * self.t()
                - self.t() * operand.yz() * self.z()
                - self.x() * operand.xt() * self.y()
                + self.x() * operand.xy() * self.t()
                + self.x() * operand.yt() * self.x()
                - self.y() * operand.xt() * self.x()
                - self.y() * operand.yt() * self.y()
                - self.y() * operand.zt() * self.z()
                + self.z() * operand.yt() * self.z()
                - self.z() * operand.yz() * self.t()
                - self.z() * operand.zt() * self.y(),
            self.t() * operand.xz() * self.x()
                + self.t() * operand.yz() * self.y()
                + self.t() * operand.zt() * self.t()
                - self.x() * operand.xt() * self.z()
                + self.x() * operand.xz() * self.t()
                + self.x() * operand.zt() * self.x()
                - self.y() * operand.yt() * self.z()
                + self.y() * operand.yz() * self.t()
                + self.y() * operand.zt() * self.y()
                - self.z() * operand.xt() * self.x()
                - self.z() * operand.yt() * self.y()
                - self.z() * operand.zt() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.xy())
                + -T::TWO * operand.xy() * self.as_inner().t() * self.as_inner().t()
                + -T::TWO * operand.xz() * self.as_inner().y() * self.as_inner().z()
                + -T::TWO * operand.yt() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.xt() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.xy() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.yz() * self.as_inner().x() * self.as_inner().z(),
            -(operand.xz())
                + -T::TWO * operand.xy() * self.as_inner().y() * self.as_inner().z()
                + -T::TWO * operand.xz() * self.as_inner().t() * self.as_inner().t()
                + -T::TWO * operand.yz() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.zt() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.xt() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.xz() * self.as_inner().y() * self.as_inner().y(),
            -(operand.xt())
                + -T::TWO * operand.xy() * self.as_inner().t() * self.as_inner().y()
                + -T::TWO * operand.xz() * self.as_inner().t() * self.as_inner().z()
                + -T::TWO * operand.yt() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.zt() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.xt() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.xt() * self.as_inner().z() * self.as_inner().z(),
            -T::TWO * operand.xz() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.yz() * self.as_inner().y() * self.as_inner().y()
                + -T::TWO * operand.yz() * self.as_inner().z() * self.as_inner().z()
                + -T::TWO * operand.zt() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.xy() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.yt() * self.as_inner().t() * self.as_inner().z()
                + operand.yz(),
            -T::TWO * operand.xt() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.yt() * self.as_inner().y() * self.as_inner().y()
                + -T::TWO * operand.yz() * self.as_inner().t() * self.as_inner().z()
                + -T::TWO * operand.zt() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.xy() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.yt() * self.as_inner().t() * self.as_inner().t()
                + operand.yt(),
            -T::TWO * operand.xt() * self.as_inner().x() * self.as_inner().z()
                + -T::TWO * operand.yt() * self.as_inner().y() * self.as_inner().z()
                + -T::TWO * operand.zt() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.xz() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.yz() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.zt() * self.as_inner().t() * self.as_inner().t()
                + operand.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.as_inner().xy() * self.t() * self.t())
                + -(operand.as_inner().xy() * self.x() * self.x())
                + -(operand.as_inner().xy() * self.y() * self.y())
                + -T::TWO * operand.as_inner().xz() * self.y() * self.z()
                + -T::TWO * operand.as_inner().yt() * self.t() * self.x()
                + T::TWO * operand.as_inner().xt() * self.t() * self.y()
                + T::TWO * operand.as_inner().yz() * self.x() * self.z()
                + operand.as_inner().xy() * self.z() * self.z(),
            -(operand.as_inner().xz() * self.t() * self.t())
                + -(operand.as_inner().xz() * self.x() * self.x())
                + -(operand.as_inner().xz() * self.z() * self.z())
                + -T::TWO * operand.as_inner().xy() * self.y() * self.z()
                + -T::TWO * operand.as_inner().yz() * self.x() * self.y()
                + -T::TWO * operand.as_inner().zt() * self.t() * self.x()
                + T::TWO * operand.as_inner().xt() * self.t() * self.z()
                + operand.as_inner().xz() * self.y() * self.y(),
            -(operand.as_inner().xt() * self.x() * self.x())
                + -T::TWO * operand.as_inner().xy() * self.t() * self.y()
                + -T::TWO * operand.as_inner().xz() * self.t() * self.z()
                + -T::TWO * operand.as_inner().yt() * self.x() * self.y()
                + -T::TWO * operand.as_inner().zt() * self.x() * self.z()
                + operand.as_inner().xt() * self.t() * self.t()
                + operand.as_inner().xt() * self.y() * self.y()
                + operand.as_inner().xt() * self.z() * self.z(),
            -(operand.as_inner().yz() * self.t() * self.t())
                + -(operand.as_inner().yz() * self.y() * self.y())
                + -(operand.as_inner().yz() * self.z() * self.z())
                + -T::TWO * operand.as_inner().xz() * self.x() * self.y()
                + -T::TWO * operand.as_inner().zt() * self.t() * self.y()
                + T::TWO * operand.as_inner().xy() * self.x() * self.z()
                + T::TWO * operand.as_inner().yt() * self.t() * self.z()
                + operand.as_inner().yz() * self.x() * self.x(),
            -(operand.as_inner().yt() * self.y() * self.y())
                + -T::TWO * operand.as_inner().xt() * self.x() * self.y()
                + -T::TWO * operand.as_inner().yz() * self.t() * self.z()
                + -T::TWO * operand.as_inner().zt() * self.y() * self.z()
                + T::TWO * operand.as_inner().xy() * self.t() * self.x()
                + operand.as_inner().yt() * self.t() * self.t()
                + operand.as_inner().yt() * self.x() * self.x()
                + operand.as_inner().yt() * self.z() * self.z(),
            -(operand.as_inner().zt() * self.z() * self.z())
                + -T::TWO * operand.as_inner().xt() * self.x() * self.z()
                + -T::TWO * operand.as_inner().yt() * self.y() * self.z()
                + T::TWO * operand.as_inner().xz() * self.t() * self.x()
                + T::TWO * operand.as_inner().yz() * self.t() * self.y()
                + operand.as_inner().zt() * self.t() * self.t()
                + operand.as_inner().zt() * self.x() * self.x()
                + operand.as_inner().zt() * self.y() * self.y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.as_inner().xy())
                + -T::TWO * operand.as_inner().xy() * self.as_inner().t() * self.as_inner().t()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().y() * self.as_inner().z()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.as_inner().xt() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.as_inner().xy() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.as_inner().yz() * self.as_inner().x() * self.as_inner().z(),
            -(operand.as_inner().xz())
                + -T::TWO * operand.as_inner().xy() * self.as_inner().y() * self.as_inner().z()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().t() * self.as_inner().t()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.as_inner().xt() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.as_inner().xz() * self.as_inner().y() * self.as_inner().y(),
            -(operand.as_inner().xt())
                + -T::TWO * operand.as_inner().xy() * self.as_inner().t() * self.as_inner().y()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().t() * self.as_inner().z()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.as_inner().xt() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.as_inner().xt() * self.as_inner().z() * self.as_inner().z(),
            -T::TWO * operand.as_inner().xz() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().y() * self.as_inner().y()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().z() * self.as_inner().z()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.as_inner().xy() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.as_inner().yt() * self.as_inner().t() * self.as_inner().z()
                + operand.as_inner().yz(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().y() * self.as_inner().y()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().t() * self.as_inner().z()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.as_inner().xy() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.as_inner().yt() * self.as_inner().t() * self.as_inner().t()
                + operand.as_inner().yt(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().x() * self.as_inner().z()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().y() * self.as_inner().z()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.as_inner().xz() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.as_inner().yz() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.as_inner().zt() * self.as_inner().t() * self.as_inner().t()
                + operand.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Vector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(self.t() * operand.s() * self.t())
                + self.t() * operand.xt() * self.x()
                + self.t() * operand.yt() * self.y()
                + self.t() * operand.zt() * self.z()
                + self.x() * operand.s() * self.x()
                - self.x() * operand.xt() * self.t()
                + self.x() * operand.xy() * self.y()
                + self.x() * operand.xz() * self.z()
                + self.y() * operand.s() * self.y()
                - self.y() * operand.xy() * self.x()
                - self.y() * operand.yt() * self.t()
                + self.y() * operand.yz() * self.z()
                + self.z() * operand.s() * self.z()
                - self.z() * operand.xz() * self.x()
                - self.z() * operand.yz() * self.y()
                - self.z() * operand.zt() * self.t(),
            self.t() * operand.xt() * self.y() - self.t() * operand.xy() * self.t()
                + self.t() * operand.xyzt() * self.z()
                - self.t() * operand.yt() * self.x()
                + self.x() * operand.s() * self.y()
                - self.x() * operand.xy() * self.x()
                - self.x() * operand.yt() * self.t()
                + self.x() * operand.yz() * self.z()
                - self.y() * operand.s() * self.x()
                + self.y() * operand.xt() * self.t()
                - self.y() * operand.xy() * self.y()
                - self.y() * operand.xz() * self.z()
                + self.z() * operand.xy() * self.z()
                - self.z() * operand.xyzt() * self.t()
                - self.z() * operand.xz() * self.y()
                + self.z() * operand.yz() * self.x(),
            self.t() * operand.xt() * self.z()
                - self.t() * operand.xyzt() * self.y()
                - self.t() * operand.xz() * self.t()
                - self.t() * operand.zt() * self.x()
                + self.x() * operand.s() * self.z()
                - self.x() * operand.xz() * self.x()
                - self.x() * operand.yz() * self.y()
                - self.x() * operand.zt() * self.t()
                - self.y() * operand.xy() * self.z()
                + self.y() * operand.xyzt() * self.t()
                + self.y() * operand.xz() * self.y()
                - self.y() * operand.yz() * self.x()
                - self.z() * operand.s() * self.x()
                + self.z() * operand.xt() * self.t()
                - self.z() * operand.xy() * self.y()
                - self.z() * operand.xz() * self.z(),
            -(self.t() * operand.s() * self.x()) + self.t() * operand.xt() * self.t()
                - self.t() * operand.xy() * self.y()
                - self.t() * operand.xz() * self.z()
                + self.x() * operand.s() * self.t()
                - self.x() * operand.xt() * self.x()
                - self.x() * operand.yt() * self.y()
                - self.x() * operand.zt() * self.z()
                + self.y() * operand.xt() * self.y()
                - self.y() * operand.xy() * self.t()
                + self.y() * operand.xyzt() * self.z()
                - self.y() * operand.yt() * self.x()
                + self.z() * operand.xt() * self.z()
                - self.z() * operand.xyzt() * self.y()
                - self.z() * operand.xz() * self.t()
                - self.z() * operand.zt() * self.x(),
            self.t() * operand.xyzt() * self.x() + self.t() * operand.yt() * self.z()
                - self.t() * operand.yz() * self.t()
                - self.t() * operand.zt() * self.y()
                + self.x() * operand.xy() * self.z()
                - self.x() * operand.xyzt() * self.t()
                - self.x() * operand.xz() * self.y()
                + self.x() * operand.yz() * self.x()
                + self.y() * operand.s() * self.z()
                - self.y() * operand.xz() * self.x()
                - self.y() * operand.yz() * self.y()
                - self.y() * operand.zt() * self.t()
                - self.z() * operand.s() * self.y()
                + self.z() * operand.xy() * self.x()
                + self.z() * operand.yt() * self.t()
                - self.z() * operand.yz() * self.z(),
            -(self.t() * operand.s() * self.y())
                + self.t() * operand.xy() * self.x()
                + self.t() * operand.yt() * self.t()
                - self.t() * operand.yz() * self.z()
                - self.x() * operand.xt() * self.y()
                + self.x() * operand.xy() * self.t()
                - self.x() * operand.xyzt() * self.z()
                + self.x() * operand.yt() * self.x()
                + self.y() * operand.s() * self.t()
                - self.y() * operand.xt() * self.x()
                - self.y() * operand.yt() * self.y()
                - self.y() * operand.zt() * self.z()
                + self.z() * operand.xyzt() * self.x()
                + self.z() * operand.yt() * self.z()
                - self.z() * operand.yz() * self.t()
                - self.z() * operand.zt() * self.y(),
            -(self.t() * operand.s() * self.z())
                + self.t() * operand.xz() * self.x()
                + self.t() * operand.yz() * self.y()
                + self.t() * operand.zt() * self.t()
                - self.x() * operand.xt() * self.z()
                + self.x() * operand.xyzt() * self.y()
                + self.x() * operand.xz() * self.t()
                + self.x() * operand.zt() * self.x()
                - self.y() * operand.xyzt() * self.x()
                - self.y() * operand.yt() * self.z()
                + self.y() * operand.yz() * self.t()
                + self.y() * operand.zt() * self.y()
                + self.z() * operand.s() * self.t()
                - self.z() * operand.xt() * self.x()
                - self.z() * operand.yt() * self.y()
                - self.z() * operand.zt() * self.z(),
            -(self.t() * operand.xy() * self.z())
                + self.t() * operand.xyzt() * self.t()
                + self.t() * operand.xz() * self.y()
                - self.t() * operand.yz() * self.x()
                - self.x() * operand.xyzt() * self.x()
                - self.x() * operand.yt() * self.z()
                + self.x() * operand.yz() * self.t()
                + self.x() * operand.zt() * self.y()
                + self.y() * operand.xt() * self.z()
                - self.y() * operand.xyzt() * self.y()
                - self.y() * operand.xz() * self.t()
                - self.y() * operand.zt() * self.x()
                - self.z() * operand.xt() * self.y()
                + self.z() * operand.xy() * self.t()
                - self.z() * operand.xyzt() * self.z()
                + self.z() * operand.yt() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Unit<Vector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            operand.s(),
            -(operand.xy())
                + -T::TWO * operand.xy() * self.as_inner().t() * self.as_inner().t()
                + -T::TWO * operand.xz() * self.as_inner().y() * self.as_inner().z()
                + -T::TWO * operand.yt() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.xt() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.xy() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.yz() * self.as_inner().x() * self.as_inner().z(),
            -(operand.xz())
                + -T::TWO * operand.xy() * self.as_inner().y() * self.as_inner().z()
                + -T::TWO * operand.xz() * self.as_inner().t() * self.as_inner().t()
                + -T::TWO * operand.yz() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.zt() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.xt() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.xz() * self.as_inner().y() * self.as_inner().y(),
            -(operand.xt())
                + -T::TWO * operand.xy() * self.as_inner().t() * self.as_inner().y()
                + -T::TWO * operand.xz() * self.as_inner().t() * self.as_inner().z()
                + -T::TWO * operand.yt() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.zt() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.xt() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.xt() * self.as_inner().z() * self.as_inner().z(),
            -T::TWO * operand.xz() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.yz() * self.as_inner().y() * self.as_inner().y()
                + -T::TWO * operand.yz() * self.as_inner().z() * self.as_inner().z()
                + -T::TWO * operand.zt() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.xy() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.yt() * self.as_inner().t() * self.as_inner().z()
                + operand.yz(),
            -T::TWO * operand.xt() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.yt() * self.as_inner().y() * self.as_inner().y()
                + -T::TWO * operand.yz() * self.as_inner().t() * self.as_inner().z()
                + -T::TWO * operand.zt() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.xy() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.yt() * self.as_inner().t() * self.as_inner().t()
                + operand.yt(),
            -T::TWO * operand.xt() * self.as_inner().x() * self.as_inner().z()
                + -T::TWO * operand.yt() * self.as_inner().y() * self.as_inner().z()
                + -T::TWO * operand.zt() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.xz() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.yz() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.zt() * self.as_inner().t() * self.as_inner().t()
                + operand.zt(),
            -(operand.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Vector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.as_inner().s() * self.t() * self.t())
                + operand.as_inner().s() * self.x() * self.x()
                + operand.as_inner().s() * self.y() * self.y()
                + operand.as_inner().s() * self.z() * self.z(),
            -(operand.as_inner().xy() * self.t() * self.t())
                + -(operand.as_inner().xy() * self.x() * self.x())
                + -(operand.as_inner().xy() * self.y() * self.y())
                + -T::TWO * operand.as_inner().xz() * self.y() * self.z()
                + -T::TWO * operand.as_inner().yt() * self.t() * self.x()
                + T::TWO * operand.as_inner().xt() * self.t() * self.y()
                + T::TWO * operand.as_inner().yz() * self.x() * self.z()
                + operand.as_inner().xy() * self.z() * self.z(),
            -(operand.as_inner().xz() * self.t() * self.t())
                + -(operand.as_inner().xz() * self.x() * self.x())
                + -(operand.as_inner().xz() * self.z() * self.z())
                + -T::TWO * operand.as_inner().xy() * self.y() * self.z()
                + -T::TWO * operand.as_inner().yz() * self.x() * self.y()
                + -T::TWO * operand.as_inner().zt() * self.t() * self.x()
                + T::TWO * operand.as_inner().xt() * self.t() * self.z()
                + operand.as_inner().xz() * self.y() * self.y(),
            -(operand.as_inner().xt() * self.x() * self.x())
                + -T::TWO * operand.as_inner().xy() * self.t() * self.y()
                + -T::TWO * operand.as_inner().xz() * self.t() * self.z()
                + -T::TWO * operand.as_inner().yt() * self.x() * self.y()
                + -T::TWO * operand.as_inner().zt() * self.x() * self.z()
                + operand.as_inner().xt() * self.t() * self.t()
                + operand.as_inner().xt() * self.y() * self.y()
                + operand.as_inner().xt() * self.z() * self.z(),
            -(operand.as_inner().yz() * self.t() * self.t())
                + -(operand.as_inner().yz() * self.y() * self.y())
                + -(operand.as_inner().yz() * self.z() * self.z())
                + -T::TWO * operand.as_inner().xz() * self.x() * self.y()
                + -T::TWO * operand.as_inner().zt() * self.t() * self.y()
                + T::TWO * operand.as_inner().xy() * self.x() * self.z()
                + T::TWO * operand.as_inner().yt() * self.t() * self.z()
                + operand.as_inner().yz() * self.x() * self.x(),
            -(operand.as_inner().yt() * self.y() * self.y())
                + -T::TWO * operand.as_inner().xt() * self.x() * self.y()
                + -T::TWO * operand.as_inner().yz() * self.t() * self.z()
                + -T::TWO * operand.as_inner().zt() * self.y() * self.z()
                + T::TWO * operand.as_inner().xy() * self.t() * self.x()
                + operand.as_inner().yt() * self.t() * self.t()
                + operand.as_inner().yt() * self.x() * self.x()
                + operand.as_inner().yt() * self.z() * self.z(),
            -(operand.as_inner().zt() * self.z() * self.z())
                + -T::TWO * operand.as_inner().xt() * self.x() * self.z()
                + -T::TWO * operand.as_inner().yt() * self.y() * self.z()
                + T::TWO * operand.as_inner().xz() * self.t() * self.x()
                + T::TWO * operand.as_inner().yz() * self.t() * self.y()
                + operand.as_inner().zt() * self.t() * self.t()
                + operand.as_inner().zt() * self.x() * self.x()
                + operand.as_inner().zt() * self.y() * self.y(),
            -(operand.as_inner().xyzt() * self.x() * self.x())
                + -(operand.as_inner().xyzt() * self.y() * self.y())
                + -(operand.as_inner().xyzt() * self.z() * self.z())
                + operand.as_inner().xyzt() * self.t() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Unit<Vector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            operand.as_inner().s(),
            -(operand.as_inner().xy())
                + -T::TWO * operand.as_inner().xy() * self.as_inner().t() * self.as_inner().t()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().y() * self.as_inner().z()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.as_inner().xt() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.as_inner().xy() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.as_inner().yz() * self.as_inner().x() * self.as_inner().z(),
            -(operand.as_inner().xz())
                + -T::TWO * operand.as_inner().xy() * self.as_inner().y() * self.as_inner().z()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().t() * self.as_inner().t()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.as_inner().xt() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.as_inner().xz() * self.as_inner().y() * self.as_inner().y(),
            -(operand.as_inner().xt())
                + -T::TWO * operand.as_inner().xy() * self.as_inner().t() * self.as_inner().y()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().t() * self.as_inner().z()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.as_inner().xt() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.as_inner().xt() * self.as_inner().z() * self.as_inner().z(),
            -T::TWO * operand.as_inner().xz() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().y() * self.as_inner().y()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().z() * self.as_inner().z()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.as_inner().xy() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.as_inner().yt() * self.as_inner().t() * self.as_inner().z()
                + operand.as_inner().yz(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().x() * self.as_inner().y()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().y() * self.as_inner().y()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().t() * self.as_inner().z()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.as_inner().xy() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.as_inner().yt() * self.as_inner().t() * self.as_inner().t()
                + operand.as_inner().yt(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().x() * self.as_inner().z()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().y() * self.as_inner().z()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.as_inner().xz() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.as_inner().yz() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.as_inner().zt() * self.as_inner().t() * self.as_inner().t()
                + operand.as_inner().zt(),
            -(operand.as_inner().xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Vector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.t() * operand.xyzt() * self.t()
                - self.x() * operand.xyzt() * self.x()
                - self.y() * operand.xyzt() * self.y()
                - self.z() * operand.xyzt() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Unit<Vector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(operand.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Vector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(operand.as_inner().xyzt() * self.x() * self.x())
                + -(operand.as_inner().xyzt() * self.y() * self.y())
                + -(operand.as_inner().xyzt() * self.z() * self.z())
                + operand.as_inner().xyzt() * self.t() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Unit<Vector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(operand.as_inner().xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.t() * operand.s() * self.t())
                + self.x() * operand.s() * self.x()
                + self.y() * operand.s() * self.y()
                + self.z() * operand.s() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(operand.as_inner().s() * self.t() * self.t())
                + operand.as_inner().s() * self.x() * self.x()
                + operand.as_inner().s() * self.y() * self.y()
                + operand.as_inner().s() * self.z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(self.t() * operand.xyt() * self.z())
                + self.t() * operand.xyz() * self.t()
                + self.t() * operand.xzt() * self.y()
                - self.t() * operand.yzt() * self.x()
                + self.x() * operand.xyz() * self.x()
                - self.x() * operand.yzt() * self.t()
                + self.y() * operand.xyz() * self.y()
                + self.y() * operand.xzt() * self.t()
                - self.z() * operand.xyt() * self.t()
                + self.z() * operand.xyz() * self.z(),
            -(self.t() * operand.xyt() * self.t())
                + self.t() * operand.xyz() * self.z()
                + self.x() * operand.xyt() * self.x()
                - self.x() * operand.yzt() * self.z()
                + self.y() * operand.xyt() * self.y()
                + self.y() * operand.xzt() * self.z()
                - self.z() * operand.xyt() * self.z()
                + self.z() * operand.xyz() * self.t()
                + self.z() * operand.xzt() * self.y()
                - self.z() * operand.yzt() * self.x(),
            -(self.t() * operand.xyz() * self.y()) - self.t() * operand.xzt() * self.t()
                + self.x() * operand.xzt() * self.x()
                + self.x() * operand.yzt() * self.y()
                + self.y() * operand.xyt() * self.z()
                - self.y() * operand.xyz() * self.t()
                - self.y() * operand.xzt() * self.y()
                + self.y() * operand.yzt() * self.x()
                + self.z() * operand.xyt() * self.y()
                + self.z() * operand.xzt() * self.z(),
            self.t() * operand.xyz() * self.x()
                - self.t() * operand.yzt() * self.t()
                - self.x() * operand.xyt() * self.z()
                + self.x() * operand.xyz() * self.t()
                + self.x() * operand.xzt() * self.y()
                - self.x() * operand.yzt() * self.x()
                + self.y() * operand.xzt() * self.x()
                + self.y() * operand.yzt() * self.y()
                - self.z() * operand.xyt() * self.x()
                + self.z() * operand.yzt() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Trivector<T>> for Unit<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.xyt() * self.as_inner().t() * self.as_inner().z()
                + -T::TWO * operand.yzt() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.xyz() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.xzt() * self.as_inner().t() * self.as_inner().y()
                + operand.xyz(),
            -T::TWO * operand.xyt() * self.as_inner().z() * self.as_inner().z()
                + -T::TWO * operand.yzt() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.xyz() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.xzt() * self.as_inner().y() * self.as_inner().z()
                + operand.xyt(),
            -T::TWO * operand.xyz() * self.as_inner().t() * self.as_inner().y()
                + -T::TWO * operand.xzt() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.xyt() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.yzt() * self.as_inner().x() * self.as_inner().y()
                + operand.xzt(),
            -(operand.yzt())
                + -T::TWO * operand.xyt() * self.as_inner().x() * self.as_inner().z()
                + -T::TWO * operand.yzt() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.xyz() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.xzt() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.yzt() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.yzt() * self.as_inner().z() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Trivector<T>>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.as_inner().xyt() * self.t() * self.z()
                + -T::TWO * operand.as_inner().yzt() * self.t() * self.x()
                + T::TWO * operand.as_inner().xzt() * self.t() * self.y()
                + operand.as_inner().xyz() * self.t() * self.t()
                + operand.as_inner().xyz() * self.x() * self.x()
                + operand.as_inner().xyz() * self.y() * self.y()
                + operand.as_inner().xyz() * self.z() * self.z(),
            -(operand.as_inner().xyt() * self.t() * self.t())
                + -(operand.as_inner().xyt() * self.z() * self.z())
                + -T::TWO * operand.as_inner().yzt() * self.x() * self.z()
                + T::TWO * operand.as_inner().xyz() * self.t() * self.z()
                + T::TWO * operand.as_inner().xzt() * self.y() * self.z()
                + operand.as_inner().xyt() * self.x() * self.x()
                + operand.as_inner().xyt() * self.y() * self.y(),
            -(operand.as_inner().xzt() * self.t() * self.t())
                + -(operand.as_inner().xzt() * self.y() * self.y())
                + -T::TWO * operand.as_inner().xyz() * self.t() * self.y()
                + T::TWO * operand.as_inner().xyt() * self.y() * self.z()
                + T::TWO * operand.as_inner().yzt() * self.x() * self.y()
                + operand.as_inner().xzt() * self.x() * self.x()
                + operand.as_inner().xzt() * self.z() * self.z(),
            -(operand.as_inner().yzt() * self.t() * self.t())
                + -(operand.as_inner().yzt() * self.x() * self.x())
                + -T::TWO * operand.as_inner().xyt() * self.x() * self.z()
                + T::TWO * operand.as_inner().xyz() * self.t() * self.x()
                + T::TWO * operand.as_inner().xzt() * self.x() * self.y()
                + operand.as_inner().yzt() * self.y() * self.y()
                + operand.as_inner().yzt() * self.z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Trivector<T>>> for Unit<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.as_inner().xyt() * self.as_inner().t() * self.as_inner().z()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().t() * self.as_inner().y()
                + operand.as_inner().xyz(),
            -T::TWO * operand.as_inner().xyt() * self.as_inner().z() * self.as_inner().z()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().y() * self.as_inner().z()
                + operand.as_inner().xyt(),
            -T::TWO * operand.as_inner().xyz() * self.as_inner().t() * self.as_inner().y()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().x() * self.as_inner().y()
                + operand.as_inner().xzt(),
            -(operand.as_inner().yzt())
                + -T::TWO * operand.as_inner().xyt() * self.as_inner().x() * self.as_inner().z()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().z() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.t() * operand.t() * self.x()) + self.t() * operand.x() * self.t()
                - self.x() * operand.t() * self.t()
                + self.x() * operand.x() * self.x()
                + self.x() * operand.y() * self.y()
                + self.x() * operand.z() * self.z()
                - self.y() * operand.x() * self.y()
                + self.y() * operand.y() * self.x()
                - self.z() * operand.x() * self.z()
                + self.z() * operand.z() * self.x(),
            -(self.t() * operand.t() * self.y())
                + self.t() * operand.y() * self.t()
                + self.x() * operand.x() * self.y()
                - self.x() * operand.y() * self.x()
                - self.y() * operand.t() * self.t()
                + self.y() * operand.x() * self.x()
                + self.y() * operand.y() * self.y()
                + self.y() * operand.z() * self.z()
                - self.z() * operand.y() * self.z()
                + self.z() * operand.z() * self.y(),
            -(self.t() * operand.t() * self.z())
                + self.t() * operand.z() * self.t()
                + self.x() * operand.x() * self.z()
                - self.x() * operand.z() * self.x()
                + self.y() * operand.y() * self.z()
                - self.y() * operand.z() * self.y()
                - self.z() * operand.t() * self.t()
                + self.z() * operand.x() * self.x()
                + self.z() * operand.y() * self.y()
                + self.z() * operand.z() * self.z(),
            -(self.t() * operand.t() * self.t())
                + self.t() * operand.x() * self.x()
                + self.t() * operand.y() * self.y()
                + self.t() * operand.z() * self.z()
                - self.x() * operand.t() * self.x()
                + self.x() * operand.x() * self.t()
                - self.y() * operand.t() * self.y()
                + self.y() * operand.y() * self.t()
                - self.z() * operand.t() * self.z()
                + self.z() * operand.z() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -T::TWO * operand.t() * self.as_inner().t() * self.as_inner().x()
                + -T::TWO * operand.x() * self.as_inner().y() * self.as_inner().y()
                + -T::TWO * operand.x() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.x() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.y() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.z() * self.as_inner().x() * self.as_inner().z()
                + operand.x(),
            -(operand.y())
                + -T::TWO * operand.t() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.x() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.y() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.z() * self.as_inner().y() * self.as_inner().z(),
            -(operand.z())
                + -T::TWO * operand.t() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.x() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.y() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.z() * self.as_inner().z() * self.as_inner().z(),
            -(operand.t())
                + -T::TWO * operand.t() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.x() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.y() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.z() * self.as_inner().t() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.as_inner().x() * self.y() * self.y())
                + -(operand.as_inner().x() * self.z() * self.z())
                + -T::TWO * operand.as_inner().t() * self.t() * self.x()
                + T::TWO * operand.as_inner().y() * self.x() * self.y()
                + T::TWO * operand.as_inner().z() * self.x() * self.z()
                + operand.as_inner().x() * self.t() * self.t()
                + operand.as_inner().x() * self.x() * self.x(),
            -(operand.as_inner().y() * self.x() * self.x())
                + -(operand.as_inner().y() * self.z() * self.z())
                + -T::TWO * operand.as_inner().t() * self.t() * self.y()
                + T::TWO * operand.as_inner().x() * self.x() * self.y()
                + T::TWO * operand.as_inner().z() * self.y() * self.z()
                + operand.as_inner().y() * self.t() * self.t()
                + operand.as_inner().y() * self.y() * self.y(),
            -(operand.as_inner().z() * self.x() * self.x())
                + -(operand.as_inner().z() * self.y() * self.y())
                + -T::TWO * operand.as_inner().t() * self.t() * self.z()
                + T::TWO * operand.as_inner().x() * self.x() * self.z()
                + T::TWO * operand.as_inner().y() * self.y() * self.z()
                + operand.as_inner().z() * self.t() * self.t()
                + operand.as_inner().z() * self.z() * self.z(),
            -(operand.as_inner().t() * self.t() * self.t())
                + -(operand.as_inner().t() * self.x() * self.x())
                + -(operand.as_inner().t() * self.y() * self.y())
                + -(operand.as_inner().t() * self.z() * self.z())
                + T::TWO * operand.as_inner().x() * self.t() * self.x()
                + T::TWO * operand.as_inner().y() * self.t() * self.y()
                + T::TWO * operand.as_inner().z() * self.t() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -T::TWO * operand.as_inner().t() * self.as_inner().t() * self.as_inner().x()
                + -T::TWO * operand.as_inner().x() * self.as_inner().y() * self.as_inner().y()
                + -T::TWO * operand.as_inner().x() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.as_inner().x() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.as_inner().y() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().z() * self.as_inner().x() * self.as_inner().z()
                + operand.as_inner().x(),
            -(operand.as_inner().y())
                + -T::TWO * operand.as_inner().t() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.as_inner().x() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().y() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.as_inner().z() * self.as_inner().y() * self.as_inner().z(),
            -(operand.as_inner().z())
                + -T::TWO * operand.as_inner().t() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.as_inner().x() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.as_inner().y() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.as_inner().z() * self.as_inner().z() * self.as_inner().z(),
            -(operand.as_inner().t())
                + -T::TWO * operand.as_inner().t() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.as_inner().x() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.as_inner().y() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.as_inner().z() * self.as_inner().t() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.xt() * operand.xt() * self.xy() - self.xt() * operand.xy() * self.xt()
                + self.xt() * operand.yz() * self.zt()
                - self.xt() * operand.zt() * self.yz()
                + self.xy() * operand.xt() * self.xt()
                - self.xy() * operand.xy() * self.xy()
                - self.xy() * operand.xz() * self.xz()
                + self.xy() * operand.yt() * self.yt()
                - self.xy() * operand.yz() * self.yz()
                + self.xy() * operand.zt() * self.zt()
                + self.xz() * operand.xy() * self.xz()
                - self.xz() * operand.xz() * self.xy()
                - self.xz() * operand.yt() * self.zt()
                + self.xz() * operand.zt() * self.yt()
                - self.yt() * operand.xy() * self.yt()
                - self.yt() * operand.xz() * self.zt()
                + self.yt() * operand.yt() * self.xy()
                + self.yt() * operand.zt() * self.xz()
                + self.yz() * operand.xt() * self.zt()
                + self.yz() * operand.xy() * self.yz()
                - self.yz() * operand.yz() * self.xy()
                - self.yz() * operand.zt() * self.xt()
                + self.zt() * operand.xt() * self.yz()
                + self.zt() * operand.xy() * self.zt()
                - self.zt() * operand.xz() * self.yt()
                - self.zt() * operand.yt() * self.xz()
                + self.zt() * operand.yz() * self.xt()
                + self.zt() * operand.zt() * self.xy(),
            self.xt() * operand.xt() * self.xz() - self.xt() * operand.xz() * self.xt()
                + self.xt() * operand.yt() * self.yz()
                - self.xt() * operand.yz() * self.yt()
                - self.xy() * operand.xy() * self.xz()
                + self.xy() * operand.xz() * self.xy()
                + self.xy() * operand.yt() * self.zt()
                - self.xy() * operand.zt() * self.yt()
                + self.xz() * operand.xt() * self.xt()
                - self.xz() * operand.xy() * self.xy()
                - self.xz() * operand.xz() * self.xz()
                + self.xz() * operand.yt() * self.yt()
                - self.xz() * operand.yz() * self.yz()
                + self.xz() * operand.zt() * self.zt()
                - self.yt() * operand.xt() * self.yz()
                - self.yt() * operand.xy() * self.zt()
                + self.yt() * operand.xz() * self.yt()
                + self.yt() * operand.yt() * self.xz()
                - self.yt() * operand.yz() * self.xt()
                - self.yt() * operand.zt() * self.xy()
                - self.yz() * operand.xt() * self.yt()
                + self.yz() * operand.xz() * self.yz()
                + self.yz() * operand.yt() * self.xt()
                - self.yz() * operand.yz() * self.xz()
                - self.zt() * operand.xy() * self.yt()
                - self.zt() * operand.xz() * self.zt()
                + self.zt() * operand.yt() * self.xy()
                + self.zt() * operand.zt() * self.xz(),
            self.xt() * operand.xt() * self.xt()
                - self.xt() * operand.xy() * self.xy()
                - self.xt() * operand.xz() * self.xz()
                + self.xt() * operand.yt() * self.yt()
                - self.xt() * operand.yz() * self.yz()
                + self.xt() * operand.zt() * self.zt()
                + self.xy() * operand.xt() * self.xy()
                - self.xy() * operand.xy() * self.xt()
                + self.xy() * operand.yz() * self.zt()
                - self.xy() * operand.zt() * self.yz()
                + self.xz() * operand.xt() * self.xz()
                - self.xz() * operand.xz() * self.xt()
                + self.xz() * operand.yt() * self.yz()
                - self.xz() * operand.yz() * self.yt()
                - self.yt() * operand.xt() * self.yt()
                + self.yt() * operand.xz() * self.yz()
                + self.yt() * operand.yt() * self.xt()
                - self.yt() * operand.yz() * self.xz()
                - self.yz() * operand.xt() * self.yz()
                - self.yz() * operand.xy() * self.zt()
                + self.yz() * operand.xz() * self.yt()
                + self.yz() * operand.yt() * self.xz()
                - self.yz() * operand.yz() * self.xt()
                - self.yz() * operand.zt() * self.xy()
                - self.zt() * operand.xt() * self.zt()
                - self.zt() * operand.xy() * self.yz()
                + self.zt() * operand.yz() * self.xy()
                + self.zt() * operand.zt() * self.xt(),
            self.xt() * operand.xt() * self.yz() + self.xt() * operand.xy() * self.zt()
                - self.xt() * operand.xz() * self.yt()
                - self.xt() * operand.yt() * self.xz()
                + self.xt() * operand.yz() * self.xt()
                + self.xt() * operand.zt() * self.xy()
                - self.xy() * operand.xt() * self.zt()
                - self.xy() * operand.xy() * self.yz()
                + self.xy() * operand.yz() * self.xy()
                + self.xy() * operand.zt() * self.xt()
                + self.xz() * operand.xt() * self.yt()
                - self.xz() * operand.xz() * self.yz()
                - self.xz() * operand.yt() * self.xt()
                + self.xz() * operand.yz() * self.xz()
                + self.yt() * operand.xt() * self.xz()
                - self.yt() * operand.xz() * self.xt()
                + self.yt() * operand.yt() * self.yz()
                - self.yt() * operand.yz() * self.yt()
                + self.yz() * operand.xt() * self.xt()
                - self.yz() * operand.xy() * self.xy()
                - self.yz() * operand.xz() * self.xz()
                + self.yz() * operand.yt() * self.yt()
                - self.yz() * operand.yz() * self.yz()
                + self.yz() * operand.zt() * self.zt()
                - self.zt() * operand.xt() * self.xy()
                + self.zt() * operand.xy() * self.xt()
                - self.zt() * operand.yz() * self.zt()
                + self.zt() * operand.zt() * self.yz(),
            self.xt() * operand.xt() * self.yt()
                - self.xt() * operand.xz() * self.yz()
                - self.xt() * operand.yt() * self.xt()
                + self.xt() * operand.yz() * self.xz()
                - self.xy() * operand.xy() * self.yt()
                - self.xy() * operand.xz() * self.zt()
                + self.xy() * operand.yt() * self.xy()
                + self.xy() * operand.zt() * self.xz()
                + self.xz() * operand.xt() * self.yz()
                + self.xz() * operand.xy() * self.zt()
                - self.xz() * operand.xz() * self.yt()
                - self.xz() * operand.yt() * self.xz()
                + self.xz() * operand.yz() * self.xt()
                + self.xz() * operand.zt() * self.xy()
                + self.yt() * operand.xt() * self.xt()
                - self.yt() * operand.xy() * self.xy()
                - self.yt() * operand.xz() * self.xz()
                + self.yt() * operand.yt() * self.yt()
                - self.yt() * operand.yz() * self.yz()
                + self.yt() * operand.zt() * self.zt()
                + self.yz() * operand.xt() * self.xz()
                - self.yz() * operand.xz() * self.xt()
                + self.yz() * operand.yt() * self.yz()
                - self.yz() * operand.yz() * self.yt()
                + self.zt() * operand.xy() * self.xz()
                - self.zt() * operand.xz() * self.xy()
                - self.zt() * operand.yt() * self.zt()
                + self.zt() * operand.zt() * self.yt(),
            self.xt() * operand.xt() * self.zt() + self.xt() * operand.xy() * self.yz()
                - self.xt() * operand.yz() * self.xy()
                - self.xt() * operand.zt() * self.xt()
                - self.xy() * operand.xt() * self.yz()
                - self.xy() * operand.xy() * self.zt()
                + self.xy() * operand.xz() * self.yt()
                + self.xy() * operand.yt() * self.xz()
                - self.xy() * operand.yz() * self.xt()
                - self.xy() * operand.zt() * self.xy()
                - self.xz() * operand.xy() * self.yt()
                - self.xz() * operand.xz() * self.zt()
                + self.xz() * operand.yt() * self.xy()
                + self.xz() * operand.zt() * self.xz()
                - self.yt() * operand.xy() * self.xz()
                + self.yt() * operand.xz() * self.xy()
                + self.yt() * operand.yt() * self.zt()
                - self.yt() * operand.zt() * self.yt()
                - self.yz() * operand.xt() * self.xy()
                + self.yz() * operand.xy() * self.xt()
                - self.yz() * operand.yz() * self.zt()
                + self.yz() * operand.zt() * self.yz()
                + self.zt() * operand.xt() * self.xt()
                - self.zt() * operand.xy() * self.xy()
                - self.zt() * operand.xz() * self.xz()
                + self.zt() * operand.yt() * self.yt()
                - self.zt() * operand.yz() * self.yz()
                + self.zt() * operand.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.xt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().zt()
                + T::from_i8(4i8) * operand.zt() * self.as_inner().xy() * self.as_inner().zt()
                + operand.xy(),
            -T::TWO * operand.xt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.xy() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.yz() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.zt() * self.as_inner().xz() * self.as_inner().zt()
                + T::from_i8(4i8) * operand.yt() * self.as_inner().xz() * self.as_inner().yt()
                + operand.xz(),
            -(operand.xt())
                + -T::TWO * operand.xt() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.xt() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.xy() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.xt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().zt()
                + T::from_i8(-4i8) * operand.yz() * self.as_inner().xz() * self.as_inner().yt()
                + T::from_i8(4i8) * operand.yz() * self.as_inner().xy() * self.as_inner().zt(),
            -(operand.yz())
                + -T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.yz() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.yz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.yz() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.zt() * self.as_inner().yz() * self.as_inner().zt()
                + T::from_i8(-4i8) * operand.xt() * self.as_inner().xy() * self.as_inner().zt()
                + T::from_i8(4i8) * operand.xt() * self.as_inner().xz() * self.as_inner().yt(),
            -T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.yz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.xt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.xy() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().yt() * self.as_inner().zt()
                + T::from_i8(-4i8) * operand.xz() * self.as_inner().xz() * self.as_inner().yt()
                + operand.yt(),
            -T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.yz() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.zt() * self.as_inner().zt() * self.as_inner().zt()
                + T::from_i8(-4i8) * operand.xy() * self.as_inner().xy() * self.as_inner().zt()
                + operand.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.as_inner().xy() * self.xt() * self.xt())
                + -(operand.as_inner().xy() * self.xy() * self.xy())
                + -(operand.as_inner().xy() * self.yt() * self.yt())
                + -T::TWO * operand.as_inner().xz() * self.xy() * self.xz()
                + -T::TWO * operand.as_inner().xz() * self.yt() * self.zt()
                + -T::TWO * operand.as_inner().yt() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().yz() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().xt() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().xt() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().yt() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().yz() * self.xt() * self.zt()
                + T::from_i8(4i8) * operand.as_inner().zt() * self.xy() * self.zt()
                + operand.as_inner().xy() * self.xz() * self.xz()
                + operand.as_inner().xy() * self.yz() * self.yz()
                + operand.as_inner().xy() * self.zt() * self.zt(),
            -(operand.as_inner().xz() * self.xt() * self.xt())
                + -(operand.as_inner().xz() * self.xz() * self.xz())
                + -(operand.as_inner().xz() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xt() * self.yt() * self.yz()
                + -T::TWO * operand.as_inner().xy() * self.xy() * self.xz()
                + -T::TWO * operand.as_inner().xy() * self.yt() * self.zt()
                + -T::TWO * operand.as_inner().yz() * self.xt() * self.yt()
                + -T::TWO * operand.as_inner().yz() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().zt() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().xt() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().zt() * self.xz() * self.zt()
                + T::from_i8(4i8) * operand.as_inner().yt() * self.xz() * self.yt()
                + operand.as_inner().xz() * self.xy() * self.xy()
                + operand.as_inner().xz() * self.yt() * self.yt()
                + operand.as_inner().xz() * self.yz() * self.yz(),
            -(operand.as_inner().xt() * self.yt() * self.yt())
                + -(operand.as_inner().xt() * self.yz() * self.yz())
                + -(operand.as_inner().xt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xy() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().xy() * self.yz() * self.zt()
                + -T::TWO * operand.as_inner().xz() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().zt() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().xz() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().yt() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().yt() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().zt() * self.xt() * self.zt()
                + T::from_i8(-4i8) * operand.as_inner().yz() * self.xz() * self.yt()
                + T::from_i8(4i8) * operand.as_inner().yz() * self.xy() * self.zt()
                + operand.as_inner().xt() * self.xt() * self.xt()
                + operand.as_inner().xt() * self.xy() * self.xy()
                + operand.as_inner().xt() * self.xz() * self.xz(),
            -(operand.as_inner().yz() * self.yt() * self.yt())
                + -(operand.as_inner().yz() * self.yz() * self.yz())
                + -(operand.as_inner().yz() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xy() * self.xy() * self.yz()
                + -T::TWO * operand.as_inner().xz() * self.xt() * self.yt()
                + -T::TWO * operand.as_inner().xz() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().yt() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().xy() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().yt() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().zt() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().zt() * self.yz() * self.zt()
                + T::from_i8(-4i8) * operand.as_inner().xt() * self.xy() * self.zt()
                + T::from_i8(4i8) * operand.as_inner().xt() * self.xz() * self.yt()
                + operand.as_inner().yz() * self.xt() * self.xt()
                + operand.as_inner().yz() * self.xy() * self.xy()
                + operand.as_inner().yz() * self.xz() * self.xz(),
            -(operand.as_inner().yt() * self.xt() * self.xt())
                + -(operand.as_inner().yt() * self.xz() * self.xz())
                + -(operand.as_inner().yt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xy() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().yz() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().xt() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().xt() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().xy() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().zt() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().zt() * self.yt() * self.zt()
                + T::from_i8(-4i8) * operand.as_inner().xz() * self.xz() * self.yt()
                + operand.as_inner().yt() * self.xy() * self.xy()
                + operand.as_inner().yt() * self.yt() * self.yt()
                + operand.as_inner().yt() * self.yz() * self.yz(),
            -(operand.as_inner().zt() * self.xt() * self.xt())
                + -(operand.as_inner().zt() * self.xy() * self.xy())
                + -(operand.as_inner().zt() * self.yt() * self.yt())
                + -T::TWO * operand.as_inner().xt() * self.xy() * self.yz()
                + -T::TWO * operand.as_inner().xz() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().yz() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().yz() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().xt() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().xz() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().yt() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().yt() * self.yt() * self.zt()
                + T::from_i8(-4i8) * operand.as_inner().xy() * self.xy() * self.zt()
                + operand.as_inner().zt() * self.xz() * self.xz()
                + operand.as_inner().zt() * self.yz() * self.yz()
                + operand.as_inner().zt() * self.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().zt()
                + T::from_i8(4i8)
                    * operand.as_inner().zt()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + operand.as_inner().xy(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xz() * self.as_inner().zt()
                + T::from_i8(4i8)
                    * operand.as_inner().yt()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + operand.as_inner().xz(),
            -(operand.as_inner().xt())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().zt()
                + T::from_i8(-4i8)
                    * operand.as_inner().yz()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + T::from_i8(4i8)
                    * operand.as_inner().yz()
                    * self.as_inner().xy()
                    * self.as_inner().zt(),
            -(operand.as_inner().yz())
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().zt() * self.as_inner().yz() * self.as_inner().zt()
                + T::from_i8(-4i8)
                    * operand.as_inner().xt()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + T::from_i8(4i8)
                    * operand.as_inner().xt()
                    * self.as_inner().xz()
                    * self.as_inner().yt(),
            -T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().yt() * self.as_inner().zt()
                + T::from_i8(-4i8)
                    * operand.as_inner().xz()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + operand.as_inner().yt(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().zt() * self.as_inner().zt()
                + T::from_i8(-4i8)
                    * operand.as_inner().xy()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + operand.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            self.xt() * operand.s() * self.xt()
                - self.xt() * operand.xy() * self.yt()
                - self.xt() * operand.xyzt() * self.yz()
                - self.xt() * operand.xz() * self.zt()
                + self.xt() * operand.yt() * self.xy()
                + self.xt() * operand.zt() * self.xz()
                - self.xy() * operand.s() * self.xy()
                + self.xy() * operand.xt() * self.yt()
                - self.xy() * operand.xyzt() * self.zt()
                - self.xy() * operand.xz() * self.yz()
                - self.xy() * operand.yt() * self.xt()
                + self.xy() * operand.yz() * self.xz()
                - self.xz() * operand.s() * self.xz()
                + self.xz() * operand.xt() * self.zt()
                + self.xz() * operand.xy() * self.yz()
                + self.xz() * operand.xyzt() * self.yt()
                - self.xz() * operand.yz() * self.xy()
                - self.xz() * operand.zt() * self.xt()
                + self.yt() * operand.s() * self.yt()
                - self.yt() * operand.xt() * self.xy()
                + self.yt() * operand.xy() * self.xt()
                + self.yt() * operand.xyzt() * self.xz()
                - self.yt() * operand.yz() * self.zt()
                + self.yt() * operand.zt() * self.yz()
                - self.yz() * operand.s() * self.yz()
                - self.yz() * operand.xy() * self.xz()
                - self.yz() * operand.xyzt() * self.xt()
                + self.yz() * operand.xz() * self.xy()
                + self.yz() * operand.yt() * self.zt()
                - self.yz() * operand.zt() * self.yt()
                + self.zt() * operand.s() * self.zt()
                - self.zt() * operand.xt() * self.xz()
                - self.zt() * operand.xyzt() * self.xy()
                + self.zt() * operand.xz() * self.xt()
                - self.zt() * operand.yt() * self.yz()
                + self.zt() * operand.yz() * self.yt(),
            -(self.xt() * operand.s() * self.yt()) + self.xt() * operand.xt() * self.xy()
                - self.xt() * operand.xy() * self.xt()
                - self.xt() * operand.xyzt() * self.xz()
                + self.xt() * operand.yz() * self.zt()
                - self.xt() * operand.zt() * self.yz()
                + self.xy() * operand.xt() * self.xt()
                - self.xy() * operand.xy() * self.xy()
                - self.xy() * operand.xz() * self.xz()
                + self.xy() * operand.yt() * self.yt()
                - self.xy() * operand.yz() * self.yz()
                + self.xy() * operand.zt() * self.zt()
                + self.xz() * operand.s() * self.yz()
                + self.xz() * operand.xy() * self.xz()
                + self.xz() * operand.xyzt() * self.xt()
                - self.xz() * operand.xz() * self.xy()
                - self.xz() * operand.yt() * self.zt()
                + self.xz() * operand.zt() * self.yt()
                + self.yt() * operand.s() * self.xt()
                - self.yt() * operand.xy() * self.yt()
                - self.yt() * operand.xyzt() * self.yz()
                - self.yt() * operand.xz() * self.zt()
                + self.yt() * operand.yt() * self.xy()
                + self.yt() * operand.zt() * self.xz()
                - self.yz() * operand.s() * self.xz()
                + self.yz() * operand.xt() * self.zt()
                + self.yz() * operand.xy() * self.yz()
                + self.yz() * operand.xyzt() * self.yt()
                - self.yz() * operand.yz() * self.xy()
                - self.yz() * operand.zt() * self.xt()
                + self.zt() * operand.xt() * self.yz()
                + self.zt() * operand.xy() * self.zt()
                - self.zt() * operand.xz() * self.yt()
                - self.zt() * operand.yt() * self.xz()
                + self.zt() * operand.yz() * self.xt()
                + self.zt() * operand.zt() * self.xy(),
            -(self.xt() * operand.s() * self.zt())
                + self.xt() * operand.xt() * self.xz()
                + self.xt() * operand.xyzt() * self.xy()
                - self.xt() * operand.xz() * self.xt()
                + self.xt() * operand.yt() * self.yz()
                - self.xt() * operand.yz() * self.yt()
                - self.xy() * operand.s() * self.yz()
                - self.xy() * operand.xy() * self.xz()
                - self.xy() * operand.xyzt() * self.xt()
                + self.xy() * operand.xz() * self.xy()
                + self.xy() * operand.yt() * self.zt()
                - self.xy() * operand.zt() * self.yt()
                + self.xz() * operand.xt() * self.xt()
                - self.xz() * operand.xy() * self.xy()
                - self.xz() * operand.xz() * self.xz()
                + self.xz() * operand.yt() * self.yt()
                - self.xz() * operand.yz() * self.yz()
                + self.xz() * operand.zt() * self.zt()
                - self.yt() * operand.xt() * self.yz()
                - self.yt() * operand.xy() * self.zt()
                + self.yt() * operand.xz() * self.yt()
                + self.yt() * operand.yt() * self.xz()
                - self.yt() * operand.yz() * self.xt()
                - self.yt() * operand.zt() * self.xy()
                + self.yz() * operand.s() * self.xy()
                - self.yz() * operand.xt() * self.yt()
                + self.yz() * operand.xyzt() * self.zt()
                + self.yz() * operand.xz() * self.yz()
                + self.yz() * operand.yt() * self.xt()
                - self.yz() * operand.yz() * self.xz()
                + self.zt() * operand.s() * self.xt()
                - self.zt() * operand.xy() * self.yt()
                - self.zt() * operand.xyzt() * self.yz()
                - self.zt() * operand.xz() * self.zt()
                + self.zt() * operand.yt() * self.xy()
                + self.zt() * operand.zt() * self.xz(),
            self.xt() * operand.xt() * self.xt()
                - self.xt() * operand.xy() * self.xy()
                - self.xt() * operand.xz() * self.xz()
                + self.xt() * operand.yt() * self.yt()
                - self.xt() * operand.yz() * self.yz()
                + self.xt() * operand.zt() * self.zt()
                - self.xy() * operand.s() * self.yt()
                + self.xy() * operand.xt() * self.xy()
                - self.xy() * operand.xy() * self.xt()
                - self.xy() * operand.xyzt() * self.xz()
                + self.xy() * operand.yz() * self.zt()
                - self.xy() * operand.zt() * self.yz()
                - self.xz() * operand.s() * self.zt()
                + self.xz() * operand.xt() * self.xz()
                + self.xz() * operand.xyzt() * self.xy()
                - self.xz() * operand.xz() * self.xt()
                + self.xz() * operand.yt() * self.yz()
                - self.xz() * operand.yz() * self.yt()
                + self.yt() * operand.s() * self.xy()
                - self.yt() * operand.xt() * self.yt()
                + self.yt() * operand.xyzt() * self.zt()
                + self.yt() * operand.xz() * self.yz()
                + self.yt() * operand.yt() * self.xt()
                - self.yt() * operand.yz() * self.xz()
                - self.yz() * operand.xt() * self.yz()
                - self.yz() * operand.xy() * self.zt()
                + self.yz() * operand.xz() * self.yt()
                + self.yz() * operand.yt() * self.xz()
                - self.yz() * operand.yz() * self.xt()
                - self.yz() * operand.zt() * self.xy()
                + self.zt() * operand.s() * self.xz()
                - self.zt() * operand.xt() * self.zt()
                - self.zt() * operand.xy() * self.yz()
                - self.zt() * operand.xyzt() * self.yt()
                + self.zt() * operand.yz() * self.xy()
                + self.zt() * operand.zt() * self.xt(),
            self.xt() * operand.xt() * self.yz() + self.xt() * operand.xy() * self.zt()
                - self.xt() * operand.xz() * self.yt()
                - self.xt() * operand.yt() * self.xz()
                + self.xt() * operand.yz() * self.xt()
                + self.xt() * operand.zt() * self.xy()
                + self.xy() * operand.s() * self.xz()
                - self.xy() * operand.xt() * self.zt()
                - self.xy() * operand.xy() * self.yz()
                - self.xy() * operand.xyzt() * self.yt()
                + self.xy() * operand.yz() * self.xy()
                + self.xy() * operand.zt() * self.xt()
                - self.xz() * operand.s() * self.xy()
                + self.xz() * operand.xt() * self.yt()
                - self.xz() * operand.xyzt() * self.zt()
                - self.xz() * operand.xz() * self.yz()
                - self.xz() * operand.yt() * self.xt()
                + self.xz() * operand.yz() * self.xz()
                - self.yt() * operand.s() * self.zt()
                + self.yt() * operand.xt() * self.xz()
                + self.yt() * operand.xyzt() * self.xy()
                - self.yt() * operand.xz() * self.xt()
                + self.yt() * operand.yt() * self.yz()
                - self.yt() * operand.yz() * self.yt()
                + self.yz() * operand.xt() * self.xt()
                - self.yz() * operand.xy() * self.xy()
                - self.yz() * operand.xz() * self.xz()
                + self.yz() * operand.yt() * self.yt()
                - self.yz() * operand.yz() * self.yz()
                + self.yz() * operand.zt() * self.zt()
                + self.zt() * operand.s() * self.yt()
                - self.zt() * operand.xt() * self.xy()
                + self.zt() * operand.xy() * self.xt()
                + self.zt() * operand.xyzt() * self.xz()
                - self.zt() * operand.yz() * self.zt()
                + self.zt() * operand.zt() * self.yz(),
            -(self.xt() * operand.s() * self.xy()) + self.xt() * operand.xt() * self.yt()
                - self.xt() * operand.xyzt() * self.zt()
                - self.xt() * operand.xz() * self.yz()
                - self.xt() * operand.yt() * self.xt()
                + self.xt() * operand.yz() * self.xz()
                + self.xy() * operand.s() * self.xt()
                - self.xy() * operand.xy() * self.yt()
                - self.xy() * operand.xyzt() * self.yz()
                - self.xy() * operand.xz() * self.zt()
                + self.xy() * operand.yt() * self.xy()
                + self.xy() * operand.zt() * self.xz()
                + self.xz() * operand.xt() * self.yz()
                + self.xz() * operand.xy() * self.zt()
                - self.xz() * operand.xz() * self.yt()
                - self.xz() * operand.yt() * self.xz()
                + self.xz() * operand.yz() * self.xt()
                + self.xz() * operand.zt() * self.xy()
                + self.yt() * operand.xt() * self.xt()
                - self.yt() * operand.xy() * self.xy()
                - self.yt() * operand.xz() * self.xz()
                + self.yt() * operand.yt() * self.yt()
                - self.yt() * operand.yz() * self.yz()
                + self.yt() * operand.zt() * self.zt()
                - self.yz() * operand.s() * self.zt()
                + self.yz() * operand.xt() * self.xz()
                + self.yz() * operand.xyzt() * self.xy()
                - self.yz() * operand.xz() * self.xt()
                + self.yz() * operand.yt() * self.yz()
                - self.yz() * operand.yz() * self.yt()
                + self.zt() * operand.s() * self.yz()
                + self.zt() * operand.xy() * self.xz()
                + self.zt() * operand.xyzt() * self.xt()
                - self.zt() * operand.xz() * self.xy()
                - self.zt() * operand.yt() * self.zt()
                + self.zt() * operand.zt() * self.yt(),
            -(self.xt() * operand.s() * self.xz())
                + self.xt() * operand.xt() * self.zt()
                + self.xt() * operand.xy() * self.yz()
                + self.xt() * operand.xyzt() * self.yt()
                - self.xt() * operand.yz() * self.xy()
                - self.xt() * operand.zt() * self.xt()
                - self.xy() * operand.xt() * self.yz()
                - self.xy() * operand.xy() * self.zt()
                + self.xy() * operand.xz() * self.yt()
                + self.xy() * operand.yt() * self.xz()
                - self.xy() * operand.yz() * self.xt()
                - self.xy() * operand.zt() * self.xy()
                + self.xz() * operand.s() * self.xt()
                - self.xz() * operand.xy() * self.yt()
                - self.xz() * operand.xyzt() * self.yz()
                - self.xz() * operand.xz() * self.zt()
                + self.xz() * operand.yt() * self.xy()
                + self.xz() * operand.zt() * self.xz()
                - self.yt() * operand.s() * self.yz()
                - self.yt() * operand.xy() * self.xz()
                - self.yt() * operand.xyzt() * self.xt()
                + self.yt() * operand.xz() * self.xy()
                + self.yt() * operand.yt() * self.zt()
                - self.yt() * operand.zt() * self.yt()
                + self.yz() * operand.s() * self.yt()
                - self.yz() * operand.xt() * self.xy()
                + self.yz() * operand.xy() * self.xt()
                + self.yz() * operand.xyzt() * self.xz()
                - self.yz() * operand.yz() * self.zt()
                + self.yz() * operand.zt() * self.yz()
                + self.zt() * operand.xt() * self.xt()
                - self.zt() * operand.xy() * self.xy()
                - self.zt() * operand.xz() * self.xz()
                + self.zt() * operand.yt() * self.yt()
                - self.zt() * operand.yz() * self.yz()
                + self.zt() * operand.zt() * self.zt(),
            self.xt() * operand.s() * self.yz()
                + self.xt() * operand.xy() * self.xz()
                + self.xt() * operand.xyzt() * self.xt()
                - self.xt() * operand.xz() * self.xy()
                - self.xt() * operand.yt() * self.zt()
                + self.xt() * operand.zt() * self.yt()
                + self.xy() * operand.s() * self.zt()
                - self.xy() * operand.xt() * self.xz()
                - self.xy() * operand.xyzt() * self.xy()
                + self.xy() * operand.xz() * self.xt()
                - self.xy() * operand.yt() * self.yz()
                + self.xy() * operand.yz() * self.yt()
                - self.xz() * operand.s() * self.yt()
                + self.xz() * operand.xt() * self.xy()
                - self.xz() * operand.xy() * self.xt()
                - self.xz() * operand.xyzt() * self.xz()
                + self.xz() * operand.yz() * self.zt()
                - self.xz() * operand.zt() * self.yz()
                - self.yt() * operand.s() * self.xz()
                + self.yt() * operand.xt() * self.zt()
                + self.yt() * operand.xy() * self.yz()
                + self.yt() * operand.xyzt() * self.yt()
                - self.yt() * operand.yz() * self.xy()
                - self.yt() * operand.zt() * self.xt()
                + self.yz() * operand.s() * self.xt()
                - self.yz() * operand.xy() * self.yt()
                - self.yz() * operand.xyzt() * self.yz()
                - self.yz() * operand.xz() * self.zt()
                + self.yz() * operand.yt() * self.xy()
                + self.yz() * operand.zt() * self.xz()
                + self.zt() * operand.s() * self.xy()
                - self.zt() * operand.xt() * self.yt()
                + self.zt() * operand.xyzt() * self.zt()
                + self.zt() * operand.xz() * self.yz()
                + self.zt() * operand.yt() * self.xt()
                - self.zt() * operand.yz() * self.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Unit<Bivector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.s()),
            -T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.xt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().zt()
                + T::from_i8(4i8) * operand.zt() * self.as_inner().xy() * self.as_inner().zt()
                + operand.xy(),
            -T::TWO * operand.xt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.xy() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.yz() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.zt() * self.as_inner().xz() * self.as_inner().zt()
                + T::from_i8(4i8) * operand.yt() * self.as_inner().xz() * self.as_inner().yt()
                + operand.xz(),
            -(operand.xt())
                + -T::TWO * operand.xt() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.xt() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.xy() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.xt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().zt()
                + T::from_i8(-4i8) * operand.yz() * self.as_inner().xz() * self.as_inner().yt()
                + T::from_i8(4i8) * operand.yz() * self.as_inner().xy() * self.as_inner().zt(),
            -(operand.yz())
                + -T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.yz() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.yz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.yz() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.zt() * self.as_inner().yz() * self.as_inner().zt()
                + T::from_i8(-4i8) * operand.xt() * self.as_inner().xy() * self.as_inner().zt()
                + T::from_i8(4i8) * operand.xt() * self.as_inner().xz() * self.as_inner().yt(),
            -T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.yz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.xt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.xy() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().yt() * self.as_inner().zt()
                + T::from_i8(-4i8) * operand.xz() * self.as_inner().xz() * self.as_inner().yt()
                + operand.yt(),
            -T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.yz() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.zt() * self.as_inner().zt() * self.as_inner().zt()
                + T::from_i8(-4i8) * operand.xy() * self.as_inner().xy() * self.as_inner().zt()
                + operand.zt(),
            -(operand.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.as_inner().s() * self.xy() * self.xy())
                + -(operand.as_inner().s() * self.xz() * self.xz())
                + -(operand.as_inner().s() * self.yz() * self.yz())
                + operand.as_inner().s() * self.xt() * self.xt()
                + operand.as_inner().s() * self.yt() * self.yt()
                + operand.as_inner().s() * self.zt() * self.zt(),
            -(operand.as_inner().xy() * self.xt() * self.xt())
                + -(operand.as_inner().xy() * self.xy() * self.xy())
                + -(operand.as_inner().xy() * self.yt() * self.yt())
                + -T::TWO * operand.as_inner().xz() * self.xy() * self.xz()
                + -T::TWO * operand.as_inner().xz() * self.yt() * self.zt()
                + -T::TWO * operand.as_inner().yt() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().yz() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().xt() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().xt() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().yt() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().yz() * self.xt() * self.zt()
                + T::from_i8(4i8) * operand.as_inner().zt() * self.xy() * self.zt()
                + operand.as_inner().xy() * self.xz() * self.xz()
                + operand.as_inner().xy() * self.yz() * self.yz()
                + operand.as_inner().xy() * self.zt() * self.zt(),
            -(operand.as_inner().xz() * self.xt() * self.xt())
                + -(operand.as_inner().xz() * self.xz() * self.xz())
                + -(operand.as_inner().xz() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xt() * self.yt() * self.yz()
                + -T::TWO * operand.as_inner().xy() * self.xy() * self.xz()
                + -T::TWO * operand.as_inner().xy() * self.yt() * self.zt()
                + -T::TWO * operand.as_inner().yz() * self.xt() * self.yt()
                + -T::TWO * operand.as_inner().yz() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().zt() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().xt() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().zt() * self.xz() * self.zt()
                + T::from_i8(4i8) * operand.as_inner().yt() * self.xz() * self.yt()
                + operand.as_inner().xz() * self.xy() * self.xy()
                + operand.as_inner().xz() * self.yt() * self.yt()
                + operand.as_inner().xz() * self.yz() * self.yz(),
            -(operand.as_inner().xt() * self.yt() * self.yt())
                + -(operand.as_inner().xt() * self.yz() * self.yz())
                + -(operand.as_inner().xt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xy() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().xy() * self.yz() * self.zt()
                + -T::TWO * operand.as_inner().xz() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().zt() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().xz() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().yt() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().yt() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().zt() * self.xt() * self.zt()
                + T::from_i8(-4i8) * operand.as_inner().yz() * self.xz() * self.yt()
                + T::from_i8(4i8) * operand.as_inner().yz() * self.xy() * self.zt()
                + operand.as_inner().xt() * self.xt() * self.xt()
                + operand.as_inner().xt() * self.xy() * self.xy()
                + operand.as_inner().xt() * self.xz() * self.xz(),
            -(operand.as_inner().yz() * self.yt() * self.yt())
                + -(operand.as_inner().yz() * self.yz() * self.yz())
                + -(operand.as_inner().yz() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xy() * self.xy() * self.yz()
                + -T::TWO * operand.as_inner().xz() * self.xt() * self.yt()
                + -T::TWO * operand.as_inner().xz() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().yt() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().xy() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().yt() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().zt() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().zt() * self.yz() * self.zt()
                + T::from_i8(-4i8) * operand.as_inner().xt() * self.xy() * self.zt()
                + T::from_i8(4i8) * operand.as_inner().xt() * self.xz() * self.yt()
                + operand.as_inner().yz() * self.xt() * self.xt()
                + operand.as_inner().yz() * self.xy() * self.xy()
                + operand.as_inner().yz() * self.xz() * self.xz(),
            -(operand.as_inner().yt() * self.xt() * self.xt())
                + -(operand.as_inner().yt() * self.xz() * self.xz())
                + -(operand.as_inner().yt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xy() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().yz() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().xt() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().xt() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().xy() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().zt() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().zt() * self.yt() * self.zt()
                + T::from_i8(-4i8) * operand.as_inner().xz() * self.xz() * self.yt()
                + operand.as_inner().yt() * self.xy() * self.xy()
                + operand.as_inner().yt() * self.yt() * self.yt()
                + operand.as_inner().yt() * self.yz() * self.yz(),
            -(operand.as_inner().zt() * self.xt() * self.xt())
                + -(operand.as_inner().zt() * self.xy() * self.xy())
                + -(operand.as_inner().zt() * self.yt() * self.yt())
                + -T::TWO * operand.as_inner().xt() * self.xy() * self.yz()
                + -T::TWO * operand.as_inner().xz() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().yz() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().yz() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().xt() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().xz() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().yt() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().yt() * self.yt() * self.zt()
                + T::from_i8(-4i8) * operand.as_inner().xy() * self.xy() * self.zt()
                + operand.as_inner().zt() * self.xz() * self.xz()
                + operand.as_inner().zt() * self.yz() * self.yz()
                + operand.as_inner().zt() * self.zt() * self.zt(),
            -(operand.as_inner().xyzt() * self.xy() * self.xy())
                + -(operand.as_inner().xyzt() * self.xz() * self.xz())
                + -(operand.as_inner().xyzt() * self.yz() * self.yz())
                + operand.as_inner().xyzt() * self.xt() * self.xt()
                + operand.as_inner().xyzt() * self.yt() * self.yt()
                + operand.as_inner().xyzt() * self.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Unit<Bivector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.as_inner().s()),
            -T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().zt()
                + T::from_i8(4i8)
                    * operand.as_inner().zt()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + operand.as_inner().xy(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xz() * self.as_inner().zt()
                + T::from_i8(4i8)
                    * operand.as_inner().yt()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + operand.as_inner().xz(),
            -(operand.as_inner().xt())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().zt()
                + T::from_i8(-4i8)
                    * operand.as_inner().yz()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + T::from_i8(4i8)
                    * operand.as_inner().yz()
                    * self.as_inner().xy()
                    * self.as_inner().zt(),
            -(operand.as_inner().yz())
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().zt() * self.as_inner().yz() * self.as_inner().zt()
                + T::from_i8(-4i8)
                    * operand.as_inner().xt()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + T::from_i8(4i8)
                    * operand.as_inner().xt()
                    * self.as_inner().xz()
                    * self.as_inner().yt(),
            -T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().yt() * self.as_inner().zt()
                + T::from_i8(-4i8)
                    * operand.as_inner().xz()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + operand.as_inner().yt(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().zt() * self.as_inner().zt()
                + T::from_i8(-4i8)
                    * operand.as_inner().xy()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + operand.as_inner().zt(),
            -(operand.as_inner().xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Bivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.xt() * operand.xyzt() * self.xt()
                - self.xy() * operand.xyzt() * self.xy()
                - self.xz() * operand.xyzt() * self.xz()
                + self.yt() * operand.xyzt() * self.yt()
                - self.yz() * operand.xyzt() * self.yz()
                + self.zt() * operand.xyzt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Unit<Bivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(operand.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Bivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(operand.as_inner().xyzt() * self.xy() * self.xy())
                + -(operand.as_inner().xyzt() * self.xz() * self.xz())
                + -(operand.as_inner().xyzt() * self.yz() * self.yz())
                + operand.as_inner().xyzt() * self.xt() * self.xt()
                + operand.as_inner().xyzt() * self.yt() * self.yt()
                + operand.as_inner().xyzt() * self.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Unit<Bivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(operand.as_inner().xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.xt() * operand.s() * self.xt()
                - self.xy() * operand.s() * self.xy()
                - self.xz() * operand.s() * self.xz()
                + self.yt() * operand.s() * self.yt()
                - self.yz() * operand.s() * self.yz()
                + self.zt() * operand.s() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(operand.as_inner().s() * self.xy() * self.xy())
                + -(operand.as_inner().s() * self.xz() * self.xz())
                + -(operand.as_inner().s() * self.yz() * self.yz())
                + operand.as_inner().s() * self.xt() * self.xt()
                + operand.as_inner().s() * self.yt() * self.yt()
                + operand.as_inner().s() * self.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(self.xt() * operand.xyt() * self.xz())
                + self.xt() * operand.xyz() * self.xt()
                + self.xt() * operand.xzt() * self.xy()
                + self.xy() * operand.xyz() * self.xy()
                + self.xy() * operand.xzt() * self.xt()
                + self.xy() * operand.yzt() * self.yt()
                - self.xz() * operand.xyt() * self.xt()
                + self.xz() * operand.xyz() * self.xz()
                + self.xz() * operand.yzt() * self.zt()
                - self.yt() * operand.xyt() * self.yz()
                + self.yt() * operand.xyz() * self.yt()
                + self.yt() * operand.yzt() * self.xy()
                - self.yz() * operand.xyt() * self.yt()
                + self.yz() * operand.xyz() * self.yz()
                - self.yz() * operand.xzt() * self.zt()
                + self.zt() * operand.xyz() * self.zt()
                - self.zt() * operand.xzt() * self.yz()
                + self.zt() * operand.yzt() * self.xz(),
            -(self.xt() * operand.xyt() * self.xt())
                + self.xt() * operand.xyz() * self.xz()
                + self.xt() * operand.yzt() * self.zt()
                + self.xy() * operand.xyt() * self.xy()
                + self.xy() * operand.xzt() * self.xz()
                + self.xy() * operand.yzt() * self.yz()
                - self.xz() * operand.xyt() * self.xz()
                + self.xz() * operand.xyz() * self.xt()
                + self.xz() * operand.xzt() * self.xy()
                - self.yt() * operand.xyt() * self.yt()
                + self.yt() * operand.xyz() * self.yz()
                - self.yt() * operand.xzt() * self.zt()
                - self.yz() * operand.xyt() * self.yz()
                + self.yz() * operand.xyz() * self.yt()
                + self.yz() * operand.yzt() * self.xy()
                + self.zt() * operand.xyt() * self.zt()
                - self.zt() * operand.xzt() * self.yt()
                + self.zt() * operand.yzt() * self.xt(),
            -(self.xt() * operand.xyz() * self.xy())
                - self.xt() * operand.xzt() * self.xt()
                - self.xt() * operand.yzt() * self.yt()
                + self.xy() * operand.xyt() * self.xz()
                - self.xy() * operand.xyz() * self.xt()
                - self.xy() * operand.xzt() * self.xy()
                + self.xz() * operand.xyt() * self.xy()
                + self.xz() * operand.xzt() * self.xz()
                + self.xz() * operand.yzt() * self.yz()
                - self.yt() * operand.xyt() * self.zt()
                + self.yt() * operand.xzt() * self.yt()
                - self.yt() * operand.yzt() * self.xt()
                + self.yz() * operand.xyz() * self.zt()
                - self.yz() * operand.xzt() * self.yz()
                + self.yz() * operand.yzt() * self.xz()
                - self.zt() * operand.xyt() * self.yt()
                + self.zt() * operand.xyz() * self.yz()
                - self.zt() * operand.xzt() * self.zt(),
            self.xt() * operand.xyt() * self.zt() - self.xt() * operand.xzt() * self.yt()
                + self.xt() * operand.yzt() * self.xt()
                + self.xy() * operand.xyt() * self.yz()
                - self.xy() * operand.xyz() * self.yt()
                - self.xy() * operand.yzt() * self.xy()
                - self.xz() * operand.xyz() * self.zt()
                + self.xz() * operand.xzt() * self.yz()
                - self.xz() * operand.yzt() * self.xz()
                - self.yt() * operand.xyz() * self.xy()
                - self.yt() * operand.xzt() * self.xt()
                - self.yt() * operand.yzt() * self.yt()
                + self.yz() * operand.xyt() * self.xy()
                + self.yz() * operand.xzt() * self.xz()
                + self.yz() * operand.yzt() * self.yz()
                + self.zt() * operand.xyt() * self.xt()
                - self.zt() * operand.xyz() * self.xz()
                - self.zt() * operand.yzt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Unit<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(operand.xyz())
                + -T::TWO * operand.xyt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.xyt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.xzt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.xyz() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.xyz() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.xyz() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.xzt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.yzt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.yzt() * self.as_inner().xz() * self.as_inner().zt(),
            -T::TWO * operand.xyt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.xyt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.xzt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.xyt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.xyz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.xyz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.xzt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.yzt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.yzt() * self.as_inner().xy() * self.as_inner().yz()
                + operand.xyt(),
            -T::TWO * operand.xyt() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.xyz() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.xzt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.xzt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.yzt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.xyt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.xyz() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.xzt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.yzt() * self.as_inner().xz() * self.as_inner().yz()
                + operand.xzt(),
            -(operand.yzt())
                + -T::TWO * operand.xyz() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.xyz() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.xzt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.yzt() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.yzt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.xyt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.xyt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.xzt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.yzt() * self.as_inner().yz() * self.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Trivector<T>>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.as_inner().xyt() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().xyt() * self.yt() * self.yz()
                + -T::TWO * operand.as_inner().xzt() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().xzt() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().yzt() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().yzt() * self.xz() * self.zt()
                + operand.as_inner().xyz() * self.xt() * self.xt()
                + operand.as_inner().xyz() * self.xy() * self.xy()
                + operand.as_inner().xyz() * self.xz() * self.xz()
                + operand.as_inner().xyz() * self.yt() * self.yt()
                + operand.as_inner().xyz() * self.yz() * self.yz()
                + operand.as_inner().xyz() * self.zt() * self.zt(),
            -(operand.as_inner().xyt() * self.xt() * self.xt())
                + -(operand.as_inner().xyt() * self.xz() * self.xz())
                + -(operand.as_inner().xyt() * self.yt() * self.yt())
                + -(operand.as_inner().xyt() * self.yz() * self.yz())
                + -T::TWO * operand.as_inner().xzt() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().xyz() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().xyz() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().xzt() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().yzt() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().yzt() * self.xy() * self.yz()
                + operand.as_inner().xyt() * self.xy() * self.xy()
                + operand.as_inner().xyt() * self.zt() * self.zt(),
            -(operand.as_inner().xzt() * self.xt() * self.xt())
                + -(operand.as_inner().xzt() * self.xy() * self.xy())
                + -(operand.as_inner().xzt() * self.yz() * self.yz())
                + -(operand.as_inner().xzt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xyt() * self.yt() * self.zt()
                + -T::TWO * operand.as_inner().xyz() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().yzt() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().xyt() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().xyz() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().yzt() * self.xz() * self.yz()
                + operand.as_inner().xzt() * self.xz() * self.xz()
                + operand.as_inner().xzt() * self.yt() * self.yt(),
            -(operand.as_inner().yzt() * self.xy() * self.xy())
                + -(operand.as_inner().yzt() * self.xz() * self.xz())
                + -(operand.as_inner().yzt() * self.yt() * self.yt())
                + -(operand.as_inner().yzt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xyz() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().xyz() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().xzt() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().xyt() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().xyt() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().xzt() * self.xz() * self.yz()
                + operand.as_inner().yzt() * self.xt() * self.xt()
                + operand.as_inner().yzt() * self.yz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Trivector<T>>> for Unit<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(operand.as_inner().xyz())
                + -T::TWO * operand.as_inner().xyt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xyt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xz() * self.as_inner().zt(),
            -T::TWO * operand.as_inner().xyt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xyt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xy() * self.as_inner().yz()
                + operand.as_inner().xyt(),
            -T::TWO * operand.as_inner().xyt() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xyz() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xz() * self.as_inner().yz()
                + operand.as_inner().xzt(),
            -(operand.as_inner().yzt())
                + -T::TWO * operand.as_inner().xyz() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xyz() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().yz() * self.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            self.xt() * operand.x() * self.xt()
                + self.xt() * operand.y() * self.yt()
                + self.xt() * operand.z() * self.zt()
                - self.xy() * operand.t() * self.yt()
                - self.xy() * operand.x() * self.xy()
                + self.xy() * operand.z() * self.yz()
                - self.xz() * operand.t() * self.zt()
                - self.xz() * operand.x() * self.xz()
                - self.xz() * operand.y() * self.yz()
                - self.yt() * operand.t() * self.xy()
                - self.yt() * operand.x() * self.yt()
                + self.yt() * operand.y() * self.xt()
                + self.yz() * operand.x() * self.yz()
                - self.yz() * operand.y() * self.xz()
                + self.yz() * operand.z() * self.xy()
                - self.zt() * operand.t() * self.xz()
                - self.zt() * operand.x() * self.zt()
                + self.zt() * operand.z() * self.xt(),
            self.xt() * operand.t() * self.xy() + self.xt() * operand.x() * self.yt()
                - self.xt() * operand.y() * self.xt()
                + self.xy() * operand.t() * self.xt()
                - self.xy() * operand.y() * self.xy()
                - self.xy() * operand.z() * self.xz()
                - self.xz() * operand.x() * self.yz()
                + self.xz() * operand.y() * self.xz()
                - self.xz() * operand.z() * self.xy()
                + self.yt() * operand.x() * self.xt()
                + self.yt() * operand.y() * self.yt()
                + self.yt() * operand.z() * self.zt()
                - self.yz() * operand.t() * self.zt()
                - self.yz() * operand.x() * self.xz()
                - self.yz() * operand.y() * self.yz()
                - self.zt() * operand.t() * self.yz()
                - self.zt() * operand.y() * self.zt()
                + self.zt() * operand.z() * self.yt(),
            self.xt() * operand.t() * self.xz() + self.xt() * operand.x() * self.zt()
                - self.xt() * operand.z() * self.xt()
                + self.xy() * operand.x() * self.yz()
                - self.xy() * operand.y() * self.xz()
                + self.xy() * operand.z() * self.xy()
                + self.xz() * operand.t() * self.xt()
                - self.xz() * operand.y() * self.xy()
                - self.xz() * operand.z() * self.xz()
                + self.yt() * operand.t() * self.yz()
                + self.yt() * operand.y() * self.zt()
                - self.yt() * operand.z() * self.yt()
                + self.yz() * operand.t() * self.yt()
                + self.yz() * operand.x() * self.xy()
                - self.yz() * operand.z() * self.yz()
                + self.zt() * operand.x() * self.xt()
                + self.zt() * operand.y() * self.yt()
                + self.zt() * operand.z() * self.zt(),
            self.xt() * operand.t() * self.xt()
                - self.xt() * operand.y() * self.xy()
                - self.xt() * operand.z() * self.xz()
                + self.xy() * operand.t() * self.xy()
                + self.xy() * operand.x() * self.yt()
                - self.xy() * operand.y() * self.xt()
                + self.xz() * operand.t() * self.xz()
                + self.xz() * operand.x() * self.zt()
                - self.xz() * operand.z() * self.xt()
                + self.yt() * operand.t() * self.yt()
                + self.yt() * operand.x() * self.xy()
                - self.yt() * operand.z() * self.yz()
                + self.yz() * operand.t() * self.yz()
                + self.yz() * operand.y() * self.zt()
                - self.yz() * operand.z() * self.yt()
                + self.zt() * operand.t() * self.zt()
                + self.zt() * operand.x() * self.xz()
                + self.zt() * operand.y() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.x())
                + -T::TWO * operand.t() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.t() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.x() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.x() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.y() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.x() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.y() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.z() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.z() * self.as_inner().xy() * self.as_inner().yz(),
            -T::TWO * operand.t() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.x() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.y() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.y() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.z() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.t() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.x() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.y() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.z() * self.as_inner().yt() * self.as_inner().zt()
                + operand.y(),
            -T::TWO * operand.y() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.z() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.z() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.t() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.t() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.x() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.x() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.y() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.z() * self.as_inner().zt() * self.as_inner().zt()
                + operand.z(),
            -(operand.t())
                + -T::TWO * operand.y() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.z() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.z() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.t() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.t() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.t() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.x() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.x() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.y() * self.as_inner().yz() * self.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.as_inner().x() * self.xy() * self.xy())
                + -(operand.as_inner().x() * self.xz() * self.xz())
                + -(operand.as_inner().x() * self.yt() * self.yt())
                + -(operand.as_inner().x() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().t() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().t() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().y() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().y() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().z() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().z() * self.xy() * self.yz()
                + operand.as_inner().x() * self.xt() * self.xt()
                + operand.as_inner().x() * self.yz() * self.yz(),
            -(operand.as_inner().y() * self.xt() * self.xt())
                + -(operand.as_inner().y() * self.xy() * self.xy())
                + -(operand.as_inner().y() * self.yz() * self.yz())
                + -(operand.as_inner().y() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().t() * self.yz() * self.zt()
                + -T::TWO * operand.as_inner().x() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().z() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().t() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().x() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().z() * self.yt() * self.zt()
                + operand.as_inner().y() * self.xz() * self.xz()
                + operand.as_inner().y() * self.yt() * self.yt(),
            -(operand.as_inner().z() * self.xt() * self.xt())
                + -(operand.as_inner().z() * self.xz() * self.xz())
                + -(operand.as_inner().z() * self.yt() * self.yt())
                + -(operand.as_inner().z() * self.yz() * self.yz())
                + -T::TWO * operand.as_inner().y() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().t() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().t() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().x() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().x() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().y() * self.yt() * self.zt()
                + operand.as_inner().z() * self.xy() * self.xy()
                + operand.as_inner().z() * self.zt() * self.zt(),
            -T::TWO * operand.as_inner().y() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().z() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().z() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().x() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().x() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().y() * self.yz() * self.zt()
                + operand.as_inner().t() * self.xt() * self.xt()
                + operand.as_inner().t() * self.xy() * self.xy()
                + operand.as_inner().t() * self.xz() * self.xz()
                + operand.as_inner().t() * self.yt() * self.yt()
                + operand.as_inner().t() * self.yz() * self.yz()
                + operand.as_inner().t() * self.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.as_inner().x())
                + -T::TWO * operand.as_inner().t() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().t() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().x() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().x() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().x() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().y() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().z() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().z() * self.as_inner().xy() * self.as_inner().yz(),
            -T::TWO * operand.as_inner().t() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().x() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().y() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().t() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().x() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().y() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().z() * self.as_inner().yt() * self.as_inner().zt()
                + operand.as_inner().y(),
            -T::TWO * operand.as_inner().y() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().t() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().t() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().x() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().x() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().y() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().z() * self.as_inner().zt() * self.as_inner().zt()
                + operand.as_inner().z(),
            -(operand.as_inner().t())
                + -T::TWO * operand.as_inner().y() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().t() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().t() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().t() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().x() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().x() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().y() * self.as_inner().yz() * self.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Eventor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(self.s() * operand.xt() * self.yt()) - self.s() * operand.xy() * self.s()
                + self.s() * operand.xz() * self.yz()
                + self.s() * operand.yt() * self.xt()
                - self.s() * operand.yz() * self.xz()
                - self.s() * operand.zt() * self.xyzt()
                + self.xt() * operand.xt() * self.xy()
                - self.xt() * operand.xy() * self.xt()
                + self.xt() * operand.xz() * self.xyzt()
                + self.xt() * operand.yt() * self.s()
                + self.xt() * operand.yz() * self.zt()
                - self.xt() * operand.zt() * self.yz()
                + self.xy() * operand.xt() * self.xt()
                - self.xy() * operand.xy() * self.xy()
                - self.xy() * operand.xz() * self.xz()
                + self.xy() * operand.yt() * self.yt()
                - self.xy() * operand.yz() * self.yz()
                + self.xy() * operand.zt() * self.zt()
                - self.xyzt() * operand.xt() * self.xz()
                + self.xyzt() * operand.xy() * self.xyzt()
                + self.xyzt() * operand.xz() * self.xt()
                - self.xyzt() * operand.yt() * self.yz()
                + self.xyzt() * operand.yz() * self.yt()
                - self.xyzt() * operand.zt() * self.s()
                - self.xz() * operand.xt() * self.xyzt()
                + self.xz() * operand.xy() * self.xz()
                - self.xz() * operand.xz() * self.xy()
                - self.xz() * operand.yt() * self.zt()
                - self.xz() * operand.yz() * self.s()
                + self.xz() * operand.zt() * self.yt()
                - self.yt() * operand.xt() * self.s()
                - self.yt() * operand.xy() * self.yt()
                - self.yt() * operand.xz() * self.zt()
                + self.yt() * operand.yt() * self.xy()
                + self.yt() * operand.yz() * self.xyzt()
                + self.yt() * operand.zt() * self.xz()
                + self.yz() * operand.xt() * self.zt()
                + self.yz() * operand.xy() * self.yz()
                + self.yz() * operand.xz() * self.s()
                - self.yz() * operand.yt() * self.xyzt()
                - self.yz() * operand.yz() * self.xy()
                - self.yz() * operand.zt() * self.xt()
                + self.zt() * operand.xt() * self.yz()
                + self.zt() * operand.xy() * self.zt()
                - self.zt() * operand.xz() * self.yt()
                - self.zt() * operand.yt() * self.xz()
                + self.zt() * operand.yz() * self.xt()
                + self.zt() * operand.zt() * self.xy(),
            -(self.s() * operand.xt() * self.zt())
                - self.s() * operand.xy() * self.yz()
                - self.s() * operand.xz() * self.s()
                + self.s() * operand.yt() * self.xyzt()
                + self.s() * operand.yz() * self.xy()
                + self.s() * operand.zt() * self.xt()
                + self.xt() * operand.xt() * self.xz()
                - self.xt() * operand.xy() * self.xyzt()
                - self.xt() * operand.xz() * self.xt()
                + self.xt() * operand.yt() * self.yz()
                - self.xt() * operand.yz() * self.yt()
                + self.xt() * operand.zt() * self.s()
                + self.xy() * operand.xt() * self.xyzt()
                - self.xy() * operand.xy() * self.xz()
                + self.xy() * operand.xz() * self.xy()
                + self.xy() * operand.yt() * self.zt()
                + self.xy() * operand.yz() * self.s()
                - self.xy() * operand.zt() * self.yt()
                + self.xyzt() * operand.xt() * self.xy()
                - self.xyzt() * operand.xy() * self.xt()
                + self.xyzt() * operand.xz() * self.xyzt()
                + self.xyzt() * operand.yt() * self.s()
                + self.xyzt() * operand.yz() * self.zt()
                - self.xyzt() * operand.zt() * self.yz()
                + self.xz() * operand.xt() * self.xt()
                - self.xz() * operand.xy() * self.xy()
                - self.xz() * operand.xz() * self.xz()
                + self.xz() * operand.yt() * self.yt()
                - self.xz() * operand.yz() * self.yz()
                + self.xz() * operand.zt() * self.zt()
                - self.yt() * operand.xt() * self.yz()
                - self.yt() * operand.xy() * self.zt()
                + self.yt() * operand.xz() * self.yt()
                + self.yt() * operand.yt() * self.xz()
                - self.yt() * operand.yz() * self.xt()
                - self.yt() * operand.zt() * self.xy()
                - self.yz() * operand.xt() * self.yt()
                - self.yz() * operand.xy() * self.s()
                + self.yz() * operand.xz() * self.yz()
                + self.yz() * operand.yt() * self.xt()
                - self.yz() * operand.yz() * self.xz()
                - self.yz() * operand.zt() * self.xyzt()
                - self.zt() * operand.xt() * self.s()
                - self.zt() * operand.xy() * self.yt()
                - self.zt() * operand.xz() * self.zt()
                + self.zt() * operand.yt() * self.xy()
                + self.zt() * operand.yz() * self.xyzt()
                + self.zt() * operand.zt() * self.xz(),
            -(self.s() * operand.xt() * self.s())
                - self.s() * operand.xy() * self.yt()
                - self.s() * operand.xz() * self.zt()
                + self.s() * operand.yt() * self.xy()
                + self.s() * operand.yz() * self.xyzt()
                + self.s() * operand.zt() * self.xz()
                + self.xt() * operand.xt() * self.xt()
                - self.xt() * operand.xy() * self.xy()
                - self.xt() * operand.xz() * self.xz()
                + self.xt() * operand.yt() * self.yt()
                - self.xt() * operand.yz() * self.yz()
                + self.xt() * operand.zt() * self.zt()
                + self.xy() * operand.xt() * self.xy()
                - self.xy() * operand.xy() * self.xt()
                + self.xy() * operand.xz() * self.xyzt()
                + self.xy() * operand.yt() * self.s()
                + self.xy() * operand.yz() * self.zt()
                - self.xy() * operand.zt() * self.yz()
                + self.xyzt() * operand.xt() * self.xyzt()
                - self.xyzt() * operand.xy() * self.xz()
                + self.xyzt() * operand.xz() * self.xy()
                + self.xyzt() * operand.yt() * self.zt()
                + self.xyzt() * operand.yz() * self.s()
                - self.xyzt() * operand.zt() * self.yt()
                + self.xz() * operand.xt() * self.xz()
                - self.xz() * operand.xy() * self.xyzt()
                - self.xz() * operand.xz() * self.xt()
                + self.xz() * operand.yt() * self.yz()
                - self.xz() * operand.yz() * self.yt()
                + self.xz() * operand.zt() * self.s()
                - self.yt() * operand.xt() * self.yt()
                - self.yt() * operand.xy() * self.s()
                + self.yt() * operand.xz() * self.yz()
                + self.yt() * operand.yt() * self.xt()
                - self.yt() * operand.yz() * self.xz()
                - self.yt() * operand.zt() * self.xyzt()
                - self.yz() * operand.xt() * self.yz()
                - self.yz() * operand.xy() * self.zt()
                + self.yz() * operand.xz() * self.yt()
                + self.yz() * operand.yt() * self.xz()
                - self.yz() * operand.yz() * self.xt()
                - self.yz() * operand.zt() * self.xy()
                - self.zt() * operand.xt() * self.zt()
                - self.zt() * operand.xy() * self.yz()
                - self.zt() * operand.xz() * self.s()
                + self.zt() * operand.yt() * self.xyzt()
                + self.zt() * operand.yz() * self.xy()
                + self.zt() * operand.zt() * self.xt(),
            -(self.s() * operand.xt() * self.xyzt()) + self.s() * operand.xy() * self.xz()
                - self.s() * operand.xz() * self.xy()
                - self.s() * operand.yt() * self.zt()
                - self.s() * operand.yz() * self.s()
                + self.s() * operand.zt() * self.yt()
                + self.xt() * operand.xt() * self.yz()
                + self.xt() * operand.xy() * self.zt()
                - self.xt() * operand.xz() * self.yt()
                - self.xt() * operand.yt() * self.xz()
                + self.xt() * operand.yz() * self.xt()
                + self.xt() * operand.zt() * self.xy()
                - self.xy() * operand.xt() * self.zt()
                - self.xy() * operand.xy() * self.yz()
                - self.xy() * operand.xz() * self.s()
                + self.xy() * operand.yt() * self.xyzt()
                + self.xy() * operand.yz() * self.xy()
                + self.xy() * operand.zt() * self.xt()
                - self.xyzt() * operand.xt() * self.s()
                - self.xyzt() * operand.xy() * self.yt()
                - self.xyzt() * operand.xz() * self.zt()
                + self.xyzt() * operand.yt() * self.xy()
                + self.xyzt() * operand.yz() * self.xyzt()
                + self.xyzt() * operand.zt() * self.xz()
                + self.xz() * operand.xt() * self.yt()
                + self.xz() * operand.xy() * self.s()
                - self.xz() * operand.xz() * self.yz()
                - self.xz() * operand.yt() * self.xt()
                + self.xz() * operand.yz() * self.xz()
                + self.xz() * operand.zt() * self.xyzt()
                + self.yt() * operand.xt() * self.xz()
                - self.yt() * operand.xy() * self.xyzt()
                - self.yt() * operand.xz() * self.xt()
                + self.yt() * operand.yt() * self.yz()
                - self.yt() * operand.yz() * self.yt()
                + self.yt() * operand.zt() * self.s()
                + self.yz() * operand.xt() * self.xt()
                - self.yz() * operand.xy() * self.xy()
                - self.yz() * operand.xz() * self.xz()
                + self.yz() * operand.yt() * self.yt()
                - self.yz() * operand.yz() * self.yz()
                + self.yz() * operand.zt() * self.zt()
                - self.zt() * operand.xt() * self.xy()
                + self.zt() * operand.xy() * self.xt()
                - self.zt() * operand.xz() * self.xyzt()
                - self.zt() * operand.yt() * self.s()
                - self.zt() * operand.yz() * self.zt()
                + self.zt() * operand.zt() * self.yz(),
            -(self.s() * operand.xt() * self.xy()) + self.s() * operand.xy() * self.xt()
                - self.s() * operand.xz() * self.xyzt()
                - self.s() * operand.yt() * self.s()
                - self.s() * operand.yz() * self.zt()
                + self.s() * operand.zt() * self.yz()
                + self.xt() * operand.xt() * self.yt()
                + self.xt() * operand.xy() * self.s()
                - self.xt() * operand.xz() * self.yz()
                - self.xt() * operand.yt() * self.xt()
                + self.xt() * operand.yz() * self.xz()
                + self.xt() * operand.zt() * self.xyzt()
                - self.xy() * operand.xt() * self.s()
                - self.xy() * operand.xy() * self.yt()
                - self.xy() * operand.xz() * self.zt()
                + self.xy() * operand.yt() * self.xy()
                + self.xy() * operand.yz() * self.xyzt()
                + self.xy() * operand.zt() * self.xz()
                - self.xyzt() * operand.xt() * self.zt()
                - self.xyzt() * operand.xy() * self.yz()
                - self.xyzt() * operand.xz() * self.s()
                + self.xyzt() * operand.yt() * self.xyzt()
                + self.xyzt() * operand.yz() * self.xy()
                + self.xyzt() * operand.zt() * self.xt()
                + self.xz() * operand.xt() * self.yz()
                + self.xz() * operand.xy() * self.zt()
                - self.xz() * operand.xz() * self.yt()
                - self.xz() * operand.yt() * self.xz()
                + self.xz() * operand.yz() * self.xt()
                + self.xz() * operand.zt() * self.xy()
                + self.yt() * operand.xt() * self.xt()
                - self.yt() * operand.xy() * self.xy()
                - self.yt() * operand.xz() * self.xz()
                + self.yt() * operand.yt() * self.yt()
                - self.yt() * operand.yz() * self.yz()
                + self.yt() * operand.zt() * self.zt()
                + self.yz() * operand.xt() * self.xz()
                - self.yz() * operand.xy() * self.xyzt()
                - self.yz() * operand.xz() * self.xt()
                + self.yz() * operand.yt() * self.yz()
                - self.yz() * operand.yz() * self.yt()
                + self.yz() * operand.zt() * self.s()
                - self.zt() * operand.xt() * self.xyzt()
                + self.zt() * operand.xy() * self.xz()
                - self.zt() * operand.xz() * self.xy()
                - self.zt() * operand.yt() * self.zt()
                - self.zt() * operand.yz() * self.s()
                + self.zt() * operand.zt() * self.yt(),
            -(self.s() * operand.xt() * self.xz())
                + self.s() * operand.xy() * self.xyzt()
                + self.s() * operand.xz() * self.xt()
                - self.s() * operand.yt() * self.yz()
                + self.s() * operand.yz() * self.yt()
                - self.s() * operand.zt() * self.s()
                + self.xt() * operand.xt() * self.zt()
                + self.xt() * operand.xy() * self.yz()
                + self.xt() * operand.xz() * self.s()
                - self.xt() * operand.yt() * self.xyzt()
                - self.xt() * operand.yz() * self.xy()
                - self.xt() * operand.zt() * self.xt()
                - self.xy() * operand.xt() * self.yz()
                - self.xy() * operand.xy() * self.zt()
                + self.xy() * operand.xz() * self.yt()
                + self.xy() * operand.yt() * self.xz()
                - self.xy() * operand.yz() * self.xt()
                - self.xy() * operand.zt() * self.xy()
                + self.xyzt() * operand.xt() * self.yt()
                + self.xyzt() * operand.xy() * self.s()
                - self.xyzt() * operand.xz() * self.yz()
                - self.xyzt() * operand.yt() * self.xt()
                + self.xyzt() * operand.yz() * self.xz()
                + self.xyzt() * operand.zt() * self.xyzt()
                - self.xz() * operand.xt() * self.s()
                - self.xz() * operand.xy() * self.yt()
                - self.xz() * operand.xz() * self.zt()
                + self.xz() * operand.yt() * self.xy()
                + self.xz() * operand.yz() * self.xyzt()
                + self.xz() * operand.zt() * self.xz()
                + self.yt() * operand.xt() * self.xyzt()
                - self.yt() * operand.xy() * self.xz()
                + self.yt() * operand.xz() * self.xy()
                + self.yt() * operand.yt() * self.zt()
                + self.yt() * operand.yz() * self.s()
                - self.yt() * operand.zt() * self.yt()
                - self.yz() * operand.xt() * self.xy()
                + self.yz() * operand.xy() * self.xt()
                - self.yz() * operand.xz() * self.xyzt()
                - self.yz() * operand.yt() * self.s()
                - self.yz() * operand.yz() * self.zt()
                + self.yz() * operand.zt() * self.yz()
                + self.zt() * operand.xt() * self.xt()
                - self.zt() * operand.xy() * self.xy()
                - self.zt() * operand.xz() * self.xz()
                + self.zt() * operand.yt() * self.yt()
                - self.zt() * operand.yz() * self.yz()
                + self.zt() * operand.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Unit<Eventor<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.xy())
                + -T::TWO * operand.xt() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.xt() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * operand.xy() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.yz() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.xt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.xy() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.xz() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.yt() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.yz() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::from_i8(-4i8) * operand.zt() * self.as_inner().xt() * self.as_inner().yz()
                + T::from_i8(4i8) * operand.zt() * self.as_inner().xz() * self.as_inner().yt(),
            -(operand.xz())
                + -T::TWO * operand.xt() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.xt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.xy() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.xy() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * operand.xz() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.yz() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.zt() * self.as_inner().xyzt() * self.as_inner().yz()
                + T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.xz() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.yz() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.yz() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.zt() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.zt() * self.as_inner().xz() * self.as_inner().zt()
                + T::from_i8(4i8) * operand.yt() * self.as_inner().xt() * self.as_inner().yz()
                + T::from_i8(4i8) * operand.yt() * self.as_inner().xy() * self.as_inner().zt(),
            -(operand.xt())
                + -T::TWO * operand.xt() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.xt() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.xy() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.xy() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.xy() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.xz() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.zt() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.xt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.yt() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.yt() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.zt() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().zt()
                + T::from_i8(-4i8) * operand.yz() * self.as_inner().xz() * self.as_inner().yt()
                + T::from_i8(4i8) * operand.yz() * self.as_inner().xy() * self.as_inner().zt(),
            -(operand.yz())
                + -T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.xy() * self.as_inner().xyzt() * self.as_inner().yt()
                + -T::TWO * operand.xz() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.xz() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.yz() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.yz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.yz() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.zt() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().yz() * self.as_inner().zt()
                + T::from_i8(-4i8) * operand.xt() * self.as_inner().xy() * self.as_inner().zt()
                + T::from_i8(4i8) * operand.xt() * self.as_inner().xz() * self.as_inner().yt(),
            -(operand.yt())
                + -T::TWO * operand.xt() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.xt() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.xy() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * operand.yt() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.yz() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.yz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.xt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.xy() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.xy() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.yt() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.zt() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().yt() * self.as_inner().zt()
                + T::from_i8(-4i8) * operand.xz() * self.as_inner().xt() * self.as_inner().yz()
                + T::from_i8(-4i8) * operand.xz() * self.as_inner().xy() * self.as_inner().zt(),
            -(operand.zt())
                + -T::TWO * operand.xt() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.xz() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.yz() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * operand.zt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.xt() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.xz() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.yz() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.yz() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().yz() * self.as_inner().yz()
                + T::from_i8(-4i8) * operand.xy() * self.as_inner().xz() * self.as_inner().yt()
                + T::from_i8(4i8) * operand.xy() * self.as_inner().xt() * self.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Eventor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.as_inner().xy() * self.s() * self.s())
                + -(operand.as_inner().xy() * self.xt() * self.xt())
                + -(operand.as_inner().xy() * self.xy() * self.xy())
                + -(operand.as_inner().xy() * self.yt() * self.yt())
                + -T::TWO * operand.as_inner().xt() * self.s() * self.yt()
                + -T::TWO * operand.as_inner().xt() * self.xyzt() * self.xz()
                + -T::TWO * operand.as_inner().xz() * self.xy() * self.xz()
                + -T::TWO * operand.as_inner().xz() * self.yt() * self.zt()
                + -T::TWO * operand.as_inner().yt() * self.xyzt() * self.yz()
                + -T::TWO * operand.as_inner().yt() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().yz() * self.s() * self.xz()
                + -T::TWO * operand.as_inner().yz() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().xt() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().xt() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().xz() * self.s() * self.yz()
                + T::TWO * operand.as_inner().xz() * self.xt() * self.xyzt()
                + T::TWO * operand.as_inner().yt() * self.s() * self.xt()
                + T::TWO * operand.as_inner().yt() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().yz() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.xyzt() * self.yt()
                + T::from_i8(-4i8) * operand.as_inner().zt() * self.xt() * self.yz()
                + T::from_i8(4i8) * operand.as_inner().zt() * self.xz() * self.yt()
                + operand.as_inner().xy() * self.xyzt() * self.xyzt()
                + operand.as_inner().xy() * self.xz() * self.xz()
                + operand.as_inner().xy() * self.yz() * self.yz()
                + operand.as_inner().xy() * self.zt() * self.zt(),
            -(operand.as_inner().xz() * self.s() * self.s())
                + -(operand.as_inner().xz() * self.xt() * self.xt())
                + -(operand.as_inner().xz() * self.xz() * self.xz())
                + -(operand.as_inner().xz() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xt() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().xt() * self.yt() * self.yz()
                + -T::TWO * operand.as_inner().xy() * self.s() * self.yz()
                + -T::TWO * operand.as_inner().xy() * self.xt() * self.xyzt()
                + -T::TWO * operand.as_inner().xy() * self.xy() * self.xz()
                + -T::TWO * operand.as_inner().xy() * self.yt() * self.zt()
                + -T::TWO * operand.as_inner().yz() * self.xt() * self.yt()
                + -T::TWO * operand.as_inner().yz() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().zt() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().zt() * self.xyzt() * self.yz()
                + T::TWO * operand.as_inner().xt() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().xt() * self.xy() * self.xyzt()
                + T::TWO * operand.as_inner().yz() * self.s() * self.xy()
                + T::TWO * operand.as_inner().yz() * self.xyzt() * self.zt()
                + T::TWO * operand.as_inner().zt() * self.s() * self.xt()
                + T::TWO * operand.as_inner().zt() * self.xz() * self.zt()
                + T::from_i8(4i8) * operand.as_inner().yt() * self.xt() * self.yz()
                + T::from_i8(4i8) * operand.as_inner().yt() * self.xy() * self.zt()
                + operand.as_inner().xz() * self.xy() * self.xy()
                + operand.as_inner().xz() * self.xyzt() * self.xyzt()
                + operand.as_inner().xz() * self.yt() * self.yt()
                + operand.as_inner().xz() * self.yz() * self.yz(),
            -(operand.as_inner().xt() * self.s() * self.s())
                + -(operand.as_inner().xt() * self.yt() * self.yt())
                + -(operand.as_inner().xt() * self.yz() * self.yz())
                + -(operand.as_inner().xt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xy() * self.s() * self.yt()
                + -T::TWO * operand.as_inner().xy() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().xy() * self.xyzt() * self.xz()
                + -T::TWO * operand.as_inner().xy() * self.yz() * self.zt()
                + -T::TWO * operand.as_inner().xz() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().xz() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().zt() * self.xy() * self.yz()
                + -T::TWO * operand.as_inner().zt() * self.xyzt() * self.yt()
                + T::TWO * operand.as_inner().xz() * self.xy() * self.xyzt()
                + T::TWO * operand.as_inner().xz() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().yt() * self.s() * self.xy()
                + T::TWO * operand.as_inner().yt() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().yt() * self.xyzt() * self.zt()
                + T::TWO * operand.as_inner().yt() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().zt() * self.s() * self.xz()
                + T::TWO * operand.as_inner().zt() * self.xt() * self.zt()
                + T::from_i8(-4i8) * operand.as_inner().yz() * self.xz() * self.yt()
                + T::from_i8(4i8) * operand.as_inner().yz() * self.xy() * self.zt()
                + operand.as_inner().xt() * self.xt() * self.xt()
                + operand.as_inner().xt() * self.xy() * self.xy()
                + operand.as_inner().xt() * self.xyzt() * self.xyzt()
                + operand.as_inner().xt() * self.xz() * self.xz(),
            -(operand.as_inner().yz() * self.s() * self.s())
                + -(operand.as_inner().yz() * self.yt() * self.yt())
                + -(operand.as_inner().yz() * self.yz() * self.yz())
                + -(operand.as_inner().yz() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xy() * self.xy() * self.yz()
                + -T::TWO * operand.as_inner().xy() * self.xyzt() * self.yt()
                + -T::TWO * operand.as_inner().xz() * self.s() * self.xy()
                + -T::TWO * operand.as_inner().xz() * self.xt() * self.yt()
                + -T::TWO * operand.as_inner().xz() * self.xyzt() * self.zt()
                + -T::TWO * operand.as_inner().xz() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().yt() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().yt() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().xy() * self.s() * self.xz()
                + T::TWO * operand.as_inner().xy() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().yt() * self.xy() * self.xyzt()
                + T::TWO * operand.as_inner().yt() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().zt() * self.s() * self.yt()
                + T::TWO * operand.as_inner().zt() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().zt() * self.xyzt() * self.xz()
                + T::TWO * operand.as_inner().zt() * self.yz() * self.zt()
                + T::from_i8(-4i8) * operand.as_inner().xt() * self.xy() * self.zt()
                + T::from_i8(4i8) * operand.as_inner().xt() * self.xz() * self.yt()
                + operand.as_inner().yz() * self.xt() * self.xt()
                + operand.as_inner().yz() * self.xy() * self.xy()
                + operand.as_inner().yz() * self.xyzt() * self.xyzt()
                + operand.as_inner().yz() * self.xz() * self.xz(),
            -(operand.as_inner().yt() * self.s() * self.s())
                + -(operand.as_inner().yt() * self.xt() * self.xt())
                + -(operand.as_inner().yt() * self.xz() * self.xz())
                + -(operand.as_inner().yt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xt() * self.s() * self.xy()
                + -T::TWO * operand.as_inner().xt() * self.xyzt() * self.zt()
                + -T::TWO * operand.as_inner().xy() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().xy() * self.xyzt() * self.yz()
                + -T::TWO * operand.as_inner().yz() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().yz() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().xt() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().xt() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().xy() * self.s() * self.xt()
                + T::TWO * operand.as_inner().xy() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().yz() * self.xy() * self.xyzt()
                + T::TWO * operand.as_inner().zt() * self.s() * self.yz()
                + T::TWO * operand.as_inner().zt() * self.xt() * self.xyzt()
                + T::TWO * operand.as_inner().zt() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().zt() * self.yt() * self.zt()
                + T::from_i8(-4i8) * operand.as_inner().xz() * self.xt() * self.yz()
                + T::from_i8(-4i8) * operand.as_inner().xz() * self.xy() * self.zt()
                + operand.as_inner().yt() * self.xy() * self.xy()
                + operand.as_inner().yt() * self.xyzt() * self.xyzt()
                + operand.as_inner().yt() * self.yt() * self.yt()
                + operand.as_inner().yt() * self.yz() * self.yz(),
            -(operand.as_inner().zt() * self.s() * self.s())
                + -(operand.as_inner().zt() * self.xt() * self.xt())
                + -(operand.as_inner().zt() * self.xy() * self.xy())
                + -(operand.as_inner().zt() * self.yt() * self.yt())
                + -T::TWO * operand.as_inner().xt() * self.s() * self.xz()
                + -T::TWO * operand.as_inner().xt() * self.xy() * self.yz()
                + -T::TWO * operand.as_inner().xz() * self.xyzt() * self.yz()
                + -T::TWO * operand.as_inner().xz() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().yt() * self.s() * self.yz()
                + -T::TWO * operand.as_inner().yt() * self.xt() * self.xyzt()
                + -T::TWO * operand.as_inner().yz() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().yz() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().xt() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().xt() * self.xyzt() * self.yt()
                + T::TWO * operand.as_inner().xz() * self.s() * self.xt()
                + T::TWO * operand.as_inner().xz() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().yt() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().yt() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.s() * self.yt()
                + T::TWO * operand.as_inner().yz() * self.xyzt() * self.xz()
                + T::from_i8(-4i8) * operand.as_inner().xy() * self.xz() * self.yt()
                + T::from_i8(4i8) * operand.as_inner().xy() * self.xt() * self.yz()
                + operand.as_inner().zt() * self.xyzt() * self.xyzt()
                + operand.as_inner().zt() * self.xz() * self.xz()
                + operand.as_inner().zt() * self.yz() * self.yz()
                + operand.as_inner().zt() * self.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Unit<Eventor<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.as_inner().xy())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::from_i8(-4i8)
                    * operand.as_inner().zt()
                    * self.as_inner().xt()
                    * self.as_inner().yz()
                + T::from_i8(4i8)
                    * operand.as_inner().zt()
                    * self.as_inner().xz()
                    * self.as_inner().yt(),
            -(operand.as_inner().xz())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xyzt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xz() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xz() * self.as_inner().zt()
                + T::from_i8(4i8)
                    * operand.as_inner().yt()
                    * self.as_inner().xt()
                    * self.as_inner().yz()
                + T::from_i8(4i8)
                    * operand.as_inner().yt()
                    * self.as_inner().xy()
                    * self.as_inner().zt(),
            -(operand.as_inner().xt())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yt() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().zt()
                + T::from_i8(-4i8)
                    * operand.as_inner().yz()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + T::from_i8(4i8)
                    * operand.as_inner().yz()
                    * self.as_inner().xy()
                    * self.as_inner().zt(),
            -(operand.as_inner().yz())
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xyzt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().yz() * self.as_inner().zt()
                + T::from_i8(-4i8)
                    * operand.as_inner().xt()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + T::from_i8(4i8)
                    * operand.as_inner().xt()
                    * self.as_inner().xz()
                    * self.as_inner().yt(),
            -(operand.as_inner().yt())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yt() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().yt() * self.as_inner().zt()
                + T::from_i8(-4i8)
                    * operand.as_inner().xz()
                    * self.as_inner().xt()
                    * self.as_inner().yz()
                + T::from_i8(-4i8)
                    * operand.as_inner().xz()
                    * self.as_inner().xy()
                    * self.as_inner().zt(),
            -(operand.as_inner().zt())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().yz() * self.as_inner().yz()
                + T::from_i8(-4i8)
                    * operand.as_inner().xy()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + T::from_i8(4i8)
                    * operand.as_inner().xy()
                    * self.as_inner().xt()
                    * self.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(self.s() * operand.s() * self.s()) + self.s() * operand.xt() * self.xt()
                - self.s() * operand.xy() * self.xy()
                + self.s() * operand.xyzt() * self.xyzt()
                - self.s() * operand.xz() * self.xz()
                + self.s() * operand.yt() * self.yt()
                - self.s() * operand.yz() * self.yz()
                + self.s() * operand.zt() * self.zt()
                + self.xt() * operand.s() * self.xt()
                - self.xt() * operand.xt() * self.s()
                - self.xt() * operand.xy() * self.yt()
                - self.xt() * operand.xyzt() * self.yz()
                - self.xt() * operand.xz() * self.zt()
                + self.xt() * operand.yt() * self.xy()
                + self.xt() * operand.yz() * self.xyzt()
                + self.xt() * operand.zt() * self.xz()
                - self.xy() * operand.s() * self.xy()
                + self.xy() * operand.xt() * self.yt()
                + self.xy() * operand.xy() * self.s()
                - self.xy() * operand.xyzt() * self.zt()
                - self.xy() * operand.xz() * self.yz()
                - self.xy() * operand.yt() * self.xt()
                + self.xy() * operand.yz() * self.xz()
                + self.xy() * operand.zt() * self.xyzt()
                + self.xyzt() * operand.s() * self.xyzt()
                - self.xyzt() * operand.xt() * self.yz()
                - self.xyzt() * operand.xy() * self.zt()
                + self.xyzt() * operand.xyzt() * self.s()
                + self.xyzt() * operand.xz() * self.yt()
                + self.xyzt() * operand.yt() * self.xz()
                - self.xyzt() * operand.yz() * self.xt()
                - self.xyzt() * operand.zt() * self.xy()
                - self.xz() * operand.s() * self.xz()
                + self.xz() * operand.xt() * self.zt()
                + self.xz() * operand.xy() * self.yz()
                + self.xz() * operand.xyzt() * self.yt()
                + self.xz() * operand.xz() * self.s()
                - self.xz() * operand.yt() * self.xyzt()
                - self.xz() * operand.yz() * self.xy()
                - self.xz() * operand.zt() * self.xt()
                + self.yt() * operand.s() * self.yt()
                - self.yt() * operand.xt() * self.xy()
                + self.yt() * operand.xy() * self.xt()
                + self.yt() * operand.xyzt() * self.xz()
                - self.yt() * operand.xz() * self.xyzt()
                - self.yt() * operand.yt() * self.s()
                - self.yt() * operand.yz() * self.zt()
                + self.yt() * operand.zt() * self.yz()
                - self.yz() * operand.s() * self.yz()
                + self.yz() * operand.xt() * self.xyzt()
                - self.yz() * operand.xy() * self.xz()
                - self.yz() * operand.xyzt() * self.xt()
                + self.yz() * operand.xz() * self.xy()
                + self.yz() * operand.yt() * self.zt()
                + self.yz() * operand.yz() * self.s()
                - self.yz() * operand.zt() * self.yt()
                + self.zt() * operand.s() * self.zt()
                - self.zt() * operand.xt() * self.xz()
                + self.zt() * operand.xy() * self.xyzt()
                - self.zt() * operand.xyzt() * self.xy()
                + self.zt() * operand.xz() * self.xt()
                - self.zt() * operand.yt() * self.yz()
                + self.zt() * operand.yz() * self.yt()
                - self.zt() * operand.zt() * self.s(),
            self.s() * operand.s() * self.xy()
                - self.s() * operand.xt() * self.yt()
                - self.s() * operand.xy() * self.s()
                + self.s() * operand.xyzt() * self.zt()
                + self.s() * operand.xz() * self.yz()
                + self.s() * operand.yt() * self.xt()
                - self.s() * operand.yz() * self.xz()
                - self.s() * operand.zt() * self.xyzt()
                - self.xt() * operand.s() * self.yt()
                + self.xt() * operand.xt() * self.xy()
                - self.xt() * operand.xy() * self.xt()
                - self.xt() * operand.xyzt() * self.xz()
                + self.xt() * operand.xz() * self.xyzt()
                + self.xt() * operand.yt() * self.s()
                + self.xt() * operand.yz() * self.zt()
                - self.xt() * operand.zt() * self.yz()
                - self.xy() * operand.s() * self.s()
                + self.xy() * operand.xt() * self.xt()
                - self.xy() * operand.xy() * self.xy()
                + self.xy() * operand.xyzt() * self.xyzt()
                - self.xy() * operand.xz() * self.xz()
                + self.xy() * operand.yt() * self.yt()
                - self.xy() * operand.yz() * self.yz()
                + self.xy() * operand.zt() * self.zt()
                + self.xyzt() * operand.s() * self.zt()
                - self.xyzt() * operand.xt() * self.xz()
                + self.xyzt() * operand.xy() * self.xyzt()
                - self.xyzt() * operand.xyzt() * self.xy()
                + self.xyzt() * operand.xz() * self.xt()
                - self.xyzt() * operand.yt() * self.yz()
                + self.xyzt() * operand.yz() * self.yt()
                - self.xyzt() * operand.zt() * self.s()
                + self.xz() * operand.s() * self.yz()
                - self.xz() * operand.xt() * self.xyzt()
                + self.xz() * operand.xy() * self.xz()
                + self.xz() * operand.xyzt() * self.xt()
                - self.xz() * operand.xz() * self.xy()
                - self.xz() * operand.yt() * self.zt()
                - self.xz() * operand.yz() * self.s()
                + self.xz() * operand.zt() * self.yt()
                + self.yt() * operand.s() * self.xt()
                - self.yt() * operand.xt() * self.s()
                - self.yt() * operand.xy() * self.yt()
                - self.yt() * operand.xyzt() * self.yz()
                - self.yt() * operand.xz() * self.zt()
                + self.yt() * operand.yt() * self.xy()
                + self.yt() * operand.yz() * self.xyzt()
                + self.yt() * operand.zt() * self.xz()
                - self.yz() * operand.s() * self.xz()
                + self.yz() * operand.xt() * self.zt()
                + self.yz() * operand.xy() * self.yz()
                + self.yz() * operand.xyzt() * self.yt()
                + self.yz() * operand.xz() * self.s()
                - self.yz() * operand.yt() * self.xyzt()
                - self.yz() * operand.yz() * self.xy()
                - self.yz() * operand.zt() * self.xt()
                - self.zt() * operand.s() * self.xyzt()
                + self.zt() * operand.xt() * self.yz()
                + self.zt() * operand.xy() * self.zt()
                - self.zt() * operand.xyzt() * self.s()
                - self.zt() * operand.xz() * self.yt()
                - self.zt() * operand.yt() * self.xz()
                + self.zt() * operand.yz() * self.xt()
                + self.zt() * operand.zt() * self.xy(),
            self.s() * operand.s() * self.xz()
                - self.s() * operand.xt() * self.zt()
                - self.s() * operand.xy() * self.yz()
                - self.s() * operand.xyzt() * self.yt()
                - self.s() * operand.xz() * self.s()
                + self.s() * operand.yt() * self.xyzt()
                + self.s() * operand.yz() * self.xy()
                + self.s() * operand.zt() * self.xt()
                - self.xt() * operand.s() * self.zt()
                + self.xt() * operand.xt() * self.xz()
                - self.xt() * operand.xy() * self.xyzt()
                + self.xt() * operand.xyzt() * self.xy()
                - self.xt() * operand.xz() * self.xt()
                + self.xt() * operand.yt() * self.yz()
                - self.xt() * operand.yz() * self.yt()
                + self.xt() * operand.zt() * self.s()
                - self.xy() * operand.s() * self.yz()
                + self.xy() * operand.xt() * self.xyzt()
                - self.xy() * operand.xy() * self.xz()
                - self.xy() * operand.xyzt() * self.xt()
                + self.xy() * operand.xz() * self.xy()
                + self.xy() * operand.yt() * self.zt()
                + self.xy() * operand.yz() * self.s()
                - self.xy() * operand.zt() * self.yt()
                - self.xyzt() * operand.s() * self.yt()
                + self.xyzt() * operand.xt() * self.xy()
                - self.xyzt() * operand.xy() * self.xt()
                - self.xyzt() * operand.xyzt() * self.xz()
                + self.xyzt() * operand.xz() * self.xyzt()
                + self.xyzt() * operand.yt() * self.s()
                + self.xyzt() * operand.yz() * self.zt()
                - self.xyzt() * operand.zt() * self.yz()
                - self.xz() * operand.s() * self.s()
                + self.xz() * operand.xt() * self.xt()
                - self.xz() * operand.xy() * self.xy()
                + self.xz() * operand.xyzt() * self.xyzt()
                - self.xz() * operand.xz() * self.xz()
                + self.xz() * operand.yt() * self.yt()
                - self.xz() * operand.yz() * self.yz()
                + self.xz() * operand.zt() * self.zt()
                + self.yt() * operand.s() * self.xyzt()
                - self.yt() * operand.xt() * self.yz()
                - self.yt() * operand.xy() * self.zt()
                + self.yt() * operand.xyzt() * self.s()
                + self.yt() * operand.xz() * self.yt()
                + self.yt() * operand.yt() * self.xz()
                - self.yt() * operand.yz() * self.xt()
                - self.yt() * operand.zt() * self.xy()
                + self.yz() * operand.s() * self.xy()
                - self.yz() * operand.xt() * self.yt()
                - self.yz() * operand.xy() * self.s()
                + self.yz() * operand.xyzt() * self.zt()
                + self.yz() * operand.xz() * self.yz()
                + self.yz() * operand.yt() * self.xt()
                - self.yz() * operand.yz() * self.xz()
                - self.yz() * operand.zt() * self.xyzt()
                + self.zt() * operand.s() * self.xt()
                - self.zt() * operand.xt() * self.s()
                - self.zt() * operand.xy() * self.yt()
                - self.zt() * operand.xyzt() * self.yz()
                - self.zt() * operand.xz() * self.zt()
                + self.zt() * operand.yt() * self.xy()
                + self.zt() * operand.yz() * self.xyzt()
                + self.zt() * operand.zt() * self.xz(),
            self.s() * operand.s() * self.xt()
                - self.s() * operand.xt() * self.s()
                - self.s() * operand.xy() * self.yt()
                - self.s() * operand.xyzt() * self.yz()
                - self.s() * operand.xz() * self.zt()
                + self.s() * operand.yt() * self.xy()
                + self.s() * operand.yz() * self.xyzt()
                + self.s() * operand.zt() * self.xz()
                - self.xt() * operand.s() * self.s()
                + self.xt() * operand.xt() * self.xt()
                - self.xt() * operand.xy() * self.xy()
                + self.xt() * operand.xyzt() * self.xyzt()
                - self.xt() * operand.xz() * self.xz()
                + self.xt() * operand.yt() * self.yt()
                - self.xt() * operand.yz() * self.yz()
                + self.xt() * operand.zt() * self.zt()
                - self.xy() * operand.s() * self.yt()
                + self.xy() * operand.xt() * self.xy()
                - self.xy() * operand.xy() * self.xt()
                - self.xy() * operand.xyzt() * self.xz()
                + self.xy() * operand.xz() * self.xyzt()
                + self.xy() * operand.yt() * self.s()
                + self.xy() * operand.yz() * self.zt()
                - self.xy() * operand.zt() * self.yz()
                - self.xyzt() * operand.s() * self.yz()
                + self.xyzt() * operand.xt() * self.xyzt()
                - self.xyzt() * operand.xy() * self.xz()
                - self.xyzt() * operand.xyzt() * self.xt()
                + self.xyzt() * operand.xz() * self.xy()
                + self.xyzt() * operand.yt() * self.zt()
                + self.xyzt() * operand.yz() * self.s()
                - self.xyzt() * operand.zt() * self.yt()
                - self.xz() * operand.s() * self.zt()
                + self.xz() * operand.xt() * self.xz()
                - self.xz() * operand.xy() * self.xyzt()
                + self.xz() * operand.xyzt() * self.xy()
                - self.xz() * operand.xz() * self.xt()
                + self.xz() * operand.yt() * self.yz()
                - self.xz() * operand.yz() * self.yt()
                + self.xz() * operand.zt() * self.s()
                + self.yt() * operand.s() * self.xy()
                - self.yt() * operand.xt() * self.yt()
                - self.yt() * operand.xy() * self.s()
                + self.yt() * operand.xyzt() * self.zt()
                + self.yt() * operand.xz() * self.yz()
                + self.yt() * operand.yt() * self.xt()
                - self.yt() * operand.yz() * self.xz()
                - self.yt() * operand.zt() * self.xyzt()
                + self.yz() * operand.s() * self.xyzt()
                - self.yz() * operand.xt() * self.yz()
                - self.yz() * operand.xy() * self.zt()
                + self.yz() * operand.xyzt() * self.s()
                + self.yz() * operand.xz() * self.yt()
                + self.yz() * operand.yt() * self.xz()
                - self.yz() * operand.yz() * self.xt()
                - self.yz() * operand.zt() * self.xy()
                + self.zt() * operand.s() * self.xz()
                - self.zt() * operand.xt() * self.zt()
                - self.zt() * operand.xy() * self.yz()
                - self.zt() * operand.xyzt() * self.yt()
                - self.zt() * operand.xz() * self.s()
                + self.zt() * operand.yt() * self.xyzt()
                + self.zt() * operand.yz() * self.xy()
                + self.zt() * operand.zt() * self.xt(),
            self.s() * operand.s() * self.yz() - self.s() * operand.xt() * self.xyzt()
                + self.s() * operand.xy() * self.xz()
                + self.s() * operand.xyzt() * self.xt()
                - self.s() * operand.xz() * self.xy()
                - self.s() * operand.yt() * self.zt()
                - self.s() * operand.yz() * self.s()
                + self.s() * operand.zt() * self.yt()
                - self.xt() * operand.s() * self.xyzt()
                + self.xt() * operand.xt() * self.yz()
                + self.xt() * operand.xy() * self.zt()
                - self.xt() * operand.xyzt() * self.s()
                - self.xt() * operand.xz() * self.yt()
                - self.xt() * operand.yt() * self.xz()
                + self.xt() * operand.yz() * self.xt()
                + self.xt() * operand.zt() * self.xy()
                + self.xy() * operand.s() * self.xz()
                - self.xy() * operand.xt() * self.zt()
                - self.xy() * operand.xy() * self.yz()
                - self.xy() * operand.xyzt() * self.yt()
                - self.xy() * operand.xz() * self.s()
                + self.xy() * operand.yt() * self.xyzt()
                + self.xy() * operand.yz() * self.xy()
                + self.xy() * operand.zt() * self.xt()
                + self.xyzt() * operand.s() * self.xt()
                - self.xyzt() * operand.xt() * self.s()
                - self.xyzt() * operand.xy() * self.yt()
                - self.xyzt() * operand.xyzt() * self.yz()
                - self.xyzt() * operand.xz() * self.zt()
                + self.xyzt() * operand.yt() * self.xy()
                + self.xyzt() * operand.yz() * self.xyzt()
                + self.xyzt() * operand.zt() * self.xz()
                - self.xz() * operand.s() * self.xy()
                + self.xz() * operand.xt() * self.yt()
                + self.xz() * operand.xy() * self.s()
                - self.xz() * operand.xyzt() * self.zt()
                - self.xz() * operand.xz() * self.yz()
                - self.xz() * operand.yt() * self.xt()
                + self.xz() * operand.yz() * self.xz()
                + self.xz() * operand.zt() * self.xyzt()
                - self.yt() * operand.s() * self.zt()
                + self.yt() * operand.xt() * self.xz()
                - self.yt() * operand.xy() * self.xyzt()
                + self.yt() * operand.xyzt() * self.xy()
                - self.yt() * operand.xz() * self.xt()
                + self.yt() * operand.yt() * self.yz()
                - self.yt() * operand.yz() * self.yt()
                + self.yt() * operand.zt() * self.s()
                - self.yz() * operand.s() * self.s()
                + self.yz() * operand.xt() * self.xt()
                - self.yz() * operand.xy() * self.xy()
                + self.yz() * operand.xyzt() * self.xyzt()
                - self.yz() * operand.xz() * self.xz()
                + self.yz() * operand.yt() * self.yt()
                - self.yz() * operand.yz() * self.yz()
                + self.yz() * operand.zt() * self.zt()
                + self.zt() * operand.s() * self.yt()
                - self.zt() * operand.xt() * self.xy()
                + self.zt() * operand.xy() * self.xt()
                + self.zt() * operand.xyzt() * self.xz()
                - self.zt() * operand.xz() * self.xyzt()
                - self.zt() * operand.yt() * self.s()
                - self.zt() * operand.yz() * self.zt()
                + self.zt() * operand.zt() * self.yz(),
            self.s() * operand.s() * self.yt() - self.s() * operand.xt() * self.xy()
                + self.s() * operand.xy() * self.xt()
                + self.s() * operand.xyzt() * self.xz()
                - self.s() * operand.xz() * self.xyzt()
                - self.s() * operand.yt() * self.s()
                - self.s() * operand.yz() * self.zt()
                + self.s() * operand.zt() * self.yz()
                - self.xt() * operand.s() * self.xy()
                + self.xt() * operand.xt() * self.yt()
                + self.xt() * operand.xy() * self.s()
                - self.xt() * operand.xyzt() * self.zt()
                - self.xt() * operand.xz() * self.yz()
                - self.xt() * operand.yt() * self.xt()
                + self.xt() * operand.yz() * self.xz()
                + self.xt() * operand.zt() * self.xyzt()
                + self.xy() * operand.s() * self.xt()
                - self.xy() * operand.xt() * self.s()
                - self.xy() * operand.xy() * self.yt()
                - self.xy() * operand.xyzt() * self.yz()
                - self.xy() * operand.xz() * self.zt()
                + self.xy() * operand.yt() * self.xy()
                + self.xy() * operand.yz() * self.xyzt()
                + self.xy() * operand.zt() * self.xz()
                + self.xyzt() * operand.s() * self.xz()
                - self.xyzt() * operand.xt() * self.zt()
                - self.xyzt() * operand.xy() * self.yz()
                - self.xyzt() * operand.xyzt() * self.yt()
                - self.xyzt() * operand.xz() * self.s()
                + self.xyzt() * operand.yt() * self.xyzt()
                + self.xyzt() * operand.yz() * self.xy()
                + self.xyzt() * operand.zt() * self.xt()
                - self.xz() * operand.s() * self.xyzt()
                + self.xz() * operand.xt() * self.yz()
                + self.xz() * operand.xy() * self.zt()
                - self.xz() * operand.xyzt() * self.s()
                - self.xz() * operand.xz() * self.yt()
                - self.xz() * operand.yt() * self.xz()
                + self.xz() * operand.yz() * self.xt()
                + self.xz() * operand.zt() * self.xy()
                - self.yt() * operand.s() * self.s()
                + self.yt() * operand.xt() * self.xt()
                - self.yt() * operand.xy() * self.xy()
                + self.yt() * operand.xyzt() * self.xyzt()
                - self.yt() * operand.xz() * self.xz()
                + self.yt() * operand.yt() * self.yt()
                - self.yt() * operand.yz() * self.yz()
                + self.yt() * operand.zt() * self.zt()
                - self.yz() * operand.s() * self.zt()
                + self.yz() * operand.xt() * self.xz()
                - self.yz() * operand.xy() * self.xyzt()
                + self.yz() * operand.xyzt() * self.xy()
                - self.yz() * operand.xz() * self.xt()
                + self.yz() * operand.yt() * self.yz()
                - self.yz() * operand.yz() * self.yt()
                + self.yz() * operand.zt() * self.s()
                + self.zt() * operand.s() * self.yz()
                - self.zt() * operand.xt() * self.xyzt()
                + self.zt() * operand.xy() * self.xz()
                + self.zt() * operand.xyzt() * self.xt()
                - self.zt() * operand.xz() * self.xy()
                - self.zt() * operand.yt() * self.zt()
                - self.zt() * operand.yz() * self.s()
                + self.zt() * operand.zt() * self.yt(),
            self.s() * operand.s() * self.zt() - self.s() * operand.xt() * self.xz()
                + self.s() * operand.xy() * self.xyzt()
                - self.s() * operand.xyzt() * self.xy()
                + self.s() * operand.xz() * self.xt()
                - self.s() * operand.yt() * self.yz()
                + self.s() * operand.yz() * self.yt()
                - self.s() * operand.zt() * self.s()
                - self.xt() * operand.s() * self.xz()
                + self.xt() * operand.xt() * self.zt()
                + self.xt() * operand.xy() * self.yz()
                + self.xt() * operand.xyzt() * self.yt()
                + self.xt() * operand.xz() * self.s()
                - self.xt() * operand.yt() * self.xyzt()
                - self.xt() * operand.yz() * self.xy()
                - self.xt() * operand.zt() * self.xt()
                + self.xy() * operand.s() * self.xyzt()
                - self.xy() * operand.xt() * self.yz()
                - self.xy() * operand.xy() * self.zt()
                + self.xy() * operand.xyzt() * self.s()
                + self.xy() * operand.xz() * self.yt()
                + self.xy() * operand.yt() * self.xz()
                - self.xy() * operand.yz() * self.xt()
                - self.xy() * operand.zt() * self.xy()
                - self.xyzt() * operand.s() * self.xy()
                + self.xyzt() * operand.xt() * self.yt()
                + self.xyzt() * operand.xy() * self.s()
                - self.xyzt() * operand.xyzt() * self.zt()
                - self.xyzt() * operand.xz() * self.yz()
                - self.xyzt() * operand.yt() * self.xt()
                + self.xyzt() * operand.yz() * self.xz()
                + self.xyzt() * operand.zt() * self.xyzt()
                + self.xz() * operand.s() * self.xt()
                - self.xz() * operand.xt() * self.s()
                - self.xz() * operand.xy() * self.yt()
                - self.xz() * operand.xyzt() * self.yz()
                - self.xz() * operand.xz() * self.zt()
                + self.xz() * operand.yt() * self.xy()
                + self.xz() * operand.yz() * self.xyzt()
                + self.xz() * operand.zt() * self.xz()
                - self.yt() * operand.s() * self.yz()
                + self.yt() * operand.xt() * self.xyzt()
                - self.yt() * operand.xy() * self.xz()
                - self.yt() * operand.xyzt() * self.xt()
                + self.yt() * operand.xz() * self.xy()
                + self.yt() * operand.yt() * self.zt()
                + self.yt() * operand.yz() * self.s()
                - self.yt() * operand.zt() * self.yt()
                + self.yz() * operand.s() * self.yt()
                - self.yz() * operand.xt() * self.xy()
                + self.yz() * operand.xy() * self.xt()
                + self.yz() * operand.xyzt() * self.xz()
                - self.yz() * operand.xz() * self.xyzt()
                - self.yz() * operand.yt() * self.s()
                - self.yz() * operand.yz() * self.zt()
                + self.yz() * operand.zt() * self.yz()
                - self.zt() * operand.s() * self.s()
                + self.zt() * operand.xt() * self.xt()
                - self.zt() * operand.xy() * self.xy()
                + self.zt() * operand.xyzt() * self.xyzt()
                - self.zt() * operand.xz() * self.xz()
                + self.zt() * operand.yt() * self.yt()
                - self.zt() * operand.yz() * self.yz()
                + self.zt() * operand.zt() * self.zt(),
            -(self.s() * operand.s() * self.xyzt())
                + self.s() * operand.xt() * self.yz()
                + self.s() * operand.xy() * self.zt()
                - self.s() * operand.xyzt() * self.s()
                - self.s() * operand.xz() * self.yt()
                - self.s() * operand.yt() * self.xz()
                + self.s() * operand.yz() * self.xt()
                + self.s() * operand.zt() * self.xy()
                + self.xt() * operand.s() * self.yz()
                - self.xt() * operand.xt() * self.xyzt()
                + self.xt() * operand.xy() * self.xz()
                + self.xt() * operand.xyzt() * self.xt()
                - self.xt() * operand.xz() * self.xy()
                - self.xt() * operand.yt() * self.zt()
                - self.xt() * operand.yz() * self.s()
                + self.xt() * operand.zt() * self.yt()
                + self.xy() * operand.s() * self.zt()
                - self.xy() * operand.xt() * self.xz()
                + self.xy() * operand.xy() * self.xyzt()
                - self.xy() * operand.xyzt() * self.xy()
                + self.xy() * operand.xz() * self.xt()
                - self.xy() * operand.yt() * self.yz()
                + self.xy() * operand.yz() * self.yt()
                - self.xy() * operand.zt() * self.s()
                - self.xyzt() * operand.s() * self.s()
                + self.xyzt() * operand.xt() * self.xt()
                - self.xyzt() * operand.xy() * self.xy()
                + self.xyzt() * operand.xyzt() * self.xyzt()
                - self.xyzt() * operand.xz() * self.xz()
                + self.xyzt() * operand.yt() * self.yt()
                - self.xyzt() * operand.yz() * self.yz()
                + self.xyzt() * operand.zt() * self.zt()
                - self.xz() * operand.s() * self.yt()
                + self.xz() * operand.xt() * self.xy()
                - self.xz() * operand.xy() * self.xt()
                - self.xz() * operand.xyzt() * self.xz()
                + self.xz() * operand.xz() * self.xyzt()
                + self.xz() * operand.yt() * self.s()
                + self.xz() * operand.yz() * self.zt()
                - self.xz() * operand.zt() * self.yz()
                - self.yt() * operand.s() * self.xz()
                + self.yt() * operand.xt() * self.zt()
                + self.yt() * operand.xy() * self.yz()
                + self.yt() * operand.xyzt() * self.yt()
                + self.yt() * operand.xz() * self.s()
                - self.yt() * operand.yt() * self.xyzt()
                - self.yt() * operand.yz() * self.xy()
                - self.yt() * operand.zt() * self.xt()
                + self.yz() * operand.s() * self.xt()
                - self.yz() * operand.xt() * self.s()
                - self.yz() * operand.xy() * self.yt()
                - self.yz() * operand.xyzt() * self.yz()
                - self.yz() * operand.xz() * self.zt()
                + self.yz() * operand.yt() * self.xy()
                + self.yz() * operand.yz() * self.xyzt()
                + self.yz() * operand.zt() * self.xz()
                + self.zt() * operand.s() * self.xy()
                - self.zt() * operand.xt() * self.yt()
                - self.zt() * operand.xy() * self.s()
                + self.zt() * operand.xyzt() * self.zt()
                + self.zt() * operand.xz() * self.yz()
                + self.zt() * operand.yt() * self.xt()
                - self.zt() * operand.yz() * self.xz()
                - self.zt() * operand.zt() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Unit<Eventor<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.s()),
            -(operand.xy())
                + -T::TWO * operand.xt() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.xt() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * operand.xy() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.yz() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.xt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.xy() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.xz() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.yt() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.yz() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::from_i8(-4i8) * operand.zt() * self.as_inner().xt() * self.as_inner().yz()
                + T::from_i8(4i8) * operand.zt() * self.as_inner().xz() * self.as_inner().yt(),
            -(operand.xz())
                + -T::TWO * operand.xt() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.xt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.xy() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.xy() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * operand.xz() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.yz() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.zt() * self.as_inner().xyzt() * self.as_inner().yz()
                + T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.xz() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.yz() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.yz() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.zt() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.zt() * self.as_inner().xz() * self.as_inner().zt()
                + T::from_i8(4i8) * operand.yt() * self.as_inner().xt() * self.as_inner().yz()
                + T::from_i8(4i8) * operand.yt() * self.as_inner().xy() * self.as_inner().zt(),
            -(operand.xt())
                + -T::TWO * operand.xt() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.xt() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.xy() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.xy() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.xy() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.xz() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.zt() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.xt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.xz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.yt() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.yt() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.yt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.zt() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().zt()
                + T::from_i8(-4i8) * operand.yz() * self.as_inner().xz() * self.as_inner().yt()
                + T::from_i8(4i8) * operand.yz() * self.as_inner().xy() * self.as_inner().zt(),
            -(operand.yz())
                + -T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.xy() * self.as_inner().xyzt() * self.as_inner().yt()
                + -T::TWO * operand.xz() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.xz() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.xz() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.yz() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.yz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.xy() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.xy() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.yz() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.zt() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().yz() * self.as_inner().zt()
                + T::from_i8(-4i8) * operand.xt() * self.as_inner().xy() * self.as_inner().zt()
                + T::from_i8(4i8) * operand.xt() * self.as_inner().xz() * self.as_inner().yt(),
            -(operand.yt())
                + -T::TWO * operand.xt() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.xt() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.xy() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.xy() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * operand.yt() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.yz() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.yz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.xt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.xy() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.xy() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.yt() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.yz() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.zt() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.zt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().yt() * self.as_inner().zt()
                + T::from_i8(-4i8) * operand.xz() * self.as_inner().xt() * self.as_inner().yz()
                + T::from_i8(-4i8) * operand.xz() * self.as_inner().xy() * self.as_inner().zt(),
            -(operand.zt())
                + -T::TWO * operand.xt() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.xt() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.xz() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.xz() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.yt() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.yt() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.yz() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.yz() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.zt() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * operand.zt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.xt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.xt() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.xz() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.xz() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.yt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.yt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.yz() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.yz() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.zt() * self.as_inner().yz() * self.as_inner().yz()
                + T::from_i8(-4i8) * operand.xy() * self.as_inner().xz() * self.as_inner().yt()
                + T::from_i8(4i8) * operand.xy() * self.as_inner().xt() * self.as_inner().yz(),
            -(operand.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.as_inner().s() * self.s() * self.s())
                + -(operand.as_inner().s() * self.xy() * self.xy())
                + -(operand.as_inner().s() * self.xz() * self.xz())
                + -(operand.as_inner().s() * self.yz() * self.yz())
                + operand.as_inner().s() * self.xt() * self.xt()
                + operand.as_inner().s() * self.xyzt() * self.xyzt()
                + operand.as_inner().s() * self.yt() * self.yt()
                + operand.as_inner().s() * self.zt() * self.zt(),
            -(operand.as_inner().xy() * self.s() * self.s())
                + -(operand.as_inner().xy() * self.xt() * self.xt())
                + -(operand.as_inner().xy() * self.xy() * self.xy())
                + -(operand.as_inner().xy() * self.yt() * self.yt())
                + -T::TWO * operand.as_inner().xt() * self.s() * self.yt()
                + -T::TWO * operand.as_inner().xt() * self.xyzt() * self.xz()
                + -T::TWO * operand.as_inner().xz() * self.xy() * self.xz()
                + -T::TWO * operand.as_inner().xz() * self.yt() * self.zt()
                + -T::TWO * operand.as_inner().yt() * self.xyzt() * self.yz()
                + -T::TWO * operand.as_inner().yt() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().yz() * self.s() * self.xz()
                + -T::TWO * operand.as_inner().yz() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().xt() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().xt() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().xz() * self.s() * self.yz()
                + T::TWO * operand.as_inner().xz() * self.xt() * self.xyzt()
                + T::TWO * operand.as_inner().yt() * self.s() * self.xt()
                + T::TWO * operand.as_inner().yt() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().yz() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.xyzt() * self.yt()
                + T::from_i8(-4i8) * operand.as_inner().zt() * self.xt() * self.yz()
                + T::from_i8(4i8) * operand.as_inner().zt() * self.xz() * self.yt()
                + operand.as_inner().xy() * self.xyzt() * self.xyzt()
                + operand.as_inner().xy() * self.xz() * self.xz()
                + operand.as_inner().xy() * self.yz() * self.yz()
                + operand.as_inner().xy() * self.zt() * self.zt(),
            -(operand.as_inner().xz() * self.s() * self.s())
                + -(operand.as_inner().xz() * self.xt() * self.xt())
                + -(operand.as_inner().xz() * self.xz() * self.xz())
                + -(operand.as_inner().xz() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xt() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().xt() * self.yt() * self.yz()
                + -T::TWO * operand.as_inner().xy() * self.s() * self.yz()
                + -T::TWO * operand.as_inner().xy() * self.xt() * self.xyzt()
                + -T::TWO * operand.as_inner().xy() * self.xy() * self.xz()
                + -T::TWO * operand.as_inner().xy() * self.yt() * self.zt()
                + -T::TWO * operand.as_inner().yz() * self.xt() * self.yt()
                + -T::TWO * operand.as_inner().yz() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().zt() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().zt() * self.xyzt() * self.yz()
                + T::TWO * operand.as_inner().xt() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().xt() * self.xy() * self.xyzt()
                + T::TWO * operand.as_inner().yz() * self.s() * self.xy()
                + T::TWO * operand.as_inner().yz() * self.xyzt() * self.zt()
                + T::TWO * operand.as_inner().zt() * self.s() * self.xt()
                + T::TWO * operand.as_inner().zt() * self.xz() * self.zt()
                + T::from_i8(4i8) * operand.as_inner().yt() * self.xt() * self.yz()
                + T::from_i8(4i8) * operand.as_inner().yt() * self.xy() * self.zt()
                + operand.as_inner().xz() * self.xy() * self.xy()
                + operand.as_inner().xz() * self.xyzt() * self.xyzt()
                + operand.as_inner().xz() * self.yt() * self.yt()
                + operand.as_inner().xz() * self.yz() * self.yz(),
            -(operand.as_inner().xt() * self.s() * self.s())
                + -(operand.as_inner().xt() * self.yt() * self.yt())
                + -(operand.as_inner().xt() * self.yz() * self.yz())
                + -(operand.as_inner().xt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xy() * self.s() * self.yt()
                + -T::TWO * operand.as_inner().xy() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().xy() * self.xyzt() * self.xz()
                + -T::TWO * operand.as_inner().xy() * self.yz() * self.zt()
                + -T::TWO * operand.as_inner().xz() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().xz() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().zt() * self.xy() * self.yz()
                + -T::TWO * operand.as_inner().zt() * self.xyzt() * self.yt()
                + T::TWO * operand.as_inner().xz() * self.xy() * self.xyzt()
                + T::TWO * operand.as_inner().xz() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().yt() * self.s() * self.xy()
                + T::TWO * operand.as_inner().yt() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().yt() * self.xyzt() * self.zt()
                + T::TWO * operand.as_inner().yt() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().zt() * self.s() * self.xz()
                + T::TWO * operand.as_inner().zt() * self.xt() * self.zt()
                + T::from_i8(-4i8) * operand.as_inner().yz() * self.xz() * self.yt()
                + T::from_i8(4i8) * operand.as_inner().yz() * self.xy() * self.zt()
                + operand.as_inner().xt() * self.xt() * self.xt()
                + operand.as_inner().xt() * self.xy() * self.xy()
                + operand.as_inner().xt() * self.xyzt() * self.xyzt()
                + operand.as_inner().xt() * self.xz() * self.xz(),
            -(operand.as_inner().yz() * self.s() * self.s())
                + -(operand.as_inner().yz() * self.yt() * self.yt())
                + -(operand.as_inner().yz() * self.yz() * self.yz())
                + -(operand.as_inner().yz() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xy() * self.xy() * self.yz()
                + -T::TWO * operand.as_inner().xy() * self.xyzt() * self.yt()
                + -T::TWO * operand.as_inner().xz() * self.s() * self.xy()
                + -T::TWO * operand.as_inner().xz() * self.xt() * self.yt()
                + -T::TWO * operand.as_inner().xz() * self.xyzt() * self.zt()
                + -T::TWO * operand.as_inner().xz() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().yt() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().yt() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().xy() * self.s() * self.xz()
                + T::TWO * operand.as_inner().xy() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().yt() * self.xy() * self.xyzt()
                + T::TWO * operand.as_inner().yt() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().zt() * self.s() * self.yt()
                + T::TWO * operand.as_inner().zt() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().zt() * self.xyzt() * self.xz()
                + T::TWO * operand.as_inner().zt() * self.yz() * self.zt()
                + T::from_i8(-4i8) * operand.as_inner().xt() * self.xy() * self.zt()
                + T::from_i8(4i8) * operand.as_inner().xt() * self.xz() * self.yt()
                + operand.as_inner().yz() * self.xt() * self.xt()
                + operand.as_inner().yz() * self.xy() * self.xy()
                + operand.as_inner().yz() * self.xyzt() * self.xyzt()
                + operand.as_inner().yz() * self.xz() * self.xz(),
            -(operand.as_inner().yt() * self.s() * self.s())
                + -(operand.as_inner().yt() * self.xt() * self.xt())
                + -(operand.as_inner().yt() * self.xz() * self.xz())
                + -(operand.as_inner().yt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xt() * self.s() * self.xy()
                + -T::TWO * operand.as_inner().xt() * self.xyzt() * self.zt()
                + -T::TWO * operand.as_inner().xy() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().xy() * self.xyzt() * self.yz()
                + -T::TWO * operand.as_inner().yz() * self.s() * self.zt()
                + -T::TWO * operand.as_inner().yz() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().xt() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().xt() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().xy() * self.s() * self.xt()
                + T::TWO * operand.as_inner().xy() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().yz() * self.xy() * self.xyzt()
                + T::TWO * operand.as_inner().zt() * self.s() * self.yz()
                + T::TWO * operand.as_inner().zt() * self.xt() * self.xyzt()
                + T::TWO * operand.as_inner().zt() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().zt() * self.yt() * self.zt()
                + T::from_i8(-4i8) * operand.as_inner().xz() * self.xt() * self.yz()
                + T::from_i8(-4i8) * operand.as_inner().xz() * self.xy() * self.zt()
                + operand.as_inner().yt() * self.xy() * self.xy()
                + operand.as_inner().yt() * self.xyzt() * self.xyzt()
                + operand.as_inner().yt() * self.yt() * self.yt()
                + operand.as_inner().yt() * self.yz() * self.yz(),
            -(operand.as_inner().zt() * self.s() * self.s())
                + -(operand.as_inner().zt() * self.xt() * self.xt())
                + -(operand.as_inner().zt() * self.xy() * self.xy())
                + -(operand.as_inner().zt() * self.yt() * self.yt())
                + -T::TWO * operand.as_inner().xt() * self.s() * self.xz()
                + -T::TWO * operand.as_inner().xt() * self.xy() * self.yz()
                + -T::TWO * operand.as_inner().xz() * self.xyzt() * self.yz()
                + -T::TWO * operand.as_inner().xz() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().yt() * self.s() * self.yz()
                + -T::TWO * operand.as_inner().yt() * self.xt() * self.xyzt()
                + -T::TWO * operand.as_inner().yz() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().yz() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().xt() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().xt() * self.xyzt() * self.yt()
                + T::TWO * operand.as_inner().xz() * self.s() * self.xt()
                + T::TWO * operand.as_inner().xz() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().yt() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().yt() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().yz() * self.s() * self.yt()
                + T::TWO * operand.as_inner().yz() * self.xyzt() * self.xz()
                + T::from_i8(-4i8) * operand.as_inner().xy() * self.xz() * self.yt()
                + T::from_i8(4i8) * operand.as_inner().xy() * self.xt() * self.yz()
                + operand.as_inner().zt() * self.xyzt() * self.xyzt()
                + operand.as_inner().zt() * self.xz() * self.xz()
                + operand.as_inner().zt() * self.yz() * self.yz()
                + operand.as_inner().zt() * self.zt() * self.zt(),
            -(operand.as_inner().xyzt() * self.s() * self.s())
                + -(operand.as_inner().xyzt() * self.xy() * self.xy())
                + -(operand.as_inner().xyzt() * self.xz() * self.xz())
                + -(operand.as_inner().xyzt() * self.yz() * self.yz())
                + operand.as_inner().xyzt() * self.xt() * self.xt()
                + operand.as_inner().xyzt() * self.xyzt() * self.xyzt()
                + operand.as_inner().xyzt() * self.yt() * self.yt()
                + operand.as_inner().xyzt() * self.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Unit<Eventor<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.as_inner().s()),
            -(operand.as_inner().xy())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::from_i8(-4i8)
                    * operand.as_inner().zt()
                    * self.as_inner().xt()
                    * self.as_inner().yz()
                + T::from_i8(4i8)
                    * operand.as_inner().zt()
                    * self.as_inner().xz()
                    * self.as_inner().yt(),
            -(operand.as_inner().xz())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xyzt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xz() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xz() * self.as_inner().zt()
                + T::from_i8(4i8)
                    * operand.as_inner().yt()
                    * self.as_inner().xt()
                    * self.as_inner().yz()
                + T::from_i8(4i8)
                    * operand.as_inner().yt()
                    * self.as_inner().xy()
                    * self.as_inner().zt(),
            -(operand.as_inner().xt())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yt() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().zt()
                + T::from_i8(-4i8)
                    * operand.as_inner().yz()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + T::from_i8(4i8)
                    * operand.as_inner().yz()
                    * self.as_inner().xy()
                    * self.as_inner().zt(),
            -(operand.as_inner().yz())
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xyzt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().yt() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().yz() * self.as_inner().zt()
                + T::from_i8(-4i8)
                    * operand.as_inner().xt()
                    * self.as_inner().xy()
                    * self.as_inner().zt()
                + T::from_i8(4i8)
                    * operand.as_inner().xt()
                    * self.as_inner().xz()
                    * self.as_inner().yt(),
            -(operand.as_inner().yt())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().zt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().s() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().xy()
                + T::TWO * operand.as_inner().yt() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().yt() * self.as_inner().zt()
                + T::from_i8(-4i8)
                    * operand.as_inner().xz()
                    * self.as_inner().xt()
                    * self.as_inner().yz()
                + T::from_i8(-4i8)
                    * operand.as_inner().xz()
                    * self.as_inner().xy()
                    * self.as_inner().zt(),
            -(operand.as_inner().zt())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xyzt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().yz() * self.as_inner().yz()
                + T::from_i8(-4i8)
                    * operand.as_inner().xy()
                    * self.as_inner().xz()
                    * self.as_inner().yt()
                + T::from_i8(4i8)
                    * operand.as_inner().xy()
                    * self.as_inner().xt()
                    * self.as_inner().yz(),
            -(operand.as_inner().xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Eventor<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(self.s() * operand.xyzt() * self.s()) + self.xt() * operand.xyzt() * self.xt()
                - self.xy() * operand.xyzt() * self.xy()
                + self.xyzt() * operand.xyzt() * self.xyzt()
                - self.xz() * operand.xyzt() * self.xz()
                + self.yt() * operand.xyzt() * self.yt()
                - self.yz() * operand.xyzt() * self.yz()
                + self.zt() * operand.xyzt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Unit<Eventor<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(operand.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Eventor<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(operand.as_inner().xyzt() * self.s() * self.s())
                + -(operand.as_inner().xyzt() * self.xy() * self.xy())
                + -(operand.as_inner().xyzt() * self.xz() * self.xz())
                + -(operand.as_inner().xyzt() * self.yz() * self.yz())
                + operand.as_inner().xyzt() * self.xt() * self.xt()
                + operand.as_inner().xyzt() * self.xyzt() * self.xyzt()
                + operand.as_inner().xyzt() * self.yt() * self.yt()
                + operand.as_inner().xyzt() * self.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Unit<Eventor<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(operand.as_inner().xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Eventor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.s() * operand.s() * self.s()) + self.xt() * operand.s() * self.xt()
                - self.xy() * operand.s() * self.xy()
                + self.xyzt() * operand.s() * self.xyzt()
                - self.xz() * operand.s() * self.xz()
                + self.yt() * operand.s() * self.yt()
                - self.yz() * operand.s() * self.yz()
                + self.zt() * operand.s() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unit<Eventor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Eventor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(operand.as_inner().s() * self.s() * self.s())
                + -(operand.as_inner().s() * self.xy() * self.xy())
                + -(operand.as_inner().s() * self.xz() * self.xz())
                + -(operand.as_inner().s() * self.yz() * self.yz())
                + operand.as_inner().s() * self.xt() * self.xt()
                + operand.as_inner().s() * self.xyzt() * self.xyzt()
                + operand.as_inner().s() * self.yt() * self.yt()
                + operand.as_inner().s() * self.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Unit<Eventor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Eventor<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            self.s() * operand.xyt() * self.zt() + self.s() * operand.xyz() * self.s()
                - self.s() * operand.xzt() * self.yt()
                + self.s() * operand.yzt() * self.xt()
                - self.xt() * operand.xyt() * self.xz()
                + self.xt() * operand.xyz() * self.xt()
                + self.xt() * operand.xzt() * self.xy()
                + self.xt() * operand.yzt() * self.s()
                + self.xy() * operand.xyt() * self.xyzt()
                + self.xy() * operand.xyz() * self.xy()
                + self.xy() * operand.xzt() * self.xt()
                + self.xy() * operand.yzt() * self.yt()
                + self.xyzt() * operand.xyt() * self.xy()
                + self.xyzt() * operand.xyz() * self.xyzt()
                + self.xyzt() * operand.xzt() * self.xz()
                + self.xyzt() * operand.yzt() * self.yz()
                - self.xz() * operand.xyt() * self.xt()
                + self.xz() * operand.xyz() * self.xz()
                + self.xz() * operand.xzt() * self.xyzt()
                + self.xz() * operand.yzt() * self.zt()
                - self.yt() * operand.xyt() * self.yz()
                + self.yt() * operand.xyz() * self.yt()
                - self.yt() * operand.xzt() * self.s()
                + self.yt() * operand.yzt() * self.xy()
                - self.yz() * operand.xyt() * self.yt()
                + self.yz() * operand.xyz() * self.yz()
                - self.yz() * operand.xzt() * self.zt()
                + self.yz() * operand.yzt() * self.xyzt()
                + self.zt() * operand.xyt() * self.s()
                + self.zt() * operand.xyz() * self.zt()
                - self.zt() * operand.xzt() * self.yz()
                + self.zt() * operand.yzt() * self.xz(),
            self.s() * operand.xyt() * self.s() + self.s() * operand.xyz() * self.zt()
                - self.s() * operand.xzt() * self.yz()
                + self.s() * operand.yzt() * self.xz()
                - self.xt() * operand.xyt() * self.xt()
                + self.xt() * operand.xyz() * self.xz()
                + self.xt() * operand.xzt() * self.xyzt()
                + self.xt() * operand.yzt() * self.zt()
                + self.xy() * operand.xyt() * self.xy()
                + self.xy() * operand.xyz() * self.xyzt()
                + self.xy() * operand.xzt() * self.xz()
                + self.xy() * operand.yzt() * self.yz()
                + self.xyzt() * operand.xyt() * self.xyzt()
                + self.xyzt() * operand.xyz() * self.xy()
                + self.xyzt() * operand.xzt() * self.xt()
                + self.xyzt() * operand.yzt() * self.yt()
                - self.xz() * operand.xyt() * self.xz()
                + self.xz() * operand.xyz() * self.xt()
                + self.xz() * operand.xzt() * self.xy()
                + self.xz() * operand.yzt() * self.s()
                - self.yt() * operand.xyt() * self.yt()
                + self.yt() * operand.xyz() * self.yz()
                - self.yt() * operand.xzt() * self.zt()
                + self.yt() * operand.yzt() * self.xyzt()
                - self.yz() * operand.xyt() * self.yz()
                + self.yz() * operand.xyz() * self.yt()
                - self.yz() * operand.xzt() * self.s()
                + self.yz() * operand.yzt() * self.xy()
                + self.zt() * operand.xyt() * self.zt()
                + self.zt() * operand.xyz() * self.s()
                - self.zt() * operand.xzt() * self.yt()
                + self.zt() * operand.yzt() * self.xt(),
            self.s() * operand.xyt() * self.yz() - self.s() * operand.xyz() * self.yt()
                + self.s() * operand.xzt() * self.s()
                - self.s() * operand.yzt() * self.xy()
                - self.xt() * operand.xyt() * self.xyzt()
                - self.xt() * operand.xyz() * self.xy()
                - self.xt() * operand.xzt() * self.xt()
                - self.xt() * operand.yzt() * self.yt()
                + self.xy() * operand.xyt() * self.xz()
                - self.xy() * operand.xyz() * self.xt()
                - self.xy() * operand.xzt() * self.xy()
                - self.xy() * operand.yzt() * self.s()
                - self.xyzt() * operand.xyt() * self.xt()
                + self.xyzt() * operand.xyz() * self.xz()
                + self.xyzt() * operand.xzt() * self.xyzt()
                + self.xyzt() * operand.yzt() * self.zt()
                + self.xz() * operand.xyt() * self.xy()
                + self.xz() * operand.xyz() * self.xyzt()
                + self.xz() * operand.xzt() * self.xz()
                + self.xz() * operand.yzt() * self.yz()
                - self.yt() * operand.xyt() * self.zt()
                - self.yt() * operand.xyz() * self.s()
                + self.yt() * operand.xzt() * self.yt()
                - self.yt() * operand.yzt() * self.xt()
                + self.yz() * operand.xyt() * self.s()
                + self.yz() * operand.xyz() * self.zt()
                - self.yz() * operand.xzt() * self.yz()
                + self.yz() * operand.yzt() * self.xz()
                - self.zt() * operand.xyt() * self.yt()
                + self.zt() * operand.xyz() * self.yz()
                - self.zt() * operand.xzt() * self.zt()
                + self.zt() * operand.yzt() * self.xyzt(),
            -(self.s() * operand.xyt() * self.xz())
                + self.s() * operand.xyz() * self.xt()
                + self.s() * operand.xzt() * self.xy()
                + self.s() * operand.yzt() * self.s()
                + self.xt() * operand.xyt() * self.zt()
                + self.xt() * operand.xyz() * self.s()
                - self.xt() * operand.xzt() * self.yt()
                + self.xt() * operand.yzt() * self.xt()
                + self.xy() * operand.xyt() * self.yz()
                - self.xy() * operand.xyz() * self.yt()
                + self.xy() * operand.xzt() * self.s()
                - self.xy() * operand.yzt() * self.xy()
                - self.xyzt() * operand.xyt() * self.yt()
                + self.xyzt() * operand.xyz() * self.yz()
                - self.xyzt() * operand.xzt() * self.zt()
                + self.xyzt() * operand.yzt() * self.xyzt()
                - self.xz() * operand.xyt() * self.s()
                - self.xz() * operand.xyz() * self.zt()
                + self.xz() * operand.xzt() * self.yz()
                - self.xz() * operand.yzt() * self.xz()
                - self.yt() * operand.xyt() * self.xyzt()
                - self.yt() * operand.xyz() * self.xy()
                - self.yt() * operand.xzt() * self.xt()
                - self.yt() * operand.yzt() * self.yt()
                + self.yz() * operand.xyt() * self.xy()
                + self.yz() * operand.xyz() * self.xyzt()
                + self.yz() * operand.xzt() * self.xz()
                + self.yz() * operand.yzt() * self.yz()
                + self.zt() * operand.xyt() * self.xt()
                - self.zt() * operand.xyz() * self.xz()
                - self.zt() * operand.xzt() * self.xyzt()
                - self.zt() * operand.yzt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Unit<Eventor<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.xyt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.xyt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.xzt() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.xzt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.xyt() * self.as_inner().s() * self.as_inner().zt()
                + T::TWO * operand.xyt() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.xyz() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.xyz() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.xyz() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.xyz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.xzt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.xzt() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.yzt() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.yzt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.yzt() * self.as_inner().xyzt() * self.as_inner().yz()
                + T::TWO * operand.yzt() * self.as_inner().xz() * self.as_inner().zt()
                + operand.xyz(),
            -T::TWO * operand.xyt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.xyt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.xzt() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.xzt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.xyt() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.xyt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.xyz() * self.as_inner().s() * self.as_inner().zt()
                + T::TWO * operand.xyz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.xyz() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.xyz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.xzt() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.xzt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.yzt() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.yzt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.yzt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.yzt() * self.as_inner().xyzt() * self.as_inner().yt()
                + operand.xyt(),
            -T::TWO * operand.xyt() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.xyt() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.xyz() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.xyz() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.xzt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.xzt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.yzt() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.yzt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.xyt() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.xyt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.xyz() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.xyz() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.xzt() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.xzt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.yzt() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.yzt() * self.as_inner().xz() * self.as_inner().yz()
                + operand.xzt(),
            -T::TWO * operand.xyt() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.xyt() * self.as_inner().xyzt() * self.as_inner().yt()
                + -T::TWO * operand.xyz() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.xyz() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.xzt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO * operand.xzt() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.yzt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.yzt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.xyt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.xyt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.xyz() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.xyz() * self.as_inner().xyzt() * self.as_inner().yz()
                + T::TWO * operand.xzt() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.xzt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.yzt() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.yzt() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + operand.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Trivector<T>>> for Eventor<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.as_inner().xyt() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().xyt() * self.yt() * self.yz()
                + -T::TWO * operand.as_inner().xzt() * self.s() * self.yt()
                + -T::TWO * operand.as_inner().xzt() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().xyt() * self.s() * self.zt()
                + T::TWO * operand.as_inner().xyt() * self.xy() * self.xyzt()
                + T::TWO * operand.as_inner().xzt() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().xzt() * self.xyzt() * self.xz()
                + T::TWO * operand.as_inner().yzt() * self.s() * self.xt()
                + T::TWO * operand.as_inner().yzt() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().yzt() * self.xyzt() * self.yz()
                + T::TWO * operand.as_inner().yzt() * self.xz() * self.zt()
                + operand.as_inner().xyz() * self.s() * self.s()
                + operand.as_inner().xyz() * self.xt() * self.xt()
                + operand.as_inner().xyz() * self.xy() * self.xy()
                + operand.as_inner().xyz() * self.xyzt() * self.xyzt()
                + operand.as_inner().xyz() * self.xz() * self.xz()
                + operand.as_inner().xyz() * self.yt() * self.yt()
                + operand.as_inner().xyz() * self.yz() * self.yz()
                + operand.as_inner().xyz() * self.zt() * self.zt(),
            -(operand.as_inner().xyt() * self.xt() * self.xt())
                + -(operand.as_inner().xyt() * self.xz() * self.xz())
                + -(operand.as_inner().xyt() * self.yt() * self.yt())
                + -(operand.as_inner().xyt() * self.yz() * self.yz())
                + -T::TWO * operand.as_inner().xzt() * self.s() * self.yz()
                + -T::TWO * operand.as_inner().xzt() * self.yt() * self.zt()
                + T::TWO * operand.as_inner().xyz() * self.s() * self.zt()
                + T::TWO * operand.as_inner().xyz() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().xyz() * self.xy() * self.xyzt()
                + T::TWO * operand.as_inner().xyz() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().xzt() * self.xt() * self.xyzt()
                + T::TWO * operand.as_inner().xzt() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().yzt() * self.s() * self.xz()
                + T::TWO * operand.as_inner().yzt() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().yzt() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().yzt() * self.xyzt() * self.yt()
                + operand.as_inner().xyt() * self.s() * self.s()
                + operand.as_inner().xyt() * self.xy() * self.xy()
                + operand.as_inner().xyt() * self.xyzt() * self.xyzt()
                + operand.as_inner().xyt() * self.zt() * self.zt(),
            -(operand.as_inner().xzt() * self.xt() * self.xt())
                + -(operand.as_inner().xzt() * self.xy() * self.xy())
                + -(operand.as_inner().xzt() * self.yz() * self.yz())
                + -(operand.as_inner().xzt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xyt() * self.xt() * self.xyzt()
                + -T::TWO * operand.as_inner().xyt() * self.yt() * self.zt()
                + -T::TWO * operand.as_inner().xyz() * self.s() * self.yt()
                + -T::TWO * operand.as_inner().xyz() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().yzt() * self.s() * self.xy()
                + -T::TWO * operand.as_inner().yzt() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().xyt() * self.s() * self.yz()
                + T::TWO * operand.as_inner().xyt() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().xyz() * self.xyzt() * self.xz()
                + T::TWO * operand.as_inner().xyz() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().yzt() * self.xyzt() * self.zt()
                + T::TWO * operand.as_inner().yzt() * self.xz() * self.yz()
                + operand.as_inner().xzt() * self.s() * self.s()
                + operand.as_inner().xzt() * self.xyzt() * self.xyzt()
                + operand.as_inner().xzt() * self.xz() * self.xz()
                + operand.as_inner().xzt() * self.yt() * self.yt(),
            -(operand.as_inner().yzt() * self.xy() * self.xy())
                + -(operand.as_inner().yzt() * self.xz() * self.xz())
                + -(operand.as_inner().yzt() * self.yt() * self.yt())
                + -(operand.as_inner().yzt() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().xyt() * self.s() * self.xz()
                + -T::TWO * operand.as_inner().xyt() * self.xyzt() * self.yt()
                + -T::TWO * operand.as_inner().xyz() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().xyz() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().xzt() * self.xt() * self.yt()
                + -T::TWO * operand.as_inner().xzt() * self.xyzt() * self.zt()
                + T::TWO * operand.as_inner().xyt() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().xyt() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().xyz() * self.s() * self.xt()
                + T::TWO * operand.as_inner().xyz() * self.xyzt() * self.yz()
                + T::TWO * operand.as_inner().xzt() * self.s() * self.xy()
                + T::TWO * operand.as_inner().xzt() * self.xz() * self.yz()
                + operand.as_inner().yzt() * self.s() * self.s()
                + operand.as_inner().yzt() * self.xt() * self.xt()
                + operand.as_inner().yzt() * self.xyzt() * self.xyzt()
                + operand.as_inner().yzt() * self.yz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Trivector<T>>> for Unit<Eventor<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.as_inner().xyt() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xyt() * self.as_inner().yt() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().s() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO
                    * operand.as_inner().xyz()
                    * self.as_inner().xyzt()
                    * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xyzt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xz() * self.as_inner().zt()
                + operand.as_inner().xyz(),
            -T::TWO * operand.as_inner().xyt() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().xyt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO
                    * operand.as_inner().xyt()
                    * self.as_inner().xyzt()
                    * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().s() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xyzt() * self.as_inner().yt()
                + operand.as_inner().xyt(),
            -T::TWO * operand.as_inner().xyt() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.as_inner().xyt() * self.as_inner().yt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xyz() * self.as_inner().s() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xyz() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xyzt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO
                    * operand.as_inner().xzt()
                    * self.as_inner().xyzt()
                    * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xz() * self.as_inner().yz()
                + operand.as_inner().xzt(),
            -T::TWO * operand.as_inner().xyt() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO
                    * operand.as_inner().xyt()
                    * self.as_inner().xyzt()
                    * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xyz() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().xyz() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().xt() * self.as_inner().yt()
                + -T::TWO
                    * operand.as_inner().xzt()
                    * self.as_inner().xyzt()
                    * self.as_inner().zt()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xyzt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO
                    * operand.as_inner().yzt()
                    * self.as_inner().xyzt()
                    * self.as_inner().xyzt()
                + operand.as_inner().yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Eventor<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            self.s() * operand.t() * self.xt() + self.s() * operand.x() * self.s()
                - self.s() * operand.y() * self.xy()
                - self.s() * operand.z() * self.xz()
                + self.xt() * operand.t() * self.s()
                + self.xt() * operand.x() * self.xt()
                + self.xt() * operand.y() * self.yt()
                + self.xt() * operand.z() * self.zt()
                - self.xy() * operand.t() * self.yt()
                - self.xy() * operand.x() * self.xy()
                - self.xy() * operand.y() * self.s()
                + self.xy() * operand.z() * self.yz()
                + self.xyzt() * operand.t() * self.yz()
                + self.xyzt() * operand.x() * self.xyzt()
                + self.xyzt() * operand.y() * self.zt()
                - self.xyzt() * operand.z() * self.yt()
                - self.xz() * operand.t() * self.zt()
                - self.xz() * operand.x() * self.xz()
                - self.xz() * operand.y() * self.yz()
                - self.xz() * operand.z() * self.s()
                - self.yt() * operand.t() * self.xy()
                - self.yt() * operand.x() * self.yt()
                + self.yt() * operand.y() * self.xt()
                - self.yt() * operand.z() * self.xyzt()
                + self.yz() * operand.t() * self.xyzt()
                + self.yz() * operand.x() * self.yz()
                - self.yz() * operand.y() * self.xz()
                + self.yz() * operand.z() * self.xy()
                - self.zt() * operand.t() * self.xz()
                - self.zt() * operand.x() * self.zt()
                + self.zt() * operand.y() * self.xyzt()
                + self.zt() * operand.z() * self.xt(),
            self.s() * operand.t() * self.yt()
                + self.s() * operand.x() * self.xy()
                + self.s() * operand.y() * self.s()
                - self.s() * operand.z() * self.yz()
                + self.xt() * operand.t() * self.xy()
                + self.xt() * operand.x() * self.yt()
                - self.xt() * operand.y() * self.xt()
                + self.xt() * operand.z() * self.xyzt()
                + self.xy() * operand.t() * self.xt()
                + self.xy() * operand.x() * self.s()
                - self.xy() * operand.y() * self.xy()
                - self.xy() * operand.z() * self.xz()
                - self.xyzt() * operand.t() * self.xz()
                - self.xyzt() * operand.x() * self.zt()
                + self.xyzt() * operand.y() * self.xyzt()
                + self.xyzt() * operand.z() * self.xt()
                - self.xz() * operand.t() * self.xyzt()
                - self.xz() * operand.x() * self.yz()
                + self.xz() * operand.y() * self.xz()
                - self.xz() * operand.z() * self.xy()
                + self.yt() * operand.t() * self.s()
                + self.yt() * operand.x() * self.xt()
                + self.yt() * operand.y() * self.yt()
                + self.yt() * operand.z() * self.zt()
                - self.yz() * operand.t() * self.zt()
                - self.yz() * operand.x() * self.xz()
                - self.yz() * operand.y() * self.yz()
                - self.yz() * operand.z() * self.s()
                - self.zt() * operand.t() * self.yz()
                - self.zt() * operand.x() * self.xyzt()
                - self.zt() * operand.y() * self.zt()
                + self.zt() * operand.z() * self.yt(),
            self.s() * operand.t() * self.zt()
                + self.s() * operand.x() * self.xz()
                + self.s() * operand.y() * self.yz()
                + self.s() * operand.z() * self.s()
                + self.xt() * operand.t() * self.xz()
                + self.xt() * operand.x() * self.zt()
                - self.xt() * operand.y() * self.xyzt()
                - self.xt() * operand.z() * self.xt()
                + self.xy() * operand.t() * self.xyzt()
                + self.xy() * operand.x() * self.yz()
                - self.xy() * operand.y() * self.xz()
                + self.xy() * operand.z() * self.xy()
                + self.xyzt() * operand.t() * self.xy()
                + self.xyzt() * operand.x() * self.yt()
                - self.xyzt() * operand.y() * self.xt()
                + self.xyzt() * operand.z() * self.xyzt()
                + self.xz() * operand.t() * self.xt()
                + self.xz() * operand.x() * self.s()
                - self.xz() * operand.y() * self.xy()
                - self.xz() * operand.z() * self.xz()
                + self.yt() * operand.t() * self.yz()
                + self.yt() * operand.x() * self.xyzt()
                + self.yt() * operand.y() * self.zt()
                - self.yt() * operand.z() * self.yt()
                + self.yz() * operand.t() * self.yt()
                + self.yz() * operand.x() * self.xy()
                + self.yz() * operand.y() * self.s()
                - self.yz() * operand.z() * self.yz()
                + self.zt() * operand.t() * self.s()
                + self.zt() * operand.x() * self.xt()
                + self.zt() * operand.y() * self.yt()
                + self.zt() * operand.z() * self.zt(),
            self.s() * operand.t() * self.s()
                + self.s() * operand.x() * self.xt()
                + self.s() * operand.y() * self.yt()
                + self.s() * operand.z() * self.zt()
                + self.xt() * operand.t() * self.xt()
                + self.xt() * operand.x() * self.s()
                - self.xt() * operand.y() * self.xy()
                - self.xt() * operand.z() * self.xz()
                + self.xy() * operand.t() * self.xy()
                + self.xy() * operand.x() * self.yt()
                - self.xy() * operand.y() * self.xt()
                + self.xy() * operand.z() * self.xyzt()
                + self.xyzt() * operand.t() * self.xyzt()
                + self.xyzt() * operand.x() * self.yz()
                - self.xyzt() * operand.y() * self.xz()
                + self.xyzt() * operand.z() * self.xy()
                + self.xz() * operand.t() * self.xz()
                + self.xz() * operand.x() * self.zt()
                - self.xz() * operand.y() * self.xyzt()
                - self.xz() * operand.z() * self.xt()
                + self.yt() * operand.t() * self.yt()
                + self.yt() * operand.x() * self.xy()
                + self.yt() * operand.y() * self.s()
                - self.yt() * operand.z() * self.yz()
                + self.yz() * operand.t() * self.yz()
                + self.yz() * operand.x() * self.xyzt()
                + self.yz() * operand.y() * self.zt()
                - self.yz() * operand.z() * self.yt()
                + self.zt() * operand.t() * self.zt()
                + self.zt() * operand.x() * self.xz()
                + self.zt() * operand.y() * self.yz()
                + self.zt() * operand.z() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Unit<Eventor<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -T::TWO * operand.t() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.t() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.x() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.x() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.y() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.y() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.z() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.z() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.t() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.t() * self.as_inner().xyzt() * self.as_inner().yz()
                + T::TWO * operand.x() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.x() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.y() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.y() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.z() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.z() * self.as_inner().xy() * self.as_inner().yz()
                + operand.x(),
            -T::TWO * operand.t() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.t() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.x() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.x() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.y() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.y() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.z() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.z() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.t() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.t() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.x() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.x() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.y() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.y() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.z() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.z() * self.as_inner().yt() * self.as_inner().zt()
                + operand.y(),
            -T::TWO * operand.y() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.y() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.z() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.z() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.t() * self.as_inner().s() * self.as_inner().zt()
                + T::TWO * operand.t() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.t() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.t() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.x() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.x() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.x() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.x() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.y() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.y() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.z() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.z() * self.as_inner().zt() * self.as_inner().zt()
                + operand.z(),
            -T::TWO * operand.y() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.y() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.z() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.z() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.t() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.t() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.t() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.t() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.x() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.x() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.x() * self.as_inner().xyzt() * self.as_inner().yz()
                + T::TWO * operand.x() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.y() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.y() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.z() * self.as_inner().s() * self.as_inner().zt()
                + T::TWO * operand.z() * self.as_inner().xy() * self.as_inner().xyzt()
                + operand.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Eventor<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.as_inner().x() * self.xy() * self.xy())
                + -(operand.as_inner().x() * self.xz() * self.xz())
                + -(operand.as_inner().x() * self.yt() * self.yt())
                + -(operand.as_inner().x() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().t() * self.xy() * self.yt()
                + -T::TWO * operand.as_inner().t() * self.xz() * self.zt()
                + -T::TWO * operand.as_inner().y() * self.s() * self.xy()
                + -T::TWO * operand.as_inner().y() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().z() * self.s() * self.xz()
                + -T::TWO * operand.as_inner().z() * self.xyzt() * self.yt()
                + T::TWO * operand.as_inner().t() * self.s() * self.xt()
                + T::TWO * operand.as_inner().t() * self.xyzt() * self.yz()
                + T::TWO * operand.as_inner().y() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().y() * self.xyzt() * self.zt()
                + T::TWO * operand.as_inner().z() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().z() * self.xy() * self.yz()
                + operand.as_inner().x() * self.s() * self.s()
                + operand.as_inner().x() * self.xt() * self.xt()
                + operand.as_inner().x() * self.xyzt() * self.xyzt()
                + operand.as_inner().x() * self.yz() * self.yz(),
            -(operand.as_inner().y() * self.xt() * self.xt())
                + -(operand.as_inner().y() * self.xy() * self.xy())
                + -(operand.as_inner().y() * self.yz() * self.yz())
                + -(operand.as_inner().y() * self.zt() * self.zt())
                + -T::TWO * operand.as_inner().t() * self.xyzt() * self.xz()
                + -T::TWO * operand.as_inner().t() * self.yz() * self.zt()
                + -T::TWO * operand.as_inner().x() * self.xyzt() * self.zt()
                + -T::TWO * operand.as_inner().x() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().z() * self.s() * self.yz()
                + -T::TWO * operand.as_inner().z() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().t() * self.s() * self.yt()
                + T::TWO * operand.as_inner().t() * self.xt() * self.xy()
                + T::TWO * operand.as_inner().x() * self.s() * self.xy()
                + T::TWO * operand.as_inner().x() * self.xt() * self.yt()
                + T::TWO * operand.as_inner().z() * self.xt() * self.xyzt()
                + T::TWO * operand.as_inner().z() * self.yt() * self.zt()
                + operand.as_inner().y() * self.s() * self.s()
                + operand.as_inner().y() * self.xyzt() * self.xyzt()
                + operand.as_inner().y() * self.xz() * self.xz()
                + operand.as_inner().y() * self.yt() * self.yt(),
            -(operand.as_inner().z() * self.xt() * self.xt())
                + -(operand.as_inner().z() * self.xz() * self.xz())
                + -(operand.as_inner().z() * self.yt() * self.yt())
                + -(operand.as_inner().z() * self.yz() * self.yz())
                + -T::TWO * operand.as_inner().y() * self.xt() * self.xyzt()
                + -T::TWO * operand.as_inner().y() * self.xy() * self.xz()
                + T::TWO * operand.as_inner().t() * self.s() * self.zt()
                + T::TWO * operand.as_inner().t() * self.xt() * self.xz()
                + T::TWO * operand.as_inner().t() * self.xy() * self.xyzt()
                + T::TWO * operand.as_inner().t() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().x() * self.s() * self.xz()
                + T::TWO * operand.as_inner().x() * self.xt() * self.zt()
                + T::TWO * operand.as_inner().x() * self.xy() * self.yz()
                + T::TWO * operand.as_inner().x() * self.xyzt() * self.yt()
                + T::TWO * operand.as_inner().y() * self.s() * self.yz()
                + T::TWO * operand.as_inner().y() * self.yt() * self.zt()
                + operand.as_inner().z() * self.s() * self.s()
                + operand.as_inner().z() * self.xy() * self.xy()
                + operand.as_inner().z() * self.xyzt() * self.xyzt()
                + operand.as_inner().z() * self.zt() * self.zt(),
            -T::TWO * operand.as_inner().y() * self.xt() * self.xy()
                + -T::TWO * operand.as_inner().y() * self.xyzt() * self.xz()
                + -T::TWO * operand.as_inner().z() * self.xt() * self.xz()
                + -T::TWO * operand.as_inner().z() * self.yt() * self.yz()
                + T::TWO * operand.as_inner().x() * self.s() * self.xt()
                + T::TWO * operand.as_inner().x() * self.xy() * self.yt()
                + T::TWO * operand.as_inner().x() * self.xyzt() * self.yz()
                + T::TWO * operand.as_inner().x() * self.xz() * self.zt()
                + T::TWO * operand.as_inner().y() * self.s() * self.yt()
                + T::TWO * operand.as_inner().y() * self.yz() * self.zt()
                + T::TWO * operand.as_inner().z() * self.s() * self.zt()
                + T::TWO * operand.as_inner().z() * self.xy() * self.xyzt()
                + operand.as_inner().t() * self.s() * self.s()
                + operand.as_inner().t() * self.xt() * self.xt()
                + operand.as_inner().t() * self.xy() * self.xy()
                + operand.as_inner().t() * self.xyzt() * self.xyzt()
                + operand.as_inner().t() * self.xz() * self.xz()
                + operand.as_inner().t() * self.yt() * self.yt()
                + operand.as_inner().t() * self.yz() * self.yz()
                + operand.as_inner().t() * self.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Unit<Eventor<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -T::TWO * operand.as_inner().t() * self.as_inner().xy() * self.as_inner().yt()
                + -T::TWO * operand.as_inner().t() * self.as_inner().xz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().x() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().x() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().s() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().s() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().t() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().t() * self.as_inner().xyzt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().x() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.as_inner().x() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().y() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().y() * self.as_inner().xyzt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().z() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().z() * self.as_inner().xy() * self.as_inner().yz()
                + operand.as_inner().x(),
            -T::TWO * operand.as_inner().t() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().t() * self.as_inner().yz() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().x() * self.as_inner().xyzt() * self.as_inner().zt()
                + -T::TWO * operand.as_inner().x() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().y() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().s() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xy() * self.as_inner().xz()
                + T::TWO * operand.as_inner().t() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.as_inner().t() * self.as_inner().xt() * self.as_inner().xy()
                + T::TWO * operand.as_inner().x() * self.as_inner().s() * self.as_inner().xy()
                + T::TWO * operand.as_inner().x() * self.as_inner().xt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().y() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().y() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().z() * self.as_inner().xt() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().z() * self.as_inner().yt() * self.as_inner().zt()
                + operand.as_inner().y(),
            -T::TWO * operand.as_inner().y() * self.as_inner().xt() * self.as_inner().xyzt()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xy() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().t() * self.as_inner().s() * self.as_inner().zt()
                + T::TWO * operand.as_inner().t() * self.as_inner().xt() * self.as_inner().xz()
                + T::TWO * operand.as_inner().t() * self.as_inner().xy() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().t() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().x() * self.as_inner().s() * self.as_inner().xz()
                + T::TWO * operand.as_inner().x() * self.as_inner().xt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().x() * self.as_inner().xy() * self.as_inner().yz()
                + T::TWO * operand.as_inner().x() * self.as_inner().xyzt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().y() * self.as_inner().s() * self.as_inner().yz()
                + T::TWO * operand.as_inner().y() * self.as_inner().yt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().z() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().z() * self.as_inner().zt() * self.as_inner().zt()
                + operand.as_inner().z(),
            -T::TWO * operand.as_inner().y() * self.as_inner().xt() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xyzt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xt() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().yt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().t() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * operand.as_inner().t() * self.as_inner().xyzt() * self.as_inner().xyzt()
                + T::TWO * operand.as_inner().t() * self.as_inner().yt() * self.as_inner().yt()
                + T::TWO * operand.as_inner().t() * self.as_inner().zt() * self.as_inner().zt()
                + T::TWO * operand.as_inner().x() * self.as_inner().s() * self.as_inner().xt()
                + T::TWO * operand.as_inner().x() * self.as_inner().xy() * self.as_inner().yt()
                + T::TWO * operand.as_inner().x() * self.as_inner().xyzt() * self.as_inner().yz()
                + T::TWO * operand.as_inner().x() * self.as_inner().xz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().y() * self.as_inner().s() * self.as_inner().yt()
                + T::TWO * operand.as_inner().y() * self.as_inner().yz() * self.as_inner().zt()
                + T::TWO * operand.as_inner().z() * self.as_inner().s() * self.as_inner().zt()
                + T::TWO * operand.as_inner().z() * self.as_inner().xy() * self.as_inner().xyzt()
                + operand.as_inner().t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Pseudoscalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.xyzt() * operand.xy() * self.xyzt(),
            self.xyzt() * operand.xz() * self.xyzt(),
            self.xyzt() * operand.xt() * self.xyzt(),
            self.xyzt() * operand.yz() * self.xyzt(),
            self.xyzt() * operand.yt() * self.xyzt(),
            self.xyzt() * operand.zt() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.xy()),
            -(operand.xz()),
            -(operand.xt()),
            -(operand.yz()),
            -(operand.yt()),
            -(operand.zt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Pseudoscalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            operand.as_inner().xy() * self.xyzt() * self.xyzt(),
            operand.as_inner().xz() * self.xyzt() * self.xyzt(),
            operand.as_inner().xt() * self.xyzt() * self.xyzt(),
            operand.as_inner().yz() * self.xyzt() * self.xyzt(),
            operand.as_inner().yt() * self.xyzt() * self.xyzt(),
            operand.as_inner().zt() * self.xyzt() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.as_inner().xy()),
            -(operand.as_inner().xz()),
            -(operand.as_inner().xt()),
            -(operand.as_inner().yz()),
            -(operand.as_inner().yt()),
            -(operand.as_inner().zt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Pseudoscalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            self.xyzt() * operand.s() * self.xyzt(),
            self.xyzt() * operand.xy() * self.xyzt(),
            self.xyzt() * operand.xz() * self.xyzt(),
            self.xyzt() * operand.xt() * self.xyzt(),
            self.xyzt() * operand.yz() * self.xyzt(),
            self.xyzt() * operand.yt() * self.xyzt(),
            self.xyzt() * operand.zt() * self.xyzt(),
            self.xyzt() * operand.xyzt() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Unit<Pseudoscalar<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.s()),
            -(operand.xy()),
            -(operand.xz()),
            -(operand.xt()),
            -(operand.yz()),
            -(operand.yt()),
            -(operand.zt()),
            -(operand.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Pseudoscalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            operand.as_inner().s() * self.xyzt() * self.xyzt(),
            operand.as_inner().xy() * self.xyzt() * self.xyzt(),
            operand.as_inner().xz() * self.xyzt() * self.xyzt(),
            operand.as_inner().xt() * self.xyzt() * self.xyzt(),
            operand.as_inner().yz() * self.xyzt() * self.xyzt(),
            operand.as_inner().yt() * self.xyzt() * self.xyzt(),
            operand.as_inner().zt() * self.xyzt() * self.xyzt(),
            operand.as_inner().xyzt() * self.xyzt() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.as_inner().s()),
            -(operand.as_inner().xy()),
            -(operand.as_inner().xz()),
            -(operand.as_inner().xt()),
            -(operand.as_inner().yz()),
            -(operand.as_inner().yt()),
            -(operand.as_inner().zt()),
            -(operand.as_inner().xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.xyzt() * operand.xyzt() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(operand.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.as_inner().xyzt() * self.xyzt() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(operand.as_inner().xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.xyzt() * operand.s() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s() * self.xyzt() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Pseudoscalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            self.xyzt() * operand.xyz() * self.xyzt(),
            self.xyzt() * operand.xyt() * self.xyzt(),
            self.xyzt() * operand.xzt() * self.xyzt(),
            self.xyzt() * operand.yzt() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(operand.xyz()),
            -(operand.xyt()),
            -(operand.xzt()),
            -(operand.yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Trivector<T>>> for Pseudoscalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            operand.as_inner().xyz() * self.xyzt() * self.xyzt(),
            operand.as_inner().xyt() * self.xyzt() * self.xyzt(),
            operand.as_inner().xzt() * self.xyzt() * self.xyzt(),
            operand.as_inner().yzt() * self.xyzt() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Trivector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(operand.as_inner().xyz()),
            -(operand.as_inner().xyt()),
            -(operand.as_inner().xzt()),
            -(operand.as_inner().yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Pseudoscalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            self.xyzt() * operand.x() * self.xyzt(),
            self.xyzt() * operand.y() * self.xyzt(),
            self.xyzt() * operand.z() * self.xyzt(),
            self.xyzt() * operand.t() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.x()),
            -(operand.y()),
            -(operand.z()),
            -(operand.t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Pseudoscalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            operand.as_inner().x() * self.xyzt() * self.xyzt(),
            operand.as_inner().y() * self.xyzt() * self.xyzt(),
            operand.as_inner().z() * self.xyzt() * self.xyzt(),
            operand.as_inner().t() * self.xyzt() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.as_inner().x()),
            -(operand.as_inner().y()),
            -(operand.as_inner().z()),
            -(operand.as_inner().t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(self.s() * operand.xy() * self.s()),
            -(self.s() * operand.xz() * self.s()),
            -(self.s() * operand.xt() * self.s()),
            -(self.s() * operand.yz() * self.s()),
            -(self.s() * operand.yt() * self.s()),
            -(self.s() * operand.zt() * self.s()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.xy()),
            -(operand.xz()),
            -(operand.xt()),
            -(operand.yz()),
            -(operand.yt()),
            -(operand.zt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.as_inner().xy() * self.s() * self.s()),
            -(operand.as_inner().xz() * self.s() * self.s()),
            -(operand.as_inner().xt() * self.s() * self.s()),
            -(operand.as_inner().yz() * self.s() * self.s()),
            -(operand.as_inner().yt() * self.s() * self.s()),
            -(operand.as_inner().zt() * self.s() * self.s()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.as_inner().xy()),
            -(operand.as_inner().xz()),
            -(operand.as_inner().xt()),
            -(operand.as_inner().yz()),
            -(operand.as_inner().yt()),
            -(operand.as_inner().zt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(self.s() * operand.s() * self.s()),
            -(self.s() * operand.xy() * self.s()),
            -(self.s() * operand.xz() * self.s()),
            -(self.s() * operand.xt() * self.s()),
            -(self.s() * operand.yz() * self.s()),
            -(self.s() * operand.yt() * self.s()),
            -(self.s() * operand.zt() * self.s()),
            -(self.s() * operand.xyzt() * self.s()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Unit<Scalar<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.s()),
            -(operand.xy()),
            -(operand.xz()),
            -(operand.xt()),
            -(operand.yz()),
            -(operand.yt()),
            -(operand.zt()),
            -(operand.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.as_inner().s() * self.s() * self.s()),
            -(operand.as_inner().xy() * self.s() * self.s()),
            -(operand.as_inner().xz() * self.s() * self.s()),
            -(operand.as_inner().xt() * self.s() * self.s()),
            -(operand.as_inner().yz() * self.s() * self.s()),
            -(operand.as_inner().yt() * self.s() * self.s()),
            -(operand.as_inner().zt() * self.s() * self.s()),
            -(operand.as_inner().xyzt() * self.s() * self.s()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Unit<Scalar<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.as_inner().s()),
            -(operand.as_inner().xy()),
            -(operand.as_inner().xz()),
            -(operand.as_inner().xt()),
            -(operand.as_inner().yz()),
            -(operand.as_inner().yt()),
            -(operand.as_inner().zt()),
            -(operand.as_inner().xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(self.s() * operand.xyzt() * self.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(operand.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(operand.as_inner().xyzt() * self.s() * self.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(operand.as_inner().xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.s() * operand.s() * self.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.as_inner().s() * self.s() * self.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            self.s() * operand.xyz() * self.s(),
            self.s() * operand.xyt() * self.s(),
            self.s() * operand.xzt() * self.s(),
            self.s() * operand.yzt() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Unit<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(operand.xyz(), operand.xyt(), operand.xzt(), operand.yzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Trivector<T>>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            operand.as_inner().xyz() * self.s() * self.s(),
            operand.as_inner().xyt() * self.s() * self.s(),
            operand.as_inner().xzt() * self.s() * self.s(),
            operand.as_inner().yzt() * self.s() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Trivector<T>>> for Unit<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            operand.as_inner().xyz(),
            operand.as_inner().xyt(),
            operand.as_inner().xzt(),
            operand.as_inner().yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            self.s() * operand.x() * self.s(),
            self.s() * operand.y() * self.s(),
            self.s() * operand.z() * self.s(),
            self.s() * operand.t() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(operand.x(), operand.y(), operand.z(), operand.t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            operand.as_inner().x() * self.s() * self.s(),
            operand.as_inner().y() * self.s() * self.s(),
            operand.as_inner().z() * self.s() * self.s(),
            operand.as_inner().t() * self.s() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            operand.as_inner().x(),
            operand.as_inner().y(),
            operand.as_inner().z(),
            operand.as_inner().t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.xyt() * operand.xy() * self.xyt()
                + self.xyt() * operand.xz() * self.xzt()
                + self.xyt() * operand.yz() * self.yzt()
                - self.xyz() * operand.xt() * self.xzt()
                - self.xyz() * operand.xy() * self.xyz()
                - self.xyz() * operand.yt() * self.yzt()
                - self.xzt() * operand.xt() * self.xyz()
                - self.xzt() * operand.xy() * self.xzt()
                + self.xzt() * operand.xz() * self.xyt()
                - self.yzt() * operand.xy() * self.yzt()
                - self.yzt() * operand.yt() * self.xyz()
                + self.yzt() * operand.yz() * self.xyt(),
            self.xyt() * operand.xt() * self.xyz() + self.xyt() * operand.xy() * self.xzt()
                - self.xyt() * operand.xz() * self.xyt()
                + self.xyz() * operand.xt() * self.xyt()
                - self.xyz() * operand.xz() * self.xyz()
                - self.xyz() * operand.zt() * self.yzt()
                + self.xzt() * operand.xy() * self.xyt()
                + self.xzt() * operand.xz() * self.xzt()
                + self.xzt() * operand.yz() * self.yzt()
                - self.yzt() * operand.xz() * self.yzt()
                + self.yzt() * operand.yz() * self.xzt()
                - self.yzt() * operand.zt() * self.xyz(),
            self.xyt() * operand.xt() * self.xyt()
                - self.xyt() * operand.xz() * self.xyz()
                - self.xyt() * operand.zt() * self.yzt()
                + self.xyz() * operand.xt() * self.xyz()
                + self.xyz() * operand.xy() * self.xzt()
                - self.xyz() * operand.xz() * self.xyt()
                + self.xzt() * operand.xt() * self.xzt()
                + self.xzt() * operand.xy() * self.xyz()
                + self.xzt() * operand.yt() * self.yzt()
                - self.yzt() * operand.xt() * self.yzt()
                + self.yzt() * operand.yt() * self.xzt()
                - self.yzt() * operand.zt() * self.xyt(),
            self.xyt() * operand.xy() * self.yzt() + self.xyt() * operand.yt() * self.xyz()
                - self.xyt() * operand.yz() * self.xyt()
                + self.xyz() * operand.yt() * self.xyt()
                - self.xyz() * operand.yz() * self.xyz()
                + self.xyz() * operand.zt() * self.xzt()
                + self.xzt() * operand.xz() * self.yzt()
                - self.xzt() * operand.yz() * self.xzt()
                + self.xzt() * operand.zt() * self.xyz()
                + self.yzt() * operand.xy() * self.xyt()
                + self.yzt() * operand.xz() * self.xzt()
                + self.yzt() * operand.yz() * self.yzt(),
            self.xyt() * operand.yt() * self.xyt() - self.xyt() * operand.yz() * self.xyz()
                + self.xyt() * operand.zt() * self.xzt()
                + self.xyz() * operand.xy() * self.yzt()
                + self.xyz() * operand.yt() * self.xyz()
                - self.xyz() * operand.yz() * self.xyt()
                + self.xzt() * operand.xt() * self.yzt()
                - self.xzt() * operand.yt() * self.xzt()
                + self.xzt() * operand.zt() * self.xyt()
                + self.yzt() * operand.xt() * self.xzt()
                + self.yzt() * operand.xy() * self.xyz()
                + self.yzt() * operand.yt() * self.yzt(),
            -(self.xyt() * operand.xt() * self.yzt()) + self.xyt() * operand.yt() * self.xzt()
                - self.xyt() * operand.zt() * self.xyt()
                + self.xyz() * operand.xz() * self.yzt()
                - self.xyz() * operand.yz() * self.xzt()
                + self.xyz() * operand.zt() * self.xyz()
                + self.xzt() * operand.yt() * self.xyt()
                - self.xzt() * operand.yz() * self.xyz()
                + self.xzt() * operand.zt() * self.xzt()
                - self.yzt() * operand.xt() * self.xyt()
                + self.yzt() * operand.xz() * self.xyz()
                + self.yzt() * operand.zt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Unit<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.xy())
                + -T::TWO * operand.xt() * self.as_inner().xyz() * self.as_inner().xzt()
                + -T::TWO * operand.xy() * self.as_inner().xzt() * self.as_inner().xzt()
                + -T::TWO * operand.xy() * self.as_inner().yzt() * self.as_inner().yzt()
                + -T::TWO * operand.yt() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.xz() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.yz() * self.as_inner().xyt() * self.as_inner().yzt(),
            -(operand.xz())
                + -T::TWO * operand.xz() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.xz() * self.as_inner().yzt() * self.as_inner().yzt()
                + -T::TWO * operand.zt() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.xt() * self.as_inner().xyt() * self.as_inner().xyz()
                + T::TWO * operand.xy() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.yz() * self.as_inner().xzt() * self.as_inner().yzt(),
            -T::TWO * operand.xz() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO * operand.zt() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.xt() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.xt() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.xy() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.yt() * self.as_inner().xzt() * self.as_inner().yzt()
                + operand.xt(),
            -(operand.yz())
                + -T::TWO * operand.yz() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.yz() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.xy() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.xz() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.yt() * self.as_inner().xyt() * self.as_inner().xyz()
                + T::TWO * operand.zt() * self.as_inner().xyz() * self.as_inner().xzt(),
            -T::TWO * operand.yz() * self.as_inner().xyt() * self.as_inner().xyz()
                + T::TWO * operand.xt() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.xy() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.yt() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.yt() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.zt() * self.as_inner().xyt() * self.as_inner().xzt()
                + operand.yt(),
            -T::TWO * operand.xt() * self.as_inner().xyt() * self.as_inner().yzt()
                + -T::TWO * operand.yz() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.xz() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.yt() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.zt() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.zt() * self.as_inner().yzt() * self.as_inner().yzt()
                + operand.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.as_inner().xy() * self.xyz() * self.xyz())
                + -(operand.as_inner().xy() * self.xzt() * self.xzt())
                + -(operand.as_inner().xy() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().xt() * self.xyz() * self.xzt()
                + -T::TWO * operand.as_inner().yt() * self.xyz() * self.yzt()
                + T::TWO * operand.as_inner().xz() * self.xyt() * self.xzt()
                + T::TWO * operand.as_inner().yz() * self.xyt() * self.yzt()
                + operand.as_inner().xy() * self.xyt() * self.xyt(),
            -(operand.as_inner().xz() * self.xyt() * self.xyt())
                + -(operand.as_inner().xz() * self.xyz() * self.xyz())
                + -(operand.as_inner().xz() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().zt() * self.xyz() * self.yzt()
                + T::TWO * operand.as_inner().xt() * self.xyt() * self.xyz()
                + T::TWO * operand.as_inner().xy() * self.xyt() * self.xzt()
                + T::TWO * operand.as_inner().yz() * self.xzt() * self.yzt()
                + operand.as_inner().xz() * self.xzt() * self.xzt(),
            -(operand.as_inner().xt() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().xz() * self.xyt() * self.xyz()
                + -T::TWO * operand.as_inner().zt() * self.xyt() * self.yzt()
                + T::TWO * operand.as_inner().xy() * self.xyz() * self.xzt()
                + T::TWO * operand.as_inner().yt() * self.xzt() * self.yzt()
                + operand.as_inner().xt() * self.xyt() * self.xyt()
                + operand.as_inner().xt() * self.xyz() * self.xyz()
                + operand.as_inner().xt() * self.xzt() * self.xzt(),
            -(operand.as_inner().yz() * self.xyt() * self.xyt())
                + -(operand.as_inner().yz() * self.xyz() * self.xyz())
                + -(operand.as_inner().yz() * self.xzt() * self.xzt())
                + T::TWO * operand.as_inner().xy() * self.xyt() * self.yzt()
                + T::TWO * operand.as_inner().xz() * self.xzt() * self.yzt()
                + T::TWO * operand.as_inner().yt() * self.xyt() * self.xyz()
                + T::TWO * operand.as_inner().zt() * self.xyz() * self.xzt()
                + operand.as_inner().yz() * self.yzt() * self.yzt(),
            -(operand.as_inner().yt() * self.xzt() * self.xzt())
                + -T::TWO * operand.as_inner().yz() * self.xyt() * self.xyz()
                + T::TWO * operand.as_inner().xt() * self.xzt() * self.yzt()
                + T::TWO * operand.as_inner().xy() * self.xyz() * self.yzt()
                + T::TWO * operand.as_inner().zt() * self.xyt() * self.xzt()
                + operand.as_inner().yt() * self.xyt() * self.xyt()
                + operand.as_inner().yt() * self.xyz() * self.xyz()
                + operand.as_inner().yt() * self.yzt() * self.yzt(),
            -(operand.as_inner().zt() * self.xyt() * self.xyt())
                + -T::TWO * operand.as_inner().xt() * self.xyt() * self.yzt()
                + -T::TWO * operand.as_inner().yz() * self.xyz() * self.xzt()
                + T::TWO * operand.as_inner().xz() * self.xyz() * self.yzt()
                + T::TWO * operand.as_inner().yt() * self.xyt() * self.xzt()
                + operand.as_inner().zt() * self.xyz() * self.xyz()
                + operand.as_inner().zt() * self.xzt() * self.xzt()
                + operand.as_inner().zt() * self.yzt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Unit<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.as_inner().xy())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xyz() * self.as_inner().xzt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xzt() * self.as_inner().xzt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().yzt() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyt() * self.as_inner().yzt(),
            -(operand.as_inner().xz())
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().yzt() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xyt() * self.as_inner().xyz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xzt() * self.as_inner().yzt(),
            -T::TWO * operand.as_inner().xz() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xzt() * self.as_inner().yzt()
                + operand.as_inner().xt(),
            -(operand.as_inner().yz())
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xyt() * self.as_inner().xyz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xyz() * self.as_inner().xzt(),
            -T::TWO * operand.as_inner().yz() * self.as_inner().xyt() * self.as_inner().xyz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xyt() * self.as_inner().xzt()
                + operand.as_inner().yt(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().xyt() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().yzt() * self.as_inner().yzt()
                + operand.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Trivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            self.xyt() * operand.s() * self.xyt() + self.xyt() * operand.xz() * self.yzt()
                - self.xyt() * operand.yz() * self.xzt()
                + self.xyt() * operand.zt() * self.xyz()
                - self.xyz() * operand.s() * self.xyz()
                - self.xyz() * operand.xt() * self.yzt()
                + self.xyz() * operand.yt() * self.xzt()
                - self.xyz() * operand.zt() * self.xyt()
                + self.xzt() * operand.s() * self.xzt()
                - self.xzt() * operand.xy() * self.yzt()
                - self.xzt() * operand.yt() * self.xyz()
                + self.xzt() * operand.yz() * self.xyt()
                + self.yzt() * operand.s() * self.yzt()
                + self.yzt() * operand.xt() * self.xyz()
                + self.yzt() * operand.xy() * self.xzt()
                - self.yzt() * operand.xz() * self.xyt(),
            self.xyt() * operand.xy() * self.xyt()
                + self.xyt() * operand.xyzt() * self.xyz()
                + self.xyt() * operand.xz() * self.xzt()
                + self.xyt() * operand.yz() * self.yzt()
                - self.xyz() * operand.xt() * self.xzt()
                - self.xyz() * operand.xy() * self.xyz()
                - self.xyz() * operand.xyzt() * self.xyt()
                - self.xyz() * operand.yt() * self.yzt()
                - self.xzt() * operand.s() * self.yzt()
                - self.xzt() * operand.xt() * self.xyz()
                - self.xzt() * operand.xy() * self.xzt()
                + self.xzt() * operand.xz() * self.xyt()
                + self.yzt() * operand.s() * self.xzt()
                - self.yzt() * operand.xy() * self.yzt()
                - self.yzt() * operand.yt() * self.xyz()
                + self.yzt() * operand.yz() * self.xyt(),
            self.xyt() * operand.s() * self.yzt()
                + self.xyt() * operand.xt() * self.xyz()
                + self.xyt() * operand.xy() * self.xzt()
                - self.xyt() * operand.xz() * self.xyt()
                + self.xyz() * operand.xt() * self.xyt()
                - self.xyz() * operand.xyzt() * self.xzt()
                - self.xyz() * operand.xz() * self.xyz()
                - self.xyz() * operand.zt() * self.yzt()
                + self.xzt() * operand.xy() * self.xyt()
                + self.xzt() * operand.xyzt() * self.xyz()
                + self.xzt() * operand.xz() * self.xzt()
                + self.xzt() * operand.yz() * self.yzt()
                - self.yzt() * operand.s() * self.xyt()
                - self.yzt() * operand.xz() * self.yzt()
                + self.yzt() * operand.yz() * self.xzt()
                - self.yzt() * operand.zt() * self.xyz(),
            self.xyt() * operand.xt() * self.xyt()
                - self.xyt() * operand.xyzt() * self.xzt()
                - self.xyt() * operand.xz() * self.xyz()
                - self.xyt() * operand.zt() * self.yzt()
                + self.xyz() * operand.s() * self.yzt()
                + self.xyz() * operand.xt() * self.xyz()
                + self.xyz() * operand.xy() * self.xzt()
                - self.xyz() * operand.xz() * self.xyt()
                + self.xzt() * operand.xt() * self.xzt()
                + self.xzt() * operand.xy() * self.xyz()
                + self.xzt() * operand.xyzt() * self.xyt()
                + self.xzt() * operand.yt() * self.yzt()
                - self.yzt() * operand.s() * self.xyz()
                - self.yzt() * operand.xt() * self.yzt()
                + self.yzt() * operand.yt() * self.xzt()
                - self.yzt() * operand.zt() * self.xyt(),
            -(self.xyt() * operand.s() * self.xzt())
                + self.xyt() * operand.xy() * self.yzt()
                + self.xyt() * operand.yt() * self.xyz()
                - self.xyt() * operand.yz() * self.xyt()
                - self.xyz() * operand.xyzt() * self.yzt()
                + self.xyz() * operand.yt() * self.xyt()
                - self.xyz() * operand.yz() * self.xyz()
                + self.xyz() * operand.zt() * self.xzt()
                + self.xzt() * operand.s() * self.xyt()
                + self.xzt() * operand.xz() * self.yzt()
                - self.xzt() * operand.yz() * self.xzt()
                + self.xzt() * operand.zt() * self.xyz()
                + self.yzt() * operand.xy() * self.xyt()
                + self.yzt() * operand.xyzt() * self.xyz()
                + self.yzt() * operand.xz() * self.xzt()
                + self.yzt() * operand.yz() * self.yzt(),
            -(self.xyt() * operand.xyzt() * self.yzt()) + self.xyt() * operand.yt() * self.xyt()
                - self.xyt() * operand.yz() * self.xyz()
                + self.xyt() * operand.zt() * self.xzt()
                - self.xyz() * operand.s() * self.xzt()
                + self.xyz() * operand.xy() * self.yzt()
                + self.xyz() * operand.yt() * self.xyz()
                - self.xyz() * operand.yz() * self.xyt()
                + self.xzt() * operand.s() * self.xyz()
                + self.xzt() * operand.xt() * self.yzt()
                - self.xzt() * operand.yt() * self.xzt()
                + self.xzt() * operand.zt() * self.xyt()
                + self.yzt() * operand.xt() * self.xzt()
                + self.yzt() * operand.xy() * self.xyz()
                + self.yzt() * operand.xyzt() * self.xyt()
                + self.yzt() * operand.yt() * self.yzt(),
            -(self.xyt() * operand.s() * self.xyz()) - self.xyt() * operand.xt() * self.yzt()
                + self.xyt() * operand.yt() * self.xzt()
                - self.xyt() * operand.zt() * self.xyt()
                + self.xyz() * operand.s() * self.xyt()
                + self.xyz() * operand.xz() * self.yzt()
                - self.xyz() * operand.yz() * self.xzt()
                + self.xyz() * operand.zt() * self.xyz()
                - self.xzt() * operand.xyzt() * self.yzt()
                + self.xzt() * operand.yt() * self.xyt()
                - self.xzt() * operand.yz() * self.xyz()
                + self.xzt() * operand.zt() * self.xzt()
                - self.yzt() * operand.xt() * self.xyt()
                + self.yzt() * operand.xyzt() * self.xzt()
                + self.yzt() * operand.xz() * self.xyz()
                + self.yzt() * operand.zt() * self.yzt(),
            -(self.xyt() * operand.xt() * self.xzt())
                - self.xyt() * operand.xy() * self.xyz()
                - self.xyt() * operand.xyzt() * self.xyt()
                - self.xyt() * operand.yt() * self.yzt()
                + self.xyz() * operand.xy() * self.xyt()
                + self.xyz() * operand.xyzt() * self.xyz()
                + self.xyz() * operand.xz() * self.xzt()
                + self.xyz() * operand.yz() * self.yzt()
                + self.xzt() * operand.xt() * self.xyt()
                - self.xzt() * operand.xyzt() * self.xzt()
                - self.xzt() * operand.xz() * self.xyz()
                - self.xzt() * operand.zt() * self.yzt()
                - self.yzt() * operand.xyzt() * self.yzt()
                + self.yzt() * operand.yt() * self.xyt()
                - self.yzt() * operand.yz() * self.xyz()
                + self.yzt() * operand.zt() * self.xzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Unit<Trivector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.s()),
            -(operand.xy())
                + -T::TWO * operand.xt() * self.as_inner().xyz() * self.as_inner().xzt()
                + -T::TWO * operand.xy() * self.as_inner().xzt() * self.as_inner().xzt()
                + -T::TWO * operand.xy() * self.as_inner().yzt() * self.as_inner().yzt()
                + -T::TWO * operand.yt() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.xz() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.yz() * self.as_inner().xyt() * self.as_inner().yzt(),
            -(operand.xz())
                + -T::TWO * operand.xz() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.xz() * self.as_inner().yzt() * self.as_inner().yzt()
                + -T::TWO * operand.zt() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.xt() * self.as_inner().xyt() * self.as_inner().xyz()
                + T::TWO * operand.xy() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.yz() * self.as_inner().xzt() * self.as_inner().yzt(),
            -T::TWO * operand.xz() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO * operand.zt() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.xt() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.xt() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.xy() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.yt() * self.as_inner().xzt() * self.as_inner().yzt()
                + operand.xt(),
            -(operand.yz())
                + -T::TWO * operand.yz() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.yz() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.xy() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.xz() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.yt() * self.as_inner().xyt() * self.as_inner().xyz()
                + T::TWO * operand.zt() * self.as_inner().xyz() * self.as_inner().xzt(),
            -T::TWO * operand.yz() * self.as_inner().xyt() * self.as_inner().xyz()
                + T::TWO * operand.xt() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.xy() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.yt() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.yt() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.zt() * self.as_inner().xyt() * self.as_inner().xzt()
                + operand.yt(),
            -T::TWO * operand.xt() * self.as_inner().xyt() * self.as_inner().yzt()
                + -T::TWO * operand.yz() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.xz() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.yt() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.zt() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.zt() * self.as_inner().yzt() * self.as_inner().yzt()
                + operand.zt(),
            operand.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Trivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.as_inner().s() * self.xyz() * self.xyz())
                + operand.as_inner().s() * self.xyt() * self.xyt()
                + operand.as_inner().s() * self.xzt() * self.xzt()
                + operand.as_inner().s() * self.yzt() * self.yzt(),
            -(operand.as_inner().xy() * self.xyz() * self.xyz())
                + -(operand.as_inner().xy() * self.xzt() * self.xzt())
                + -(operand.as_inner().xy() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().xt() * self.xyz() * self.xzt()
                + -T::TWO * operand.as_inner().yt() * self.xyz() * self.yzt()
                + T::TWO * operand.as_inner().xz() * self.xyt() * self.xzt()
                + T::TWO * operand.as_inner().yz() * self.xyt() * self.yzt()
                + operand.as_inner().xy() * self.xyt() * self.xyt(),
            -(operand.as_inner().xz() * self.xyt() * self.xyt())
                + -(operand.as_inner().xz() * self.xyz() * self.xyz())
                + -(operand.as_inner().xz() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().zt() * self.xyz() * self.yzt()
                + T::TWO * operand.as_inner().xt() * self.xyt() * self.xyz()
                + T::TWO * operand.as_inner().xy() * self.xyt() * self.xzt()
                + T::TWO * operand.as_inner().yz() * self.xzt() * self.yzt()
                + operand.as_inner().xz() * self.xzt() * self.xzt(),
            -(operand.as_inner().xt() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().xz() * self.xyt() * self.xyz()
                + -T::TWO * operand.as_inner().zt() * self.xyt() * self.yzt()
                + T::TWO * operand.as_inner().xy() * self.xyz() * self.xzt()
                + T::TWO * operand.as_inner().yt() * self.xzt() * self.yzt()
                + operand.as_inner().xt() * self.xyt() * self.xyt()
                + operand.as_inner().xt() * self.xyz() * self.xyz()
                + operand.as_inner().xt() * self.xzt() * self.xzt(),
            -(operand.as_inner().yz() * self.xyt() * self.xyt())
                + -(operand.as_inner().yz() * self.xyz() * self.xyz())
                + -(operand.as_inner().yz() * self.xzt() * self.xzt())
                + T::TWO * operand.as_inner().xy() * self.xyt() * self.yzt()
                + T::TWO * operand.as_inner().xz() * self.xzt() * self.yzt()
                + T::TWO * operand.as_inner().yt() * self.xyt() * self.xyz()
                + T::TWO * operand.as_inner().zt() * self.xyz() * self.xzt()
                + operand.as_inner().yz() * self.yzt() * self.yzt(),
            -(operand.as_inner().yt() * self.xzt() * self.xzt())
                + -T::TWO * operand.as_inner().yz() * self.xyt() * self.xyz()
                + T::TWO * operand.as_inner().xt() * self.xzt() * self.yzt()
                + T::TWO * operand.as_inner().xy() * self.xyz() * self.yzt()
                + T::TWO * operand.as_inner().zt() * self.xyt() * self.xzt()
                + operand.as_inner().yt() * self.xyt() * self.xyt()
                + operand.as_inner().yt() * self.xyz() * self.xyz()
                + operand.as_inner().yt() * self.yzt() * self.yzt(),
            -(operand.as_inner().zt() * self.xyt() * self.xyt())
                + -T::TWO * operand.as_inner().xt() * self.xyt() * self.yzt()
                + -T::TWO * operand.as_inner().yz() * self.xyz() * self.xzt()
                + T::TWO * operand.as_inner().xz() * self.xyz() * self.yzt()
                + T::TWO * operand.as_inner().yt() * self.xyt() * self.xzt()
                + operand.as_inner().zt() * self.xyz() * self.xyz()
                + operand.as_inner().zt() * self.xzt() * self.xzt()
                + operand.as_inner().zt() * self.yzt() * self.yzt(),
            -(operand.as_inner().xyzt() * self.xyt() * self.xyt())
                + -(operand.as_inner().xyzt() * self.xzt() * self.xzt())
                + -(operand.as_inner().xyzt() * self.yzt() * self.yzt())
                + operand.as_inner().xyzt() * self.xyz() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Unit<Trivector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.as_inner().s()),
            -(operand.as_inner().xy())
                + -T::TWO * operand.as_inner().xt() * self.as_inner().xyz() * self.as_inner().xzt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().xzt() * self.as_inner().xzt()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().yzt() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xyt() * self.as_inner().yzt(),
            -(operand.as_inner().xz())
                + -T::TWO * operand.as_inner().xz() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().yzt() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xyt() * self.as_inner().xyz()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().yz() * self.as_inner().xzt() * self.as_inner().yzt(),
            -T::TWO * operand.as_inner().xz() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xzt() * self.as_inner().yzt()
                + operand.as_inner().xt(),
            -(operand.as_inner().yz())
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xyt() * self.as_inner().xyz()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xyz() * self.as_inner().xzt(),
            -T::TWO * operand.as_inner().yz() * self.as_inner().xyt() * self.as_inner().xyz()
                + T::TWO * operand.as_inner().xt() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xy() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xyt() * self.as_inner().xzt()
                + operand.as_inner().yt(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().xyt() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().xz() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().yt() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().zt() * self.as_inner().yzt() * self.as_inner().yzt()
                + operand.as_inner().zt(),
            operand.as_inner().xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Trivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(self.xyt() * operand.xyzt() * self.xyt()) + self.xyz() * operand.xyzt() * self.xyz()
                - self.xzt() * operand.xyzt() * self.xzt()
                - self.yzt() * operand.xyzt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Unit<Trivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Trivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(operand.as_inner().xyzt() * self.xyt() * self.xyt())
                + -(operand.as_inner().xyzt() * self.xzt() * self.xzt())
                + -(operand.as_inner().xyzt() * self.yzt() * self.yzt())
                + operand.as_inner().xyzt() * self.xyz() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Unit<Trivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.as_inner().xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.xyt() * operand.s() * self.xyt() - self.xyz() * operand.s() * self.xyz()
                + self.xzt() * operand.s() * self.xzt()
                + self.yzt() * operand.s() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unit<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(operand.as_inner().s() * self.xyz() * self.xyz())
                + operand.as_inner().s() * self.xyt() * self.xyt()
                + operand.as_inner().s() * self.xzt() * self.xzt()
                + operand.as_inner().s() * self.yzt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Unit<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(self.xyt() * operand.xyt() * self.xyz()) + self.xyt() * operand.xyz() * self.xyt()
                - self.xyz() * operand.xyt() * self.xyt()
                + self.xyz() * operand.xyz() * self.xyz()
                - self.xyz() * operand.xzt() * self.xzt()
                - self.xyz() * operand.yzt() * self.yzt()
                + self.xzt() * operand.xyz() * self.xzt()
                - self.xzt() * operand.xzt() * self.xyz()
                + self.yzt() * operand.xyz() * self.yzt()
                - self.yzt() * operand.yzt() * self.xyz(),
            -(self.xyt() * operand.xyt() * self.xyt()) + self.xyt() * operand.xyz() * self.xyz()
                - self.xyt() * operand.xzt() * self.xzt()
                - self.xyt() * operand.yzt() * self.yzt()
                - self.xyz() * operand.xyt() * self.xyz()
                + self.xyz() * operand.xyz() * self.xyt()
                + self.xzt() * operand.xyt() * self.xzt()
                - self.xzt() * operand.xzt() * self.xyt()
                + self.yzt() * operand.xyt() * self.yzt()
                - self.yzt() * operand.yzt() * self.xyt(),
            -(self.xyt() * operand.xyt() * self.xzt())
                + self.xyt() * operand.xzt() * self.xyt()
                + self.xyz() * operand.xyz() * self.xzt()
                - self.xyz() * operand.xzt() * self.xyz()
                - self.xzt() * operand.xyt() * self.xyt()
                + self.xzt() * operand.xyz() * self.xyz()
                - self.xzt() * operand.xzt() * self.xzt()
                - self.xzt() * operand.yzt() * self.yzt()
                + self.yzt() * operand.xzt() * self.yzt()
                - self.yzt() * operand.yzt() * self.xzt(),
            -(self.xyt() * operand.xyt() * self.yzt())
                + self.xyt() * operand.yzt() * self.xyt()
                + self.xyz() * operand.xyz() * self.yzt()
                - self.xyz() * operand.yzt() * self.xyz()
                - self.xzt() * operand.xzt() * self.yzt()
                + self.xzt() * operand.yzt() * self.xzt()
                - self.yzt() * operand.xyt() * self.xyt()
                + self.yzt() * operand.xyz() * self.xyz()
                - self.yzt() * operand.xzt() * self.xzt()
                - self.yzt() * operand.yzt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.xyt() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO * operand.xzt() * self.as_inner().xyz() * self.as_inner().xzt()
                + -T::TWO * operand.yzt() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.xyz() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.xyz() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.xyz() * self.as_inner().yzt() * self.as_inner().yzt()
                + operand.xyz(),
            -(operand.xyt())
                + -T::TWO * operand.xyt() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.xzt() * self.as_inner().xyt() * self.as_inner().xzt()
                + -T::TWO * operand.yzt() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.xyz() * self.as_inner().xyt() * self.as_inner().xyz(),
            -(operand.xzt())
                + -T::TWO * operand.xyt() * self.as_inner().xyt() * self.as_inner().xzt()
                + -T::TWO * operand.xzt() * self.as_inner().xzt() * self.as_inner().xzt()
                + -T::TWO * operand.yzt() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.xyz() * self.as_inner().xyz() * self.as_inner().xzt(),
            -(operand.yzt())
                + -T::TWO * operand.xyt() * self.as_inner().xyt() * self.as_inner().yzt()
                + -T::TWO * operand.xzt() * self.as_inner().xzt() * self.as_inner().yzt()
                + -T::TWO * operand.yzt() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.xyz() * self.as_inner().xyz() * self.as_inner().yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Trivector<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.as_inner().xyt() * self.xyt() * self.xyz()
                + -T::TWO * operand.as_inner().xzt() * self.xyz() * self.xzt()
                + -T::TWO * operand.as_inner().yzt() * self.xyz() * self.yzt()
                + operand.as_inner().xyz() * self.xyt() * self.xyt()
                + operand.as_inner().xyz() * self.xyz() * self.xyz()
                + operand.as_inner().xyz() * self.xzt() * self.xzt()
                + operand.as_inner().xyz() * self.yzt() * self.yzt(),
            -(operand.as_inner().xyt() * self.xyt() * self.xyt())
                + -(operand.as_inner().xyt() * self.xyz() * self.xyz())
                + -T::TWO * operand.as_inner().xzt() * self.xyt() * self.xzt()
                + -T::TWO * operand.as_inner().yzt() * self.xyt() * self.yzt()
                + T::TWO * operand.as_inner().xyz() * self.xyt() * self.xyz()
                + operand.as_inner().xyt() * self.xzt() * self.xzt()
                + operand.as_inner().xyt() * self.yzt() * self.yzt(),
            -(operand.as_inner().xzt() * self.xyz() * self.xyz())
                + -(operand.as_inner().xzt() * self.xzt() * self.xzt())
                + -T::TWO * operand.as_inner().xyt() * self.xyt() * self.xzt()
                + -T::TWO * operand.as_inner().yzt() * self.xzt() * self.yzt()
                + T::TWO * operand.as_inner().xyz() * self.xyz() * self.xzt()
                + operand.as_inner().xzt() * self.xyt() * self.xyt()
                + operand.as_inner().xzt() * self.yzt() * self.yzt(),
            -(operand.as_inner().yzt() * self.xyz() * self.xyz())
                + -(operand.as_inner().yzt() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().xyt() * self.xyt() * self.yzt()
                + -T::TWO * operand.as_inner().xzt() * self.xzt() * self.yzt()
                + T::TWO * operand.as_inner().xyz() * self.xyz() * self.yzt()
                + operand.as_inner().yzt() * self.xyt() * self.xyt()
                + operand.as_inner().yzt() * self.xzt() * self.xzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Trivector<T>>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.as_inner().xyt() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO
                    * operand.as_inner().xzt()
                    * self.as_inner().xyz()
                    * self.as_inner().xzt()
                + -T::TWO
                    * operand.as_inner().yzt()
                    * self.as_inner().xyz()
                    * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xyt() * self.as_inner().xyt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xzt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().yzt() * self.as_inner().yzt()
                + operand.as_inner().xyz(),
            -(operand.as_inner().xyt())
                + -T::TWO
                    * operand.as_inner().xyt()
                    * self.as_inner().xyt()
                    * self.as_inner().xyt()
                + -T::TWO
                    * operand.as_inner().xzt()
                    * self.as_inner().xyt()
                    * self.as_inner().xzt()
                + -T::TWO
                    * operand.as_inner().yzt()
                    * self.as_inner().xyt()
                    * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xyt() * self.as_inner().xyz(),
            -(operand.as_inner().xzt())
                + -T::TWO
                    * operand.as_inner().xyt()
                    * self.as_inner().xyt()
                    * self.as_inner().xzt()
                + -T::TWO
                    * operand.as_inner().xzt()
                    * self.as_inner().xzt()
                    * self.as_inner().xzt()
                + -T::TWO
                    * operand.as_inner().yzt()
                    * self.as_inner().xzt()
                    * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xyz() * self.as_inner().xzt(),
            -(operand.as_inner().yzt())
                + -T::TWO
                    * operand.as_inner().xyt()
                    * self.as_inner().xyt()
                    * self.as_inner().yzt()
                + -T::TWO
                    * operand.as_inner().xzt()
                    * self.as_inner().xzt()
                    * self.as_inner().yzt()
                + -T::TWO
                    * operand.as_inner().yzt()
                    * self.as_inner().yzt()
                    * self.as_inner().yzt()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().xyz() * self.as_inner().yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.xyt() * operand.x() * self.xyt()) + self.xyt() * operand.z() * self.yzt()
                - self.xyz() * operand.t() * self.yzt()
                + self.xyz() * operand.x() * self.xyz()
                - self.xzt() * operand.x() * self.xzt()
                - self.xzt() * operand.y() * self.yzt()
                - self.yzt() * operand.t() * self.xyz()
                + self.yzt() * operand.x() * self.yzt()
                - self.yzt() * operand.y() * self.xzt()
                + self.yzt() * operand.z() * self.xyt(),
            -(self.xyt() * operand.y() * self.xyt()) - self.xyt() * operand.z() * self.xzt()
                + self.xyz() * operand.t() * self.xzt()
                + self.xyz() * operand.y() * self.xyz()
                + self.xzt() * operand.t() * self.xyz()
                - self.xzt() * operand.x() * self.yzt()
                + self.xzt() * operand.y() * self.xzt()
                - self.xzt() * operand.z() * self.xyt()
                - self.yzt() * operand.x() * self.xzt()
                - self.yzt() * operand.y() * self.yzt(),
            -(self.xyt() * operand.t() * self.xyz()) + self.xyt() * operand.x() * self.yzt()
                - self.xyt() * operand.y() * self.xzt()
                + self.xyt() * operand.z() * self.xyt()
                - self.xyz() * operand.t() * self.xyt()
                + self.xyz() * operand.z() * self.xyz()
                - self.xzt() * operand.y() * self.xyt()
                - self.xzt() * operand.z() * self.xzt()
                + self.yzt() * operand.x() * self.xyt()
                - self.yzt() * operand.z() * self.yzt(),
            -(self.xyt() * operand.t() * self.xyt()) + self.xyt() * operand.z() * self.xyz()
                - self.xyz() * operand.t() * self.xyz()
                + self.xyz() * operand.x() * self.yzt()
                - self.xyz() * operand.y() * self.xzt()
                + self.xyz() * operand.z() * self.xyt()
                - self.xzt() * operand.t() * self.xzt()
                - self.xzt() * operand.y() * self.xyz()
                - self.yzt() * operand.t() * self.yzt()
                + self.yzt() * operand.x() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Unit<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -T::TWO * operand.t() * self.as_inner().xyz() * self.as_inner().yzt()
                + -T::TWO * operand.y() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.x() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.z() * self.as_inner().xyt() * self.as_inner().yzt()
                + operand.x(),
            -T::TWO * operand.x() * self.as_inner().xzt() * self.as_inner().yzt()
                + -T::TWO * operand.z() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.t() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.y() * self.as_inner().xzt() * self.as_inner().xzt()
                + operand.y(),
            -T::TWO * operand.t() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO * operand.y() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.x() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.z() * self.as_inner().xyt() * self.as_inner().xyt()
                + operand.z(),
            -(operand.t())
                + -T::TWO * operand.t() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.t() * self.as_inner().xzt() * self.as_inner().xzt()
                + -T::TWO * operand.t() * self.as_inner().yzt() * self.as_inner().yzt()
                + -T::TWO * operand.y() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.x() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.z() * self.as_inner().xyt() * self.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.as_inner().x() * self.xyt() * self.xyt())
                + -(operand.as_inner().x() * self.xzt() * self.xzt())
                + -T::TWO * operand.as_inner().t() * self.xyz() * self.yzt()
                + -T::TWO * operand.as_inner().y() * self.xzt() * self.yzt()
                + T::TWO * operand.as_inner().z() * self.xyt() * self.yzt()
                + operand.as_inner().x() * self.xyz() * self.xyz()
                + operand.as_inner().x() * self.yzt() * self.yzt(),
            -(operand.as_inner().y() * self.xyt() * self.xyt())
                + -(operand.as_inner().y() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().x() * self.xzt() * self.yzt()
                + -T::TWO * operand.as_inner().z() * self.xyt() * self.xzt()
                + T::TWO * operand.as_inner().t() * self.xyz() * self.xzt()
                + operand.as_inner().y() * self.xyz() * self.xyz()
                + operand.as_inner().y() * self.xzt() * self.xzt(),
            -(operand.as_inner().z() * self.xzt() * self.xzt())
                + -(operand.as_inner().z() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().t() * self.xyt() * self.xyz()
                + -T::TWO * operand.as_inner().y() * self.xyt() * self.xzt()
                + T::TWO * operand.as_inner().x() * self.xyt() * self.yzt()
                + operand.as_inner().z() * self.xyt() * self.xyt()
                + operand.as_inner().z() * self.xyz() * self.xyz(),
            -(operand.as_inner().t() * self.xyt() * self.xyt())
                + -(operand.as_inner().t() * self.xyz() * self.xyz())
                + -(operand.as_inner().t() * self.xzt() * self.xzt())
                + -(operand.as_inner().t() * self.yzt() * self.yzt())
                + -T::TWO * operand.as_inner().y() * self.xyz() * self.xzt()
                + T::TWO * operand.as_inner().x() * self.xyz() * self.yzt()
                + T::TWO * operand.as_inner().z() * self.xyt() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Unit<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -T::TWO * operand.as_inner().t() * self.as_inner().xyz() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().x() * self.as_inner().yzt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().z() * self.as_inner().xyt() * self.as_inner().yzt()
                + operand.as_inner().x(),
            -T::TWO * operand.as_inner().x() * self.as_inner().xzt() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().t() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().y() * self.as_inner().xzt() * self.as_inner().xzt()
                + operand.as_inner().y(),
            -T::TWO * operand.as_inner().t() * self.as_inner().xyt() * self.as_inner().xyz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xyt() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().x() * self.as_inner().xyt() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().z() * self.as_inner().xyt() * self.as_inner().xyt()
                + operand.as_inner().z(),
            -(operand.as_inner().t())
                + -T::TWO * operand.as_inner().t() * self.as_inner().xyt() * self.as_inner().xyt()
                + -T::TWO * operand.as_inner().t() * self.as_inner().xzt() * self.as_inner().xzt()
                + -T::TWO * operand.as_inner().t() * self.as_inner().yzt() * self.as_inner().yzt()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xyz() * self.as_inner().xzt()
                + T::TWO * operand.as_inner().x() * self.as_inner().xyz() * self.as_inner().yzt()
                + T::TWO * operand.as_inner().z() * self.as_inner().xyt() * self.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(self.t() * operand.xt() * self.y())
                + self.t() * operand.xy() * self.t()
                + self.t() * operand.yt() * self.x()
                + self.x() * operand.xy() * self.x()
                + self.x() * operand.yt() * self.t()
                - self.x() * operand.yz() * self.z()
                - self.y() * operand.xt() * self.t()
                + self.y() * operand.xy() * self.y()
                + self.y() * operand.xz() * self.z()
                - self.z() * operand.xy() * self.z()
                + self.z() * operand.xz() * self.y()
                - self.z() * operand.yz() * self.x(),
            -(self.t() * operand.xt() * self.z())
                + self.t() * operand.xz() * self.t()
                + self.t() * operand.zt() * self.x()
                + self.x() * operand.xz() * self.x()
                + self.x() * operand.yz() * self.y()
                + self.x() * operand.zt() * self.t()
                + self.y() * operand.xy() * self.z()
                - self.y() * operand.xz() * self.y()
                + self.y() * operand.yz() * self.x()
                - self.z() * operand.xt() * self.t()
                + self.z() * operand.xy() * self.y()
                + self.z() * operand.xz() * self.z(),
            -(self.t() * operand.xt() * self.t())
                + self.t() * operand.xy() * self.y()
                + self.t() * operand.xz() * self.z()
                + self.x() * operand.xt() * self.x()
                + self.x() * operand.yt() * self.y()
                + self.x() * operand.zt() * self.z()
                - self.y() * operand.xt() * self.y()
                + self.y() * operand.xy() * self.t()
                + self.y() * operand.yt() * self.x()
                - self.z() * operand.xt() * self.z()
                + self.z() * operand.xz() * self.t()
                + self.z() * operand.zt() * self.x(),
            -(self.t() * operand.yt() * self.z())
                + self.t() * operand.yz() * self.t()
                + self.t() * operand.zt() * self.y()
                - self.x() * operand.xy() * self.z()
                + self.x() * operand.xz() * self.y()
                - self.x() * operand.yz() * self.x()
                + self.y() * operand.xz() * self.x()
                + self.y() * operand.yz() * self.y()
                + self.y() * operand.zt() * self.t()
                - self.z() * operand.xy() * self.x()
                - self.z() * operand.yt() * self.t()
                + self.z() * operand.yz() * self.z(),
            -(self.t() * operand.xy() * self.x()) - self.t() * operand.yt() * self.t()
                + self.t() * operand.yz() * self.z()
                + self.x() * operand.xt() * self.y()
                - self.x() * operand.xy() * self.t()
                - self.x() * operand.yt() * self.x()
                + self.y() * operand.xt() * self.x()
                + self.y() * operand.yt() * self.y()
                + self.y() * operand.zt() * self.z()
                - self.z() * operand.yt() * self.z()
                + self.z() * operand.yz() * self.t()
                + self.z() * operand.zt() * self.y(),
            -(self.t() * operand.xz() * self.x())
                - self.t() * operand.yz() * self.y()
                - self.t() * operand.zt() * self.t()
                + self.x() * operand.xt() * self.z()
                - self.x() * operand.xz() * self.t()
                - self.x() * operand.zt() * self.x()
                + self.y() * operand.yt() * self.z()
                - self.y() * operand.yz() * self.t()
                - self.y() * operand.zt() * self.y()
                + self.z() * operand.xt() * self.x()
                + self.z() * operand.yt() * self.y()
                + self.z() * operand.zt() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -T::TWO * operand.xt() * self.as_inner().t() * self.as_inner().y()
                + -T::TWO * operand.xy() * self.as_inner().z() * self.as_inner().z()
                + -T::TWO * operand.yz() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.xy() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.xz() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.yt() * self.as_inner().t() * self.as_inner().x()
                + operand.xy(),
            -T::TWO * operand.xt() * self.as_inner().t() * self.as_inner().z()
                + -T::TWO * operand.xz() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.xy() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.xz() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.yz() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.zt() * self.as_inner().t() * self.as_inner().x()
                + operand.xz(),
            -T::TWO * operand.xt() * self.as_inner().y() * self.as_inner().y()
                + -T::TWO * operand.xt() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.xy() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.xz() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.yt() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.zt() * self.as_inner().x() * self.as_inner().z()
                + operand.xt(),
            -(operand.yz())
                + -T::TWO * operand.xy() * self.as_inner().x() * self.as_inner().z()
                + -T::TWO * operand.yt() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.xz() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.yz() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.yz() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.zt() * self.as_inner().t() * self.as_inner().y(),
            -(operand.yt())
                + -T::TWO * operand.xy() * self.as_inner().t() * self.as_inner().x()
                + -T::TWO * operand.yt() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.xt() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.yt() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.yz() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.zt() * self.as_inner().y() * self.as_inner().z(),
            -(operand.zt())
                + -T::TWO * operand.xz() * self.as_inner().t() * self.as_inner().x()
                + -T::TWO * operand.yz() * self.as_inner().t() * self.as_inner().y()
                + -T::TWO * operand.zt() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.xt() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.yt() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.zt() * self.as_inner().z() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(operand.as_inner().xy() * self.z() * self.z())
                + -T::TWO * operand.as_inner().xt() * self.t() * self.y()
                + -T::TWO * operand.as_inner().yz() * self.x() * self.z()
                + T::TWO * operand.as_inner().xz() * self.y() * self.z()
                + T::TWO * operand.as_inner().yt() * self.t() * self.x()
                + operand.as_inner().xy() * self.t() * self.t()
                + operand.as_inner().xy() * self.x() * self.x()
                + operand.as_inner().xy() * self.y() * self.y(),
            -(operand.as_inner().xz() * self.y() * self.y())
                + -T::TWO * operand.as_inner().xt() * self.t() * self.z()
                + T::TWO * operand.as_inner().xy() * self.y() * self.z()
                + T::TWO * operand.as_inner().yz() * self.x() * self.y()
                + T::TWO * operand.as_inner().zt() * self.t() * self.x()
                + operand.as_inner().xz() * self.t() * self.t()
                + operand.as_inner().xz() * self.x() * self.x()
                + operand.as_inner().xz() * self.z() * self.z(),
            -(operand.as_inner().xt() * self.t() * self.t())
                + -(operand.as_inner().xt() * self.y() * self.y())
                + -(operand.as_inner().xt() * self.z() * self.z())
                + T::TWO * operand.as_inner().xy() * self.t() * self.y()
                + T::TWO * operand.as_inner().xz() * self.t() * self.z()
                + T::TWO * operand.as_inner().yt() * self.x() * self.y()
                + T::TWO * operand.as_inner().zt() * self.x() * self.z()
                + operand.as_inner().xt() * self.x() * self.x(),
            -(operand.as_inner().yz() * self.x() * self.x())
                + -T::TWO * operand.as_inner().xy() * self.x() * self.z()
                + -T::TWO * operand.as_inner().yt() * self.t() * self.z()
                + T::TWO * operand.as_inner().xz() * self.x() * self.y()
                + T::TWO * operand.as_inner().zt() * self.t() * self.y()
                + operand.as_inner().yz() * self.t() * self.t()
                + operand.as_inner().yz() * self.y() * self.y()
                + operand.as_inner().yz() * self.z() * self.z(),
            -(operand.as_inner().yt() * self.t() * self.t())
                + -(operand.as_inner().yt() * self.x() * self.x())
                + -(operand.as_inner().yt() * self.z() * self.z())
                + -T::TWO * operand.as_inner().xy() * self.t() * self.x()
                + T::TWO * operand.as_inner().xt() * self.x() * self.y()
                + T::TWO * operand.as_inner().yz() * self.t() * self.z()
                + T::TWO * operand.as_inner().zt() * self.y() * self.z()
                + operand.as_inner().yt() * self.y() * self.y(),
            -(operand.as_inner().zt() * self.t() * self.t())
                + -(operand.as_inner().zt() * self.x() * self.x())
                + -(operand.as_inner().zt() * self.y() * self.y())
                + -T::TWO * operand.as_inner().xz() * self.t() * self.x()
                + -T::TWO * operand.as_inner().yz() * self.t() * self.y()
                + T::TWO * operand.as_inner().xt() * self.x() * self.z()
                + T::TWO * operand.as_inner().yt() * self.y() * self.z()
                + operand.as_inner().zt() * self.z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -T::TWO * operand.as_inner().xt() * self.as_inner().t() * self.as_inner().y()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().z() * self.as_inner().z()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.as_inner().xy() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.as_inner().xz() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.as_inner().yt() * self.as_inner().t() * self.as_inner().x()
                + operand.as_inner().xy(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().t() * self.as_inner().z()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.as_inner().xy() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.as_inner().xz() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.as_inner().yz() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().zt() * self.as_inner().t() * self.as_inner().x()
                + operand.as_inner().xz(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().y() * self.as_inner().y()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.as_inner().xy() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.as_inner().xz() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.as_inner().yt() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().zt() * self.as_inner().x() * self.as_inner().z()
                + operand.as_inner().xt(),
            -(operand.as_inner().yz())
                + -T::TWO * operand.as_inner().xy() * self.as_inner().x() * self.as_inner().z()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.as_inner().xz() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().yz() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.as_inner().yz() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.as_inner().zt() * self.as_inner().t() * self.as_inner().y(),
            -(operand.as_inner().yt())
                + -T::TWO * operand.as_inner().xy() * self.as_inner().t() * self.as_inner().x()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.as_inner().xt() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().yt() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.as_inner().yz() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.as_inner().zt() * self.as_inner().y() * self.as_inner().z(),
            -(operand.as_inner().zt())
                + -T::TWO * operand.as_inner().xz() * self.as_inner().t() * self.as_inner().x()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().t() * self.as_inner().y()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.as_inner().xt() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.as_inner().yt() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.as_inner().zt() * self.as_inner().z() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Vector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            self.t() * operand.s() * self.t()
                + self.t() * operand.xt() * self.x()
                + self.t() * operand.yt() * self.y()
                + self.t() * operand.zt() * self.z()
                - self.x() * operand.s() * self.x()
                - self.x() * operand.xt() * self.t()
                + self.x() * operand.xy() * self.y()
                + self.x() * operand.xz() * self.z()
                - self.y() * operand.s() * self.y()
                - self.y() * operand.xy() * self.x()
                - self.y() * operand.yt() * self.t()
                + self.y() * operand.yz() * self.z()
                - self.z() * operand.s() * self.z()
                - self.z() * operand.xz() * self.x()
                - self.z() * operand.yz() * self.y()
                - self.z() * operand.zt() * self.t(),
            -(self.t() * operand.xt() * self.y())
                + self.t() * operand.xy() * self.t()
                + self.t() * operand.xyzt() * self.z()
                + self.t() * operand.yt() * self.x()
                + self.x() * operand.s() * self.y()
                + self.x() * operand.xy() * self.x()
                + self.x() * operand.yt() * self.t()
                - self.x() * operand.yz() * self.z()
                - self.y() * operand.s() * self.x()
                - self.y() * operand.xt() * self.t()
                + self.y() * operand.xy() * self.y()
                + self.y() * operand.xz() * self.z()
                - self.z() * operand.xy() * self.z()
                - self.z() * operand.xyzt() * self.t()
                + self.z() * operand.xz() * self.y()
                - self.z() * operand.yz() * self.x(),
            -(self.t() * operand.xt() * self.z()) - self.t() * operand.xyzt() * self.y()
                + self.t() * operand.xz() * self.t()
                + self.t() * operand.zt() * self.x()
                + self.x() * operand.s() * self.z()
                + self.x() * operand.xz() * self.x()
                + self.x() * operand.yz() * self.y()
                + self.x() * operand.zt() * self.t()
                + self.y() * operand.xy() * self.z()
                + self.y() * operand.xyzt() * self.t()
                - self.y() * operand.xz() * self.y()
                + self.y() * operand.yz() * self.x()
                - self.z() * operand.s() * self.x()
                - self.z() * operand.xt() * self.t()
                + self.z() * operand.xy() * self.y()
                + self.z() * operand.xz() * self.z(),
            -(self.t() * operand.s() * self.x()) - self.t() * operand.xt() * self.t()
                + self.t() * operand.xy() * self.y()
                + self.t() * operand.xz() * self.z()
                + self.x() * operand.s() * self.t()
                + self.x() * operand.xt() * self.x()
                + self.x() * operand.yt() * self.y()
                + self.x() * operand.zt() * self.z()
                - self.y() * operand.xt() * self.y()
                + self.y() * operand.xy() * self.t()
                + self.y() * operand.xyzt() * self.z()
                + self.y() * operand.yt() * self.x()
                - self.z() * operand.xt() * self.z()
                - self.z() * operand.xyzt() * self.y()
                + self.z() * operand.xz() * self.t()
                + self.z() * operand.zt() * self.x(),
            self.t() * operand.xyzt() * self.x() - self.t() * operand.yt() * self.z()
                + self.t() * operand.yz() * self.t()
                + self.t() * operand.zt() * self.y()
                - self.x() * operand.xy() * self.z()
                - self.x() * operand.xyzt() * self.t()
                + self.x() * operand.xz() * self.y()
                - self.x() * operand.yz() * self.x()
                + self.y() * operand.s() * self.z()
                + self.y() * operand.xz() * self.x()
                + self.y() * operand.yz() * self.y()
                + self.y() * operand.zt() * self.t()
                - self.z() * operand.s() * self.y()
                - self.z() * operand.xy() * self.x()
                - self.z() * operand.yt() * self.t()
                + self.z() * operand.yz() * self.z(),
            -(self.t() * operand.s() * self.y())
                - self.t() * operand.xy() * self.x()
                - self.t() * operand.yt() * self.t()
                + self.t() * operand.yz() * self.z()
                + self.x() * operand.xt() * self.y()
                - self.x() * operand.xy() * self.t()
                - self.x() * operand.xyzt() * self.z()
                - self.x() * operand.yt() * self.x()
                + self.y() * operand.s() * self.t()
                + self.y() * operand.xt() * self.x()
                + self.y() * operand.yt() * self.y()
                + self.y() * operand.zt() * self.z()
                + self.z() * operand.xyzt() * self.x()
                - self.z() * operand.yt() * self.z()
                + self.z() * operand.yz() * self.t()
                + self.z() * operand.zt() * self.y(),
            -(self.t() * operand.s() * self.z())
                - self.t() * operand.xz() * self.x()
                - self.t() * operand.yz() * self.y()
                - self.t() * operand.zt() * self.t()
                + self.x() * operand.xt() * self.z()
                + self.x() * operand.xyzt() * self.y()
                - self.x() * operand.xz() * self.t()
                - self.x() * operand.zt() * self.x()
                - self.y() * operand.xyzt() * self.x()
                + self.y() * operand.yt() * self.z()
                - self.y() * operand.yz() * self.t()
                - self.y() * operand.zt() * self.y()
                + self.z() * operand.s() * self.t()
                + self.z() * operand.xt() * self.x()
                + self.z() * operand.yt() * self.y()
                + self.z() * operand.zt() * self.z(),
            -(self.t() * operand.xy() * self.z()) - self.t() * operand.xyzt() * self.t()
                + self.t() * operand.xz() * self.y()
                - self.t() * operand.yz() * self.x()
                + self.x() * operand.xyzt() * self.x()
                - self.x() * operand.yt() * self.z()
                + self.x() * operand.yz() * self.t()
                + self.x() * operand.zt() * self.y()
                + self.y() * operand.xt() * self.z()
                + self.y() * operand.xyzt() * self.y()
                - self.y() * operand.xz() * self.t()
                - self.y() * operand.zt() * self.x()
                - self.z() * operand.xt() * self.y()
                + self.z() * operand.xy() * self.t()
                + self.z() * operand.xyzt() * self.z()
                + self.z() * operand.yt() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Unit<Vector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.s()),
            -T::TWO * operand.xt() * self.as_inner().t() * self.as_inner().y()
                + -T::TWO * operand.xy() * self.as_inner().z() * self.as_inner().z()
                + -T::TWO * operand.yz() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.xy() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.xz() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.yt() * self.as_inner().t() * self.as_inner().x()
                + operand.xy(),
            -T::TWO * operand.xt() * self.as_inner().t() * self.as_inner().z()
                + -T::TWO * operand.xz() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.xy() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.xz() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.yz() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.zt() * self.as_inner().t() * self.as_inner().x()
                + operand.xz(),
            -T::TWO * operand.xt() * self.as_inner().y() * self.as_inner().y()
                + -T::TWO * operand.xt() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.xy() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.xz() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.yt() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.zt() * self.as_inner().x() * self.as_inner().z()
                + operand.xt(),
            -(operand.yz())
                + -T::TWO * operand.xy() * self.as_inner().x() * self.as_inner().z()
                + -T::TWO * operand.yt() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.xz() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.yz() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.yz() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.zt() * self.as_inner().t() * self.as_inner().y(),
            -(operand.yt())
                + -T::TWO * operand.xy() * self.as_inner().t() * self.as_inner().x()
                + -T::TWO * operand.yt() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.xt() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.yt() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.yz() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.zt() * self.as_inner().y() * self.as_inner().z(),
            -(operand.zt())
                + -T::TWO * operand.xz() * self.as_inner().t() * self.as_inner().x()
                + -T::TWO * operand.yz() * self.as_inner().t() * self.as_inner().y()
                + -T::TWO * operand.zt() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.xt() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.yt() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.zt() * self.as_inner().z() * self.as_inner().z(),
            operand.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Vector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.as_inner().s() * self.x() * self.x())
                + -(operand.as_inner().s() * self.y() * self.y())
                + -(operand.as_inner().s() * self.z() * self.z())
                + operand.as_inner().s() * self.t() * self.t(),
            -(operand.as_inner().xy() * self.z() * self.z())
                + -T::TWO * operand.as_inner().xt() * self.t() * self.y()
                + -T::TWO * operand.as_inner().yz() * self.x() * self.z()
                + T::TWO * operand.as_inner().xz() * self.y() * self.z()
                + T::TWO * operand.as_inner().yt() * self.t() * self.x()
                + operand.as_inner().xy() * self.t() * self.t()
                + operand.as_inner().xy() * self.x() * self.x()
                + operand.as_inner().xy() * self.y() * self.y(),
            -(operand.as_inner().xz() * self.y() * self.y())
                + -T::TWO * operand.as_inner().xt() * self.t() * self.z()
                + T::TWO * operand.as_inner().xy() * self.y() * self.z()
                + T::TWO * operand.as_inner().yz() * self.x() * self.y()
                + T::TWO * operand.as_inner().zt() * self.t() * self.x()
                + operand.as_inner().xz() * self.t() * self.t()
                + operand.as_inner().xz() * self.x() * self.x()
                + operand.as_inner().xz() * self.z() * self.z(),
            -(operand.as_inner().xt() * self.t() * self.t())
                + -(operand.as_inner().xt() * self.y() * self.y())
                + -(operand.as_inner().xt() * self.z() * self.z())
                + T::TWO * operand.as_inner().xy() * self.t() * self.y()
                + T::TWO * operand.as_inner().xz() * self.t() * self.z()
                + T::TWO * operand.as_inner().yt() * self.x() * self.y()
                + T::TWO * operand.as_inner().zt() * self.x() * self.z()
                + operand.as_inner().xt() * self.x() * self.x(),
            -(operand.as_inner().yz() * self.x() * self.x())
                + -T::TWO * operand.as_inner().xy() * self.x() * self.z()
                + -T::TWO * operand.as_inner().yt() * self.t() * self.z()
                + T::TWO * operand.as_inner().xz() * self.x() * self.y()
                + T::TWO * operand.as_inner().zt() * self.t() * self.y()
                + operand.as_inner().yz() * self.t() * self.t()
                + operand.as_inner().yz() * self.y() * self.y()
                + operand.as_inner().yz() * self.z() * self.z(),
            -(operand.as_inner().yt() * self.t() * self.t())
                + -(operand.as_inner().yt() * self.x() * self.x())
                + -(operand.as_inner().yt() * self.z() * self.z())
                + -T::TWO * operand.as_inner().xy() * self.t() * self.x()
                + T::TWO * operand.as_inner().xt() * self.x() * self.y()
                + T::TWO * operand.as_inner().yz() * self.t() * self.z()
                + T::TWO * operand.as_inner().zt() * self.y() * self.z()
                + operand.as_inner().yt() * self.y() * self.y(),
            -(operand.as_inner().zt() * self.t() * self.t())
                + -(operand.as_inner().zt() * self.x() * self.x())
                + -(operand.as_inner().zt() * self.y() * self.y())
                + -T::TWO * operand.as_inner().xz() * self.t() * self.x()
                + -T::TWO * operand.as_inner().yz() * self.t() * self.y()
                + T::TWO * operand.as_inner().xt() * self.x() * self.z()
                + T::TWO * operand.as_inner().yt() * self.y() * self.z()
                + operand.as_inner().zt() * self.z() * self.z(),
            -(operand.as_inner().xyzt() * self.t() * self.t())
                + operand.as_inner().xyzt() * self.x() * self.x()
                + operand.as_inner().xyzt() * self.y() * self.y()
                + operand.as_inner().xyzt() * self.z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Unit<Vector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.as_inner().s()),
            -T::TWO * operand.as_inner().xt() * self.as_inner().t() * self.as_inner().y()
                + -T::TWO * operand.as_inner().xy() * self.as_inner().z() * self.as_inner().z()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.as_inner().xy() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.as_inner().xz() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.as_inner().yt() * self.as_inner().t() * self.as_inner().x()
                + operand.as_inner().xy(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().t() * self.as_inner().z()
                + -T::TWO * operand.as_inner().xz() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.as_inner().xy() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.as_inner().xz() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.as_inner().yz() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().zt() * self.as_inner().t() * self.as_inner().x()
                + operand.as_inner().xz(),
            -T::TWO * operand.as_inner().xt() * self.as_inner().y() * self.as_inner().y()
                + -T::TWO * operand.as_inner().xt() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.as_inner().xy() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.as_inner().xz() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.as_inner().yt() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().zt() * self.as_inner().x() * self.as_inner().z()
                + operand.as_inner().xt(),
            -(operand.as_inner().yz())
                + -T::TWO * operand.as_inner().xy() * self.as_inner().x() * self.as_inner().z()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.as_inner().xz() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().yz() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.as_inner().yz() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.as_inner().zt() * self.as_inner().t() * self.as_inner().y(),
            -(operand.as_inner().yt())
                + -T::TWO * operand.as_inner().xy() * self.as_inner().t() * self.as_inner().x()
                + -T::TWO * operand.as_inner().yt() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.as_inner().xt() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().yt() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.as_inner().yz() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.as_inner().zt() * self.as_inner().y() * self.as_inner().z(),
            -(operand.as_inner().zt())
                + -T::TWO * operand.as_inner().xz() * self.as_inner().t() * self.as_inner().x()
                + -T::TWO * operand.as_inner().yz() * self.as_inner().t() * self.as_inner().y()
                + -T::TWO * operand.as_inner().zt() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.as_inner().xt() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.as_inner().yt() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.as_inner().zt() * self.as_inner().z() * self.as_inner().z(),
            operand.as_inner().xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Vector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(self.t() * operand.xyzt() * self.t())
                + self.x() * operand.xyzt() * self.x()
                + self.y() * operand.xyzt() * self.y()
                + self.z() * operand.xyzt() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Unit<Vector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Vector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(operand.as_inner().xyzt() * self.t() * self.t())
                + operand.as_inner().xyzt() * self.x() * self.x()
                + operand.as_inner().xyzt() * self.y() * self.y()
                + operand.as_inner().xyzt() * self.z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Unit<Vector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.as_inner().xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.t() * operand.s() * self.t()
                - self.x() * operand.s() * self.x()
                - self.y() * operand.s() * self.y()
                - self.z() * operand.s() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(operand.as_inner().s() * self.x() * self.x())
                + -(operand.as_inner().s() * self.y() * self.y())
                + -(operand.as_inner().s() * self.z() * self.z())
                + operand.as_inner().s() * self.t() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(self.t() * operand.xyt() * self.z())
                + self.t() * operand.xyz() * self.t()
                + self.t() * operand.xzt() * self.y()
                - self.t() * operand.yzt() * self.x()
                + self.x() * operand.xyz() * self.x()
                - self.x() * operand.yzt() * self.t()
                + self.y() * operand.xyz() * self.y()
                + self.y() * operand.xzt() * self.t()
                - self.z() * operand.xyt() * self.t()
                + self.z() * operand.xyz() * self.z(),
            -(self.t() * operand.xyt() * self.t())
                + self.t() * operand.xyz() * self.z()
                + self.x() * operand.xyt() * self.x()
                - self.x() * operand.yzt() * self.z()
                + self.y() * operand.xyt() * self.y()
                + self.y() * operand.xzt() * self.z()
                - self.z() * operand.xyt() * self.z()
                + self.z() * operand.xyz() * self.t()
                + self.z() * operand.xzt() * self.y()
                - self.z() * operand.yzt() * self.x(),
            -(self.t() * operand.xyz() * self.y()) - self.t() * operand.xzt() * self.t()
                + self.x() * operand.xzt() * self.x()
                + self.x() * operand.yzt() * self.y()
                + self.y() * operand.xyt() * self.z()
                - self.y() * operand.xyz() * self.t()
                - self.y() * operand.xzt() * self.y()
                + self.y() * operand.yzt() * self.x()
                + self.z() * operand.xyt() * self.y()
                + self.z() * operand.xzt() * self.z(),
            self.t() * operand.xyz() * self.x()
                - self.t() * operand.yzt() * self.t()
                - self.x() * operand.xyt() * self.z()
                + self.x() * operand.xyz() * self.t()
                + self.x() * operand.xzt() * self.y()
                - self.x() * operand.yzt() * self.x()
                + self.y() * operand.xzt() * self.x()
                + self.y() * operand.yzt() * self.y()
                - self.z() * operand.xyt() * self.x()
                + self.z() * operand.yzt() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Trivector<T>> for Unit<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.xyt() * self.as_inner().t() * self.as_inner().z()
                + -T::TWO * operand.yzt() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.xyz() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.xzt() * self.as_inner().t() * self.as_inner().y()
                + operand.xyz(),
            -T::TWO * operand.xyt() * self.as_inner().z() * self.as_inner().z()
                + -T::TWO * operand.yzt() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.xyz() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.xzt() * self.as_inner().y() * self.as_inner().z()
                + operand.xyt(),
            -T::TWO * operand.xyz() * self.as_inner().t() * self.as_inner().y()
                + -T::TWO * operand.xzt() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.xyt() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.yzt() * self.as_inner().x() * self.as_inner().y()
                + operand.xzt(),
            -(operand.yzt())
                + -T::TWO * operand.xyt() * self.as_inner().x() * self.as_inner().z()
                + -T::TWO * operand.yzt() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.xyz() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.xzt() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.yzt() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.yzt() * self.as_inner().z() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Trivector<T>>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.as_inner().xyt() * self.t() * self.z()
                + -T::TWO * operand.as_inner().yzt() * self.t() * self.x()
                + T::TWO * operand.as_inner().xzt() * self.t() * self.y()
                + operand.as_inner().xyz() * self.t() * self.t()
                + operand.as_inner().xyz() * self.x() * self.x()
                + operand.as_inner().xyz() * self.y() * self.y()
                + operand.as_inner().xyz() * self.z() * self.z(),
            -(operand.as_inner().xyt() * self.t() * self.t())
                + -(operand.as_inner().xyt() * self.z() * self.z())
                + -T::TWO * operand.as_inner().yzt() * self.x() * self.z()
                + T::TWO * operand.as_inner().xyz() * self.t() * self.z()
                + T::TWO * operand.as_inner().xzt() * self.y() * self.z()
                + operand.as_inner().xyt() * self.x() * self.x()
                + operand.as_inner().xyt() * self.y() * self.y(),
            -(operand.as_inner().xzt() * self.t() * self.t())
                + -(operand.as_inner().xzt() * self.y() * self.y())
                + -T::TWO * operand.as_inner().xyz() * self.t() * self.y()
                + T::TWO * operand.as_inner().xyt() * self.y() * self.z()
                + T::TWO * operand.as_inner().yzt() * self.x() * self.y()
                + operand.as_inner().xzt() * self.x() * self.x()
                + operand.as_inner().xzt() * self.z() * self.z(),
            -(operand.as_inner().yzt() * self.t() * self.t())
                + -(operand.as_inner().yzt() * self.x() * self.x())
                + -T::TWO * operand.as_inner().xyt() * self.x() * self.z()
                + T::TWO * operand.as_inner().xyz() * self.t() * self.x()
                + T::TWO * operand.as_inner().xzt() * self.x() * self.y()
                + operand.as_inner().yzt() * self.y() * self.y()
                + operand.as_inner().yzt() * self.z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Trivector<T>>> for Unit<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -T::TWO * operand.as_inner().xyt() * self.as_inner().t() * self.as_inner().z()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().t() * self.as_inner().y()
                + operand.as_inner().xyz(),
            -T::TWO * operand.as_inner().xyt() * self.as_inner().z() * self.as_inner().z()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().y() * self.as_inner().z()
                + operand.as_inner().xyt(),
            -T::TWO * operand.as_inner().xyz() * self.as_inner().t() * self.as_inner().y()
                + -T::TWO * operand.as_inner().xzt() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.as_inner().xyt() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().x() * self.as_inner().y()
                + operand.as_inner().xzt(),
            -(operand.as_inner().yzt())
                + -T::TWO * operand.as_inner().xyt() * self.as_inner().x() * self.as_inner().z()
                + -T::TWO * operand.as_inner().yzt() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.as_inner().xyz() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.as_inner().xzt() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.as_inner().yzt() * self.as_inner().z() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.t() * operand.t() * self.x()) + self.t() * operand.x() * self.t()
                - self.x() * operand.t() * self.t()
                + self.x() * operand.x() * self.x()
                + self.x() * operand.y() * self.y()
                + self.x() * operand.z() * self.z()
                - self.y() * operand.x() * self.y()
                + self.y() * operand.y() * self.x()
                - self.z() * operand.x() * self.z()
                + self.z() * operand.z() * self.x(),
            -(self.t() * operand.t() * self.y())
                + self.t() * operand.y() * self.t()
                + self.x() * operand.x() * self.y()
                - self.x() * operand.y() * self.x()
                - self.y() * operand.t() * self.t()
                + self.y() * operand.x() * self.x()
                + self.y() * operand.y() * self.y()
                + self.y() * operand.z() * self.z()
                - self.z() * operand.y() * self.z()
                + self.z() * operand.z() * self.y(),
            -(self.t() * operand.t() * self.z())
                + self.t() * operand.z() * self.t()
                + self.x() * operand.x() * self.z()
                - self.x() * operand.z() * self.x()
                + self.y() * operand.y() * self.z()
                - self.y() * operand.z() * self.y()
                - self.z() * operand.t() * self.t()
                + self.z() * operand.x() * self.x()
                + self.z() * operand.y() * self.y()
                + self.z() * operand.z() * self.z(),
            -(self.t() * operand.t() * self.t())
                + self.t() * operand.x() * self.x()
                + self.t() * operand.y() * self.y()
                + self.t() * operand.z() * self.z()
                - self.x() * operand.t() * self.x()
                + self.x() * operand.x() * self.t()
                - self.y() * operand.t() * self.y()
                + self.y() * operand.y() * self.t()
                - self.z() * operand.t() * self.z()
                + self.z() * operand.z() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -T::TWO * operand.t() * self.as_inner().t() * self.as_inner().x()
                + -T::TWO * operand.x() * self.as_inner().y() * self.as_inner().y()
                + -T::TWO * operand.x() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.x() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.y() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.z() * self.as_inner().x() * self.as_inner().z()
                + operand.x(),
            -(operand.y())
                + -T::TWO * operand.t() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.x() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.y() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.z() * self.as_inner().y() * self.as_inner().z(),
            -(operand.z())
                + -T::TWO * operand.t() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.x() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.y() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.z() * self.as_inner().z() * self.as_inner().z(),
            -(operand.t())
                + -T::TWO * operand.t() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.x() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.y() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.z() * self.as_inner().t() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(operand.as_inner().x() * self.y() * self.y())
                + -(operand.as_inner().x() * self.z() * self.z())
                + -T::TWO * operand.as_inner().t() * self.t() * self.x()
                + T::TWO * operand.as_inner().y() * self.x() * self.y()
                + T::TWO * operand.as_inner().z() * self.x() * self.z()
                + operand.as_inner().x() * self.t() * self.t()
                + operand.as_inner().x() * self.x() * self.x(),
            -(operand.as_inner().y() * self.x() * self.x())
                + -(operand.as_inner().y() * self.z() * self.z())
                + -T::TWO * operand.as_inner().t() * self.t() * self.y()
                + T::TWO * operand.as_inner().x() * self.x() * self.y()
                + T::TWO * operand.as_inner().z() * self.y() * self.z()
                + operand.as_inner().y() * self.t() * self.t()
                + operand.as_inner().y() * self.y() * self.y(),
            -(operand.as_inner().z() * self.x() * self.x())
                + -(operand.as_inner().z() * self.y() * self.y())
                + -T::TWO * operand.as_inner().t() * self.t() * self.z()
                + T::TWO * operand.as_inner().x() * self.x() * self.z()
                + T::TWO * operand.as_inner().y() * self.y() * self.z()
                + operand.as_inner().z() * self.t() * self.t()
                + operand.as_inner().z() * self.z() * self.z(),
            -(operand.as_inner().t() * self.t() * self.t())
                + -(operand.as_inner().t() * self.x() * self.x())
                + -(operand.as_inner().t() * self.y() * self.y())
                + -(operand.as_inner().t() * self.z() * self.z())
                + T::TWO * operand.as_inner().x() * self.t() * self.x()
                + T::TWO * operand.as_inner().y() * self.t() * self.y()
                + T::TWO * operand.as_inner().z() * self.t() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -T::TWO * operand.as_inner().t() * self.as_inner().t() * self.as_inner().x()
                + -T::TWO * operand.as_inner().x() * self.as_inner().y() * self.as_inner().y()
                + -T::TWO * operand.as_inner().x() * self.as_inner().z() * self.as_inner().z()
                + T::TWO * operand.as_inner().x() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.as_inner().y() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().z() * self.as_inner().x() * self.as_inner().z()
                + operand.as_inner().x(),
            -(operand.as_inner().y())
                + -T::TWO * operand.as_inner().t() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.as_inner().x() * self.as_inner().x() * self.as_inner().y()
                + T::TWO * operand.as_inner().y() * self.as_inner().y() * self.as_inner().y()
                + T::TWO * operand.as_inner().z() * self.as_inner().y() * self.as_inner().z(),
            -(operand.as_inner().z())
                + -T::TWO * operand.as_inner().t() * self.as_inner().t() * self.as_inner().z()
                + T::TWO * operand.as_inner().x() * self.as_inner().x() * self.as_inner().z()
                + T::TWO * operand.as_inner().y() * self.as_inner().y() * self.as_inner().z()
                + T::TWO * operand.as_inner().z() * self.as_inner().z() * self.as_inner().z(),
            -(operand.as_inner().t())
                + -T::TWO * operand.as_inner().t() * self.as_inner().t() * self.as_inner().t()
                + T::TWO * operand.as_inner().x() * self.as_inner().t() * self.as_inner().x()
                + T::TWO * operand.as_inner().y() * self.as_inner().t() * self.as_inner().y()
                + T::TWO * operand.as_inner().z() * self.as_inner().t() * self.as_inner().z(),
        )
    }
}
impl<T: Float> Transform<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Unit<Bivector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Unit<Bivector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Bivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Unit<Bivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Bivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Unit<Bivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Unit<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Trivector<T>>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Trivector<T>>> for Unit<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Eventor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Unit<Eventor<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Eventor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Unit<Eventor<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Unit<Eventor<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Unit<Eventor<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Eventor<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Unit<Eventor<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Eventor<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Unit<Eventor<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Eventor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unit<Eventor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Eventor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Unit<Eventor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Eventor<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Unit<Eventor<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Trivector<T>>> for Eventor<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Trivector<T>>> for Unit<Eventor<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Eventor<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Unit<Eventor<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Eventor<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Unit<Eventor<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Pseudoscalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Pseudoscalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Pseudoscalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Unit<Pseudoscalar<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Pseudoscalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Pseudoscalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Trivector<T>>> for Pseudoscalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Trivector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Pseudoscalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Pseudoscalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Unit<Scalar<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Unit<Scalar<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Unit<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Trivector<T>>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Trivector<T>>> for Unit<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Unit<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Unit<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Trivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Unit<Trivector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Trivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Unit<Trivector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Trivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Unit<Trivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Trivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Unit<Trivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unit<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Unit<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Trivector<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Trivector<T>>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Unit<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Unit<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Vector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Unit<Vector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Vector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Unit<Vector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Vector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Unit<Vector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Vector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Unit<Vector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Trivector<T>> for Unit<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Trivector<T>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Trivector<T>>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Trivector<T>>> for Unit<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Trivector<T>>) -> Trivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (-(self.xt() * operand.xt() * self.xy()) + self.xt() * operand.xy() * self.xt()
                - self.xt() * operand.yz() * self.zt()
                + self.xt() * operand.zt() * self.yz()
                - self.xy() * operand.xt() * self.xt()
                + self.xy() * operand.xy() * self.xy()
                + self.xy() * operand.xz() * self.xz()
                - self.xy() * operand.yt() * self.yt()
                + self.xy() * operand.yz() * self.yz()
                - self.xy() * operand.zt() * self.zt()
                - self.xz() * operand.xy() * self.xz()
                + self.xz() * operand.xz() * self.xy()
                + self.xz() * operand.yt() * self.zt()
                - self.xz() * operand.zt() * self.yt()
                + self.yt() * operand.xy() * self.yt()
                + self.yt() * operand.xz() * self.zt()
                - self.yt() * operand.yt() * self.xy()
                - self.yt() * operand.zt() * self.xz()
                - self.yz() * operand.xt() * self.zt()
                - self.yz() * operand.xy() * self.yz()
                + self.yz() * operand.yz() * self.xy()
                + self.yz() * operand.zt() * self.xt()
                - self.zt() * operand.xt() * self.yz()
                - self.zt() * operand.xy() * self.zt()
                + self.zt() * operand.xz() * self.yt()
                + self.zt() * operand.yt() * self.xz()
                - self.zt() * operand.yz() * self.xt()
                - self.zt() * operand.zt() * self.xy())
                * inv_norm_sq,
            (-(self.xt() * operand.xt() * self.xz()) + self.xt() * operand.xz() * self.xt()
                - self.xt() * operand.yt() * self.yz()
                + self.xt() * operand.yz() * self.yt()
                + self.xy() * operand.xy() * self.xz()
                - self.xy() * operand.xz() * self.xy()
                - self.xy() * operand.yt() * self.zt()
                + self.xy() * operand.zt() * self.yt()
                - self.xz() * operand.xt() * self.xt()
                + self.xz() * operand.xy() * self.xy()
                + self.xz() * operand.xz() * self.xz()
                - self.xz() * operand.yt() * self.yt()
                + self.xz() * operand.yz() * self.yz()
                - self.xz() * operand.zt() * self.zt()
                + self.yt() * operand.xt() * self.yz()
                + self.yt() * operand.xy() * self.zt()
                - self.yt() * operand.xz() * self.yt()
                - self.yt() * operand.yt() * self.xz()
                + self.yt() * operand.yz() * self.xt()
                + self.yt() * operand.zt() * self.xy()
                + self.yz() * operand.xt() * self.yt()
                - self.yz() * operand.xz() * self.yz()
                - self.yz() * operand.yt() * self.xt()
                + self.yz() * operand.yz() * self.xz()
                + self.zt() * operand.xy() * self.yt()
                + self.zt() * operand.xz() * self.zt()
                - self.zt() * operand.yt() * self.xy()
                - self.zt() * operand.zt() * self.xz())
                * inv_norm_sq,
            (-(self.xt() * operand.xt() * self.xt())
                + self.xt() * operand.xy() * self.xy()
                + self.xt() * operand.xz() * self.xz()
                - self.xt() * operand.yt() * self.yt()
                + self.xt() * operand.yz() * self.yz()
                - self.xt() * operand.zt() * self.zt()
                - self.xy() * operand.xt() * self.xy()
                + self.xy() * operand.xy() * self.xt()
                - self.xy() * operand.yz() * self.zt()
                + self.xy() * operand.zt() * self.yz()
                - self.xz() * operand.xt() * self.xz()
                + self.xz() * operand.xz() * self.xt()
                - self.xz() * operand.yt() * self.yz()
                + self.xz() * operand.yz() * self.yt()
                + self.yt() * operand.xt() * self.yt()
                - self.yt() * operand.xz() * self.yz()
                - self.yt() * operand.yt() * self.xt()
                + self.yt() * operand.yz() * self.xz()
                + self.yz() * operand.xt() * self.yz()
                + self.yz() * operand.xy() * self.zt()
                - self.yz() * operand.xz() * self.yt()
                - self.yz() * operand.yt() * self.xz()
                + self.yz() * operand.yz() * self.xt()
                + self.yz() * operand.zt() * self.xy()
                + self.zt() * operand.xt() * self.zt()
                + self.zt() * operand.xy() * self.yz()
                - self.zt() * operand.yz() * self.xy()
                - self.zt() * operand.zt() * self.xt())
                * inv_norm_sq,
            (-(self.xt() * operand.xt() * self.yz()) - self.xt() * operand.xy() * self.zt()
                + self.xt() * operand.xz() * self.yt()
                + self.xt() * operand.yt() * self.xz()
                - self.xt() * operand.yz() * self.xt()
                - self.xt() * operand.zt() * self.xy()
                + self.xy() * operand.xt() * self.zt()
                + self.xy() * operand.xy() * self.yz()
                - self.xy() * operand.yz() * self.xy()
                - self.xy() * operand.zt() * self.xt()
                - self.xz() * operand.xt() * self.yt()
                + self.xz() * operand.xz() * self.yz()
                + self.xz() * operand.yt() * self.xt()
                - self.xz() * operand.yz() * self.xz()
                - self.yt() * operand.xt() * self.xz()
                + self.yt() * operand.xz() * self.xt()
                - self.yt() * operand.yt() * self.yz()
                + self.yt() * operand.yz() * self.yt()
                - self.yz() * operand.xt() * self.xt()
                + self.yz() * operand.xy() * self.xy()
                + self.yz() * operand.xz() * self.xz()
                - self.yz() * operand.yt() * self.yt()
                + self.yz() * operand.yz() * self.yz()
                - self.yz() * operand.zt() * self.zt()
                + self.zt() * operand.xt() * self.xy()
                - self.zt() * operand.xy() * self.xt()
                + self.zt() * operand.yz() * self.zt()
                - self.zt() * operand.zt() * self.yz())
                * inv_norm_sq,
            (-(self.xt() * operand.xt() * self.yt())
                + self.xt() * operand.xz() * self.yz()
                + self.xt() * operand.yt() * self.xt()
                - self.xt() * operand.yz() * self.xz()
                + self.xy() * operand.xy() * self.yt()
                + self.xy() * operand.xz() * self.zt()
                - self.xy() * operand.yt() * self.xy()
                - self.xy() * operand.zt() * self.xz()
                - self.xz() * operand.xt() * self.yz()
                - self.xz() * operand.xy() * self.zt()
                + self.xz() * operand.xz() * self.yt()
                + self.xz() * operand.yt() * self.xz()
                - self.xz() * operand.yz() * self.xt()
                - self.xz() * operand.zt() * self.xy()
                - self.yt() * operand.xt() * self.xt()
                + self.yt() * operand.xy() * self.xy()
                + self.yt() * operand.xz() * self.xz()
                - self.yt() * operand.yt() * self.yt()
                + self.yt() * operand.yz() * self.yz()
                - self.yt() * operand.zt() * self.zt()
                - self.yz() * operand.xt() * self.xz()
                + self.yz() * operand.xz() * self.xt()
                - self.yz() * operand.yt() * self.yz()
                + self.yz() * operand.yz() * self.yt()
                - self.zt() * operand.xy() * self.xz()
                + self.zt() * operand.xz() * self.xy()
                + self.zt() * operand.yt() * self.zt()
                - self.zt() * operand.zt() * self.yt())
                * inv_norm_sq,
            (-(self.xt() * operand.xt() * self.zt()) - self.xt() * operand.xy() * self.yz()
                + self.xt() * operand.yz() * self.xy()
                + self.xt() * operand.zt() * self.xt()
                + self.xy() * operand.xt() * self.yz()
                + self.xy() * operand.xy() * self.zt()
                - self.xy() * operand.xz() * self.yt()
                - self.xy() * operand.yt() * self.xz()
                + self.xy() * operand.yz() * self.xt()
                + self.xy() * operand.zt() * self.xy()
                + self.xz() * operand.xy() * self.yt()
                + self.xz() * operand.xz() * self.zt()
                - self.xz() * operand.yt() * self.xy()
                - self.xz() * operand.zt() * self.xz()
                + self.yt() * operand.xy() * self.xz()
                - self.yt() * operand.xz() * self.xy()
                - self.yt() * operand.yt() * self.zt()
                + self.yt() * operand.zt() * self.yt()
                + self.yz() * operand.xt() * self.xy()
                - self.yz() * operand.xy() * self.xt()
                + self.yz() * operand.yz() * self.zt()
                - self.yz() * operand.zt() * self.yz()
                - self.zt() * operand.xt() * self.xt()
                + self.zt() * operand.xy() * self.xy()
                + self.zt() * operand.xz() * self.xz()
                - self.zt() * operand.yt() * self.yt()
                + self.zt() * operand.yz() * self.yz()
                - self.zt() * operand.zt() * self.zt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Eventor<T>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (-(self.xt() * operand.s() * self.xt()) - self.xt() * operand.xy() * self.yt()
                + self.xt() * operand.xyzt() * self.yz()
                - self.xt() * operand.xz() * self.zt()
                + self.xt() * operand.yt() * self.xy()
                + self.xt() * operand.zt() * self.xz()
                + self.xy() * operand.s() * self.xy()
                + self.xy() * operand.xt() * self.yt()
                + self.xy() * operand.xyzt() * self.zt()
                - self.xy() * operand.xz() * self.yz()
                - self.xy() * operand.yt() * self.xt()
                + self.xy() * operand.yz() * self.xz()
                + self.xz() * operand.s() * self.xz()
                + self.xz() * operand.xt() * self.zt()
                + self.xz() * operand.xy() * self.yz()
                - self.xz() * operand.xyzt() * self.yt()
                - self.xz() * operand.yz() * self.xy()
                - self.xz() * operand.zt() * self.xt()
                - self.yt() * operand.s() * self.yt()
                - self.yt() * operand.xt() * self.xy()
                + self.yt() * operand.xy() * self.xt()
                - self.yt() * operand.xyzt() * self.xz()
                - self.yt() * operand.yz() * self.zt()
                + self.yt() * operand.zt() * self.yz()
                + self.yz() * operand.s() * self.yz()
                - self.yz() * operand.xy() * self.xz()
                + self.yz() * operand.xyzt() * self.xt()
                + self.yz() * operand.xz() * self.xy()
                + self.yz() * operand.yt() * self.zt()
                - self.yz() * operand.zt() * self.yt()
                - self.zt() * operand.s() * self.zt()
                - self.zt() * operand.xt() * self.xz()
                + self.zt() * operand.xyzt() * self.xy()
                + self.zt() * operand.xz() * self.xt()
                - self.zt() * operand.yt() * self.yz()
                + self.zt() * operand.yz() * self.yt())
                * inv_norm_sq,
            (-(self.xt() * operand.s() * self.yt()) - self.xt() * operand.xt() * self.xy()
                + self.xt() * operand.xy() * self.xt()
                - self.xt() * operand.xyzt() * self.xz()
                - self.xt() * operand.yz() * self.zt()
                + self.xt() * operand.zt() * self.yz()
                - self.xy() * operand.xt() * self.xt()
                + self.xy() * operand.xy() * self.xy()
                + self.xy() * operand.xz() * self.xz()
                - self.xy() * operand.yt() * self.yt()
                + self.xy() * operand.yz() * self.yz()
                - self.xy() * operand.zt() * self.zt()
                + self.xz() * operand.s() * self.yz()
                - self.xz() * operand.xy() * self.xz()
                + self.xz() * operand.xyzt() * self.xt()
                + self.xz() * operand.xz() * self.xy()
                + self.xz() * operand.yt() * self.zt()
                - self.xz() * operand.zt() * self.yt()
                + self.yt() * operand.s() * self.xt()
                + self.yt() * operand.xy() * self.yt()
                - self.yt() * operand.xyzt() * self.yz()
                + self.yt() * operand.xz() * self.zt()
                - self.yt() * operand.yt() * self.xy()
                - self.yt() * operand.zt() * self.xz()
                - self.yz() * operand.s() * self.xz()
                - self.yz() * operand.xt() * self.zt()
                - self.yz() * operand.xy() * self.yz()
                + self.yz() * operand.xyzt() * self.yt()
                + self.yz() * operand.yz() * self.xy()
                + self.yz() * operand.zt() * self.xt()
                - self.zt() * operand.xt() * self.yz()
                - self.zt() * operand.xy() * self.zt()
                + self.zt() * operand.xz() * self.yt()
                + self.zt() * operand.yt() * self.xz()
                - self.zt() * operand.yz() * self.xt()
                - self.zt() * operand.zt() * self.xy())
                * inv_norm_sq,
            (-(self.xt() * operand.s() * self.zt()) - self.xt() * operand.xt() * self.xz()
                + self.xt() * operand.xyzt() * self.xy()
                + self.xt() * operand.xz() * self.xt()
                - self.xt() * operand.yt() * self.yz()
                + self.xt() * operand.yz() * self.yt()
                - self.xy() * operand.s() * self.yz()
                + self.xy() * operand.xy() * self.xz()
                - self.xy() * operand.xyzt() * self.xt()
                - self.xy() * operand.xz() * self.xy()
                - self.xy() * operand.yt() * self.zt()
                + self.xy() * operand.zt() * self.yt()
                - self.xz() * operand.xt() * self.xt()
                + self.xz() * operand.xy() * self.xy()
                + self.xz() * operand.xz() * self.xz()
                - self.xz() * operand.yt() * self.yt()
                + self.xz() * operand.yz() * self.yz()
                - self.xz() * operand.zt() * self.zt()
                + self.yt() * operand.xt() * self.yz()
                + self.yt() * operand.xy() * self.zt()
                - self.yt() * operand.xz() * self.yt()
                - self.yt() * operand.yt() * self.xz()
                + self.yt() * operand.yz() * self.xt()
                + self.yt() * operand.zt() * self.xy()
                + self.yz() * operand.s() * self.xy()
                + self.yz() * operand.xt() * self.yt()
                + self.yz() * operand.xyzt() * self.zt()
                - self.yz() * operand.xz() * self.yz()
                - self.yz() * operand.yt() * self.xt()
                + self.yz() * operand.yz() * self.xz()
                + self.zt() * operand.s() * self.xt()
                + self.zt() * operand.xy() * self.yt()
                - self.zt() * operand.xyzt() * self.yz()
                + self.zt() * operand.xz() * self.zt()
                - self.zt() * operand.yt() * self.xy()
                - self.zt() * operand.zt() * self.xz())
                * inv_norm_sq,
            (-(self.xt() * operand.xt() * self.xt())
                + self.xt() * operand.xy() * self.xy()
                + self.xt() * operand.xz() * self.xz()
                - self.xt() * operand.yt() * self.yt()
                + self.xt() * operand.yz() * self.yz()
                - self.xt() * operand.zt() * self.zt()
                - self.xy() * operand.s() * self.yt()
                - self.xy() * operand.xt() * self.xy()
                + self.xy() * operand.xy() * self.xt()
                - self.xy() * operand.xyzt() * self.xz()
                - self.xy() * operand.yz() * self.zt()
                + self.xy() * operand.zt() * self.yz()
                - self.xz() * operand.s() * self.zt()
                - self.xz() * operand.xt() * self.xz()
                + self.xz() * operand.xyzt() * self.xy()
                + self.xz() * operand.xz() * self.xt()
                - self.xz() * operand.yt() * self.yz()
                + self.xz() * operand.yz() * self.yt()
                + self.yt() * operand.s() * self.xy()
                + self.yt() * operand.xt() * self.yt()
                + self.yt() * operand.xyzt() * self.zt()
                - self.yt() * operand.xz() * self.yz()
                - self.yt() * operand.yt() * self.xt()
                + self.yt() * operand.yz() * self.xz()
                + self.yz() * operand.xt() * self.yz()
                + self.yz() * operand.xy() * self.zt()
                - self.yz() * operand.xz() * self.yt()
                - self.yz() * operand.yt() * self.xz()
                + self.yz() * operand.yz() * self.xt()
                + self.yz() * operand.zt() * self.xy()
                + self.zt() * operand.s() * self.xz()
                + self.zt() * operand.xt() * self.zt()
                + self.zt() * operand.xy() * self.yz()
                - self.zt() * operand.xyzt() * self.yt()
                - self.zt() * operand.yz() * self.xy()
                - self.zt() * operand.zt() * self.xt())
                * inv_norm_sq,
            (-(self.xt() * operand.xt() * self.yz()) - self.xt() * operand.xy() * self.zt()
                + self.xt() * operand.xz() * self.yt()
                + self.xt() * operand.yt() * self.xz()
                - self.xt() * operand.yz() * self.xt()
                - self.xt() * operand.zt() * self.xy()
                + self.xy() * operand.s() * self.xz()
                + self.xy() * operand.xt() * self.zt()
                + self.xy() * operand.xy() * self.yz()
                - self.xy() * operand.xyzt() * self.yt()
                - self.xy() * operand.yz() * self.xy()
                - self.xy() * operand.zt() * self.xt()
                - self.xz() * operand.s() * self.xy()
                - self.xz() * operand.xt() * self.yt()
                - self.xz() * operand.xyzt() * self.zt()
                + self.xz() * operand.xz() * self.yz()
                + self.xz() * operand.yt() * self.xt()
                - self.xz() * operand.yz() * self.xz()
                - self.yt() * operand.s() * self.zt()
                - self.yt() * operand.xt() * self.xz()
                + self.yt() * operand.xyzt() * self.xy()
                + self.yt() * operand.xz() * self.xt()
                - self.yt() * operand.yt() * self.yz()
                + self.yt() * operand.yz() * self.yt()
                - self.yz() * operand.xt() * self.xt()
                + self.yz() * operand.xy() * self.xy()
                + self.yz() * operand.xz() * self.xz()
                - self.yz() * operand.yt() * self.yt()
                + self.yz() * operand.yz() * self.yz()
                - self.yz() * operand.zt() * self.zt()
                + self.zt() * operand.s() * self.yt()
                + self.zt() * operand.xt() * self.xy()
                - self.zt() * operand.xy() * self.xt()
                + self.zt() * operand.xyzt() * self.xz()
                + self.zt() * operand.yz() * self.zt()
                - self.zt() * operand.zt() * self.yz())
                * inv_norm_sq,
            (-(self.xt() * operand.s() * self.xy())
                - self.xt() * operand.xt() * self.yt()
                - self.xt() * operand.xyzt() * self.zt()
                + self.xt() * operand.xz() * self.yz()
                + self.xt() * operand.yt() * self.xt()
                - self.xt() * operand.yz() * self.xz()
                + self.xy() * operand.s() * self.xt()
                + self.xy() * operand.xy() * self.yt()
                - self.xy() * operand.xyzt() * self.yz()
                + self.xy() * operand.xz() * self.zt()
                - self.xy() * operand.yt() * self.xy()
                - self.xy() * operand.zt() * self.xz()
                - self.xz() * operand.xt() * self.yz()
                - self.xz() * operand.xy() * self.zt()
                + self.xz() * operand.xz() * self.yt()
                + self.xz() * operand.yt() * self.xz()
                - self.xz() * operand.yz() * self.xt()
                - self.xz() * operand.zt() * self.xy()
                - self.yt() * operand.xt() * self.xt()
                + self.yt() * operand.xy() * self.xy()
                + self.yt() * operand.xz() * self.xz()
                - self.yt() * operand.yt() * self.yt()
                + self.yt() * operand.yz() * self.yz()
                - self.yt() * operand.zt() * self.zt()
                - self.yz() * operand.s() * self.zt()
                - self.yz() * operand.xt() * self.xz()
                + self.yz() * operand.xyzt() * self.xy()
                + self.yz() * operand.xz() * self.xt()
                - self.yz() * operand.yt() * self.yz()
                + self.yz() * operand.yz() * self.yt()
                + self.zt() * operand.s() * self.yz()
                - self.zt() * operand.xy() * self.xz()
                + self.zt() * operand.xyzt() * self.xt()
                + self.zt() * operand.xz() * self.xy()
                + self.zt() * operand.yt() * self.zt()
                - self.zt() * operand.zt() * self.yt())
                * inv_norm_sq,
            (-(self.xt() * operand.s() * self.xz())
                - self.xt() * operand.xt() * self.zt()
                - self.xt() * operand.xy() * self.yz()
                + self.xt() * operand.xyzt() * self.yt()
                + self.xt() * operand.yz() * self.xy()
                + self.xt() * operand.zt() * self.xt()
                + self.xy() * operand.xt() * self.yz()
                + self.xy() * operand.xy() * self.zt()
                - self.xy() * operand.xz() * self.yt()
                - self.xy() * operand.yt() * self.xz()
                + self.xy() * operand.yz() * self.xt()
                + self.xy() * operand.zt() * self.xy()
                + self.xz() * operand.s() * self.xt()
                + self.xz() * operand.xy() * self.yt()
                - self.xz() * operand.xyzt() * self.yz()
                + self.xz() * operand.xz() * self.zt()
                - self.xz() * operand.yt() * self.xy()
                - self.xz() * operand.zt() * self.xz()
                - self.yt() * operand.s() * self.yz()
                + self.yt() * operand.xy() * self.xz()
                - self.yt() * operand.xyzt() * self.xt()
                - self.yt() * operand.xz() * self.xy()
                - self.yt() * operand.yt() * self.zt()
                + self.yt() * operand.zt() * self.yt()
                + self.yz() * operand.s() * self.yt()
                + self.yz() * operand.xt() * self.xy()
                - self.yz() * operand.xy() * self.xt()
                + self.yz() * operand.xyzt() * self.xz()
                + self.yz() * operand.yz() * self.zt()
                - self.yz() * operand.zt() * self.yz()
                - self.zt() * operand.xt() * self.xt()
                + self.zt() * operand.xy() * self.xy()
                + self.zt() * operand.xz() * self.xz()
                - self.zt() * operand.yt() * self.yt()
                + self.zt() * operand.yz() * self.yz()
                - self.zt() * operand.zt() * self.zt())
                * inv_norm_sq,
            (-(self.xt() * operand.s() * self.yz()) + self.xt() * operand.xy() * self.xz()
                - self.xt() * operand.xyzt() * self.xt()
                - self.xt() * operand.xz() * self.xy()
                - self.xt() * operand.yt() * self.zt()
                + self.xt() * operand.zt() * self.yt()
                - self.xy() * operand.s() * self.zt()
                - self.xy() * operand.xt() * self.xz()
                + self.xy() * operand.xyzt() * self.xy()
                + self.xy() * operand.xz() * self.xt()
                - self.xy() * operand.yt() * self.yz()
                + self.xy() * operand.yz() * self.yt()
                + self.xz() * operand.s() * self.yt()
                + self.xz() * operand.xt() * self.xy()
                - self.xz() * operand.xy() * self.xt()
                + self.xz() * operand.xyzt() * self.xz()
                + self.xz() * operand.yz() * self.zt()
                - self.xz() * operand.zt() * self.yz()
                + self.yt() * operand.s() * self.xz()
                + self.yt() * operand.xt() * self.zt()
                + self.yt() * operand.xy() * self.yz()
                - self.yt() * operand.xyzt() * self.yt()
                - self.yt() * operand.yz() * self.xy()
                - self.yt() * operand.zt() * self.xt()
                - self.yz() * operand.s() * self.xt()
                - self.yz() * operand.xy() * self.yt()
                + self.yz() * operand.xyzt() * self.yz()
                - self.yz() * operand.xz() * self.zt()
                + self.yz() * operand.yt() * self.xy()
                + self.yz() * operand.zt() * self.xz()
                - self.zt() * operand.s() * self.xy()
                - self.zt() * operand.xt() * self.yt()
                - self.zt() * operand.xyzt() * self.zt()
                + self.zt() * operand.xz() * self.yz()
                + self.zt() * operand.yt() * self.xt()
                - self.zt() * operand.yz() * self.xz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Pseudoscalar<T>> for Bivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (-(self.xt() * operand.xyzt() * self.xt())
                + self.xy() * operand.xyzt() * self.xy()
                + self.xz() * operand.xyzt() * self.xz()
                - self.yt() * operand.xyzt() * self.yt()
                + self.yz() * operand.xyzt() * self.yz()
                - self.zt() * operand.xyzt() * self.zt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (-(self.xt() * operand.s() * self.xt())
                + self.xy() * operand.s() * self.xy()
                + self.xz() * operand.s() * self.xz()
                - self.yt() * operand.s() * self.yt()
                + self.yz() * operand.s() * self.yz()
                - self.zt() * operand.s() * self.zt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Trivector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked(
            (-(self.xt() * operand.xyt() * self.xz())
                + self.xt() * operand.xyz() * self.xt()
                + self.xt() * operand.xzt() * self.xy()
                + self.xy() * operand.xyz() * self.xy()
                + self.xy() * operand.xzt() * self.xt()
                + self.xy() * operand.yzt() * self.yt()
                - self.xz() * operand.xyt() * self.xt()
                + self.xz() * operand.xyz() * self.xz()
                + self.xz() * operand.yzt() * self.zt()
                - self.yt() * operand.xyt() * self.yz()
                + self.yt() * operand.xyz() * self.yt()
                + self.yt() * operand.yzt() * self.xy()
                - self.yz() * operand.xyt() * self.yt()
                + self.yz() * operand.xyz() * self.yz()
                - self.yz() * operand.xzt() * self.zt()
                + self.zt() * operand.xyz() * self.zt()
                - self.zt() * operand.xzt() * self.yz()
                + self.zt() * operand.yzt() * self.xz())
                * inv_norm_sq,
            (-(self.xt() * operand.xyt() * self.xt())
                + self.xt() * operand.xyz() * self.xz()
                + self.xt() * operand.yzt() * self.zt()
                + self.xy() * operand.xyt() * self.xy()
                + self.xy() * operand.xzt() * self.xz()
                + self.xy() * operand.yzt() * self.yz()
                - self.xz() * operand.xyt() * self.xz()
                + self.xz() * operand.xyz() * self.xt()
                + self.xz() * operand.xzt() * self.xy()
                - self.yt() * operand.xyt() * self.yt()
                + self.yt() * operand.xyz() * self.yz()
                - self.yt() * operand.xzt() * self.zt()
                - self.yz() * operand.xyt() * self.yz()
                + self.yz() * operand.xyz() * self.yt()
                + self.yz() * operand.yzt() * self.xy()
                + self.zt() * operand.xyt() * self.zt()
                - self.zt() * operand.xzt() * self.yt()
                + self.zt() * operand.yzt() * self.xt())
                * inv_norm_sq,
            (-(self.xt() * operand.xyz() * self.xy())
                - self.xt() * operand.xzt() * self.xt()
                - self.xt() * operand.yzt() * self.yt()
                + self.xy() * operand.xyt() * self.xz()
                - self.xy() * operand.xyz() * self.xt()
                - self.xy() * operand.xzt() * self.xy()
                + self.xz() * operand.xyt() * self.xy()
                + self.xz() * operand.xzt() * self.xz()
                + self.xz() * operand.yzt() * self.yz()
                - self.yt() * operand.xyt() * self.zt()
                + self.yt() * operand.xzt() * self.yt()
                - self.yt() * operand.yzt() * self.xt()
                + self.yz() * operand.xyz() * self.zt()
                - self.yz() * operand.xzt() * self.yz()
                + self.yz() * operand.yzt() * self.xz()
                - self.zt() * operand.xyt() * self.yt()
                + self.zt() * operand.xyz() * self.yz()
                - self.zt() * operand.xzt() * self.zt())
                * inv_norm_sq,
            (self.xt() * operand.xyt() * self.zt() - self.xt() * operand.xzt() * self.yt()
                + self.xt() * operand.yzt() * self.xt()
                + self.xy() * operand.xyt() * self.yz()
                - self.xy() * operand.xyz() * self.yt()
                - self.xy() * operand.yzt() * self.xy()
                - self.xz() * operand.xyz() * self.zt()
                + self.xz() * operand.xzt() * self.yz()
                - self.xz() * operand.yzt() * self.xz()
                - self.yt() * operand.xyz() * self.xy()
                - self.yt() * operand.xzt() * self.xt()
                - self.yt() * operand.yzt() * self.yt()
                + self.yz() * operand.xyt() * self.xy()
                + self.yz() * operand.xzt() * self.xz()
                + self.yz() * operand.yzt() * self.yz()
                + self.zt() * operand.xyt() * self.xt()
                - self.zt() * operand.xyz() * self.xz()
                - self.zt() * operand.yzt() * self.zt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (self.xt() * operand.x() * self.xt()
                + self.xt() * operand.y() * self.yt()
                + self.xt() * operand.z() * self.zt()
                - self.xy() * operand.t() * self.yt()
                - self.xy() * operand.x() * self.xy()
                + self.xy() * operand.z() * self.yz()
                - self.xz() * operand.t() * self.zt()
                - self.xz() * operand.x() * self.xz()
                - self.xz() * operand.y() * self.yz()
                - self.yt() * operand.t() * self.xy()
                - self.yt() * operand.x() * self.yt()
                + self.yt() * operand.y() * self.xt()
                + self.yz() * operand.x() * self.yz()
                - self.yz() * operand.y() * self.xz()
                + self.yz() * operand.z() * self.xy()
                - self.zt() * operand.t() * self.xz()
                - self.zt() * operand.x() * self.zt()
                + self.zt() * operand.z() * self.xt())
                * inv_norm_sq,
            (self.xt() * operand.t() * self.xy() + self.xt() * operand.x() * self.yt()
                - self.xt() * operand.y() * self.xt()
                + self.xy() * operand.t() * self.xt()
                - self.xy() * operand.y() * self.xy()
                - self.xy() * operand.z() * self.xz()
                - self.xz() * operand.x() * self.yz()
                + self.xz() * operand.y() * self.xz()
                - self.xz() * operand.z() * self.xy()
                + self.yt() * operand.x() * self.xt()
                + self.yt() * operand.y() * self.yt()
                + self.yt() * operand.z() * self.zt()
                - self.yz() * operand.t() * self.zt()
                - self.yz() * operand.x() * self.xz()
                - self.yz() * operand.y() * self.yz()
                - self.zt() * operand.t() * self.yz()
                - self.zt() * operand.y() * self.zt()
                + self.zt() * operand.z() * self.yt())
                * inv_norm_sq,
            (self.xt() * operand.t() * self.xz() + self.xt() * operand.x() * self.zt()
                - self.xt() * operand.z() * self.xt()
                + self.xy() * operand.x() * self.yz()
                - self.xy() * operand.y() * self.xz()
                + self.xy() * operand.z() * self.xy()
                + self.xz() * operand.t() * self.xt()
                - self.xz() * operand.y() * self.xy()
                - self.xz() * operand.z() * self.xz()
                + self.yt() * operand.t() * self.yz()
                + self.yt() * operand.y() * self.zt()
                - self.yt() * operand.z() * self.yt()
                + self.yz() * operand.t() * self.yt()
                + self.yz() * operand.x() * self.xy()
                - self.yz() * operand.z() * self.yz()
                + self.zt() * operand.x() * self.xt()
                + self.zt() * operand.y() * self.yt()
                + self.zt() * operand.z() * self.zt())
                * inv_norm_sq,
            (self.xt() * operand.t() * self.xt()
                - self.xt() * operand.y() * self.xy()
                - self.xt() * operand.z() * self.xz()
                + self.xy() * operand.t() * self.xy()
                + self.xy() * operand.x() * self.yt()
                - self.xy() * operand.y() * self.xt()
                + self.xz() * operand.t() * self.xz()
                + self.xz() * operand.x() * self.zt()
                - self.xz() * operand.z() * self.xt()
                + self.yt() * operand.t() * self.yt()
                + self.yt() * operand.x() * self.xy()
                - self.yt() * operand.z() * self.yz()
                + self.yz() * operand.t() * self.yz()
                + self.yz() * operand.y() * self.zt()
                - self.yz() * operand.z() * self.yt()
                + self.zt() * operand.t() * self.zt()
                + self.zt() * operand.x() * self.xz()
                + self.zt() * operand.y() * self.yz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Bivector<T>> for Eventor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (-(self.s() * operand.xt() * self.yt())
                + self.s() * operand.xy() * self.s()
                + self.s() * operand.xz() * self.yz()
                + self.s() * operand.yt() * self.xt()
                - self.s() * operand.yz() * self.xz()
                + self.s() * operand.zt() * self.xyzt()
                - self.xt() * operand.xt() * self.xy()
                + self.xt() * operand.xy() * self.xt()
                + self.xt() * operand.xz() * self.xyzt()
                + self.xt() * operand.yt() * self.s()
                - self.xt() * operand.yz() * self.zt()
                + self.xt() * operand.zt() * self.yz()
                - self.xy() * operand.xt() * self.xt()
                + self.xy() * operand.xy() * self.xy()
                + self.xy() * operand.xz() * self.xz()
                - self.xy() * operand.yt() * self.yt()
                + self.xy() * operand.yz() * self.yz()
                - self.xy() * operand.zt() * self.zt()
                - self.xyzt() * operand.xt() * self.xz()
                - self.xyzt() * operand.xy() * self.xyzt()
                + self.xyzt() * operand.xz() * self.xt()
                - self.xyzt() * operand.yt() * self.yz()
                + self.xyzt() * operand.yz() * self.yt()
                + self.xyzt() * operand.zt() * self.s()
                - self.xz() * operand.xt() * self.xyzt()
                - self.xz() * operand.xy() * self.xz()
                + self.xz() * operand.xz() * self.xy()
                + self.xz() * operand.yt() * self.zt()
                - self.xz() * operand.yz() * self.s()
                - self.xz() * operand.zt() * self.yt()
                - self.yt() * operand.xt() * self.s()
                + self.yt() * operand.xy() * self.yt()
                + self.yt() * operand.xz() * self.zt()
                - self.yt() * operand.yt() * self.xy()
                + self.yt() * operand.yz() * self.xyzt()
                - self.yt() * operand.zt() * self.xz()
                - self.yz() * operand.xt() * self.zt()
                - self.yz() * operand.xy() * self.yz()
                + self.yz() * operand.xz() * self.s()
                - self.yz() * operand.yt() * self.xyzt()
                + self.yz() * operand.yz() * self.xy()
                + self.yz() * operand.zt() * self.xt()
                - self.zt() * operand.xt() * self.yz()
                - self.zt() * operand.xy() * self.zt()
                + self.zt() * operand.xz() * self.yt()
                + self.zt() * operand.yt() * self.xz()
                - self.zt() * operand.yz() * self.xt()
                - self.zt() * operand.zt() * self.xy())
                * inv_norm_sq,
            (-(self.s() * operand.xt() * self.zt()) - self.s() * operand.xy() * self.yz()
                + self.s() * operand.xz() * self.s()
                - self.s() * operand.yt() * self.xyzt()
                + self.s() * operand.yz() * self.xy()
                + self.s() * operand.zt() * self.xt()
                - self.xt() * operand.xt() * self.xz()
                - self.xt() * operand.xy() * self.xyzt()
                + self.xt() * operand.xz() * self.xt()
                - self.xt() * operand.yt() * self.yz()
                + self.xt() * operand.yz() * self.yt()
                + self.xt() * operand.zt() * self.s()
                + self.xy() * operand.xt() * self.xyzt()
                + self.xy() * operand.xy() * self.xz()
                - self.xy() * operand.xz() * self.xy()
                - self.xy() * operand.yt() * self.zt()
                + self.xy() * operand.yz() * self.s()
                + self.xy() * operand.zt() * self.yt()
                + self.xyzt() * operand.xt() * self.xy()
                - self.xyzt() * operand.xy() * self.xt()
                - self.xyzt() * operand.xz() * self.xyzt()
                - self.xyzt() * operand.yt() * self.s()
                + self.xyzt() * operand.yz() * self.zt()
                - self.xyzt() * operand.zt() * self.yz()
                - self.xz() * operand.xt() * self.xt()
                + self.xz() * operand.xy() * self.xy()
                + self.xz() * operand.xz() * self.xz()
                - self.xz() * operand.yt() * self.yt()
                + self.xz() * operand.yz() * self.yz()
                - self.xz() * operand.zt() * self.zt()
                + self.yt() * operand.xt() * self.yz()
                + self.yt() * operand.xy() * self.zt()
                - self.yt() * operand.xz() * self.yt()
                - self.yt() * operand.yt() * self.xz()
                + self.yt() * operand.yz() * self.xt()
                + self.yt() * operand.zt() * self.xy()
                + self.yz() * operand.xt() * self.yt()
                - self.yz() * operand.xy() * self.s()
                - self.yz() * operand.xz() * self.yz()
                - self.yz() * operand.yt() * self.xt()
                + self.yz() * operand.yz() * self.xz()
                - self.yz() * operand.zt() * self.xyzt()
                - self.zt() * operand.xt() * self.s()
                + self.zt() * operand.xy() * self.yt()
                + self.zt() * operand.xz() * self.zt()
                - self.zt() * operand.yt() * self.xy()
                + self.zt() * operand.yz() * self.xyzt()
                - self.zt() * operand.zt() * self.xz())
                * inv_norm_sq,
            (self.s() * operand.xt() * self.s()
                - self.s() * operand.xy() * self.yt()
                - self.s() * operand.xz() * self.zt()
                + self.s() * operand.yt() * self.xy()
                - self.s() * operand.yz() * self.xyzt()
                + self.s() * operand.zt() * self.xz()
                - self.xt() * operand.xt() * self.xt()
                + self.xt() * operand.xy() * self.xy()
                + self.xt() * operand.xz() * self.xz()
                - self.xt() * operand.yt() * self.yt()
                + self.xt() * operand.yz() * self.yz()
                - self.xt() * operand.zt() * self.zt()
                - self.xy() * operand.xt() * self.xy()
                + self.xy() * operand.xy() * self.xt()
                + self.xy() * operand.xz() * self.xyzt()
                + self.xy() * operand.yt() * self.s()
                - self.xy() * operand.yz() * self.zt()
                + self.xy() * operand.zt() * self.yz()
                - self.xyzt() * operand.xt() * self.xyzt()
                - self.xyzt() * operand.xy() * self.xz()
                + self.xyzt() * operand.xz() * self.xy()
                + self.xyzt() * operand.yt() * self.zt()
                - self.xyzt() * operand.yz() * self.s()
                - self.xyzt() * operand.zt() * self.yt()
                - self.xz() * operand.xt() * self.xz()
                - self.xz() * operand.xy() * self.xyzt()
                + self.xz() * operand.xz() * self.xt()
                - self.xz() * operand.yt() * self.yz()
                + self.xz() * operand.yz() * self.yt()
                + self.xz() * operand.zt() * self.s()
                + self.yt() * operand.xt() * self.yt()
                - self.yt() * operand.xy() * self.s()
                - self.yt() * operand.xz() * self.yz()
                - self.yt() * operand.yt() * self.xt()
                + self.yt() * operand.yz() * self.xz()
                - self.yt() * operand.zt() * self.xyzt()
                + self.yz() * operand.xt() * self.yz()
                + self.yz() * operand.xy() * self.zt()
                - self.yz() * operand.xz() * self.yt()
                - self.yz() * operand.yt() * self.xz()
                + self.yz() * operand.yz() * self.xt()
                + self.yz() * operand.zt() * self.xy()
                + self.zt() * operand.xt() * self.zt()
                + self.zt() * operand.xy() * self.yz()
                - self.zt() * operand.xz() * self.s()
                + self.zt() * operand.yt() * self.xyzt()
                - self.zt() * operand.yz() * self.xy()
                - self.zt() * operand.zt() * self.xt())
                * inv_norm_sq,
            (self.s() * operand.xt() * self.xyzt() + self.s() * operand.xy() * self.xz()
                - self.s() * operand.xz() * self.xy()
                - self.s() * operand.yt() * self.zt()
                + self.s() * operand.yz() * self.s()
                + self.s() * operand.zt() * self.yt()
                - self.xt() * operand.xt() * self.yz()
                - self.xt() * operand.xy() * self.zt()
                + self.xt() * operand.xz() * self.yt()
                + self.xt() * operand.yt() * self.xz()
                - self.xt() * operand.yz() * self.xt()
                - self.xt() * operand.zt() * self.xy()
                + self.xy() * operand.xt() * self.zt()
                + self.xy() * operand.xy() * self.yz()
                - self.xy() * operand.xz() * self.s()
                + self.xy() * operand.yt() * self.xyzt()
                - self.xy() * operand.yz() * self.xy()
                - self.xy() * operand.zt() * self.xt()
                + self.xyzt() * operand.xt() * self.s()
                - self.xyzt() * operand.xy() * self.yt()
                - self.xyzt() * operand.xz() * self.zt()
                + self.xyzt() * operand.yt() * self.xy()
                - self.xyzt() * operand.yz() * self.xyzt()
                + self.xyzt() * operand.zt() * self.xz()
                - self.xz() * operand.xt() * self.yt()
                + self.xz() * operand.xy() * self.s()
                + self.xz() * operand.xz() * self.yz()
                + self.xz() * operand.yt() * self.xt()
                - self.xz() * operand.yz() * self.xz()
                + self.xz() * operand.zt() * self.xyzt()
                - self.yt() * operand.xt() * self.xz()
                - self.yt() * operand.xy() * self.xyzt()
                + self.yt() * operand.xz() * self.xt()
                - self.yt() * operand.yt() * self.yz()
                + self.yt() * operand.yz() * self.yt()
                + self.yt() * operand.zt() * self.s()
                - self.yz() * operand.xt() * self.xt()
                + self.yz() * operand.xy() * self.xy()
                + self.yz() * operand.xz() * self.xz()
                - self.yz() * operand.yt() * self.yt()
                + self.yz() * operand.yz() * self.yz()
                - self.yz() * operand.zt() * self.zt()
                + self.zt() * operand.xt() * self.xy()
                - self.zt() * operand.xy() * self.xt()
                - self.zt() * operand.xz() * self.xyzt()
                - self.zt() * operand.yt() * self.s()
                + self.zt() * operand.yz() * self.zt()
                - self.zt() * operand.zt() * self.yz())
                * inv_norm_sq,
            (-(self.s() * operand.xt() * self.xy())
                + self.s() * operand.xy() * self.xt()
                + self.s() * operand.xz() * self.xyzt()
                + self.s() * operand.yt() * self.s()
                - self.s() * operand.yz() * self.zt()
                + self.s() * operand.zt() * self.yz()
                - self.xt() * operand.xt() * self.yt()
                + self.xt() * operand.xy() * self.s()
                + self.xt() * operand.xz() * self.yz()
                + self.xt() * operand.yt() * self.xt()
                - self.xt() * operand.yz() * self.xz()
                + self.xt() * operand.zt() * self.xyzt()
                - self.xy() * operand.xt() * self.s()
                + self.xy() * operand.xy() * self.yt()
                + self.xy() * operand.xz() * self.zt()
                - self.xy() * operand.yt() * self.xy()
                + self.xy() * operand.yz() * self.xyzt()
                - self.xy() * operand.zt() * self.xz()
                - self.xyzt() * operand.xt() * self.zt()
                - self.xyzt() * operand.xy() * self.yz()
                + self.xyzt() * operand.xz() * self.s()
                - self.xyzt() * operand.yt() * self.xyzt()
                + self.xyzt() * operand.yz() * self.xy()
                + self.xyzt() * operand.zt() * self.xt()
                - self.xz() * operand.xt() * self.yz()
                - self.xz() * operand.xy() * self.zt()
                + self.xz() * operand.xz() * self.yt()
                + self.xz() * operand.yt() * self.xz()
                - self.xz() * operand.yz() * self.xt()
                - self.xz() * operand.zt() * self.xy()
                - self.yt() * operand.xt() * self.xt()
                + self.yt() * operand.xy() * self.xy()
                + self.yt() * operand.xz() * self.xz()
                - self.yt() * operand.yt() * self.yt()
                + self.yt() * operand.yz() * self.yz()
                - self.yt() * operand.zt() * self.zt()
                - self.yz() * operand.xt() * self.xz()
                - self.yz() * operand.xy() * self.xyzt()
                + self.yz() * operand.xz() * self.xt()
                - self.yz() * operand.yt() * self.yz()
                + self.yz() * operand.yz() * self.yt()
                + self.yz() * operand.zt() * self.s()
                - self.zt() * operand.xt() * self.xyzt()
                - self.zt() * operand.xy() * self.xz()
                + self.zt() * operand.xz() * self.xy()
                + self.zt() * operand.yt() * self.zt()
                - self.zt() * operand.yz() * self.s()
                - self.zt() * operand.zt() * self.yt())
                * inv_norm_sq,
            (-(self.s() * operand.xt() * self.xz()) - self.s() * operand.xy() * self.xyzt()
                + self.s() * operand.xz() * self.xt()
                - self.s() * operand.yt() * self.yz()
                + self.s() * operand.yz() * self.yt()
                + self.s() * operand.zt() * self.s()
                - self.xt() * operand.xt() * self.zt()
                - self.xt() * operand.xy() * self.yz()
                + self.xt() * operand.xz() * self.s()
                - self.xt() * operand.yt() * self.xyzt()
                + self.xt() * operand.yz() * self.xy()
                + self.xt() * operand.zt() * self.xt()
                + self.xy() * operand.xt() * self.yz()
                + self.xy() * operand.xy() * self.zt()
                - self.xy() * operand.xz() * self.yt()
                - self.xy() * operand.yt() * self.xz()
                + self.xy() * operand.yz() * self.xt()
                + self.xy() * operand.zt() * self.xy()
                + self.xyzt() * operand.xt() * self.yt()
                - self.xyzt() * operand.xy() * self.s()
                - self.xyzt() * operand.xz() * self.yz()
                - self.xyzt() * operand.yt() * self.xt()
                + self.xyzt() * operand.yz() * self.xz()
                - self.xyzt() * operand.zt() * self.xyzt()
                - self.xz() * operand.xt() * self.s()
                + self.xz() * operand.xy() * self.yt()
                + self.xz() * operand.xz() * self.zt()
                - self.xz() * operand.yt() * self.xy()
                + self.xz() * operand.yz() * self.xyzt()
                - self.xz() * operand.zt() * self.xz()
                + self.yt() * operand.xt() * self.xyzt()
                + self.yt() * operand.xy() * self.xz()
                - self.yt() * operand.xz() * self.xy()
                - self.yt() * operand.yt() * self.zt()
                + self.yt() * operand.yz() * self.s()
                + self.yt() * operand.zt() * self.yt()
                + self.yz() * operand.xt() * self.xy()
                - self.yz() * operand.xy() * self.xt()
                - self.yz() * operand.xz() * self.xyzt()
                - self.yz() * operand.yt() * self.s()
                + self.yz() * operand.yz() * self.zt()
                - self.yz() * operand.zt() * self.yz()
                - self.zt() * operand.xt() * self.xt()
                + self.zt() * operand.xy() * self.xy()
                + self.zt() * operand.xz() * self.xz()
                - self.zt() * operand.yt() * self.yt()
                + self.zt() * operand.yz() * self.yz()
                - self.zt() * operand.zt() * self.zt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Eventor<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (self.s() * operand.s() * self.s() - self.s() * operand.xt() * self.xt()
                + self.s() * operand.xy() * self.xy()
                - self.s() * operand.xyzt() * self.xyzt()
                + self.s() * operand.xz() * self.xz()
                - self.s() * operand.yt() * self.yt()
                + self.s() * operand.yz() * self.yz()
                - self.s() * operand.zt() * self.zt()
                - self.xt() * operand.s() * self.xt()
                + self.xt() * operand.xt() * self.s()
                - self.xt() * operand.xy() * self.yt()
                + self.xt() * operand.xyzt() * self.yz()
                - self.xt() * operand.xz() * self.zt()
                + self.xt() * operand.yt() * self.xy()
                - self.xt() * operand.yz() * self.xyzt()
                + self.xt() * operand.zt() * self.xz()
                + self.xy() * operand.s() * self.xy()
                + self.xy() * operand.xt() * self.yt()
                - self.xy() * operand.xy() * self.s()
                + self.xy() * operand.xyzt() * self.zt()
                - self.xy() * operand.xz() * self.yz()
                - self.xy() * operand.yt() * self.xt()
                + self.xy() * operand.yz() * self.xz()
                - self.xy() * operand.zt() * self.xyzt()
                - self.xyzt() * operand.s() * self.xyzt()
                + self.xyzt() * operand.xt() * self.yz()
                + self.xyzt() * operand.xy() * self.zt()
                - self.xyzt() * operand.xyzt() * self.s()
                - self.xyzt() * operand.xz() * self.yt()
                - self.xyzt() * operand.yt() * self.xz()
                + self.xyzt() * operand.yz() * self.xt()
                + self.xyzt() * operand.zt() * self.xy()
                + self.xz() * operand.s() * self.xz()
                + self.xz() * operand.xt() * self.zt()
                + self.xz() * operand.xy() * self.yz()
                - self.xz() * operand.xyzt() * self.yt()
                - self.xz() * operand.xz() * self.s()
                + self.xz() * operand.yt() * self.xyzt()
                - self.xz() * operand.yz() * self.xy()
                - self.xz() * operand.zt() * self.xt()
                - self.yt() * operand.s() * self.yt()
                - self.yt() * operand.xt() * self.xy()
                + self.yt() * operand.xy() * self.xt()
                - self.yt() * operand.xyzt() * self.xz()
                + self.yt() * operand.xz() * self.xyzt()
                + self.yt() * operand.yt() * self.s()
                - self.yt() * operand.yz() * self.zt()
                + self.yt() * operand.zt() * self.yz()
                + self.yz() * operand.s() * self.yz()
                - self.yz() * operand.xt() * self.xyzt()
                - self.yz() * operand.xy() * self.xz()
                + self.yz() * operand.xyzt() * self.xt()
                + self.yz() * operand.xz() * self.xy()
                + self.yz() * operand.yt() * self.zt()
                - self.yz() * operand.yz() * self.s()
                - self.yz() * operand.zt() * self.yt()
                - self.zt() * operand.s() * self.zt()
                - self.zt() * operand.xt() * self.xz()
                - self.zt() * operand.xy() * self.xyzt()
                + self.zt() * operand.xyzt() * self.xy()
                + self.zt() * operand.xz() * self.xt()
                - self.zt() * operand.yt() * self.yz()
                + self.zt() * operand.yz() * self.yt()
                + self.zt() * operand.zt() * self.s())
                * inv_norm_sq,
            (-(self.s() * operand.s() * self.xy()) - self.s() * operand.xt() * self.yt()
                + self.s() * operand.xy() * self.s()
                - self.s() * operand.xyzt() * self.zt()
                + self.s() * operand.xz() * self.yz()
                + self.s() * operand.yt() * self.xt()
                - self.s() * operand.yz() * self.xz()
                + self.s() * operand.zt() * self.xyzt()
                - self.xt() * operand.s() * self.yt()
                - self.xt() * operand.xt() * self.xy()
                + self.xt() * operand.xy() * self.xt()
                - self.xt() * operand.xyzt() * self.xz()
                + self.xt() * operand.xz() * self.xyzt()
                + self.xt() * operand.yt() * self.s()
                - self.xt() * operand.yz() * self.zt()
                + self.xt() * operand.zt() * self.yz()
                + self.xy() * operand.s() * self.s()
                - self.xy() * operand.xt() * self.xt()
                + self.xy() * operand.xy() * self.xy()
                - self.xy() * operand.xyzt() * self.xyzt()
                + self.xy() * operand.xz() * self.xz()
                - self.xy() * operand.yt() * self.yt()
                + self.xy() * operand.yz() * self.yz()
                - self.xy() * operand.zt() * self.zt()
                - self.xyzt() * operand.s() * self.zt()
                - self.xyzt() * operand.xt() * self.xz()
                - self.xyzt() * operand.xy() * self.xyzt()
                + self.xyzt() * operand.xyzt() * self.xy()
                + self.xyzt() * operand.xz() * self.xt()
                - self.xyzt() * operand.yt() * self.yz()
                + self.xyzt() * operand.yz() * self.yt()
                + self.xyzt() * operand.zt() * self.s()
                + self.xz() * operand.s() * self.yz()
                - self.xz() * operand.xt() * self.xyzt()
                - self.xz() * operand.xy() * self.xz()
                + self.xz() * operand.xyzt() * self.xt()
                + self.xz() * operand.xz() * self.xy()
                + self.xz() * operand.yt() * self.zt()
                - self.xz() * operand.yz() * self.s()
                - self.xz() * operand.zt() * self.yt()
                + self.yt() * operand.s() * self.xt()
                - self.yt() * operand.xt() * self.s()
                + self.yt() * operand.xy() * self.yt()
                - self.yt() * operand.xyzt() * self.yz()
                + self.yt() * operand.xz() * self.zt()
                - self.yt() * operand.yt() * self.xy()
                + self.yt() * operand.yz() * self.xyzt()
                - self.yt() * operand.zt() * self.xz()
                - self.yz() * operand.s() * self.xz()
                - self.yz() * operand.xt() * self.zt()
                - self.yz() * operand.xy() * self.yz()
                + self.yz() * operand.xyzt() * self.yt()
                + self.yz() * operand.xz() * self.s()
                - self.yz() * operand.yt() * self.xyzt()
                + self.yz() * operand.yz() * self.xy()
                + self.yz() * operand.zt() * self.xt()
                + self.zt() * operand.s() * self.xyzt()
                - self.zt() * operand.xt() * self.yz()
                - self.zt() * operand.xy() * self.zt()
                + self.zt() * operand.xyzt() * self.s()
                + self.zt() * operand.xz() * self.yt()
                + self.zt() * operand.yt() * self.xz()
                - self.zt() * operand.yz() * self.xt()
                - self.zt() * operand.zt() * self.xy())
                * inv_norm_sq,
            (-(self.s() * operand.s() * self.xz())
                - self.s() * operand.xt() * self.zt()
                - self.s() * operand.xy() * self.yz()
                + self.s() * operand.xyzt() * self.yt()
                + self.s() * operand.xz() * self.s()
                - self.s() * operand.yt() * self.xyzt()
                + self.s() * operand.yz() * self.xy()
                + self.s() * operand.zt() * self.xt()
                - self.xt() * operand.s() * self.zt()
                - self.xt() * operand.xt() * self.xz()
                - self.xt() * operand.xy() * self.xyzt()
                + self.xt() * operand.xyzt() * self.xy()
                + self.xt() * operand.xz() * self.xt()
                - self.xt() * operand.yt() * self.yz()
                + self.xt() * operand.yz() * self.yt()
                + self.xt() * operand.zt() * self.s()
                - self.xy() * operand.s() * self.yz()
                + self.xy() * operand.xt() * self.xyzt()
                + self.xy() * operand.xy() * self.xz()
                - self.xy() * operand.xyzt() * self.xt()
                - self.xy() * operand.xz() * self.xy()
                - self.xy() * operand.yt() * self.zt()
                + self.xy() * operand.yz() * self.s()
                + self.xy() * operand.zt() * self.yt()
                + self.xyzt() * operand.s() * self.yt()
                + self.xyzt() * operand.xt() * self.xy()
                - self.xyzt() * operand.xy() * self.xt()
                + self.xyzt() * operand.xyzt() * self.xz()
                - self.xyzt() * operand.xz() * self.xyzt()
                - self.xyzt() * operand.yt() * self.s()
                + self.xyzt() * operand.yz() * self.zt()
                - self.xyzt() * operand.zt() * self.yz()
                + self.xz() * operand.s() * self.s()
                - self.xz() * operand.xt() * self.xt()
                + self.xz() * operand.xy() * self.xy()
                - self.xz() * operand.xyzt() * self.xyzt()
                + self.xz() * operand.xz() * self.xz()
                - self.xz() * operand.yt() * self.yt()
                + self.xz() * operand.yz() * self.yz()
                - self.xz() * operand.zt() * self.zt()
                - self.yt() * operand.s() * self.xyzt()
                + self.yt() * operand.xt() * self.yz()
                + self.yt() * operand.xy() * self.zt()
                - self.yt() * operand.xyzt() * self.s()
                - self.yt() * operand.xz() * self.yt()
                - self.yt() * operand.yt() * self.xz()
                + self.yt() * operand.yz() * self.xt()
                + self.yt() * operand.zt() * self.xy()
                + self.yz() * operand.s() * self.xy()
                + self.yz() * operand.xt() * self.yt()
                - self.yz() * operand.xy() * self.s()
                + self.yz() * operand.xyzt() * self.zt()
                - self.yz() * operand.xz() * self.yz()
                - self.yz() * operand.yt() * self.xt()
                + self.yz() * operand.yz() * self.xz()
                - self.yz() * operand.zt() * self.xyzt()
                + self.zt() * operand.s() * self.xt()
                - self.zt() * operand.xt() * self.s()
                + self.zt() * operand.xy() * self.yt()
                - self.zt() * operand.xyzt() * self.yz()
                + self.zt() * operand.xz() * self.zt()
                - self.zt() * operand.yt() * self.xy()
                + self.zt() * operand.yz() * self.xyzt()
                - self.zt() * operand.zt() * self.xz())
                * inv_norm_sq,
            (-(self.s() * operand.s() * self.xt()) + self.s() * operand.xt() * self.s()
                - self.s() * operand.xy() * self.yt()
                + self.s() * operand.xyzt() * self.yz()
                - self.s() * operand.xz() * self.zt()
                + self.s() * operand.yt() * self.xy()
                - self.s() * operand.yz() * self.xyzt()
                + self.s() * operand.zt() * self.xz()
                + self.xt() * operand.s() * self.s()
                - self.xt() * operand.xt() * self.xt()
                + self.xt() * operand.xy() * self.xy()
                - self.xt() * operand.xyzt() * self.xyzt()
                + self.xt() * operand.xz() * self.xz()
                - self.xt() * operand.yt() * self.yt()
                + self.xt() * operand.yz() * self.yz()
                - self.xt() * operand.zt() * self.zt()
                - self.xy() * operand.s() * self.yt()
                - self.xy() * operand.xt() * self.xy()
                + self.xy() * operand.xy() * self.xt()
                - self.xy() * operand.xyzt() * self.xz()
                + self.xy() * operand.xz() * self.xyzt()
                + self.xy() * operand.yt() * self.s()
                - self.xy() * operand.yz() * self.zt()
                + self.xy() * operand.zt() * self.yz()
                + self.xyzt() * operand.s() * self.yz()
                - self.xyzt() * operand.xt() * self.xyzt()
                - self.xyzt() * operand.xy() * self.xz()
                + self.xyzt() * operand.xyzt() * self.xt()
                + self.xyzt() * operand.xz() * self.xy()
                + self.xyzt() * operand.yt() * self.zt()
                - self.xyzt() * operand.yz() * self.s()
                - self.xyzt() * operand.zt() * self.yt()
                - self.xz() * operand.s() * self.zt()
                - self.xz() * operand.xt() * self.xz()
                - self.xz() * operand.xy() * self.xyzt()
                + self.xz() * operand.xyzt() * self.xy()
                + self.xz() * operand.xz() * self.xt()
                - self.xz() * operand.yt() * self.yz()
                + self.xz() * operand.yz() * self.yt()
                + self.xz() * operand.zt() * self.s()
                + self.yt() * operand.s() * self.xy()
                + self.yt() * operand.xt() * self.yt()
                - self.yt() * operand.xy() * self.s()
                + self.yt() * operand.xyzt() * self.zt()
                - self.yt() * operand.xz() * self.yz()
                - self.yt() * operand.yt() * self.xt()
                + self.yt() * operand.yz() * self.xz()
                - self.yt() * operand.zt() * self.xyzt()
                - self.yz() * operand.s() * self.xyzt()
                + self.yz() * operand.xt() * self.yz()
                + self.yz() * operand.xy() * self.zt()
                - self.yz() * operand.xyzt() * self.s()
                - self.yz() * operand.xz() * self.yt()
                - self.yz() * operand.yt() * self.xz()
                + self.yz() * operand.yz() * self.xt()
                + self.yz() * operand.zt() * self.xy()
                + self.zt() * operand.s() * self.xz()
                + self.zt() * operand.xt() * self.zt()
                + self.zt() * operand.xy() * self.yz()
                - self.zt() * operand.xyzt() * self.yt()
                - self.zt() * operand.xz() * self.s()
                + self.zt() * operand.yt() * self.xyzt()
                - self.zt() * operand.yz() * self.xy()
                - self.zt() * operand.zt() * self.xt())
                * inv_norm_sq,
            (-(self.s() * operand.s() * self.yz())
                + self.s() * operand.xt() * self.xyzt()
                + self.s() * operand.xy() * self.xz()
                - self.s() * operand.xyzt() * self.xt()
                - self.s() * operand.xz() * self.xy()
                - self.s() * operand.yt() * self.zt()
                + self.s() * operand.yz() * self.s()
                + self.s() * operand.zt() * self.yt()
                + self.xt() * operand.s() * self.xyzt()
                - self.xt() * operand.xt() * self.yz()
                - self.xt() * operand.xy() * self.zt()
                + self.xt() * operand.xyzt() * self.s()
                + self.xt() * operand.xz() * self.yt()
                + self.xt() * operand.yt() * self.xz()
                - self.xt() * operand.yz() * self.xt()
                - self.xt() * operand.zt() * self.xy()
                + self.xy() * operand.s() * self.xz()
                + self.xy() * operand.xt() * self.zt()
                + self.xy() * operand.xy() * self.yz()
                - self.xy() * operand.xyzt() * self.yt()
                - self.xy() * operand.xz() * self.s()
                + self.xy() * operand.yt() * self.xyzt()
                - self.xy() * operand.yz() * self.xy()
                - self.xy() * operand.zt() * self.xt()
                - self.xyzt() * operand.s() * self.xt()
                + self.xyzt() * operand.xt() * self.s()
                - self.xyzt() * operand.xy() * self.yt()
                + self.xyzt() * operand.xyzt() * self.yz()
                - self.xyzt() * operand.xz() * self.zt()
                + self.xyzt() * operand.yt() * self.xy()
                - self.xyzt() * operand.yz() * self.xyzt()
                + self.xyzt() * operand.zt() * self.xz()
                - self.xz() * operand.s() * self.xy()
                - self.xz() * operand.xt() * self.yt()
                + self.xz() * operand.xy() * self.s()
                - self.xz() * operand.xyzt() * self.zt()
                + self.xz() * operand.xz() * self.yz()
                + self.xz() * operand.yt() * self.xt()
                - self.xz() * operand.yz() * self.xz()
                + self.xz() * operand.zt() * self.xyzt()
                - self.yt() * operand.s() * self.zt()
                - self.yt() * operand.xt() * self.xz()
                - self.yt() * operand.xy() * self.xyzt()
                + self.yt() * operand.xyzt() * self.xy()
                + self.yt() * operand.xz() * self.xt()
                - self.yt() * operand.yt() * self.yz()
                + self.yt() * operand.yz() * self.yt()
                + self.yt() * operand.zt() * self.s()
                + self.yz() * operand.s() * self.s()
                - self.yz() * operand.xt() * self.xt()
                + self.yz() * operand.xy() * self.xy()
                - self.yz() * operand.xyzt() * self.xyzt()
                + self.yz() * operand.xz() * self.xz()
                - self.yz() * operand.yt() * self.yt()
                + self.yz() * operand.yz() * self.yz()
                - self.yz() * operand.zt() * self.zt()
                + self.zt() * operand.s() * self.yt()
                + self.zt() * operand.xt() * self.xy()
                - self.zt() * operand.xy() * self.xt()
                + self.zt() * operand.xyzt() * self.xz()
                - self.zt() * operand.xz() * self.xyzt()
                - self.zt() * operand.yt() * self.s()
                + self.zt() * operand.yz() * self.zt()
                - self.zt() * operand.zt() * self.yz())
                * inv_norm_sq,
            (-(self.s() * operand.s() * self.yt()) - self.s() * operand.xt() * self.xy()
                + self.s() * operand.xy() * self.xt()
                - self.s() * operand.xyzt() * self.xz()
                + self.s() * operand.xz() * self.xyzt()
                + self.s() * operand.yt() * self.s()
                - self.s() * operand.yz() * self.zt()
                + self.s() * operand.zt() * self.yz()
                - self.xt() * operand.s() * self.xy()
                - self.xt() * operand.xt() * self.yt()
                + self.xt() * operand.xy() * self.s()
                - self.xt() * operand.xyzt() * self.zt()
                + self.xt() * operand.xz() * self.yz()
                + self.xt() * operand.yt() * self.xt()
                - self.xt() * operand.yz() * self.xz()
                + self.xt() * operand.zt() * self.xyzt()
                + self.xy() * operand.s() * self.xt()
                - self.xy() * operand.xt() * self.s()
                + self.xy() * operand.xy() * self.yt()
                - self.xy() * operand.xyzt() * self.yz()
                + self.xy() * operand.xz() * self.zt()
                - self.xy() * operand.yt() * self.xy()
                + self.xy() * operand.yz() * self.xyzt()
                - self.xy() * operand.zt() * self.xz()
                - self.xyzt() * operand.s() * self.xz()
                - self.xyzt() * operand.xt() * self.zt()
                - self.xyzt() * operand.xy() * self.yz()
                + self.xyzt() * operand.xyzt() * self.yt()
                + self.xyzt() * operand.xz() * self.s()
                - self.xyzt() * operand.yt() * self.xyzt()
                + self.xyzt() * operand.yz() * self.xy()
                + self.xyzt() * operand.zt() * self.xt()
                + self.xz() * operand.s() * self.xyzt()
                - self.xz() * operand.xt() * self.yz()
                - self.xz() * operand.xy() * self.zt()
                + self.xz() * operand.xyzt() * self.s()
                + self.xz() * operand.xz() * self.yt()
                + self.xz() * operand.yt() * self.xz()
                - self.xz() * operand.yz() * self.xt()
                - self.xz() * operand.zt() * self.xy()
                + self.yt() * operand.s() * self.s()
                - self.yt() * operand.xt() * self.xt()
                + self.yt() * operand.xy() * self.xy()
                - self.yt() * operand.xyzt() * self.xyzt()
                + self.yt() * operand.xz() * self.xz()
                - self.yt() * operand.yt() * self.yt()
                + self.yt() * operand.yz() * self.yz()
                - self.yt() * operand.zt() * self.zt()
                - self.yz() * operand.s() * self.zt()
                - self.yz() * operand.xt() * self.xz()
                - self.yz() * operand.xy() * self.xyzt()
                + self.yz() * operand.xyzt() * self.xy()
                + self.yz() * operand.xz() * self.xt()
                - self.yz() * operand.yt() * self.yz()
                + self.yz() * operand.yz() * self.yt()
                + self.yz() * operand.zt() * self.s()
                + self.zt() * operand.s() * self.yz()
                - self.zt() * operand.xt() * self.xyzt()
                - self.zt() * operand.xy() * self.xz()
                + self.zt() * operand.xyzt() * self.xt()
                + self.zt() * operand.xz() * self.xy()
                + self.zt() * operand.yt() * self.zt()
                - self.zt() * operand.yz() * self.s()
                - self.zt() * operand.zt() * self.yt())
                * inv_norm_sq,
            (-(self.s() * operand.s() * self.zt())
                - self.s() * operand.xt() * self.xz()
                - self.s() * operand.xy() * self.xyzt()
                + self.s() * operand.xyzt() * self.xy()
                + self.s() * operand.xz() * self.xt()
                - self.s() * operand.yt() * self.yz()
                + self.s() * operand.yz() * self.yt()
                + self.s() * operand.zt() * self.s()
                - self.xt() * operand.s() * self.xz()
                - self.xt() * operand.xt() * self.zt()
                - self.xt() * operand.xy() * self.yz()
                + self.xt() * operand.xyzt() * self.yt()
                + self.xt() * operand.xz() * self.s()
                - self.xt() * operand.yt() * self.xyzt()
                + self.xt() * operand.yz() * self.xy()
                + self.xt() * operand.zt() * self.xt()
                - self.xy() * operand.s() * self.xyzt()
                + self.xy() * operand.xt() * self.yz()
                + self.xy() * operand.xy() * self.zt()
                - self.xy() * operand.xyzt() * self.s()
                - self.xy() * operand.xz() * self.yt()
                - self.xy() * operand.yt() * self.xz()
                + self.xy() * operand.yz() * self.xt()
                + self.xy() * operand.zt() * self.xy()
                + self.xyzt() * operand.s() * self.xy()
                + self.xyzt() * operand.xt() * self.yt()
                - self.xyzt() * operand.xy() * self.s()
                + self.xyzt() * operand.xyzt() * self.zt()
                - self.xyzt() * operand.xz() * self.yz()
                - self.xyzt() * operand.yt() * self.xt()
                + self.xyzt() * operand.yz() * self.xz()
                - self.xyzt() * operand.zt() * self.xyzt()
                + self.xz() * operand.s() * self.xt()
                - self.xz() * operand.xt() * self.s()
                + self.xz() * operand.xy() * self.yt()
                - self.xz() * operand.xyzt() * self.yz()
                + self.xz() * operand.xz() * self.zt()
                - self.xz() * operand.yt() * self.xy()
                + self.xz() * operand.yz() * self.xyzt()
                - self.xz() * operand.zt() * self.xz()
                - self.yt() * operand.s() * self.yz()
                + self.yt() * operand.xt() * self.xyzt()
                + self.yt() * operand.xy() * self.xz()
                - self.yt() * operand.xyzt() * self.xt()
                - self.yt() * operand.xz() * self.xy()
                - self.yt() * operand.yt() * self.zt()
                + self.yt() * operand.yz() * self.s()
                + self.yt() * operand.zt() * self.yt()
                + self.yz() * operand.s() * self.yt()
                + self.yz() * operand.xt() * self.xy()
                - self.yz() * operand.xy() * self.xt()
                + self.yz() * operand.xyzt() * self.xz()
                - self.yz() * operand.xz() * self.xyzt()
                - self.yz() * operand.yt() * self.s()
                + self.yz() * operand.yz() * self.zt()
                - self.yz() * operand.zt() * self.yz()
                + self.zt() * operand.s() * self.s()
                - self.zt() * operand.xt() * self.xt()
                + self.zt() * operand.xy() * self.xy()
                - self.zt() * operand.xyzt() * self.xyzt()
                + self.zt() * operand.xz() * self.xz()
                - self.zt() * operand.yt() * self.yt()
                + self.zt() * operand.yz() * self.yz()
                - self.zt() * operand.zt() * self.zt())
                * inv_norm_sq,
            (self.s() * operand.s() * self.xyzt()
                - self.s() * operand.xt() * self.yz()
                - self.s() * operand.xy() * self.zt()
                + self.s() * operand.xyzt() * self.s()
                + self.s() * operand.xz() * self.yt()
                + self.s() * operand.yt() * self.xz()
                - self.s() * operand.yz() * self.xt()
                - self.s() * operand.zt() * self.xy()
                - self.xt() * operand.s() * self.yz()
                + self.xt() * operand.xt() * self.xyzt()
                + self.xt() * operand.xy() * self.xz()
                - self.xt() * operand.xyzt() * self.xt()
                - self.xt() * operand.xz() * self.xy()
                - self.xt() * operand.yt() * self.zt()
                + self.xt() * operand.yz() * self.s()
                + self.xt() * operand.zt() * self.yt()
                - self.xy() * operand.s() * self.zt()
                - self.xy() * operand.xt() * self.xz()
                - self.xy() * operand.xy() * self.xyzt()
                + self.xy() * operand.xyzt() * self.xy()
                + self.xy() * operand.xz() * self.xt()
                - self.xy() * operand.yt() * self.yz()
                + self.xy() * operand.yz() * self.yt()
                + self.xy() * operand.zt() * self.s()
                + self.xyzt() * operand.s() * self.s()
                - self.xyzt() * operand.xt() * self.xt()
                + self.xyzt() * operand.xy() * self.xy()
                - self.xyzt() * operand.xyzt() * self.xyzt()
                + self.xyzt() * operand.xz() * self.xz()
                - self.xyzt() * operand.yt() * self.yt()
                + self.xyzt() * operand.yz() * self.yz()
                - self.xyzt() * operand.zt() * self.zt()
                + self.xz() * operand.s() * self.yt()
                + self.xz() * operand.xt() * self.xy()
                - self.xz() * operand.xy() * self.xt()
                + self.xz() * operand.xyzt() * self.xz()
                - self.xz() * operand.xz() * self.xyzt()
                - self.xz() * operand.yt() * self.s()
                + self.xz() * operand.yz() * self.zt()
                - self.xz() * operand.zt() * self.yz()
                + self.yt() * operand.s() * self.xz()
                + self.yt() * operand.xt() * self.zt()
                + self.yt() * operand.xy() * self.yz()
                - self.yt() * operand.xyzt() * self.yt()
                - self.yt() * operand.xz() * self.s()
                + self.yt() * operand.yt() * self.xyzt()
                - self.yt() * operand.yz() * self.xy()
                - self.yt() * operand.zt() * self.xt()
                - self.yz() * operand.s() * self.xt()
                + self.yz() * operand.xt() * self.s()
                - self.yz() * operand.xy() * self.yt()
                + self.yz() * operand.xyzt() * self.yz()
                - self.yz() * operand.xz() * self.zt()
                + self.yz() * operand.yt() * self.xy()
                - self.yz() * operand.yz() * self.xyzt()
                + self.yz() * operand.zt() * self.xz()
                - self.zt() * operand.s() * self.xy()
                - self.zt() * operand.xt() * self.yt()
                + self.zt() * operand.xy() * self.s()
                - self.zt() * operand.xyzt() * self.zt()
                + self.zt() * operand.xz() * self.yz()
                + self.zt() * operand.yt() * self.xt()
                - self.zt() * operand.yz() * self.xz()
                + self.zt() * operand.zt() * self.xyzt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Pseudoscalar<T>> for Eventor<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (self.s() * operand.xyzt() * self.s() - self.xt() * operand.xyzt() * self.xt()
                + self.xy() * operand.xyzt() * self.xy()
                - self.xyzt() * operand.xyzt() * self.xyzt()
                + self.xz() * operand.xyzt() * self.xz()
                - self.yt() * operand.xyzt() * self.yt()
                + self.yz() * operand.xyzt() * self.yz()
                - self.zt() * operand.xyzt() * self.zt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Eventor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.s() * operand.s() * self.s() - self.xt() * operand.s() * self.xt()
                + self.xy() * operand.s() * self.xy()
                - self.xyzt() * operand.s() * self.xyzt()
                + self.xz() * operand.s() * self.xz()
                - self.yt() * operand.s() * self.yt()
                + self.yz() * operand.s() * self.yz()
                - self.zt() * operand.s() * self.zt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Trivector<T>> for Eventor<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked(
            (-(self.s() * operand.xyt() * self.zt())
                + self.s() * operand.xyz() * self.s()
                + self.s() * operand.xzt() * self.yt()
                - self.s() * operand.yzt() * self.xt()
                - self.xt() * operand.xyt() * self.xz()
                + self.xt() * operand.xyz() * self.xt()
                + self.xt() * operand.xzt() * self.xy()
                - self.xt() * operand.yzt() * self.s()
                - self.xy() * operand.xyt() * self.xyzt()
                + self.xy() * operand.xyz() * self.xy()
                + self.xy() * operand.xzt() * self.xt()
                + self.xy() * operand.yzt() * self.yt()
                - self.xyzt() * operand.xyt() * self.xy()
                + self.xyzt() * operand.xyz() * self.xyzt()
                - self.xyzt() * operand.xzt() * self.xz()
                - self.xyzt() * operand.yzt() * self.yz()
                - self.xz() * operand.xyt() * self.xt()
                + self.xz() * operand.xyz() * self.xz()
                - self.xz() * operand.xzt() * self.xyzt()
                + self.xz() * operand.yzt() * self.zt()
                - self.yt() * operand.xyt() * self.yz()
                + self.yt() * operand.xyz() * self.yt()
                + self.yt() * operand.xzt() * self.s()
                + self.yt() * operand.yzt() * self.xy()
                - self.yz() * operand.xyt() * self.yt()
                + self.yz() * operand.xyz() * self.yz()
                - self.yz() * operand.xzt() * self.zt()
                - self.yz() * operand.yzt() * self.xyzt()
                - self.zt() * operand.xyt() * self.s()
                + self.zt() * operand.xyz() * self.zt()
                - self.zt() * operand.xzt() * self.yz()
                + self.zt() * operand.yzt() * self.xz())
                * inv_norm_sq,
            (self.s() * operand.xyt() * self.s() - self.s() * operand.xyz() * self.zt()
                + self.s() * operand.xzt() * self.yz()
                - self.s() * operand.yzt() * self.xz()
                - self.xt() * operand.xyt() * self.xt()
                + self.xt() * operand.xyz() * self.xz()
                - self.xt() * operand.xzt() * self.xyzt()
                + self.xt() * operand.yzt() * self.zt()
                + self.xy() * operand.xyt() * self.xy()
                - self.xy() * operand.xyz() * self.xyzt()
                + self.xy() * operand.xzt() * self.xz()
                + self.xy() * operand.yzt() * self.yz()
                + self.xyzt() * operand.xyt() * self.xyzt()
                - self.xyzt() * operand.xyz() * self.xy()
                - self.xyzt() * operand.xzt() * self.xt()
                - self.xyzt() * operand.yzt() * self.yt()
                - self.xz() * operand.xyt() * self.xz()
                + self.xz() * operand.xyz() * self.xt()
                + self.xz() * operand.xzt() * self.xy()
                - self.xz() * operand.yzt() * self.s()
                - self.yt() * operand.xyt() * self.yt()
                + self.yt() * operand.xyz() * self.yz()
                - self.yt() * operand.xzt() * self.zt()
                - self.yt() * operand.yzt() * self.xyzt()
                - self.yz() * operand.xyt() * self.yz()
                + self.yz() * operand.xyz() * self.yt()
                + self.yz() * operand.xzt() * self.s()
                + self.yz() * operand.yzt() * self.xy()
                + self.zt() * operand.xyt() * self.zt()
                - self.zt() * operand.xyz() * self.s()
                - self.zt() * operand.xzt() * self.yt()
                + self.zt() * operand.yzt() * self.xt())
                * inv_norm_sq,
            (-(self.s() * operand.xyt() * self.yz())
                + self.s() * operand.xyz() * self.yt()
                + self.s() * operand.xzt() * self.s()
                + self.s() * operand.yzt() * self.xy()
                + self.xt() * operand.xyt() * self.xyzt()
                - self.xt() * operand.xyz() * self.xy()
                - self.xt() * operand.xzt() * self.xt()
                - self.xt() * operand.yzt() * self.yt()
                + self.xy() * operand.xyt() * self.xz()
                - self.xy() * operand.xyz() * self.xt()
                - self.xy() * operand.xzt() * self.xy()
                + self.xy() * operand.yzt() * self.s()
                + self.xyzt() * operand.xyt() * self.xt()
                - self.xyzt() * operand.xyz() * self.xz()
                + self.xyzt() * operand.xzt() * self.xyzt()
                - self.xyzt() * operand.yzt() * self.zt()
                + self.xz() * operand.xyt() * self.xy()
                - self.xz() * operand.xyz() * self.xyzt()
                + self.xz() * operand.xzt() * self.xz()
                + self.xz() * operand.yzt() * self.yz()
                - self.yt() * operand.xyt() * self.zt()
                + self.yt() * operand.xyz() * self.s()
                + self.yt() * operand.xzt() * self.yt()
                - self.yt() * operand.yzt() * self.xt()
                - self.yz() * operand.xyt() * self.s()
                + self.yz() * operand.xyz() * self.zt()
                - self.yz() * operand.xzt() * self.yz()
                + self.yz() * operand.yzt() * self.xz()
                - self.zt() * operand.xyt() * self.yt()
                + self.zt() * operand.xyz() * self.yz()
                - self.zt() * operand.xzt() * self.zt()
                - self.zt() * operand.yzt() * self.xyzt())
                * inv_norm_sq,
            (self.s() * operand.xyt() * self.xz()
                - self.s() * operand.xyz() * self.xt()
                - self.s() * operand.xzt() * self.xy()
                + self.s() * operand.yzt() * self.s()
                + self.xt() * operand.xyt() * self.zt()
                - self.xt() * operand.xyz() * self.s()
                - self.xt() * operand.xzt() * self.yt()
                + self.xt() * operand.yzt() * self.xt()
                + self.xy() * operand.xyt() * self.yz()
                - self.xy() * operand.xyz() * self.yt()
                - self.xy() * operand.xzt() * self.s()
                - self.xy() * operand.yzt() * self.xy()
                + self.xyzt() * operand.xyt() * self.yt()
                - self.xyzt() * operand.xyz() * self.yz()
                + self.xyzt() * operand.xzt() * self.zt()
                + self.xyzt() * operand.yzt() * self.xyzt()
                + self.xz() * operand.xyt() * self.s()
                - self.xz() * operand.xyz() * self.zt()
                + self.xz() * operand.xzt() * self.yz()
                - self.xz() * operand.yzt() * self.xz()
                + self.yt() * operand.xyt() * self.xyzt()
                - self.yt() * operand.xyz() * self.xy()
                - self.yt() * operand.xzt() * self.xt()
                - self.yt() * operand.yzt() * self.yt()
                + self.yz() * operand.xyt() * self.xy()
                - self.yz() * operand.xyz() * self.xyzt()
                + self.yz() * operand.xzt() * self.xz()
                + self.yz() * operand.yzt() * self.yz()
                + self.zt() * operand.xyt() * self.xt()
                - self.zt() * operand.xyz() * self.xz()
                + self.zt() * operand.xzt() * self.xyzt()
                - self.zt() * operand.yzt() * self.zt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Vector<T>> for Eventor<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (-(self.s() * operand.t() * self.xt())
                + self.s() * operand.x() * self.s()
                + self.s() * operand.y() * self.xy()
                + self.s() * operand.z() * self.xz()
                - self.xt() * operand.t() * self.s()
                + self.xt() * operand.x() * self.xt()
                + self.xt() * operand.y() * self.yt()
                + self.xt() * operand.z() * self.zt()
                - self.xy() * operand.t() * self.yt()
                - self.xy() * operand.x() * self.xy()
                + self.xy() * operand.y() * self.s()
                + self.xy() * operand.z() * self.yz()
                - self.xyzt() * operand.t() * self.yz()
                + self.xyzt() * operand.x() * self.xyzt()
                - self.xyzt() * operand.y() * self.zt()
                + self.xyzt() * operand.z() * self.yt()
                - self.xz() * operand.t() * self.zt()
                - self.xz() * operand.x() * self.xz()
                - self.xz() * operand.y() * self.yz()
                + self.xz() * operand.z() * self.s()
                - self.yt() * operand.t() * self.xy()
                - self.yt() * operand.x() * self.yt()
                + self.yt() * operand.y() * self.xt()
                + self.yt() * operand.z() * self.xyzt()
                - self.yz() * operand.t() * self.xyzt()
                + self.yz() * operand.x() * self.yz()
                - self.yz() * operand.y() * self.xz()
                + self.yz() * operand.z() * self.xy()
                - self.zt() * operand.t() * self.xz()
                - self.zt() * operand.x() * self.zt()
                - self.zt() * operand.y() * self.xyzt()
                + self.zt() * operand.z() * self.xt())
                * inv_norm_sq,
            (-(self.s() * operand.t() * self.yt()) - self.s() * operand.x() * self.xy()
                + self.s() * operand.y() * self.s()
                + self.s() * operand.z() * self.yz()
                + self.xt() * operand.t() * self.xy()
                + self.xt() * operand.x() * self.yt()
                - self.xt() * operand.y() * self.xt()
                - self.xt() * operand.z() * self.xyzt()
                + self.xy() * operand.t() * self.xt()
                - self.xy() * operand.x() * self.s()
                - self.xy() * operand.y() * self.xy()
                - self.xy() * operand.z() * self.xz()
                + self.xyzt() * operand.t() * self.xz()
                + self.xyzt() * operand.x() * self.zt()
                + self.xyzt() * operand.y() * self.xyzt()
                - self.xyzt() * operand.z() * self.xt()
                + self.xz() * operand.t() * self.xyzt()
                - self.xz() * operand.x() * self.yz()
                + self.xz() * operand.y() * self.xz()
                - self.xz() * operand.z() * self.xy()
                - self.yt() * operand.t() * self.s()
                + self.yt() * operand.x() * self.xt()
                + self.yt() * operand.y() * self.yt()
                + self.yt() * operand.z() * self.zt()
                - self.yz() * operand.t() * self.zt()
                - self.yz() * operand.x() * self.xz()
                - self.yz() * operand.y() * self.yz()
                + self.yz() * operand.z() * self.s()
                - self.zt() * operand.t() * self.yz()
                + self.zt() * operand.x() * self.xyzt()
                - self.zt() * operand.y() * self.zt()
                + self.zt() * operand.z() * self.yt())
                * inv_norm_sq,
            (-(self.s() * operand.t() * self.zt())
                - self.s() * operand.x() * self.xz()
                - self.s() * operand.y() * self.yz()
                + self.s() * operand.z() * self.s()
                + self.xt() * operand.t() * self.xz()
                + self.xt() * operand.x() * self.zt()
                + self.xt() * operand.y() * self.xyzt()
                - self.xt() * operand.z() * self.xt()
                - self.xy() * operand.t() * self.xyzt()
                + self.xy() * operand.x() * self.yz()
                - self.xy() * operand.y() * self.xz()
                + self.xy() * operand.z() * self.xy()
                - self.xyzt() * operand.t() * self.xy()
                - self.xyzt() * operand.x() * self.yt()
                + self.xyzt() * operand.y() * self.xt()
                + self.xyzt() * operand.z() * self.xyzt()
                + self.xz() * operand.t() * self.xt()
                - self.xz() * operand.x() * self.s()
                - self.xz() * operand.y() * self.xy()
                - self.xz() * operand.z() * self.xz()
                + self.yt() * operand.t() * self.yz()
                - self.yt() * operand.x() * self.xyzt()
                + self.yt() * operand.y() * self.zt()
                - self.yt() * operand.z() * self.yt()
                + self.yz() * operand.t() * self.yt()
                + self.yz() * operand.x() * self.xy()
                - self.yz() * operand.y() * self.s()
                - self.yz() * operand.z() * self.yz()
                - self.zt() * operand.t() * self.s()
                + self.zt() * operand.x() * self.xt()
                + self.zt() * operand.y() * self.yt()
                + self.zt() * operand.z() * self.zt())
                * inv_norm_sq,
            (self.s() * operand.t() * self.s()
                - self.s() * operand.x() * self.xt()
                - self.s() * operand.y() * self.yt()
                - self.s() * operand.z() * self.zt()
                + self.xt() * operand.t() * self.xt()
                - self.xt() * operand.x() * self.s()
                - self.xt() * operand.y() * self.xy()
                - self.xt() * operand.z() * self.xz()
                + self.xy() * operand.t() * self.xy()
                + self.xy() * operand.x() * self.yt()
                - self.xy() * operand.y() * self.xt()
                - self.xy() * operand.z() * self.xyzt()
                + self.xyzt() * operand.t() * self.xyzt()
                - self.xyzt() * operand.x() * self.yz()
                + self.xyzt() * operand.y() * self.xz()
                - self.xyzt() * operand.z() * self.xy()
                + self.xz() * operand.t() * self.xz()
                + self.xz() * operand.x() * self.zt()
                + self.xz() * operand.y() * self.xyzt()
                - self.xz() * operand.z() * self.xt()
                + self.yt() * operand.t() * self.yt()
                + self.yt() * operand.x() * self.xy()
                - self.yt() * operand.y() * self.s()
                - self.yt() * operand.z() * self.yz()
                + self.yz() * operand.t() * self.yz()
                - self.yz() * operand.x() * self.xyzt()
                + self.yz() * operand.y() * self.zt()
                - self.yz() * operand.z() * self.yt()
                + self.zt() * operand.t() * self.zt()
                + self.zt() * operand.x() * self.xz()
                + self.zt() * operand.y() * self.yz()
                - self.zt() * operand.z() * self.s())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Bivector<T>> for Pseudoscalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (-(self.xyzt() * operand.xy() * self.xyzt())) * inv_norm_sq,
            (-(self.xyzt() * operand.xz() * self.xyzt())) * inv_norm_sq,
            (-(self.xyzt() * operand.xt() * self.xyzt())) * inv_norm_sq,
            (-(self.xyzt() * operand.yz() * self.xyzt())) * inv_norm_sq,
            (-(self.xyzt() * operand.yt() * self.xyzt())) * inv_norm_sq,
            (-(self.xyzt() * operand.zt() * self.xyzt())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Eventor<T>> for Pseudoscalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (-(self.xyzt() * operand.s() * self.xyzt())) * inv_norm_sq,
            (-(self.xyzt() * operand.xy() * self.xyzt())) * inv_norm_sq,
            (-(self.xyzt() * operand.xz() * self.xyzt())) * inv_norm_sq,
            (-(self.xyzt() * operand.xt() * self.xyzt())) * inv_norm_sq,
            (-(self.xyzt() * operand.yz() * self.xyzt())) * inv_norm_sq,
            (-(self.xyzt() * operand.yt() * self.xyzt())) * inv_norm_sq,
            (-(self.xyzt() * operand.zt() * self.xyzt())) * inv_norm_sq,
            (-(self.xyzt() * operand.xyzt() * self.xyzt())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (-(self.xyzt() * operand.xyzt() * self.xyzt())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (-(self.xyzt() * operand.s() * self.xyzt())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Trivector<T>> for Pseudoscalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked(
            (self.xyzt() * operand.xyz() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.xyt() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.xzt() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.yzt() * self.xyzt()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Vector<T>> for Pseudoscalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (self.xyzt() * operand.x() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.y() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.z() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.t() * self.xyzt()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (self.s() * operand.xy() * self.s()) * inv_norm_sq,
            (self.s() * operand.xz() * self.s()) * inv_norm_sq,
            (self.s() * operand.xt() * self.s()) * inv_norm_sq,
            (self.s() * operand.yz() * self.s()) * inv_norm_sq,
            (self.s() * operand.yt() * self.s()) * inv_norm_sq,
            (self.s() * operand.zt() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Eventor<T>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (self.s() * operand.s() * self.s()) * inv_norm_sq,
            (self.s() * operand.xy() * self.s()) * inv_norm_sq,
            (self.s() * operand.xz() * self.s()) * inv_norm_sq,
            (self.s() * operand.xt() * self.s()) * inv_norm_sq,
            (self.s() * operand.yz() * self.s()) * inv_norm_sq,
            (self.s() * operand.yt() * self.s()) * inv_norm_sq,
            (self.s() * operand.zt() * self.s()) * inv_norm_sq,
            (self.s() * operand.xyzt() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Pseudoscalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (self.s() * operand.xyzt() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.s() * operand.s() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked(
            (self.s() * operand.xyz() * self.s()) * inv_norm_sq,
            (self.s() * operand.xyt() * self.s()) * inv_norm_sq,
            (self.s() * operand.xzt() * self.s()) * inv_norm_sq,
            (self.s() * operand.yzt() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (self.s() * operand.x() * self.s()) * inv_norm_sq,
            (self.s() * operand.y() * self.s()) * inv_norm_sq,
            (self.s() * operand.z() * self.s()) * inv_norm_sq,
            (self.s() * operand.t() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Bivector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (-(self.xyt() * operand.xy() * self.xyt())
                - self.xyt() * operand.xz() * self.xzt()
                - self.xyt() * operand.yz() * self.yzt()
                + self.xyz() * operand.xt() * self.xzt()
                + self.xyz() * operand.xy() * self.xyz()
                + self.xyz() * operand.yt() * self.yzt()
                + self.xzt() * operand.xt() * self.xyz()
                + self.xzt() * operand.xy() * self.xzt()
                - self.xzt() * operand.xz() * self.xyt()
                + self.yzt() * operand.xy() * self.yzt()
                + self.yzt() * operand.yt() * self.xyz()
                - self.yzt() * operand.yz() * self.xyt())
                * inv_norm_sq,
            (-(self.xyt() * operand.xt() * self.xyz()) - self.xyt() * operand.xy() * self.xzt()
                + self.xyt() * operand.xz() * self.xyt()
                - self.xyz() * operand.xt() * self.xyt()
                + self.xyz() * operand.xz() * self.xyz()
                + self.xyz() * operand.zt() * self.yzt()
                - self.xzt() * operand.xy() * self.xyt()
                - self.xzt() * operand.xz() * self.xzt()
                - self.xzt() * operand.yz() * self.yzt()
                + self.yzt() * operand.xz() * self.yzt()
                - self.yzt() * operand.yz() * self.xzt()
                + self.yzt() * operand.zt() * self.xyz())
                * inv_norm_sq,
            (-(self.xyt() * operand.xt() * self.xyt())
                + self.xyt() * operand.xz() * self.xyz()
                + self.xyt() * operand.zt() * self.yzt()
                - self.xyz() * operand.xt() * self.xyz()
                - self.xyz() * operand.xy() * self.xzt()
                + self.xyz() * operand.xz() * self.xyt()
                - self.xzt() * operand.xt() * self.xzt()
                - self.xzt() * operand.xy() * self.xyz()
                - self.xzt() * operand.yt() * self.yzt()
                + self.yzt() * operand.xt() * self.yzt()
                - self.yzt() * operand.yt() * self.xzt()
                + self.yzt() * operand.zt() * self.xyt())
                * inv_norm_sq,
            (-(self.xyt() * operand.xy() * self.yzt()) - self.xyt() * operand.yt() * self.xyz()
                + self.xyt() * operand.yz() * self.xyt()
                - self.xyz() * operand.yt() * self.xyt()
                + self.xyz() * operand.yz() * self.xyz()
                - self.xyz() * operand.zt() * self.xzt()
                - self.xzt() * operand.xz() * self.yzt()
                + self.xzt() * operand.yz() * self.xzt()
                - self.xzt() * operand.zt() * self.xyz()
                - self.yzt() * operand.xy() * self.xyt()
                - self.yzt() * operand.xz() * self.xzt()
                - self.yzt() * operand.yz() * self.yzt())
                * inv_norm_sq,
            (-(self.xyt() * operand.yt() * self.xyt()) + self.xyt() * operand.yz() * self.xyz()
                - self.xyt() * operand.zt() * self.xzt()
                - self.xyz() * operand.xy() * self.yzt()
                - self.xyz() * operand.yt() * self.xyz()
                + self.xyz() * operand.yz() * self.xyt()
                - self.xzt() * operand.xt() * self.yzt()
                + self.xzt() * operand.yt() * self.xzt()
                - self.xzt() * operand.zt() * self.xyt()
                - self.yzt() * operand.xt() * self.xzt()
                - self.yzt() * operand.xy() * self.xyz()
                - self.yzt() * operand.yt() * self.yzt())
                * inv_norm_sq,
            (self.xyt() * operand.xt() * self.yzt() - self.xyt() * operand.yt() * self.xzt()
                + self.xyt() * operand.zt() * self.xyt()
                - self.xyz() * operand.xz() * self.yzt()
                + self.xyz() * operand.yz() * self.xzt()
                - self.xyz() * operand.zt() * self.xyz()
                - self.xzt() * operand.yt() * self.xyt()
                + self.xzt() * operand.yz() * self.xyz()
                - self.xzt() * operand.zt() * self.xzt()
                + self.yzt() * operand.xt() * self.xyt()
                - self.yzt() * operand.xz() * self.xyz()
                - self.yzt() * operand.zt() * self.yzt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Eventor<T>> for Trivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (-(self.xyt() * operand.s() * self.xyt()) + self.xyt() * operand.xz() * self.yzt()
                - self.xyt() * operand.yz() * self.xzt()
                + self.xyt() * operand.zt() * self.xyz()
                + self.xyz() * operand.s() * self.xyz()
                - self.xyz() * operand.xt() * self.yzt()
                + self.xyz() * operand.yt() * self.xzt()
                - self.xyz() * operand.zt() * self.xyt()
                - self.xzt() * operand.s() * self.xzt()
                - self.xzt() * operand.xy() * self.yzt()
                - self.xzt() * operand.yt() * self.xyz()
                + self.xzt() * operand.yz() * self.xyt()
                - self.yzt() * operand.s() * self.yzt()
                + self.yzt() * operand.xt() * self.xyz()
                + self.yzt() * operand.xy() * self.xzt()
                - self.yzt() * operand.xz() * self.xyt())
                * inv_norm_sq,
            (-(self.xyt() * operand.xy() * self.xyt()) + self.xyt() * operand.xyzt() * self.xyz()
                - self.xyt() * operand.xz() * self.xzt()
                - self.xyt() * operand.yz() * self.yzt()
                + self.xyz() * operand.xt() * self.xzt()
                + self.xyz() * operand.xy() * self.xyz()
                - self.xyz() * operand.xyzt() * self.xyt()
                + self.xyz() * operand.yt() * self.yzt()
                - self.xzt() * operand.s() * self.yzt()
                + self.xzt() * operand.xt() * self.xyz()
                + self.xzt() * operand.xy() * self.xzt()
                - self.xzt() * operand.xz() * self.xyt()
                + self.yzt() * operand.s() * self.xzt()
                + self.yzt() * operand.xy() * self.yzt()
                + self.yzt() * operand.yt() * self.xyz()
                - self.yzt() * operand.yz() * self.xyt())
                * inv_norm_sq,
            (self.xyt() * operand.s() * self.yzt()
                - self.xyt() * operand.xt() * self.xyz()
                - self.xyt() * operand.xy() * self.xzt()
                + self.xyt() * operand.xz() * self.xyt()
                - self.xyz() * operand.xt() * self.xyt()
                - self.xyz() * operand.xyzt() * self.xzt()
                + self.xyz() * operand.xz() * self.xyz()
                + self.xyz() * operand.zt() * self.yzt()
                - self.xzt() * operand.xy() * self.xyt()
                + self.xzt() * operand.xyzt() * self.xyz()
                - self.xzt() * operand.xz() * self.xzt()
                - self.xzt() * operand.yz() * self.yzt()
                - self.yzt() * operand.s() * self.xyt()
                + self.yzt() * operand.xz() * self.yzt()
                - self.yzt() * operand.yz() * self.xzt()
                + self.yzt() * operand.zt() * self.xyz())
                * inv_norm_sq,
            (-(self.xyt() * operand.xt() * self.xyt()) - self.xyt() * operand.xyzt() * self.xzt()
                + self.xyt() * operand.xz() * self.xyz()
                + self.xyt() * operand.zt() * self.yzt()
                + self.xyz() * operand.s() * self.yzt()
                - self.xyz() * operand.xt() * self.xyz()
                - self.xyz() * operand.xy() * self.xzt()
                + self.xyz() * operand.xz() * self.xyt()
                - self.xzt() * operand.xt() * self.xzt()
                - self.xzt() * operand.xy() * self.xyz()
                + self.xzt() * operand.xyzt() * self.xyt()
                - self.xzt() * operand.yt() * self.yzt()
                - self.yzt() * operand.s() * self.xyz()
                + self.yzt() * operand.xt() * self.yzt()
                - self.yzt() * operand.yt() * self.xzt()
                + self.yzt() * operand.zt() * self.xyt())
                * inv_norm_sq,
            (-(self.xyt() * operand.s() * self.xzt())
                - self.xyt() * operand.xy() * self.yzt()
                - self.xyt() * operand.yt() * self.xyz()
                + self.xyt() * operand.yz() * self.xyt()
                - self.xyz() * operand.xyzt() * self.yzt()
                - self.xyz() * operand.yt() * self.xyt()
                + self.xyz() * operand.yz() * self.xyz()
                - self.xyz() * operand.zt() * self.xzt()
                + self.xzt() * operand.s() * self.xyt()
                - self.xzt() * operand.xz() * self.yzt()
                + self.xzt() * operand.yz() * self.xzt()
                - self.xzt() * operand.zt() * self.xyz()
                - self.yzt() * operand.xy() * self.xyt()
                + self.yzt() * operand.xyzt() * self.xyz()
                - self.yzt() * operand.xz() * self.xzt()
                - self.yzt() * operand.yz() * self.yzt())
                * inv_norm_sq,
            (-(self.xyt() * operand.xyzt() * self.yzt()) - self.xyt() * operand.yt() * self.xyt()
                + self.xyt() * operand.yz() * self.xyz()
                - self.xyt() * operand.zt() * self.xzt()
                - self.xyz() * operand.s() * self.xzt()
                - self.xyz() * operand.xy() * self.yzt()
                - self.xyz() * operand.yt() * self.xyz()
                + self.xyz() * operand.yz() * self.xyt()
                + self.xzt() * operand.s() * self.xyz()
                - self.xzt() * operand.xt() * self.yzt()
                + self.xzt() * operand.yt() * self.xzt()
                - self.xzt() * operand.zt() * self.xyt()
                - self.yzt() * operand.xt() * self.xzt()
                - self.yzt() * operand.xy() * self.xyz()
                + self.yzt() * operand.xyzt() * self.xyt()
                - self.yzt() * operand.yt() * self.yzt())
                * inv_norm_sq,
            (-(self.xyt() * operand.s() * self.xyz()) + self.xyt() * operand.xt() * self.yzt()
                - self.xyt() * operand.yt() * self.xzt()
                + self.xyt() * operand.zt() * self.xyt()
                + self.xyz() * operand.s() * self.xyt()
                - self.xyz() * operand.xz() * self.yzt()
                + self.xyz() * operand.yz() * self.xzt()
                - self.xyz() * operand.zt() * self.xyz()
                - self.xzt() * operand.xyzt() * self.yzt()
                - self.xzt() * operand.yt() * self.xyt()
                + self.xzt() * operand.yz() * self.xyz()
                - self.xzt() * operand.zt() * self.xzt()
                + self.yzt() * operand.xt() * self.xyt()
                + self.yzt() * operand.xyzt() * self.xzt()
                - self.yzt() * operand.xz() * self.xyz()
                - self.yzt() * operand.zt() * self.yzt())
                * inv_norm_sq,
            (-(self.xyt() * operand.xt() * self.xzt()) - self.xyt() * operand.xy() * self.xyz()
                + self.xyt() * operand.xyzt() * self.xyt()
                - self.xyt() * operand.yt() * self.yzt()
                + self.xyz() * operand.xy() * self.xyt()
                - self.xyz() * operand.xyzt() * self.xyz()
                + self.xyz() * operand.xz() * self.xzt()
                + self.xyz() * operand.yz() * self.yzt()
                + self.xzt() * operand.xt() * self.xyt()
                + self.xzt() * operand.xyzt() * self.xzt()
                - self.xzt() * operand.xz() * self.xyz()
                - self.xzt() * operand.zt() * self.yzt()
                + self.yzt() * operand.xyzt() * self.yzt()
                + self.yzt() * operand.yt() * self.xyt()
                - self.yzt() * operand.yz() * self.xyz()
                + self.yzt() * operand.zt() * self.xzt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Pseudoscalar<T>> for Trivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (self.xyt() * operand.xyzt() * self.xyt() - self.xyz() * operand.xyzt() * self.xyz()
                + self.xzt() * operand.xyzt() * self.xzt()
                + self.yzt() * operand.xyzt() * self.yzt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (-(self.xyt() * operand.s() * self.xyt()) + self.xyz() * operand.s() * self.xyz()
                - self.xzt() * operand.s() * self.xzt()
                - self.yzt() * operand.s() * self.yzt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Trivector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked(
            (-(self.xyt() * operand.xyt() * self.xyz()) + self.xyt() * operand.xyz() * self.xyt()
                - self.xyz() * operand.xyt() * self.xyt()
                + self.xyz() * operand.xyz() * self.xyz()
                - self.xyz() * operand.xzt() * self.xzt()
                - self.xyz() * operand.yzt() * self.yzt()
                + self.xzt() * operand.xyz() * self.xzt()
                - self.xzt() * operand.xzt() * self.xyz()
                + self.yzt() * operand.xyz() * self.yzt()
                - self.yzt() * operand.yzt() * self.xyz())
                * inv_norm_sq,
            (-(self.xyt() * operand.xyt() * self.xyt()) + self.xyt() * operand.xyz() * self.xyz()
                - self.xyt() * operand.xzt() * self.xzt()
                - self.xyt() * operand.yzt() * self.yzt()
                - self.xyz() * operand.xyt() * self.xyz()
                + self.xyz() * operand.xyz() * self.xyt()
                + self.xzt() * operand.xyt() * self.xzt()
                - self.xzt() * operand.xzt() * self.xyt()
                + self.yzt() * operand.xyt() * self.yzt()
                - self.yzt() * operand.yzt() * self.xyt())
                * inv_norm_sq,
            (-(self.xyt() * operand.xyt() * self.xzt())
                + self.xyt() * operand.xzt() * self.xyt()
                + self.xyz() * operand.xyz() * self.xzt()
                - self.xyz() * operand.xzt() * self.xyz()
                - self.xzt() * operand.xyt() * self.xyt()
                + self.xzt() * operand.xyz() * self.xyz()
                - self.xzt() * operand.xzt() * self.xzt()
                - self.xzt() * operand.yzt() * self.yzt()
                + self.yzt() * operand.xzt() * self.yzt()
                - self.yzt() * operand.yzt() * self.xzt())
                * inv_norm_sq,
            (-(self.xyt() * operand.xyt() * self.yzt())
                + self.xyt() * operand.yzt() * self.xyt()
                + self.xyz() * operand.xyz() * self.yzt()
                - self.xyz() * operand.yzt() * self.xyz()
                - self.xzt() * operand.xzt() * self.yzt()
                + self.xzt() * operand.yzt() * self.xzt()
                - self.yzt() * operand.xyt() * self.xyt()
                + self.yzt() * operand.xyz() * self.xyz()
                - self.yzt() * operand.xzt() * self.xzt()
                - self.yzt() * operand.yzt() * self.yzt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Vector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (-(self.xyt() * operand.x() * self.xyt()) + self.xyt() * operand.z() * self.yzt()
                - self.xyz() * operand.t() * self.yzt()
                + self.xyz() * operand.x() * self.xyz()
                - self.xzt() * operand.x() * self.xzt()
                - self.xzt() * operand.y() * self.yzt()
                - self.yzt() * operand.t() * self.xyz()
                + self.yzt() * operand.x() * self.yzt()
                - self.yzt() * operand.y() * self.xzt()
                + self.yzt() * operand.z() * self.xyt())
                * inv_norm_sq,
            (-(self.xyt() * operand.y() * self.xyt()) - self.xyt() * operand.z() * self.xzt()
                + self.xyz() * operand.t() * self.xzt()
                + self.xyz() * operand.y() * self.xyz()
                + self.xzt() * operand.t() * self.xyz()
                - self.xzt() * operand.x() * self.yzt()
                + self.xzt() * operand.y() * self.xzt()
                - self.xzt() * operand.z() * self.xyt()
                - self.yzt() * operand.x() * self.xzt()
                - self.yzt() * operand.y() * self.yzt())
                * inv_norm_sq,
            (-(self.xyt() * operand.t() * self.xyz()) + self.xyt() * operand.x() * self.yzt()
                - self.xyt() * operand.y() * self.xzt()
                + self.xyt() * operand.z() * self.xyt()
                - self.xyz() * operand.t() * self.xyt()
                + self.xyz() * operand.z() * self.xyz()
                - self.xzt() * operand.y() * self.xyt()
                - self.xzt() * operand.z() * self.xzt()
                + self.yzt() * operand.x() * self.xyt()
                - self.yzt() * operand.z() * self.yzt())
                * inv_norm_sq,
            (-(self.xyt() * operand.t() * self.xyt()) + self.xyt() * operand.z() * self.xyz()
                - self.xyz() * operand.t() * self.xyz()
                + self.xyz() * operand.x() * self.yzt()
                - self.xyz() * operand.y() * self.xzt()
                + self.xyz() * operand.z() * self.xyt()
                - self.xzt() * operand.t() * self.xzt()
                - self.xzt() * operand.y() * self.xyz()
                - self.yzt() * operand.t() * self.yzt()
                + self.yzt() * operand.x() * self.xyz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Bivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (self.t() * operand.xt() * self.y()
                - self.t() * operand.xy() * self.t()
                - self.t() * operand.yt() * self.x()
                - self.x() * operand.xy() * self.x()
                - self.x() * operand.yt() * self.t()
                + self.x() * operand.yz() * self.z()
                + self.y() * operand.xt() * self.t()
                - self.y() * operand.xy() * self.y()
                - self.y() * operand.xz() * self.z()
                + self.z() * operand.xy() * self.z()
                - self.z() * operand.xz() * self.y()
                + self.z() * operand.yz() * self.x())
                * inv_norm_sq,
            (self.t() * operand.xt() * self.z()
                - self.t() * operand.xz() * self.t()
                - self.t() * operand.zt() * self.x()
                - self.x() * operand.xz() * self.x()
                - self.x() * operand.yz() * self.y()
                - self.x() * operand.zt() * self.t()
                - self.y() * operand.xy() * self.z()
                + self.y() * operand.xz() * self.y()
                - self.y() * operand.yz() * self.x()
                + self.z() * operand.xt() * self.t()
                - self.z() * operand.xy() * self.y()
                - self.z() * operand.xz() * self.z())
                * inv_norm_sq,
            (self.t() * operand.xt() * self.t()
                - self.t() * operand.xy() * self.y()
                - self.t() * operand.xz() * self.z()
                - self.x() * operand.xt() * self.x()
                - self.x() * operand.yt() * self.y()
                - self.x() * operand.zt() * self.z()
                + self.y() * operand.xt() * self.y()
                - self.y() * operand.xy() * self.t()
                - self.y() * operand.yt() * self.x()
                + self.z() * operand.xt() * self.z()
                - self.z() * operand.xz() * self.t()
                - self.z() * operand.zt() * self.x())
                * inv_norm_sq,
            (self.t() * operand.yt() * self.z()
                - self.t() * operand.yz() * self.t()
                - self.t() * operand.zt() * self.y()
                + self.x() * operand.xy() * self.z()
                - self.x() * operand.xz() * self.y()
                + self.x() * operand.yz() * self.x()
                - self.y() * operand.xz() * self.x()
                - self.y() * operand.yz() * self.y()
                - self.y() * operand.zt() * self.t()
                + self.z() * operand.xy() * self.x()
                + self.z() * operand.yt() * self.t()
                - self.z() * operand.yz() * self.z())
                * inv_norm_sq,
            (self.t() * operand.xy() * self.x() + self.t() * operand.yt() * self.t()
                - self.t() * operand.yz() * self.z()
                - self.x() * operand.xt() * self.y()
                + self.x() * operand.xy() * self.t()
                + self.x() * operand.yt() * self.x()
                - self.y() * operand.xt() * self.x()
                - self.y() * operand.yt() * self.y()
                - self.y() * operand.zt() * self.z()
                + self.z() * operand.yt() * self.z()
                - self.z() * operand.yz() * self.t()
                - self.z() * operand.zt() * self.y())
                * inv_norm_sq,
            (self.t() * operand.xz() * self.x()
                + self.t() * operand.yz() * self.y()
                + self.t() * operand.zt() * self.t()
                - self.x() * operand.xt() * self.z()
                + self.x() * operand.xz() * self.t()
                + self.x() * operand.zt() * self.x()
                - self.y() * operand.yt() * self.z()
                + self.y() * operand.yz() * self.t()
                + self.y() * operand.zt() * self.y()
                - self.z() * operand.xt() * self.x()
                - self.z() * operand.yt() * self.y()
                - self.z() * operand.zt() * self.z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Eventor<T>> for Vector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (-(self.t() * operand.s() * self.t())
                + self.t() * operand.xt() * self.x()
                + self.t() * operand.yt() * self.y()
                + self.t() * operand.zt() * self.z()
                + self.x() * operand.s() * self.x()
                - self.x() * operand.xt() * self.t()
                + self.x() * operand.xy() * self.y()
                + self.x() * operand.xz() * self.z()
                + self.y() * operand.s() * self.y()
                - self.y() * operand.xy() * self.x()
                - self.y() * operand.yt() * self.t()
                + self.y() * operand.yz() * self.z()
                + self.z() * operand.s() * self.z()
                - self.z() * operand.xz() * self.x()
                - self.z() * operand.yz() * self.y()
                - self.z() * operand.zt() * self.t())
                * inv_norm_sq,
            (self.t() * operand.xt() * self.y() - self.t() * operand.xy() * self.t()
                + self.t() * operand.xyzt() * self.z()
                - self.t() * operand.yt() * self.x()
                + self.x() * operand.s() * self.y()
                - self.x() * operand.xy() * self.x()
                - self.x() * operand.yt() * self.t()
                + self.x() * operand.yz() * self.z()
                - self.y() * operand.s() * self.x()
                + self.y() * operand.xt() * self.t()
                - self.y() * operand.xy() * self.y()
                - self.y() * operand.xz() * self.z()
                + self.z() * operand.xy() * self.z()
                - self.z() * operand.xyzt() * self.t()
                - self.z() * operand.xz() * self.y()
                + self.z() * operand.yz() * self.x())
                * inv_norm_sq,
            (self.t() * operand.xt() * self.z()
                - self.t() * operand.xyzt() * self.y()
                - self.t() * operand.xz() * self.t()
                - self.t() * operand.zt() * self.x()
                + self.x() * operand.s() * self.z()
                - self.x() * operand.xz() * self.x()
                - self.x() * operand.yz() * self.y()
                - self.x() * operand.zt() * self.t()
                - self.y() * operand.xy() * self.z()
                + self.y() * operand.xyzt() * self.t()
                + self.y() * operand.xz() * self.y()
                - self.y() * operand.yz() * self.x()
                - self.z() * operand.s() * self.x()
                + self.z() * operand.xt() * self.t()
                - self.z() * operand.xy() * self.y()
                - self.z() * operand.xz() * self.z())
                * inv_norm_sq,
            (-(self.t() * operand.s() * self.x()) + self.t() * operand.xt() * self.t()
                - self.t() * operand.xy() * self.y()
                - self.t() * operand.xz() * self.z()
                + self.x() * operand.s() * self.t()
                - self.x() * operand.xt() * self.x()
                - self.x() * operand.yt() * self.y()
                - self.x() * operand.zt() * self.z()
                + self.y() * operand.xt() * self.y()
                - self.y() * operand.xy() * self.t()
                + self.y() * operand.xyzt() * self.z()
                - self.y() * operand.yt() * self.x()
                + self.z() * operand.xt() * self.z()
                - self.z() * operand.xyzt() * self.y()
                - self.z() * operand.xz() * self.t()
                - self.z() * operand.zt() * self.x())
                * inv_norm_sq,
            (self.t() * operand.xyzt() * self.x() + self.t() * operand.yt() * self.z()
                - self.t() * operand.yz() * self.t()
                - self.t() * operand.zt() * self.y()
                + self.x() * operand.xy() * self.z()
                - self.x() * operand.xyzt() * self.t()
                - self.x() * operand.xz() * self.y()
                + self.x() * operand.yz() * self.x()
                + self.y() * operand.s() * self.z()
                - self.y() * operand.xz() * self.x()
                - self.y() * operand.yz() * self.y()
                - self.y() * operand.zt() * self.t()
                - self.z() * operand.s() * self.y()
                + self.z() * operand.xy() * self.x()
                + self.z() * operand.yt() * self.t()
                - self.z() * operand.yz() * self.z())
                * inv_norm_sq,
            (-(self.t() * operand.s() * self.y())
                + self.t() * operand.xy() * self.x()
                + self.t() * operand.yt() * self.t()
                - self.t() * operand.yz() * self.z()
                - self.x() * operand.xt() * self.y()
                + self.x() * operand.xy() * self.t()
                - self.x() * operand.xyzt() * self.z()
                + self.x() * operand.yt() * self.x()
                + self.y() * operand.s() * self.t()
                - self.y() * operand.xt() * self.x()
                - self.y() * operand.yt() * self.y()
                - self.y() * operand.zt() * self.z()
                + self.z() * operand.xyzt() * self.x()
                + self.z() * operand.yt() * self.z()
                - self.z() * operand.yz() * self.t()
                - self.z() * operand.zt() * self.y())
                * inv_norm_sq,
            (-(self.t() * operand.s() * self.z())
                + self.t() * operand.xz() * self.x()
                + self.t() * operand.yz() * self.y()
                + self.t() * operand.zt() * self.t()
                - self.x() * operand.xt() * self.z()
                + self.x() * operand.xyzt() * self.y()
                + self.x() * operand.xz() * self.t()
                + self.x() * operand.zt() * self.x()
                - self.y() * operand.xyzt() * self.x()
                - self.y() * operand.yt() * self.z()
                + self.y() * operand.yz() * self.t()
                + self.y() * operand.zt() * self.y()
                + self.z() * operand.s() * self.t()
                - self.z() * operand.xt() * self.x()
                - self.z() * operand.yt() * self.y()
                - self.z() * operand.zt() * self.z())
                * inv_norm_sq,
            (-(self.t() * operand.xy() * self.z())
                + self.t() * operand.xyzt() * self.t()
                + self.t() * operand.xz() * self.y()
                - self.t() * operand.yz() * self.x()
                - self.x() * operand.xyzt() * self.x()
                - self.x() * operand.yt() * self.z()
                + self.x() * operand.yz() * self.t()
                + self.x() * operand.zt() * self.y()
                + self.y() * operand.xt() * self.z()
                - self.y() * operand.xyzt() * self.y()
                - self.y() * operand.xz() * self.t()
                - self.y() * operand.zt() * self.x()
                - self.z() * operand.xt() * self.y()
                + self.z() * operand.xy() * self.t()
                - self.z() * operand.xyzt() * self.z()
                + self.z() * operand.yt() * self.x())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Pseudoscalar<T>> for Vector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (self.t() * operand.xyzt() * self.t()
                - self.x() * operand.xyzt() * self.x()
                - self.y() * operand.xyzt() * self.y()
                - self.z() * operand.xyzt() * self.z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (-(self.t() * operand.s() * self.t())
                + self.x() * operand.s() * self.x()
                + self.y() * operand.s() * self.y()
                + self.z() * operand.s() * self.z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Trivector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked(
            (-(self.t() * operand.xyt() * self.z())
                + self.t() * operand.xyz() * self.t()
                + self.t() * operand.xzt() * self.y()
                - self.t() * operand.yzt() * self.x()
                + self.x() * operand.xyz() * self.x()
                - self.x() * operand.yzt() * self.t()
                + self.y() * operand.xyz() * self.y()
                + self.y() * operand.xzt() * self.t()
                - self.z() * operand.xyt() * self.t()
                + self.z() * operand.xyz() * self.z())
                * inv_norm_sq,
            (-(self.t() * operand.xyt() * self.t())
                + self.t() * operand.xyz() * self.z()
                + self.x() * operand.xyt() * self.x()
                - self.x() * operand.yzt() * self.z()
                + self.y() * operand.xyt() * self.y()
                + self.y() * operand.xzt() * self.z()
                - self.z() * operand.xyt() * self.z()
                + self.z() * operand.xyz() * self.t()
                + self.z() * operand.xzt() * self.y()
                - self.z() * operand.yzt() * self.x())
                * inv_norm_sq,
            (-(self.t() * operand.xyz() * self.y()) - self.t() * operand.xzt() * self.t()
                + self.x() * operand.xzt() * self.x()
                + self.x() * operand.yzt() * self.y()
                + self.y() * operand.xyt() * self.z()
                - self.y() * operand.xyz() * self.t()
                - self.y() * operand.xzt() * self.y()
                + self.y() * operand.yzt() * self.x()
                + self.z() * operand.xyt() * self.y()
                + self.z() * operand.xzt() * self.z())
                * inv_norm_sq,
            (self.t() * operand.xyz() * self.x()
                - self.t() * operand.yzt() * self.t()
                - self.x() * operand.xyt() * self.z()
                + self.x() * operand.xyz() * self.t()
                + self.x() * operand.xzt() * self.y()
                - self.x() * operand.yzt() * self.x()
                + self.y() * operand.xzt() * self.x()
                + self.y() * operand.yzt() * self.y()
                - self.z() * operand.xyt() * self.x()
                + self.z() * operand.yzt() * self.z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Vector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (-(self.t() * operand.t() * self.x()) + self.t() * operand.x() * self.t()
                - self.x() * operand.t() * self.t()
                + self.x() * operand.x() * self.x()
                + self.x() * operand.y() * self.y()
                + self.x() * operand.z() * self.z()
                - self.y() * operand.x() * self.y()
                + self.y() * operand.y() * self.x()
                - self.z() * operand.x() * self.z()
                + self.z() * operand.z() * self.x())
                * inv_norm_sq,
            (-(self.t() * operand.t() * self.y())
                + self.t() * operand.y() * self.t()
                + self.x() * operand.x() * self.y()
                - self.x() * operand.y() * self.x()
                - self.y() * operand.t() * self.t()
                + self.y() * operand.x() * self.x()
                + self.y() * operand.y() * self.y()
                + self.y() * operand.z() * self.z()
                - self.z() * operand.y() * self.z()
                + self.z() * operand.z() * self.y())
                * inv_norm_sq,
            (-(self.t() * operand.t() * self.z())
                + self.t() * operand.z() * self.t()
                + self.x() * operand.x() * self.z()
                - self.x() * operand.z() * self.x()
                + self.y() * operand.y() * self.z()
                - self.y() * operand.z() * self.y()
                - self.z() * operand.t() * self.t()
                + self.z() * operand.x() * self.x()
                + self.z() * operand.y() * self.y()
                + self.z() * operand.z() * self.z())
                * inv_norm_sq,
            (-(self.t() * operand.t() * self.t())
                + self.t() * operand.x() * self.x()
                + self.t() * operand.y() * self.y()
                + self.t() * operand.z() * self.z()
                - self.x() * operand.t() * self.x()
                + self.x() * operand.x() * self.t()
                - self.y() * operand.t() * self.y()
                + self.y() * operand.y() * self.t()
                - self.z() * operand.t() * self.z()
                + self.z() * operand.z() * self.t())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (self.xt() * operand.xt() * self.xy() - self.xt() * operand.xy() * self.xt()
                + self.xt() * operand.yz() * self.zt()
                - self.xt() * operand.zt() * self.yz()
                + self.xy() * operand.xt() * self.xt()
                - self.xy() * operand.xy() * self.xy()
                - self.xy() * operand.xz() * self.xz()
                + self.xy() * operand.yt() * self.yt()
                - self.xy() * operand.yz() * self.yz()
                + self.xy() * operand.zt() * self.zt()
                + self.xz() * operand.xy() * self.xz()
                - self.xz() * operand.xz() * self.xy()
                - self.xz() * operand.yt() * self.zt()
                + self.xz() * operand.zt() * self.yt()
                - self.yt() * operand.xy() * self.yt()
                - self.yt() * operand.xz() * self.zt()
                + self.yt() * operand.yt() * self.xy()
                + self.yt() * operand.zt() * self.xz()
                + self.yz() * operand.xt() * self.zt()
                + self.yz() * operand.xy() * self.yz()
                - self.yz() * operand.yz() * self.xy()
                - self.yz() * operand.zt() * self.xt()
                + self.zt() * operand.xt() * self.yz()
                + self.zt() * operand.xy() * self.zt()
                - self.zt() * operand.xz() * self.yt()
                - self.zt() * operand.yt() * self.xz()
                + self.zt() * operand.yz() * self.xt()
                + self.zt() * operand.zt() * self.xy())
                * inv_norm_sq,
            (self.xt() * operand.xt() * self.xz() - self.xt() * operand.xz() * self.xt()
                + self.xt() * operand.yt() * self.yz()
                - self.xt() * operand.yz() * self.yt()
                - self.xy() * operand.xy() * self.xz()
                + self.xy() * operand.xz() * self.xy()
                + self.xy() * operand.yt() * self.zt()
                - self.xy() * operand.zt() * self.yt()
                + self.xz() * operand.xt() * self.xt()
                - self.xz() * operand.xy() * self.xy()
                - self.xz() * operand.xz() * self.xz()
                + self.xz() * operand.yt() * self.yt()
                - self.xz() * operand.yz() * self.yz()
                + self.xz() * operand.zt() * self.zt()
                - self.yt() * operand.xt() * self.yz()
                - self.yt() * operand.xy() * self.zt()
                + self.yt() * operand.xz() * self.yt()
                + self.yt() * operand.yt() * self.xz()
                - self.yt() * operand.yz() * self.xt()
                - self.yt() * operand.zt() * self.xy()
                - self.yz() * operand.xt() * self.yt()
                + self.yz() * operand.xz() * self.yz()
                + self.yz() * operand.yt() * self.xt()
                - self.yz() * operand.yz() * self.xz()
                - self.zt() * operand.xy() * self.yt()
                - self.zt() * operand.xz() * self.zt()
                + self.zt() * operand.yt() * self.xy()
                + self.zt() * operand.zt() * self.xz())
                * inv_norm_sq,
            (self.xt() * operand.xt() * self.xt()
                - self.xt() * operand.xy() * self.xy()
                - self.xt() * operand.xz() * self.xz()
                + self.xt() * operand.yt() * self.yt()
                - self.xt() * operand.yz() * self.yz()
                + self.xt() * operand.zt() * self.zt()
                + self.xy() * operand.xt() * self.xy()
                - self.xy() * operand.xy() * self.xt()
                + self.xy() * operand.yz() * self.zt()
                - self.xy() * operand.zt() * self.yz()
                + self.xz() * operand.xt() * self.xz()
                - self.xz() * operand.xz() * self.xt()
                + self.xz() * operand.yt() * self.yz()
                - self.xz() * operand.yz() * self.yt()
                - self.yt() * operand.xt() * self.yt()
                + self.yt() * operand.xz() * self.yz()
                + self.yt() * operand.yt() * self.xt()
                - self.yt() * operand.yz() * self.xz()
                - self.yz() * operand.xt() * self.yz()
                - self.yz() * operand.xy() * self.zt()
                + self.yz() * operand.xz() * self.yt()
                + self.yz() * operand.yt() * self.xz()
                - self.yz() * operand.yz() * self.xt()
                - self.yz() * operand.zt() * self.xy()
                - self.zt() * operand.xt() * self.zt()
                - self.zt() * operand.xy() * self.yz()
                + self.zt() * operand.yz() * self.xy()
                + self.zt() * operand.zt() * self.xt())
                * inv_norm_sq,
            (self.xt() * operand.xt() * self.yz() + self.xt() * operand.xy() * self.zt()
                - self.xt() * operand.xz() * self.yt()
                - self.xt() * operand.yt() * self.xz()
                + self.xt() * operand.yz() * self.xt()
                + self.xt() * operand.zt() * self.xy()
                - self.xy() * operand.xt() * self.zt()
                - self.xy() * operand.xy() * self.yz()
                + self.xy() * operand.yz() * self.xy()
                + self.xy() * operand.zt() * self.xt()
                + self.xz() * operand.xt() * self.yt()
                - self.xz() * operand.xz() * self.yz()
                - self.xz() * operand.yt() * self.xt()
                + self.xz() * operand.yz() * self.xz()
                + self.yt() * operand.xt() * self.xz()
                - self.yt() * operand.xz() * self.xt()
                + self.yt() * operand.yt() * self.yz()
                - self.yt() * operand.yz() * self.yt()
                + self.yz() * operand.xt() * self.xt()
                - self.yz() * operand.xy() * self.xy()
                - self.yz() * operand.xz() * self.xz()
                + self.yz() * operand.yt() * self.yt()
                - self.yz() * operand.yz() * self.yz()
                + self.yz() * operand.zt() * self.zt()
                - self.zt() * operand.xt() * self.xy()
                + self.zt() * operand.xy() * self.xt()
                - self.zt() * operand.yz() * self.zt()
                + self.zt() * operand.zt() * self.yz())
                * inv_norm_sq,
            (self.xt() * operand.xt() * self.yt()
                - self.xt() * operand.xz() * self.yz()
                - self.xt() * operand.yt() * self.xt()
                + self.xt() * operand.yz() * self.xz()
                - self.xy() * operand.xy() * self.yt()
                - self.xy() * operand.xz() * self.zt()
                + self.xy() * operand.yt() * self.xy()
                + self.xy() * operand.zt() * self.xz()
                + self.xz() * operand.xt() * self.yz()
                + self.xz() * operand.xy() * self.zt()
                - self.xz() * operand.xz() * self.yt()
                - self.xz() * operand.yt() * self.xz()
                + self.xz() * operand.yz() * self.xt()
                + self.xz() * operand.zt() * self.xy()
                + self.yt() * operand.xt() * self.xt()
                - self.yt() * operand.xy() * self.xy()
                - self.yt() * operand.xz() * self.xz()
                + self.yt() * operand.yt() * self.yt()
                - self.yt() * operand.yz() * self.yz()
                + self.yt() * operand.zt() * self.zt()
                + self.yz() * operand.xt() * self.xz()
                - self.yz() * operand.xz() * self.xt()
                + self.yz() * operand.yt() * self.yz()
                - self.yz() * operand.yz() * self.yt()
                + self.zt() * operand.xy() * self.xz()
                - self.zt() * operand.xz() * self.xy()
                - self.zt() * operand.yt() * self.zt()
                + self.zt() * operand.zt() * self.yt())
                * inv_norm_sq,
            (self.xt() * operand.xt() * self.zt() + self.xt() * operand.xy() * self.yz()
                - self.xt() * operand.yz() * self.xy()
                - self.xt() * operand.zt() * self.xt()
                - self.xy() * operand.xt() * self.yz()
                - self.xy() * operand.xy() * self.zt()
                + self.xy() * operand.xz() * self.yt()
                + self.xy() * operand.yt() * self.xz()
                - self.xy() * operand.yz() * self.xt()
                - self.xy() * operand.zt() * self.xy()
                - self.xz() * operand.xy() * self.yt()
                - self.xz() * operand.xz() * self.zt()
                + self.xz() * operand.yt() * self.xy()
                + self.xz() * operand.zt() * self.xz()
                - self.yt() * operand.xy() * self.xz()
                + self.yt() * operand.xz() * self.xy()
                + self.yt() * operand.yt() * self.zt()
                - self.yt() * operand.zt() * self.yt()
                - self.yz() * operand.xt() * self.xy()
                + self.yz() * operand.xy() * self.xt()
                - self.yz() * operand.yz() * self.zt()
                + self.yz() * operand.zt() * self.yz()
                + self.zt() * operand.xt() * self.xt()
                - self.zt() * operand.xy() * self.xy()
                - self.zt() * operand.xz() * self.xz()
                + self.zt() * operand.yt() * self.yt()
                - self.zt() * operand.yz() * self.yz()
                + self.zt() * operand.zt() * self.zt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Eventor<T>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (self.xt() * operand.s() * self.xt()
                - self.xt() * operand.xy() * self.yt()
                - self.xt() * operand.xyzt() * self.yz()
                - self.xt() * operand.xz() * self.zt()
                + self.xt() * operand.yt() * self.xy()
                + self.xt() * operand.zt() * self.xz()
                - self.xy() * operand.s() * self.xy()
                + self.xy() * operand.xt() * self.yt()
                - self.xy() * operand.xyzt() * self.zt()
                - self.xy() * operand.xz() * self.yz()
                - self.xy() * operand.yt() * self.xt()
                + self.xy() * operand.yz() * self.xz()
                - self.xz() * operand.s() * self.xz()
                + self.xz() * operand.xt() * self.zt()
                + self.xz() * operand.xy() * self.yz()
                + self.xz() * operand.xyzt() * self.yt()
                - self.xz() * operand.yz() * self.xy()
                - self.xz() * operand.zt() * self.xt()
                + self.yt() * operand.s() * self.yt()
                - self.yt() * operand.xt() * self.xy()
                + self.yt() * operand.xy() * self.xt()
                + self.yt() * operand.xyzt() * self.xz()
                - self.yt() * operand.yz() * self.zt()
                + self.yt() * operand.zt() * self.yz()
                - self.yz() * operand.s() * self.yz()
                - self.yz() * operand.xy() * self.xz()
                - self.yz() * operand.xyzt() * self.xt()
                + self.yz() * operand.xz() * self.xy()
                + self.yz() * operand.yt() * self.zt()
                - self.yz() * operand.zt() * self.yt()
                + self.zt() * operand.s() * self.zt()
                - self.zt() * operand.xt() * self.xz()
                - self.zt() * operand.xyzt() * self.xy()
                + self.zt() * operand.xz() * self.xt()
                - self.zt() * operand.yt() * self.yz()
                + self.zt() * operand.yz() * self.yt())
                * inv_norm_sq,
            (-(self.xt() * operand.s() * self.yt()) + self.xt() * operand.xt() * self.xy()
                - self.xt() * operand.xy() * self.xt()
                - self.xt() * operand.xyzt() * self.xz()
                + self.xt() * operand.yz() * self.zt()
                - self.xt() * operand.zt() * self.yz()
                + self.xy() * operand.xt() * self.xt()
                - self.xy() * operand.xy() * self.xy()
                - self.xy() * operand.xz() * self.xz()
                + self.xy() * operand.yt() * self.yt()
                - self.xy() * operand.yz() * self.yz()
                + self.xy() * operand.zt() * self.zt()
                + self.xz() * operand.s() * self.yz()
                + self.xz() * operand.xy() * self.xz()
                + self.xz() * operand.xyzt() * self.xt()
                - self.xz() * operand.xz() * self.xy()
                - self.xz() * operand.yt() * self.zt()
                + self.xz() * operand.zt() * self.yt()
                + self.yt() * operand.s() * self.xt()
                - self.yt() * operand.xy() * self.yt()
                - self.yt() * operand.xyzt() * self.yz()
                - self.yt() * operand.xz() * self.zt()
                + self.yt() * operand.yt() * self.xy()
                + self.yt() * operand.zt() * self.xz()
                - self.yz() * operand.s() * self.xz()
                + self.yz() * operand.xt() * self.zt()
                + self.yz() * operand.xy() * self.yz()
                + self.yz() * operand.xyzt() * self.yt()
                - self.yz() * operand.yz() * self.xy()
                - self.yz() * operand.zt() * self.xt()
                + self.zt() * operand.xt() * self.yz()
                + self.zt() * operand.xy() * self.zt()
                - self.zt() * operand.xz() * self.yt()
                - self.zt() * operand.yt() * self.xz()
                + self.zt() * operand.yz() * self.xt()
                + self.zt() * operand.zt() * self.xy())
                * inv_norm_sq,
            (-(self.xt() * operand.s() * self.zt())
                + self.xt() * operand.xt() * self.xz()
                + self.xt() * operand.xyzt() * self.xy()
                - self.xt() * operand.xz() * self.xt()
                + self.xt() * operand.yt() * self.yz()
                - self.xt() * operand.yz() * self.yt()
                - self.xy() * operand.s() * self.yz()
                - self.xy() * operand.xy() * self.xz()
                - self.xy() * operand.xyzt() * self.xt()
                + self.xy() * operand.xz() * self.xy()
                + self.xy() * operand.yt() * self.zt()
                - self.xy() * operand.zt() * self.yt()
                + self.xz() * operand.xt() * self.xt()
                - self.xz() * operand.xy() * self.xy()
                - self.xz() * operand.xz() * self.xz()
                + self.xz() * operand.yt() * self.yt()
                - self.xz() * operand.yz() * self.yz()
                + self.xz() * operand.zt() * self.zt()
                - self.yt() * operand.xt() * self.yz()
                - self.yt() * operand.xy() * self.zt()
                + self.yt() * operand.xz() * self.yt()
                + self.yt() * operand.yt() * self.xz()
                - self.yt() * operand.yz() * self.xt()
                - self.yt() * operand.zt() * self.xy()
                + self.yz() * operand.s() * self.xy()
                - self.yz() * operand.xt() * self.yt()
                + self.yz() * operand.xyzt() * self.zt()
                + self.yz() * operand.xz() * self.yz()
                + self.yz() * operand.yt() * self.xt()
                - self.yz() * operand.yz() * self.xz()
                + self.zt() * operand.s() * self.xt()
                - self.zt() * operand.xy() * self.yt()
                - self.zt() * operand.xyzt() * self.yz()
                - self.zt() * operand.xz() * self.zt()
                + self.zt() * operand.yt() * self.xy()
                + self.zt() * operand.zt() * self.xz())
                * inv_norm_sq,
            (self.xt() * operand.xt() * self.xt()
                - self.xt() * operand.xy() * self.xy()
                - self.xt() * operand.xz() * self.xz()
                + self.xt() * operand.yt() * self.yt()
                - self.xt() * operand.yz() * self.yz()
                + self.xt() * operand.zt() * self.zt()
                - self.xy() * operand.s() * self.yt()
                + self.xy() * operand.xt() * self.xy()
                - self.xy() * operand.xy() * self.xt()
                - self.xy() * operand.xyzt() * self.xz()
                + self.xy() * operand.yz() * self.zt()
                - self.xy() * operand.zt() * self.yz()
                - self.xz() * operand.s() * self.zt()
                + self.xz() * operand.xt() * self.xz()
                + self.xz() * operand.xyzt() * self.xy()
                - self.xz() * operand.xz() * self.xt()
                + self.xz() * operand.yt() * self.yz()
                - self.xz() * operand.yz() * self.yt()
                + self.yt() * operand.s() * self.xy()
                - self.yt() * operand.xt() * self.yt()
                + self.yt() * operand.xyzt() * self.zt()
                + self.yt() * operand.xz() * self.yz()
                + self.yt() * operand.yt() * self.xt()
                - self.yt() * operand.yz() * self.xz()
                - self.yz() * operand.xt() * self.yz()
                - self.yz() * operand.xy() * self.zt()
                + self.yz() * operand.xz() * self.yt()
                + self.yz() * operand.yt() * self.xz()
                - self.yz() * operand.yz() * self.xt()
                - self.yz() * operand.zt() * self.xy()
                + self.zt() * operand.s() * self.xz()
                - self.zt() * operand.xt() * self.zt()
                - self.zt() * operand.xy() * self.yz()
                - self.zt() * operand.xyzt() * self.yt()
                + self.zt() * operand.yz() * self.xy()
                + self.zt() * operand.zt() * self.xt())
                * inv_norm_sq,
            (self.xt() * operand.xt() * self.yz() + self.xt() * operand.xy() * self.zt()
                - self.xt() * operand.xz() * self.yt()
                - self.xt() * operand.yt() * self.xz()
                + self.xt() * operand.yz() * self.xt()
                + self.xt() * operand.zt() * self.xy()
                + self.xy() * operand.s() * self.xz()
                - self.xy() * operand.xt() * self.zt()
                - self.xy() * operand.xy() * self.yz()
                - self.xy() * operand.xyzt() * self.yt()
                + self.xy() * operand.yz() * self.xy()
                + self.xy() * operand.zt() * self.xt()
                - self.xz() * operand.s() * self.xy()
                + self.xz() * operand.xt() * self.yt()
                - self.xz() * operand.xyzt() * self.zt()
                - self.xz() * operand.xz() * self.yz()
                - self.xz() * operand.yt() * self.xt()
                + self.xz() * operand.yz() * self.xz()
                - self.yt() * operand.s() * self.zt()
                + self.yt() * operand.xt() * self.xz()
                + self.yt() * operand.xyzt() * self.xy()
                - self.yt() * operand.xz() * self.xt()
                + self.yt() * operand.yt() * self.yz()
                - self.yt() * operand.yz() * self.yt()
                + self.yz() * operand.xt() * self.xt()
                - self.yz() * operand.xy() * self.xy()
                - self.yz() * operand.xz() * self.xz()
                + self.yz() * operand.yt() * self.yt()
                - self.yz() * operand.yz() * self.yz()
                + self.yz() * operand.zt() * self.zt()
                + self.zt() * operand.s() * self.yt()
                - self.zt() * operand.xt() * self.xy()
                + self.zt() * operand.xy() * self.xt()
                + self.zt() * operand.xyzt() * self.xz()
                - self.zt() * operand.yz() * self.zt()
                + self.zt() * operand.zt() * self.yz())
                * inv_norm_sq,
            (-(self.xt() * operand.s() * self.xy()) + self.xt() * operand.xt() * self.yt()
                - self.xt() * operand.xyzt() * self.zt()
                - self.xt() * operand.xz() * self.yz()
                - self.xt() * operand.yt() * self.xt()
                + self.xt() * operand.yz() * self.xz()
                + self.xy() * operand.s() * self.xt()
                - self.xy() * operand.xy() * self.yt()
                - self.xy() * operand.xyzt() * self.yz()
                - self.xy() * operand.xz() * self.zt()
                + self.xy() * operand.yt() * self.xy()
                + self.xy() * operand.zt() * self.xz()
                + self.xz() * operand.xt() * self.yz()
                + self.xz() * operand.xy() * self.zt()
                - self.xz() * operand.xz() * self.yt()
                - self.xz() * operand.yt() * self.xz()
                + self.xz() * operand.yz() * self.xt()
                + self.xz() * operand.zt() * self.xy()
                + self.yt() * operand.xt() * self.xt()
                - self.yt() * operand.xy() * self.xy()
                - self.yt() * operand.xz() * self.xz()
                + self.yt() * operand.yt() * self.yt()
                - self.yt() * operand.yz() * self.yz()
                + self.yt() * operand.zt() * self.zt()
                - self.yz() * operand.s() * self.zt()
                + self.yz() * operand.xt() * self.xz()
                + self.yz() * operand.xyzt() * self.xy()
                - self.yz() * operand.xz() * self.xt()
                + self.yz() * operand.yt() * self.yz()
                - self.yz() * operand.yz() * self.yt()
                + self.zt() * operand.s() * self.yz()
                + self.zt() * operand.xy() * self.xz()
                + self.zt() * operand.xyzt() * self.xt()
                - self.zt() * operand.xz() * self.xy()
                - self.zt() * operand.yt() * self.zt()
                + self.zt() * operand.zt() * self.yt())
                * inv_norm_sq,
            (-(self.xt() * operand.s() * self.xz())
                + self.xt() * operand.xt() * self.zt()
                + self.xt() * operand.xy() * self.yz()
                + self.xt() * operand.xyzt() * self.yt()
                - self.xt() * operand.yz() * self.xy()
                - self.xt() * operand.zt() * self.xt()
                - self.xy() * operand.xt() * self.yz()
                - self.xy() * operand.xy() * self.zt()
                + self.xy() * operand.xz() * self.yt()
                + self.xy() * operand.yt() * self.xz()
                - self.xy() * operand.yz() * self.xt()
                - self.xy() * operand.zt() * self.xy()
                + self.xz() * operand.s() * self.xt()
                - self.xz() * operand.xy() * self.yt()
                - self.xz() * operand.xyzt() * self.yz()
                - self.xz() * operand.xz() * self.zt()
                + self.xz() * operand.yt() * self.xy()
                + self.xz() * operand.zt() * self.xz()
                - self.yt() * operand.s() * self.yz()
                - self.yt() * operand.xy() * self.xz()
                - self.yt() * operand.xyzt() * self.xt()
                + self.yt() * operand.xz() * self.xy()
                + self.yt() * operand.yt() * self.zt()
                - self.yt() * operand.zt() * self.yt()
                + self.yz() * operand.s() * self.yt()
                - self.yz() * operand.xt() * self.xy()
                + self.yz() * operand.xy() * self.xt()
                + self.yz() * operand.xyzt() * self.xz()
                - self.yz() * operand.yz() * self.zt()
                + self.yz() * operand.zt() * self.yz()
                + self.zt() * operand.xt() * self.xt()
                - self.zt() * operand.xy() * self.xy()
                - self.zt() * operand.xz() * self.xz()
                + self.zt() * operand.yt() * self.yt()
                - self.zt() * operand.yz() * self.yz()
                + self.zt() * operand.zt() * self.zt())
                * inv_norm_sq,
            (self.xt() * operand.s() * self.yz()
                + self.xt() * operand.xy() * self.xz()
                + self.xt() * operand.xyzt() * self.xt()
                - self.xt() * operand.xz() * self.xy()
                - self.xt() * operand.yt() * self.zt()
                + self.xt() * operand.zt() * self.yt()
                + self.xy() * operand.s() * self.zt()
                - self.xy() * operand.xt() * self.xz()
                - self.xy() * operand.xyzt() * self.xy()
                + self.xy() * operand.xz() * self.xt()
                - self.xy() * operand.yt() * self.yz()
                + self.xy() * operand.yz() * self.yt()
                - self.xz() * operand.s() * self.yt()
                + self.xz() * operand.xt() * self.xy()
                - self.xz() * operand.xy() * self.xt()
                - self.xz() * operand.xyzt() * self.xz()
                + self.xz() * operand.yz() * self.zt()
                - self.xz() * operand.zt() * self.yz()
                - self.yt() * operand.s() * self.xz()
                + self.yt() * operand.xt() * self.zt()
                + self.yt() * operand.xy() * self.yz()
                + self.yt() * operand.xyzt() * self.yt()
                - self.yt() * operand.yz() * self.xy()
                - self.yt() * operand.zt() * self.xt()
                + self.yz() * operand.s() * self.xt()
                - self.yz() * operand.xy() * self.yt()
                - self.yz() * operand.xyzt() * self.yz()
                - self.yz() * operand.xz() * self.zt()
                + self.yz() * operand.yt() * self.xy()
                + self.yz() * operand.zt() * self.xz()
                + self.zt() * operand.s() * self.xy()
                - self.zt() * operand.xt() * self.yt()
                + self.zt() * operand.xyzt() * self.zt()
                + self.zt() * operand.xz() * self.yz()
                + self.zt() * operand.yt() * self.xt()
                - self.zt() * operand.yz() * self.xz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Pseudoscalar<T>> for Bivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (self.xt() * operand.xyzt() * self.xt()
                - self.xy() * operand.xyzt() * self.xy()
                - self.xz() * operand.xyzt() * self.xz()
                + self.yt() * operand.xyzt() * self.yt()
                - self.yz() * operand.xyzt() * self.yz()
                + self.zt() * operand.xyzt() * self.zt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.xt() * operand.s() * self.xt()
                - self.xy() * operand.s() * self.xy()
                - self.xz() * operand.s() * self.xz()
                + self.yt() * operand.s() * self.yt()
                - self.yz() * operand.s() * self.yz()
                + self.zt() * operand.s() * self.zt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Trivector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked(
            (-(self.xt() * operand.xyt() * self.xz())
                + self.xt() * operand.xyz() * self.xt()
                + self.xt() * operand.xzt() * self.xy()
                + self.xy() * operand.xyz() * self.xy()
                + self.xy() * operand.xzt() * self.xt()
                + self.xy() * operand.yzt() * self.yt()
                - self.xz() * operand.xyt() * self.xt()
                + self.xz() * operand.xyz() * self.xz()
                + self.xz() * operand.yzt() * self.zt()
                - self.yt() * operand.xyt() * self.yz()
                + self.yt() * operand.xyz() * self.yt()
                + self.yt() * operand.yzt() * self.xy()
                - self.yz() * operand.xyt() * self.yt()
                + self.yz() * operand.xyz() * self.yz()
                - self.yz() * operand.xzt() * self.zt()
                + self.zt() * operand.xyz() * self.zt()
                - self.zt() * operand.xzt() * self.yz()
                + self.zt() * operand.yzt() * self.xz())
                * inv_norm_sq,
            (-(self.xt() * operand.xyt() * self.xt())
                + self.xt() * operand.xyz() * self.xz()
                + self.xt() * operand.yzt() * self.zt()
                + self.xy() * operand.xyt() * self.xy()
                + self.xy() * operand.xzt() * self.xz()
                + self.xy() * operand.yzt() * self.yz()
                - self.xz() * operand.xyt() * self.xz()
                + self.xz() * operand.xyz() * self.xt()
                + self.xz() * operand.xzt() * self.xy()
                - self.yt() * operand.xyt() * self.yt()
                + self.yt() * operand.xyz() * self.yz()
                - self.yt() * operand.xzt() * self.zt()
                - self.yz() * operand.xyt() * self.yz()
                + self.yz() * operand.xyz() * self.yt()
                + self.yz() * operand.yzt() * self.xy()
                + self.zt() * operand.xyt() * self.zt()
                - self.zt() * operand.xzt() * self.yt()
                + self.zt() * operand.yzt() * self.xt())
                * inv_norm_sq,
            (-(self.xt() * operand.xyz() * self.xy())
                - self.xt() * operand.xzt() * self.xt()
                - self.xt() * operand.yzt() * self.yt()
                + self.xy() * operand.xyt() * self.xz()
                - self.xy() * operand.xyz() * self.xt()
                - self.xy() * operand.xzt() * self.xy()
                + self.xz() * operand.xyt() * self.xy()
                + self.xz() * operand.xzt() * self.xz()
                + self.xz() * operand.yzt() * self.yz()
                - self.yt() * operand.xyt() * self.zt()
                + self.yt() * operand.xzt() * self.yt()
                - self.yt() * operand.yzt() * self.xt()
                + self.yz() * operand.xyz() * self.zt()
                - self.yz() * operand.xzt() * self.yz()
                + self.yz() * operand.yzt() * self.xz()
                - self.zt() * operand.xyt() * self.yt()
                + self.zt() * operand.xyz() * self.yz()
                - self.zt() * operand.xzt() * self.zt())
                * inv_norm_sq,
            (self.xt() * operand.xyt() * self.zt() - self.xt() * operand.xzt() * self.yt()
                + self.xt() * operand.yzt() * self.xt()
                + self.xy() * operand.xyt() * self.yz()
                - self.xy() * operand.xyz() * self.yt()
                - self.xy() * operand.yzt() * self.xy()
                - self.xz() * operand.xyz() * self.zt()
                + self.xz() * operand.xzt() * self.yz()
                - self.xz() * operand.yzt() * self.xz()
                - self.yt() * operand.xyz() * self.xy()
                - self.yt() * operand.xzt() * self.xt()
                - self.yt() * operand.yzt() * self.yt()
                + self.yz() * operand.xyt() * self.xy()
                + self.yz() * operand.xzt() * self.xz()
                + self.yz() * operand.yzt() * self.yz()
                + self.zt() * operand.xyt() * self.xt()
                - self.zt() * operand.xyz() * self.xz()
                - self.zt() * operand.yzt() * self.zt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (self.xt() * operand.x() * self.xt()
                + self.xt() * operand.y() * self.yt()
                + self.xt() * operand.z() * self.zt()
                - self.xy() * operand.t() * self.yt()
                - self.xy() * operand.x() * self.xy()
                + self.xy() * operand.z() * self.yz()
                - self.xz() * operand.t() * self.zt()
                - self.xz() * operand.x() * self.xz()
                - self.xz() * operand.y() * self.yz()
                - self.yt() * operand.t() * self.xy()
                - self.yt() * operand.x() * self.yt()
                + self.yt() * operand.y() * self.xt()
                + self.yz() * operand.x() * self.yz()
                - self.yz() * operand.y() * self.xz()
                + self.yz() * operand.z() * self.xy()
                - self.zt() * operand.t() * self.xz()
                - self.zt() * operand.x() * self.zt()
                + self.zt() * operand.z() * self.xt())
                * inv_norm_sq,
            (self.xt() * operand.t() * self.xy() + self.xt() * operand.x() * self.yt()
                - self.xt() * operand.y() * self.xt()
                + self.xy() * operand.t() * self.xt()
                - self.xy() * operand.y() * self.xy()
                - self.xy() * operand.z() * self.xz()
                - self.xz() * operand.x() * self.yz()
                + self.xz() * operand.y() * self.xz()
                - self.xz() * operand.z() * self.xy()
                + self.yt() * operand.x() * self.xt()
                + self.yt() * operand.y() * self.yt()
                + self.yt() * operand.z() * self.zt()
                - self.yz() * operand.t() * self.zt()
                - self.yz() * operand.x() * self.xz()
                - self.yz() * operand.y() * self.yz()
                - self.zt() * operand.t() * self.yz()
                - self.zt() * operand.y() * self.zt()
                + self.zt() * operand.z() * self.yt())
                * inv_norm_sq,
            (self.xt() * operand.t() * self.xz() + self.xt() * operand.x() * self.zt()
                - self.xt() * operand.z() * self.xt()
                + self.xy() * operand.x() * self.yz()
                - self.xy() * operand.y() * self.xz()
                + self.xy() * operand.z() * self.xy()
                + self.xz() * operand.t() * self.xt()
                - self.xz() * operand.y() * self.xy()
                - self.xz() * operand.z() * self.xz()
                + self.yt() * operand.t() * self.yz()
                + self.yt() * operand.y() * self.zt()
                - self.yt() * operand.z() * self.yt()
                + self.yz() * operand.t() * self.yt()
                + self.yz() * operand.x() * self.xy()
                - self.yz() * operand.z() * self.yz()
                + self.zt() * operand.x() * self.xt()
                + self.zt() * operand.y() * self.yt()
                + self.zt() * operand.z() * self.zt())
                * inv_norm_sq,
            (self.xt() * operand.t() * self.xt()
                - self.xt() * operand.y() * self.xy()
                - self.xt() * operand.z() * self.xz()
                + self.xy() * operand.t() * self.xy()
                + self.xy() * operand.x() * self.yt()
                - self.xy() * operand.y() * self.xt()
                + self.xz() * operand.t() * self.xz()
                + self.xz() * operand.x() * self.zt()
                - self.xz() * operand.z() * self.xt()
                + self.yt() * operand.t() * self.yt()
                + self.yt() * operand.x() * self.xy()
                - self.yt() * operand.z() * self.yz()
                + self.yz() * operand.t() * self.yz()
                + self.yz() * operand.y() * self.zt()
                - self.yz() * operand.z() * self.yt()
                + self.zt() * operand.t() * self.zt()
                + self.zt() * operand.x() * self.xz()
                + self.zt() * operand.y() * self.yz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Bivector<T>> for Eventor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (-(self.s() * operand.xt() * self.yt()) - self.s() * operand.xy() * self.s()
                + self.s() * operand.xz() * self.yz()
                + self.s() * operand.yt() * self.xt()
                - self.s() * operand.yz() * self.xz()
                - self.s() * operand.zt() * self.xyzt()
                + self.xt() * operand.xt() * self.xy()
                - self.xt() * operand.xy() * self.xt()
                + self.xt() * operand.xz() * self.xyzt()
                + self.xt() * operand.yt() * self.s()
                + self.xt() * operand.yz() * self.zt()
                - self.xt() * operand.zt() * self.yz()
                + self.xy() * operand.xt() * self.xt()
                - self.xy() * operand.xy() * self.xy()
                - self.xy() * operand.xz() * self.xz()
                + self.xy() * operand.yt() * self.yt()
                - self.xy() * operand.yz() * self.yz()
                + self.xy() * operand.zt() * self.zt()
                - self.xyzt() * operand.xt() * self.xz()
                + self.xyzt() * operand.xy() * self.xyzt()
                + self.xyzt() * operand.xz() * self.xt()
                - self.xyzt() * operand.yt() * self.yz()
                + self.xyzt() * operand.yz() * self.yt()
                - self.xyzt() * operand.zt() * self.s()
                - self.xz() * operand.xt() * self.xyzt()
                + self.xz() * operand.xy() * self.xz()
                - self.xz() * operand.xz() * self.xy()
                - self.xz() * operand.yt() * self.zt()
                - self.xz() * operand.yz() * self.s()
                + self.xz() * operand.zt() * self.yt()
                - self.yt() * operand.xt() * self.s()
                - self.yt() * operand.xy() * self.yt()
                - self.yt() * operand.xz() * self.zt()
                + self.yt() * operand.yt() * self.xy()
                + self.yt() * operand.yz() * self.xyzt()
                + self.yt() * operand.zt() * self.xz()
                + self.yz() * operand.xt() * self.zt()
                + self.yz() * operand.xy() * self.yz()
                + self.yz() * operand.xz() * self.s()
                - self.yz() * operand.yt() * self.xyzt()
                - self.yz() * operand.yz() * self.xy()
                - self.yz() * operand.zt() * self.xt()
                + self.zt() * operand.xt() * self.yz()
                + self.zt() * operand.xy() * self.zt()
                - self.zt() * operand.xz() * self.yt()
                - self.zt() * operand.yt() * self.xz()
                + self.zt() * operand.yz() * self.xt()
                + self.zt() * operand.zt() * self.xy())
                * inv_norm_sq,
            (-(self.s() * operand.xt() * self.zt())
                - self.s() * operand.xy() * self.yz()
                - self.s() * operand.xz() * self.s()
                + self.s() * operand.yt() * self.xyzt()
                + self.s() * operand.yz() * self.xy()
                + self.s() * operand.zt() * self.xt()
                + self.xt() * operand.xt() * self.xz()
                - self.xt() * operand.xy() * self.xyzt()
                - self.xt() * operand.xz() * self.xt()
                + self.xt() * operand.yt() * self.yz()
                - self.xt() * operand.yz() * self.yt()
                + self.xt() * operand.zt() * self.s()
                + self.xy() * operand.xt() * self.xyzt()
                - self.xy() * operand.xy() * self.xz()
                + self.xy() * operand.xz() * self.xy()
                + self.xy() * operand.yt() * self.zt()
                + self.xy() * operand.yz() * self.s()
                - self.xy() * operand.zt() * self.yt()
                + self.xyzt() * operand.xt() * self.xy()
                - self.xyzt() * operand.xy() * self.xt()
                + self.xyzt() * operand.xz() * self.xyzt()
                + self.xyzt() * operand.yt() * self.s()
                + self.xyzt() * operand.yz() * self.zt()
                - self.xyzt() * operand.zt() * self.yz()
                + self.xz() * operand.xt() * self.xt()
                - self.xz() * operand.xy() * self.xy()
                - self.xz() * operand.xz() * self.xz()
                + self.xz() * operand.yt() * self.yt()
                - self.xz() * operand.yz() * self.yz()
                + self.xz() * operand.zt() * self.zt()
                - self.yt() * operand.xt() * self.yz()
                - self.yt() * operand.xy() * self.zt()
                + self.yt() * operand.xz() * self.yt()
                + self.yt() * operand.yt() * self.xz()
                - self.yt() * operand.yz() * self.xt()
                - self.yt() * operand.zt() * self.xy()
                - self.yz() * operand.xt() * self.yt()
                - self.yz() * operand.xy() * self.s()
                + self.yz() * operand.xz() * self.yz()
                + self.yz() * operand.yt() * self.xt()
                - self.yz() * operand.yz() * self.xz()
                - self.yz() * operand.zt() * self.xyzt()
                - self.zt() * operand.xt() * self.s()
                - self.zt() * operand.xy() * self.yt()
                - self.zt() * operand.xz() * self.zt()
                + self.zt() * operand.yt() * self.xy()
                + self.zt() * operand.yz() * self.xyzt()
                + self.zt() * operand.zt() * self.xz())
                * inv_norm_sq,
            (-(self.s() * operand.xt() * self.s())
                - self.s() * operand.xy() * self.yt()
                - self.s() * operand.xz() * self.zt()
                + self.s() * operand.yt() * self.xy()
                + self.s() * operand.yz() * self.xyzt()
                + self.s() * operand.zt() * self.xz()
                + self.xt() * operand.xt() * self.xt()
                - self.xt() * operand.xy() * self.xy()
                - self.xt() * operand.xz() * self.xz()
                + self.xt() * operand.yt() * self.yt()
                - self.xt() * operand.yz() * self.yz()
                + self.xt() * operand.zt() * self.zt()
                + self.xy() * operand.xt() * self.xy()
                - self.xy() * operand.xy() * self.xt()
                + self.xy() * operand.xz() * self.xyzt()
                + self.xy() * operand.yt() * self.s()
                + self.xy() * operand.yz() * self.zt()
                - self.xy() * operand.zt() * self.yz()
                + self.xyzt() * operand.xt() * self.xyzt()
                - self.xyzt() * operand.xy() * self.xz()
                + self.xyzt() * operand.xz() * self.xy()
                + self.xyzt() * operand.yt() * self.zt()
                + self.xyzt() * operand.yz() * self.s()
                - self.xyzt() * operand.zt() * self.yt()
                + self.xz() * operand.xt() * self.xz()
                - self.xz() * operand.xy() * self.xyzt()
                - self.xz() * operand.xz() * self.xt()
                + self.xz() * operand.yt() * self.yz()
                - self.xz() * operand.yz() * self.yt()
                + self.xz() * operand.zt() * self.s()
                - self.yt() * operand.xt() * self.yt()
                - self.yt() * operand.xy() * self.s()
                + self.yt() * operand.xz() * self.yz()
                + self.yt() * operand.yt() * self.xt()
                - self.yt() * operand.yz() * self.xz()
                - self.yt() * operand.zt() * self.xyzt()
                - self.yz() * operand.xt() * self.yz()
                - self.yz() * operand.xy() * self.zt()
                + self.yz() * operand.xz() * self.yt()
                + self.yz() * operand.yt() * self.xz()
                - self.yz() * operand.yz() * self.xt()
                - self.yz() * operand.zt() * self.xy()
                - self.zt() * operand.xt() * self.zt()
                - self.zt() * operand.xy() * self.yz()
                - self.zt() * operand.xz() * self.s()
                + self.zt() * operand.yt() * self.xyzt()
                + self.zt() * operand.yz() * self.xy()
                + self.zt() * operand.zt() * self.xt())
                * inv_norm_sq,
            (-(self.s() * operand.xt() * self.xyzt()) + self.s() * operand.xy() * self.xz()
                - self.s() * operand.xz() * self.xy()
                - self.s() * operand.yt() * self.zt()
                - self.s() * operand.yz() * self.s()
                + self.s() * operand.zt() * self.yt()
                + self.xt() * operand.xt() * self.yz()
                + self.xt() * operand.xy() * self.zt()
                - self.xt() * operand.xz() * self.yt()
                - self.xt() * operand.yt() * self.xz()
                + self.xt() * operand.yz() * self.xt()
                + self.xt() * operand.zt() * self.xy()
                - self.xy() * operand.xt() * self.zt()
                - self.xy() * operand.xy() * self.yz()
                - self.xy() * operand.xz() * self.s()
                + self.xy() * operand.yt() * self.xyzt()
                + self.xy() * operand.yz() * self.xy()
                + self.xy() * operand.zt() * self.xt()
                - self.xyzt() * operand.xt() * self.s()
                - self.xyzt() * operand.xy() * self.yt()
                - self.xyzt() * operand.xz() * self.zt()
                + self.xyzt() * operand.yt() * self.xy()
                + self.xyzt() * operand.yz() * self.xyzt()
                + self.xyzt() * operand.zt() * self.xz()
                + self.xz() * operand.xt() * self.yt()
                + self.xz() * operand.xy() * self.s()
                - self.xz() * operand.xz() * self.yz()
                - self.xz() * operand.yt() * self.xt()
                + self.xz() * operand.yz() * self.xz()
                + self.xz() * operand.zt() * self.xyzt()
                + self.yt() * operand.xt() * self.xz()
                - self.yt() * operand.xy() * self.xyzt()
                - self.yt() * operand.xz() * self.xt()
                + self.yt() * operand.yt() * self.yz()
                - self.yt() * operand.yz() * self.yt()
                + self.yt() * operand.zt() * self.s()
                + self.yz() * operand.xt() * self.xt()
                - self.yz() * operand.xy() * self.xy()
                - self.yz() * operand.xz() * self.xz()
                + self.yz() * operand.yt() * self.yt()
                - self.yz() * operand.yz() * self.yz()
                + self.yz() * operand.zt() * self.zt()
                - self.zt() * operand.xt() * self.xy()
                + self.zt() * operand.xy() * self.xt()
                - self.zt() * operand.xz() * self.xyzt()
                - self.zt() * operand.yt() * self.s()
                - self.zt() * operand.yz() * self.zt()
                + self.zt() * operand.zt() * self.yz())
                * inv_norm_sq,
            (-(self.s() * operand.xt() * self.xy()) + self.s() * operand.xy() * self.xt()
                - self.s() * operand.xz() * self.xyzt()
                - self.s() * operand.yt() * self.s()
                - self.s() * operand.yz() * self.zt()
                + self.s() * operand.zt() * self.yz()
                + self.xt() * operand.xt() * self.yt()
                + self.xt() * operand.xy() * self.s()
                - self.xt() * operand.xz() * self.yz()
                - self.xt() * operand.yt() * self.xt()
                + self.xt() * operand.yz() * self.xz()
                + self.xt() * operand.zt() * self.xyzt()
                - self.xy() * operand.xt() * self.s()
                - self.xy() * operand.xy() * self.yt()
                - self.xy() * operand.xz() * self.zt()
                + self.xy() * operand.yt() * self.xy()
                + self.xy() * operand.yz() * self.xyzt()
                + self.xy() * operand.zt() * self.xz()
                - self.xyzt() * operand.xt() * self.zt()
                - self.xyzt() * operand.xy() * self.yz()
                - self.xyzt() * operand.xz() * self.s()
                + self.xyzt() * operand.yt() * self.xyzt()
                + self.xyzt() * operand.yz() * self.xy()
                + self.xyzt() * operand.zt() * self.xt()
                + self.xz() * operand.xt() * self.yz()
                + self.xz() * operand.xy() * self.zt()
                - self.xz() * operand.xz() * self.yt()
                - self.xz() * operand.yt() * self.xz()
                + self.xz() * operand.yz() * self.xt()
                + self.xz() * operand.zt() * self.xy()
                + self.yt() * operand.xt() * self.xt()
                - self.yt() * operand.xy() * self.xy()
                - self.yt() * operand.xz() * self.xz()
                + self.yt() * operand.yt() * self.yt()
                - self.yt() * operand.yz() * self.yz()
                + self.yt() * operand.zt() * self.zt()
                + self.yz() * operand.xt() * self.xz()
                - self.yz() * operand.xy() * self.xyzt()
                - self.yz() * operand.xz() * self.xt()
                + self.yz() * operand.yt() * self.yz()
                - self.yz() * operand.yz() * self.yt()
                + self.yz() * operand.zt() * self.s()
                - self.zt() * operand.xt() * self.xyzt()
                + self.zt() * operand.xy() * self.xz()
                - self.zt() * operand.xz() * self.xy()
                - self.zt() * operand.yt() * self.zt()
                - self.zt() * operand.yz() * self.s()
                + self.zt() * operand.zt() * self.yt())
                * inv_norm_sq,
            (-(self.s() * operand.xt() * self.xz())
                + self.s() * operand.xy() * self.xyzt()
                + self.s() * operand.xz() * self.xt()
                - self.s() * operand.yt() * self.yz()
                + self.s() * operand.yz() * self.yt()
                - self.s() * operand.zt() * self.s()
                + self.xt() * operand.xt() * self.zt()
                + self.xt() * operand.xy() * self.yz()
                + self.xt() * operand.xz() * self.s()
                - self.xt() * operand.yt() * self.xyzt()
                - self.xt() * operand.yz() * self.xy()
                - self.xt() * operand.zt() * self.xt()
                - self.xy() * operand.xt() * self.yz()
                - self.xy() * operand.xy() * self.zt()
                + self.xy() * operand.xz() * self.yt()
                + self.xy() * operand.yt() * self.xz()
                - self.xy() * operand.yz() * self.xt()
                - self.xy() * operand.zt() * self.xy()
                + self.xyzt() * operand.xt() * self.yt()
                + self.xyzt() * operand.xy() * self.s()
                - self.xyzt() * operand.xz() * self.yz()
                - self.xyzt() * operand.yt() * self.xt()
                + self.xyzt() * operand.yz() * self.xz()
                + self.xyzt() * operand.zt() * self.xyzt()
                - self.xz() * operand.xt() * self.s()
                - self.xz() * operand.xy() * self.yt()
                - self.xz() * operand.xz() * self.zt()
                + self.xz() * operand.yt() * self.xy()
                + self.xz() * operand.yz() * self.xyzt()
                + self.xz() * operand.zt() * self.xz()
                + self.yt() * operand.xt() * self.xyzt()
                - self.yt() * operand.xy() * self.xz()
                + self.yt() * operand.xz() * self.xy()
                + self.yt() * operand.yt() * self.zt()
                + self.yt() * operand.yz() * self.s()
                - self.yt() * operand.zt() * self.yt()
                - self.yz() * operand.xt() * self.xy()
                + self.yz() * operand.xy() * self.xt()
                - self.yz() * operand.xz() * self.xyzt()
                - self.yz() * operand.yt() * self.s()
                - self.yz() * operand.yz() * self.zt()
                + self.yz() * operand.zt() * self.yz()
                + self.zt() * operand.xt() * self.xt()
                - self.zt() * operand.xy() * self.xy()
                - self.zt() * operand.xz() * self.xz()
                + self.zt() * operand.yt() * self.yt()
                - self.zt() * operand.yz() * self.yz()
                + self.zt() * operand.zt() * self.zt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Eventor<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (-(self.s() * operand.s() * self.s()) + self.s() * operand.xt() * self.xt()
                - self.s() * operand.xy() * self.xy()
                + self.s() * operand.xyzt() * self.xyzt()
                - self.s() * operand.xz() * self.xz()
                + self.s() * operand.yt() * self.yt()
                - self.s() * operand.yz() * self.yz()
                + self.s() * operand.zt() * self.zt()
                + self.xt() * operand.s() * self.xt()
                - self.xt() * operand.xt() * self.s()
                - self.xt() * operand.xy() * self.yt()
                - self.xt() * operand.xyzt() * self.yz()
                - self.xt() * operand.xz() * self.zt()
                + self.xt() * operand.yt() * self.xy()
                + self.xt() * operand.yz() * self.xyzt()
                + self.xt() * operand.zt() * self.xz()
                - self.xy() * operand.s() * self.xy()
                + self.xy() * operand.xt() * self.yt()
                + self.xy() * operand.xy() * self.s()
                - self.xy() * operand.xyzt() * self.zt()
                - self.xy() * operand.xz() * self.yz()
                - self.xy() * operand.yt() * self.xt()
                + self.xy() * operand.yz() * self.xz()
                + self.xy() * operand.zt() * self.xyzt()
                + self.xyzt() * operand.s() * self.xyzt()
                - self.xyzt() * operand.xt() * self.yz()
                - self.xyzt() * operand.xy() * self.zt()
                + self.xyzt() * operand.xyzt() * self.s()
                + self.xyzt() * operand.xz() * self.yt()
                + self.xyzt() * operand.yt() * self.xz()
                - self.xyzt() * operand.yz() * self.xt()
                - self.xyzt() * operand.zt() * self.xy()
                - self.xz() * operand.s() * self.xz()
                + self.xz() * operand.xt() * self.zt()
                + self.xz() * operand.xy() * self.yz()
                + self.xz() * operand.xyzt() * self.yt()
                + self.xz() * operand.xz() * self.s()
                - self.xz() * operand.yt() * self.xyzt()
                - self.xz() * operand.yz() * self.xy()
                - self.xz() * operand.zt() * self.xt()
                + self.yt() * operand.s() * self.yt()
                - self.yt() * operand.xt() * self.xy()
                + self.yt() * operand.xy() * self.xt()
                + self.yt() * operand.xyzt() * self.xz()
                - self.yt() * operand.xz() * self.xyzt()
                - self.yt() * operand.yt() * self.s()
                - self.yt() * operand.yz() * self.zt()
                + self.yt() * operand.zt() * self.yz()
                - self.yz() * operand.s() * self.yz()
                + self.yz() * operand.xt() * self.xyzt()
                - self.yz() * operand.xy() * self.xz()
                - self.yz() * operand.xyzt() * self.xt()
                + self.yz() * operand.xz() * self.xy()
                + self.yz() * operand.yt() * self.zt()
                + self.yz() * operand.yz() * self.s()
                - self.yz() * operand.zt() * self.yt()
                + self.zt() * operand.s() * self.zt()
                - self.zt() * operand.xt() * self.xz()
                + self.zt() * operand.xy() * self.xyzt()
                - self.zt() * operand.xyzt() * self.xy()
                + self.zt() * operand.xz() * self.xt()
                - self.zt() * operand.yt() * self.yz()
                + self.zt() * operand.yz() * self.yt()
                - self.zt() * operand.zt() * self.s())
                * inv_norm_sq,
            (self.s() * operand.s() * self.xy()
                - self.s() * operand.xt() * self.yt()
                - self.s() * operand.xy() * self.s()
                + self.s() * operand.xyzt() * self.zt()
                + self.s() * operand.xz() * self.yz()
                + self.s() * operand.yt() * self.xt()
                - self.s() * operand.yz() * self.xz()
                - self.s() * operand.zt() * self.xyzt()
                - self.xt() * operand.s() * self.yt()
                + self.xt() * operand.xt() * self.xy()
                - self.xt() * operand.xy() * self.xt()
                - self.xt() * operand.xyzt() * self.xz()
                + self.xt() * operand.xz() * self.xyzt()
                + self.xt() * operand.yt() * self.s()
                + self.xt() * operand.yz() * self.zt()
                - self.xt() * operand.zt() * self.yz()
                - self.xy() * operand.s() * self.s()
                + self.xy() * operand.xt() * self.xt()
                - self.xy() * operand.xy() * self.xy()
                + self.xy() * operand.xyzt() * self.xyzt()
                - self.xy() * operand.xz() * self.xz()
                + self.xy() * operand.yt() * self.yt()
                - self.xy() * operand.yz() * self.yz()
                + self.xy() * operand.zt() * self.zt()
                + self.xyzt() * operand.s() * self.zt()
                - self.xyzt() * operand.xt() * self.xz()
                + self.xyzt() * operand.xy() * self.xyzt()
                - self.xyzt() * operand.xyzt() * self.xy()
                + self.xyzt() * operand.xz() * self.xt()
                - self.xyzt() * operand.yt() * self.yz()
                + self.xyzt() * operand.yz() * self.yt()
                - self.xyzt() * operand.zt() * self.s()
                + self.xz() * operand.s() * self.yz()
                - self.xz() * operand.xt() * self.xyzt()
                + self.xz() * operand.xy() * self.xz()
                + self.xz() * operand.xyzt() * self.xt()
                - self.xz() * operand.xz() * self.xy()
                - self.xz() * operand.yt() * self.zt()
                - self.xz() * operand.yz() * self.s()
                + self.xz() * operand.zt() * self.yt()
                + self.yt() * operand.s() * self.xt()
                - self.yt() * operand.xt() * self.s()
                - self.yt() * operand.xy() * self.yt()
                - self.yt() * operand.xyzt() * self.yz()
                - self.yt() * operand.xz() * self.zt()
                + self.yt() * operand.yt() * self.xy()
                + self.yt() * operand.yz() * self.xyzt()
                + self.yt() * operand.zt() * self.xz()
                - self.yz() * operand.s() * self.xz()
                + self.yz() * operand.xt() * self.zt()
                + self.yz() * operand.xy() * self.yz()
                + self.yz() * operand.xyzt() * self.yt()
                + self.yz() * operand.xz() * self.s()
                - self.yz() * operand.yt() * self.xyzt()
                - self.yz() * operand.yz() * self.xy()
                - self.yz() * operand.zt() * self.xt()
                - self.zt() * operand.s() * self.xyzt()
                + self.zt() * operand.xt() * self.yz()
                + self.zt() * operand.xy() * self.zt()
                - self.zt() * operand.xyzt() * self.s()
                - self.zt() * operand.xz() * self.yt()
                - self.zt() * operand.yt() * self.xz()
                + self.zt() * operand.yz() * self.xt()
                + self.zt() * operand.zt() * self.xy())
                * inv_norm_sq,
            (self.s() * operand.s() * self.xz()
                - self.s() * operand.xt() * self.zt()
                - self.s() * operand.xy() * self.yz()
                - self.s() * operand.xyzt() * self.yt()
                - self.s() * operand.xz() * self.s()
                + self.s() * operand.yt() * self.xyzt()
                + self.s() * operand.yz() * self.xy()
                + self.s() * operand.zt() * self.xt()
                - self.xt() * operand.s() * self.zt()
                + self.xt() * operand.xt() * self.xz()
                - self.xt() * operand.xy() * self.xyzt()
                + self.xt() * operand.xyzt() * self.xy()
                - self.xt() * operand.xz() * self.xt()
                + self.xt() * operand.yt() * self.yz()
                - self.xt() * operand.yz() * self.yt()
                + self.xt() * operand.zt() * self.s()
                - self.xy() * operand.s() * self.yz()
                + self.xy() * operand.xt() * self.xyzt()
                - self.xy() * operand.xy() * self.xz()
                - self.xy() * operand.xyzt() * self.xt()
                + self.xy() * operand.xz() * self.xy()
                + self.xy() * operand.yt() * self.zt()
                + self.xy() * operand.yz() * self.s()
                - self.xy() * operand.zt() * self.yt()
                - self.xyzt() * operand.s() * self.yt()
                + self.xyzt() * operand.xt() * self.xy()
                - self.xyzt() * operand.xy() * self.xt()
                - self.xyzt() * operand.xyzt() * self.xz()
                + self.xyzt() * operand.xz() * self.xyzt()
                + self.xyzt() * operand.yt() * self.s()
                + self.xyzt() * operand.yz() * self.zt()
                - self.xyzt() * operand.zt() * self.yz()
                - self.xz() * operand.s() * self.s()
                + self.xz() * operand.xt() * self.xt()
                - self.xz() * operand.xy() * self.xy()
                + self.xz() * operand.xyzt() * self.xyzt()
                - self.xz() * operand.xz() * self.xz()
                + self.xz() * operand.yt() * self.yt()
                - self.xz() * operand.yz() * self.yz()
                + self.xz() * operand.zt() * self.zt()
                + self.yt() * operand.s() * self.xyzt()
                - self.yt() * operand.xt() * self.yz()
                - self.yt() * operand.xy() * self.zt()
                + self.yt() * operand.xyzt() * self.s()
                + self.yt() * operand.xz() * self.yt()
                + self.yt() * operand.yt() * self.xz()
                - self.yt() * operand.yz() * self.xt()
                - self.yt() * operand.zt() * self.xy()
                + self.yz() * operand.s() * self.xy()
                - self.yz() * operand.xt() * self.yt()
                - self.yz() * operand.xy() * self.s()
                + self.yz() * operand.xyzt() * self.zt()
                + self.yz() * operand.xz() * self.yz()
                + self.yz() * operand.yt() * self.xt()
                - self.yz() * operand.yz() * self.xz()
                - self.yz() * operand.zt() * self.xyzt()
                + self.zt() * operand.s() * self.xt()
                - self.zt() * operand.xt() * self.s()
                - self.zt() * operand.xy() * self.yt()
                - self.zt() * operand.xyzt() * self.yz()
                - self.zt() * operand.xz() * self.zt()
                + self.zt() * operand.yt() * self.xy()
                + self.zt() * operand.yz() * self.xyzt()
                + self.zt() * operand.zt() * self.xz())
                * inv_norm_sq,
            (self.s() * operand.s() * self.xt()
                - self.s() * operand.xt() * self.s()
                - self.s() * operand.xy() * self.yt()
                - self.s() * operand.xyzt() * self.yz()
                - self.s() * operand.xz() * self.zt()
                + self.s() * operand.yt() * self.xy()
                + self.s() * operand.yz() * self.xyzt()
                + self.s() * operand.zt() * self.xz()
                - self.xt() * operand.s() * self.s()
                + self.xt() * operand.xt() * self.xt()
                - self.xt() * operand.xy() * self.xy()
                + self.xt() * operand.xyzt() * self.xyzt()
                - self.xt() * operand.xz() * self.xz()
                + self.xt() * operand.yt() * self.yt()
                - self.xt() * operand.yz() * self.yz()
                + self.xt() * operand.zt() * self.zt()
                - self.xy() * operand.s() * self.yt()
                + self.xy() * operand.xt() * self.xy()
                - self.xy() * operand.xy() * self.xt()
                - self.xy() * operand.xyzt() * self.xz()
                + self.xy() * operand.xz() * self.xyzt()
                + self.xy() * operand.yt() * self.s()
                + self.xy() * operand.yz() * self.zt()
                - self.xy() * operand.zt() * self.yz()
                - self.xyzt() * operand.s() * self.yz()
                + self.xyzt() * operand.xt() * self.xyzt()
                - self.xyzt() * operand.xy() * self.xz()
                - self.xyzt() * operand.xyzt() * self.xt()
                + self.xyzt() * operand.xz() * self.xy()
                + self.xyzt() * operand.yt() * self.zt()
                + self.xyzt() * operand.yz() * self.s()
                - self.xyzt() * operand.zt() * self.yt()
                - self.xz() * operand.s() * self.zt()
                + self.xz() * operand.xt() * self.xz()
                - self.xz() * operand.xy() * self.xyzt()
                + self.xz() * operand.xyzt() * self.xy()
                - self.xz() * operand.xz() * self.xt()
                + self.xz() * operand.yt() * self.yz()
                - self.xz() * operand.yz() * self.yt()
                + self.xz() * operand.zt() * self.s()
                + self.yt() * operand.s() * self.xy()
                - self.yt() * operand.xt() * self.yt()
                - self.yt() * operand.xy() * self.s()
                + self.yt() * operand.xyzt() * self.zt()
                + self.yt() * operand.xz() * self.yz()
                + self.yt() * operand.yt() * self.xt()
                - self.yt() * operand.yz() * self.xz()
                - self.yt() * operand.zt() * self.xyzt()
                + self.yz() * operand.s() * self.xyzt()
                - self.yz() * operand.xt() * self.yz()
                - self.yz() * operand.xy() * self.zt()
                + self.yz() * operand.xyzt() * self.s()
                + self.yz() * operand.xz() * self.yt()
                + self.yz() * operand.yt() * self.xz()
                - self.yz() * operand.yz() * self.xt()
                - self.yz() * operand.zt() * self.xy()
                + self.zt() * operand.s() * self.xz()
                - self.zt() * operand.xt() * self.zt()
                - self.zt() * operand.xy() * self.yz()
                - self.zt() * operand.xyzt() * self.yt()
                - self.zt() * operand.xz() * self.s()
                + self.zt() * operand.yt() * self.xyzt()
                + self.zt() * operand.yz() * self.xy()
                + self.zt() * operand.zt() * self.xt())
                * inv_norm_sq,
            (self.s() * operand.s() * self.yz() - self.s() * operand.xt() * self.xyzt()
                + self.s() * operand.xy() * self.xz()
                + self.s() * operand.xyzt() * self.xt()
                - self.s() * operand.xz() * self.xy()
                - self.s() * operand.yt() * self.zt()
                - self.s() * operand.yz() * self.s()
                + self.s() * operand.zt() * self.yt()
                - self.xt() * operand.s() * self.xyzt()
                + self.xt() * operand.xt() * self.yz()
                + self.xt() * operand.xy() * self.zt()
                - self.xt() * operand.xyzt() * self.s()
                - self.xt() * operand.xz() * self.yt()
                - self.xt() * operand.yt() * self.xz()
                + self.xt() * operand.yz() * self.xt()
                + self.xt() * operand.zt() * self.xy()
                + self.xy() * operand.s() * self.xz()
                - self.xy() * operand.xt() * self.zt()
                - self.xy() * operand.xy() * self.yz()
                - self.xy() * operand.xyzt() * self.yt()
                - self.xy() * operand.xz() * self.s()
                + self.xy() * operand.yt() * self.xyzt()
                + self.xy() * operand.yz() * self.xy()
                + self.xy() * operand.zt() * self.xt()
                + self.xyzt() * operand.s() * self.xt()
                - self.xyzt() * operand.xt() * self.s()
                - self.xyzt() * operand.xy() * self.yt()
                - self.xyzt() * operand.xyzt() * self.yz()
                - self.xyzt() * operand.xz() * self.zt()
                + self.xyzt() * operand.yt() * self.xy()
                + self.xyzt() * operand.yz() * self.xyzt()
                + self.xyzt() * operand.zt() * self.xz()
                - self.xz() * operand.s() * self.xy()
                + self.xz() * operand.xt() * self.yt()
                + self.xz() * operand.xy() * self.s()
                - self.xz() * operand.xyzt() * self.zt()
                - self.xz() * operand.xz() * self.yz()
                - self.xz() * operand.yt() * self.xt()
                + self.xz() * operand.yz() * self.xz()
                + self.xz() * operand.zt() * self.xyzt()
                - self.yt() * operand.s() * self.zt()
                + self.yt() * operand.xt() * self.xz()
                - self.yt() * operand.xy() * self.xyzt()
                + self.yt() * operand.xyzt() * self.xy()
                - self.yt() * operand.xz() * self.xt()
                + self.yt() * operand.yt() * self.yz()
                - self.yt() * operand.yz() * self.yt()
                + self.yt() * operand.zt() * self.s()
                - self.yz() * operand.s() * self.s()
                + self.yz() * operand.xt() * self.xt()
                - self.yz() * operand.xy() * self.xy()
                + self.yz() * operand.xyzt() * self.xyzt()
                - self.yz() * operand.xz() * self.xz()
                + self.yz() * operand.yt() * self.yt()
                - self.yz() * operand.yz() * self.yz()
                + self.yz() * operand.zt() * self.zt()
                + self.zt() * operand.s() * self.yt()
                - self.zt() * operand.xt() * self.xy()
                + self.zt() * operand.xy() * self.xt()
                + self.zt() * operand.xyzt() * self.xz()
                - self.zt() * operand.xz() * self.xyzt()
                - self.zt() * operand.yt() * self.s()
                - self.zt() * operand.yz() * self.zt()
                + self.zt() * operand.zt() * self.yz())
                * inv_norm_sq,
            (self.s() * operand.s() * self.yt() - self.s() * operand.xt() * self.xy()
                + self.s() * operand.xy() * self.xt()
                + self.s() * operand.xyzt() * self.xz()
                - self.s() * operand.xz() * self.xyzt()
                - self.s() * operand.yt() * self.s()
                - self.s() * operand.yz() * self.zt()
                + self.s() * operand.zt() * self.yz()
                - self.xt() * operand.s() * self.xy()
                + self.xt() * operand.xt() * self.yt()
                + self.xt() * operand.xy() * self.s()
                - self.xt() * operand.xyzt() * self.zt()
                - self.xt() * operand.xz() * self.yz()
                - self.xt() * operand.yt() * self.xt()
                + self.xt() * operand.yz() * self.xz()
                + self.xt() * operand.zt() * self.xyzt()
                + self.xy() * operand.s() * self.xt()
                - self.xy() * operand.xt() * self.s()
                - self.xy() * operand.xy() * self.yt()
                - self.xy() * operand.xyzt() * self.yz()
                - self.xy() * operand.xz() * self.zt()
                + self.xy() * operand.yt() * self.xy()
                + self.xy() * operand.yz() * self.xyzt()
                + self.xy() * operand.zt() * self.xz()
                + self.xyzt() * operand.s() * self.xz()
                - self.xyzt() * operand.xt() * self.zt()
                - self.xyzt() * operand.xy() * self.yz()
                - self.xyzt() * operand.xyzt() * self.yt()
                - self.xyzt() * operand.xz() * self.s()
                + self.xyzt() * operand.yt() * self.xyzt()
                + self.xyzt() * operand.yz() * self.xy()
                + self.xyzt() * operand.zt() * self.xt()
                - self.xz() * operand.s() * self.xyzt()
                + self.xz() * operand.xt() * self.yz()
                + self.xz() * operand.xy() * self.zt()
                - self.xz() * operand.xyzt() * self.s()
                - self.xz() * operand.xz() * self.yt()
                - self.xz() * operand.yt() * self.xz()
                + self.xz() * operand.yz() * self.xt()
                + self.xz() * operand.zt() * self.xy()
                - self.yt() * operand.s() * self.s()
                + self.yt() * operand.xt() * self.xt()
                - self.yt() * operand.xy() * self.xy()
                + self.yt() * operand.xyzt() * self.xyzt()
                - self.yt() * operand.xz() * self.xz()
                + self.yt() * operand.yt() * self.yt()
                - self.yt() * operand.yz() * self.yz()
                + self.yt() * operand.zt() * self.zt()
                - self.yz() * operand.s() * self.zt()
                + self.yz() * operand.xt() * self.xz()
                - self.yz() * operand.xy() * self.xyzt()
                + self.yz() * operand.xyzt() * self.xy()
                - self.yz() * operand.xz() * self.xt()
                + self.yz() * operand.yt() * self.yz()
                - self.yz() * operand.yz() * self.yt()
                + self.yz() * operand.zt() * self.s()
                + self.zt() * operand.s() * self.yz()
                - self.zt() * operand.xt() * self.xyzt()
                + self.zt() * operand.xy() * self.xz()
                + self.zt() * operand.xyzt() * self.xt()
                - self.zt() * operand.xz() * self.xy()
                - self.zt() * operand.yt() * self.zt()
                - self.zt() * operand.yz() * self.s()
                + self.zt() * operand.zt() * self.yt())
                * inv_norm_sq,
            (self.s() * operand.s() * self.zt() - self.s() * operand.xt() * self.xz()
                + self.s() * operand.xy() * self.xyzt()
                - self.s() * operand.xyzt() * self.xy()
                + self.s() * operand.xz() * self.xt()
                - self.s() * operand.yt() * self.yz()
                + self.s() * operand.yz() * self.yt()
                - self.s() * operand.zt() * self.s()
                - self.xt() * operand.s() * self.xz()
                + self.xt() * operand.xt() * self.zt()
                + self.xt() * operand.xy() * self.yz()
                + self.xt() * operand.xyzt() * self.yt()
                + self.xt() * operand.xz() * self.s()
                - self.xt() * operand.yt() * self.xyzt()
                - self.xt() * operand.yz() * self.xy()
                - self.xt() * operand.zt() * self.xt()
                + self.xy() * operand.s() * self.xyzt()
                - self.xy() * operand.xt() * self.yz()
                - self.xy() * operand.xy() * self.zt()
                + self.xy() * operand.xyzt() * self.s()
                + self.xy() * operand.xz() * self.yt()
                + self.xy() * operand.yt() * self.xz()
                - self.xy() * operand.yz() * self.xt()
                - self.xy() * operand.zt() * self.xy()
                - self.xyzt() * operand.s() * self.xy()
                + self.xyzt() * operand.xt() * self.yt()
                + self.xyzt() * operand.xy() * self.s()
                - self.xyzt() * operand.xyzt() * self.zt()
                - self.xyzt() * operand.xz() * self.yz()
                - self.xyzt() * operand.yt() * self.xt()
                + self.xyzt() * operand.yz() * self.xz()
                + self.xyzt() * operand.zt() * self.xyzt()
                + self.xz() * operand.s() * self.xt()
                - self.xz() * operand.xt() * self.s()
                - self.xz() * operand.xy() * self.yt()
                - self.xz() * operand.xyzt() * self.yz()
                - self.xz() * operand.xz() * self.zt()
                + self.xz() * operand.yt() * self.xy()
                + self.xz() * operand.yz() * self.xyzt()
                + self.xz() * operand.zt() * self.xz()
                - self.yt() * operand.s() * self.yz()
                + self.yt() * operand.xt() * self.xyzt()
                - self.yt() * operand.xy() * self.xz()
                - self.yt() * operand.xyzt() * self.xt()
                + self.yt() * operand.xz() * self.xy()
                + self.yt() * operand.yt() * self.zt()
                + self.yt() * operand.yz() * self.s()
                - self.yt() * operand.zt() * self.yt()
                + self.yz() * operand.s() * self.yt()
                - self.yz() * operand.xt() * self.xy()
                + self.yz() * operand.xy() * self.xt()
                + self.yz() * operand.xyzt() * self.xz()
                - self.yz() * operand.xz() * self.xyzt()
                - self.yz() * operand.yt() * self.s()
                - self.yz() * operand.yz() * self.zt()
                + self.yz() * operand.zt() * self.yz()
                - self.zt() * operand.s() * self.s()
                + self.zt() * operand.xt() * self.xt()
                - self.zt() * operand.xy() * self.xy()
                + self.zt() * operand.xyzt() * self.xyzt()
                - self.zt() * operand.xz() * self.xz()
                + self.zt() * operand.yt() * self.yt()
                - self.zt() * operand.yz() * self.yz()
                + self.zt() * operand.zt() * self.zt())
                * inv_norm_sq,
            (-(self.s() * operand.s() * self.xyzt())
                + self.s() * operand.xt() * self.yz()
                + self.s() * operand.xy() * self.zt()
                - self.s() * operand.xyzt() * self.s()
                - self.s() * operand.xz() * self.yt()
                - self.s() * operand.yt() * self.xz()
                + self.s() * operand.yz() * self.xt()
                + self.s() * operand.zt() * self.xy()
                + self.xt() * operand.s() * self.yz()
                - self.xt() * operand.xt() * self.xyzt()
                + self.xt() * operand.xy() * self.xz()
                + self.xt() * operand.xyzt() * self.xt()
                - self.xt() * operand.xz() * self.xy()
                - self.xt() * operand.yt() * self.zt()
                - self.xt() * operand.yz() * self.s()
                + self.xt() * operand.zt() * self.yt()
                + self.xy() * operand.s() * self.zt()
                - self.xy() * operand.xt() * self.xz()
                + self.xy() * operand.xy() * self.xyzt()
                - self.xy() * operand.xyzt() * self.xy()
                + self.xy() * operand.xz() * self.xt()
                - self.xy() * operand.yt() * self.yz()
                + self.xy() * operand.yz() * self.yt()
                - self.xy() * operand.zt() * self.s()
                - self.xyzt() * operand.s() * self.s()
                + self.xyzt() * operand.xt() * self.xt()
                - self.xyzt() * operand.xy() * self.xy()
                + self.xyzt() * operand.xyzt() * self.xyzt()
                - self.xyzt() * operand.xz() * self.xz()
                + self.xyzt() * operand.yt() * self.yt()
                - self.xyzt() * operand.yz() * self.yz()
                + self.xyzt() * operand.zt() * self.zt()
                - self.xz() * operand.s() * self.yt()
                + self.xz() * operand.xt() * self.xy()
                - self.xz() * operand.xy() * self.xt()
                - self.xz() * operand.xyzt() * self.xz()
                + self.xz() * operand.xz() * self.xyzt()
                + self.xz() * operand.yt() * self.s()
                + self.xz() * operand.yz() * self.zt()
                - self.xz() * operand.zt() * self.yz()
                - self.yt() * operand.s() * self.xz()
                + self.yt() * operand.xt() * self.zt()
                + self.yt() * operand.xy() * self.yz()
                + self.yt() * operand.xyzt() * self.yt()
                + self.yt() * operand.xz() * self.s()
                - self.yt() * operand.yt() * self.xyzt()
                - self.yt() * operand.yz() * self.xy()
                - self.yt() * operand.zt() * self.xt()
                + self.yz() * operand.s() * self.xt()
                - self.yz() * operand.xt() * self.s()
                - self.yz() * operand.xy() * self.yt()
                - self.yz() * operand.xyzt() * self.yz()
                - self.yz() * operand.xz() * self.zt()
                + self.yz() * operand.yt() * self.xy()
                + self.yz() * operand.yz() * self.xyzt()
                + self.yz() * operand.zt() * self.xz()
                + self.zt() * operand.s() * self.xy()
                - self.zt() * operand.xt() * self.yt()
                - self.zt() * operand.xy() * self.s()
                + self.zt() * operand.xyzt() * self.zt()
                + self.zt() * operand.xz() * self.yz()
                + self.zt() * operand.yt() * self.xt()
                - self.zt() * operand.yz() * self.xz()
                - self.zt() * operand.zt() * self.xyzt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Pseudoscalar<T>> for Eventor<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (-(self.s() * operand.xyzt() * self.s()) + self.xt() * operand.xyzt() * self.xt()
                - self.xy() * operand.xyzt() * self.xy()
                + self.xyzt() * operand.xyzt() * self.xyzt()
                - self.xz() * operand.xyzt() * self.xz()
                + self.yt() * operand.xyzt() * self.yt()
                - self.yz() * operand.xyzt() * self.yz()
                + self.zt() * operand.xyzt() * self.zt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Eventor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (-(self.s() * operand.s() * self.s()) + self.xt() * operand.s() * self.xt()
                - self.xy() * operand.s() * self.xy()
                + self.xyzt() * operand.s() * self.xyzt()
                - self.xz() * operand.s() * self.xz()
                + self.yt() * operand.s() * self.yt()
                - self.yz() * operand.s() * self.yz()
                + self.zt() * operand.s() * self.zt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Trivector<T>> for Eventor<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked(
            (self.s() * operand.xyt() * self.zt() + self.s() * operand.xyz() * self.s()
                - self.s() * operand.xzt() * self.yt()
                + self.s() * operand.yzt() * self.xt()
                - self.xt() * operand.xyt() * self.xz()
                + self.xt() * operand.xyz() * self.xt()
                + self.xt() * operand.xzt() * self.xy()
                + self.xt() * operand.yzt() * self.s()
                + self.xy() * operand.xyt() * self.xyzt()
                + self.xy() * operand.xyz() * self.xy()
                + self.xy() * operand.xzt() * self.xt()
                + self.xy() * operand.yzt() * self.yt()
                + self.xyzt() * operand.xyt() * self.xy()
                + self.xyzt() * operand.xyz() * self.xyzt()
                + self.xyzt() * operand.xzt() * self.xz()
                + self.xyzt() * operand.yzt() * self.yz()
                - self.xz() * operand.xyt() * self.xt()
                + self.xz() * operand.xyz() * self.xz()
                + self.xz() * operand.xzt() * self.xyzt()
                + self.xz() * operand.yzt() * self.zt()
                - self.yt() * operand.xyt() * self.yz()
                + self.yt() * operand.xyz() * self.yt()
                - self.yt() * operand.xzt() * self.s()
                + self.yt() * operand.yzt() * self.xy()
                - self.yz() * operand.xyt() * self.yt()
                + self.yz() * operand.xyz() * self.yz()
                - self.yz() * operand.xzt() * self.zt()
                + self.yz() * operand.yzt() * self.xyzt()
                + self.zt() * operand.xyt() * self.s()
                + self.zt() * operand.xyz() * self.zt()
                - self.zt() * operand.xzt() * self.yz()
                + self.zt() * operand.yzt() * self.xz())
                * inv_norm_sq,
            (self.s() * operand.xyt() * self.s() + self.s() * operand.xyz() * self.zt()
                - self.s() * operand.xzt() * self.yz()
                + self.s() * operand.yzt() * self.xz()
                - self.xt() * operand.xyt() * self.xt()
                + self.xt() * operand.xyz() * self.xz()
                + self.xt() * operand.xzt() * self.xyzt()
                + self.xt() * operand.yzt() * self.zt()
                + self.xy() * operand.xyt() * self.xy()
                + self.xy() * operand.xyz() * self.xyzt()
                + self.xy() * operand.xzt() * self.xz()
                + self.xy() * operand.yzt() * self.yz()
                + self.xyzt() * operand.xyt() * self.xyzt()
                + self.xyzt() * operand.xyz() * self.xy()
                + self.xyzt() * operand.xzt() * self.xt()
                + self.xyzt() * operand.yzt() * self.yt()
                - self.xz() * operand.xyt() * self.xz()
                + self.xz() * operand.xyz() * self.xt()
                + self.xz() * operand.xzt() * self.xy()
                + self.xz() * operand.yzt() * self.s()
                - self.yt() * operand.xyt() * self.yt()
                + self.yt() * operand.xyz() * self.yz()
                - self.yt() * operand.xzt() * self.zt()
                + self.yt() * operand.yzt() * self.xyzt()
                - self.yz() * operand.xyt() * self.yz()
                + self.yz() * operand.xyz() * self.yt()
                - self.yz() * operand.xzt() * self.s()
                + self.yz() * operand.yzt() * self.xy()
                + self.zt() * operand.xyt() * self.zt()
                + self.zt() * operand.xyz() * self.s()
                - self.zt() * operand.xzt() * self.yt()
                + self.zt() * operand.yzt() * self.xt())
                * inv_norm_sq,
            (self.s() * operand.xyt() * self.yz() - self.s() * operand.xyz() * self.yt()
                + self.s() * operand.xzt() * self.s()
                - self.s() * operand.yzt() * self.xy()
                - self.xt() * operand.xyt() * self.xyzt()
                - self.xt() * operand.xyz() * self.xy()
                - self.xt() * operand.xzt() * self.xt()
                - self.xt() * operand.yzt() * self.yt()
                + self.xy() * operand.xyt() * self.xz()
                - self.xy() * operand.xyz() * self.xt()
                - self.xy() * operand.xzt() * self.xy()
                - self.xy() * operand.yzt() * self.s()
                - self.xyzt() * operand.xyt() * self.xt()
                + self.xyzt() * operand.xyz() * self.xz()
                + self.xyzt() * operand.xzt() * self.xyzt()
                + self.xyzt() * operand.yzt() * self.zt()
                + self.xz() * operand.xyt() * self.xy()
                + self.xz() * operand.xyz() * self.xyzt()
                + self.xz() * operand.xzt() * self.xz()
                + self.xz() * operand.yzt() * self.yz()
                - self.yt() * operand.xyt() * self.zt()
                - self.yt() * operand.xyz() * self.s()
                + self.yt() * operand.xzt() * self.yt()
                - self.yt() * operand.yzt() * self.xt()
                + self.yz() * operand.xyt() * self.s()
                + self.yz() * operand.xyz() * self.zt()
                - self.yz() * operand.xzt() * self.yz()
                + self.yz() * operand.yzt() * self.xz()
                - self.zt() * operand.xyt() * self.yt()
                + self.zt() * operand.xyz() * self.yz()
                - self.zt() * operand.xzt() * self.zt()
                + self.zt() * operand.yzt() * self.xyzt())
                * inv_norm_sq,
            (-(self.s() * operand.xyt() * self.xz())
                + self.s() * operand.xyz() * self.xt()
                + self.s() * operand.xzt() * self.xy()
                + self.s() * operand.yzt() * self.s()
                + self.xt() * operand.xyt() * self.zt()
                + self.xt() * operand.xyz() * self.s()
                - self.xt() * operand.xzt() * self.yt()
                + self.xt() * operand.yzt() * self.xt()
                + self.xy() * operand.xyt() * self.yz()
                - self.xy() * operand.xyz() * self.yt()
                + self.xy() * operand.xzt() * self.s()
                - self.xy() * operand.yzt() * self.xy()
                - self.xyzt() * operand.xyt() * self.yt()
                + self.xyzt() * operand.xyz() * self.yz()
                - self.xyzt() * operand.xzt() * self.zt()
                + self.xyzt() * operand.yzt() * self.xyzt()
                - self.xz() * operand.xyt() * self.s()
                - self.xz() * operand.xyz() * self.zt()
                + self.xz() * operand.xzt() * self.yz()
                - self.xz() * operand.yzt() * self.xz()
                - self.yt() * operand.xyt() * self.xyzt()
                - self.yt() * operand.xyz() * self.xy()
                - self.yt() * operand.xzt() * self.xt()
                - self.yt() * operand.yzt() * self.yt()
                + self.yz() * operand.xyt() * self.xy()
                + self.yz() * operand.xyz() * self.xyzt()
                + self.yz() * operand.xzt() * self.xz()
                + self.yz() * operand.yzt() * self.yz()
                + self.zt() * operand.xyt() * self.xt()
                - self.zt() * operand.xyz() * self.xz()
                - self.zt() * operand.xzt() * self.xyzt()
                - self.zt() * operand.yzt() * self.zt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Vector<T>> for Eventor<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (self.s() * operand.t() * self.xt() + self.s() * operand.x() * self.s()
                - self.s() * operand.y() * self.xy()
                - self.s() * operand.z() * self.xz()
                + self.xt() * operand.t() * self.s()
                + self.xt() * operand.x() * self.xt()
                + self.xt() * operand.y() * self.yt()
                + self.xt() * operand.z() * self.zt()
                - self.xy() * operand.t() * self.yt()
                - self.xy() * operand.x() * self.xy()
                - self.xy() * operand.y() * self.s()
                + self.xy() * operand.z() * self.yz()
                + self.xyzt() * operand.t() * self.yz()
                + self.xyzt() * operand.x() * self.xyzt()
                + self.xyzt() * operand.y() * self.zt()
                - self.xyzt() * operand.z() * self.yt()
                - self.xz() * operand.t() * self.zt()
                - self.xz() * operand.x() * self.xz()
                - self.xz() * operand.y() * self.yz()
                - self.xz() * operand.z() * self.s()
                - self.yt() * operand.t() * self.xy()
                - self.yt() * operand.x() * self.yt()
                + self.yt() * operand.y() * self.xt()
                - self.yt() * operand.z() * self.xyzt()
                + self.yz() * operand.t() * self.xyzt()
                + self.yz() * operand.x() * self.yz()
                - self.yz() * operand.y() * self.xz()
                + self.yz() * operand.z() * self.xy()
                - self.zt() * operand.t() * self.xz()
                - self.zt() * operand.x() * self.zt()
                + self.zt() * operand.y() * self.xyzt()
                + self.zt() * operand.z() * self.xt())
                * inv_norm_sq,
            (self.s() * operand.t() * self.yt()
                + self.s() * operand.x() * self.xy()
                + self.s() * operand.y() * self.s()
                - self.s() * operand.z() * self.yz()
                + self.xt() * operand.t() * self.xy()
                + self.xt() * operand.x() * self.yt()
                - self.xt() * operand.y() * self.xt()
                + self.xt() * operand.z() * self.xyzt()
                + self.xy() * operand.t() * self.xt()
                + self.xy() * operand.x() * self.s()
                - self.xy() * operand.y() * self.xy()
                - self.xy() * operand.z() * self.xz()
                - self.xyzt() * operand.t() * self.xz()
                - self.xyzt() * operand.x() * self.zt()
                + self.xyzt() * operand.y() * self.xyzt()
                + self.xyzt() * operand.z() * self.xt()
                - self.xz() * operand.t() * self.xyzt()
                - self.xz() * operand.x() * self.yz()
                + self.xz() * operand.y() * self.xz()
                - self.xz() * operand.z() * self.xy()
                + self.yt() * operand.t() * self.s()
                + self.yt() * operand.x() * self.xt()
                + self.yt() * operand.y() * self.yt()
                + self.yt() * operand.z() * self.zt()
                - self.yz() * operand.t() * self.zt()
                - self.yz() * operand.x() * self.xz()
                - self.yz() * operand.y() * self.yz()
                - self.yz() * operand.z() * self.s()
                - self.zt() * operand.t() * self.yz()
                - self.zt() * operand.x() * self.xyzt()
                - self.zt() * operand.y() * self.zt()
                + self.zt() * operand.z() * self.yt())
                * inv_norm_sq,
            (self.s() * operand.t() * self.zt()
                + self.s() * operand.x() * self.xz()
                + self.s() * operand.y() * self.yz()
                + self.s() * operand.z() * self.s()
                + self.xt() * operand.t() * self.xz()
                + self.xt() * operand.x() * self.zt()
                - self.xt() * operand.y() * self.xyzt()
                - self.xt() * operand.z() * self.xt()
                + self.xy() * operand.t() * self.xyzt()
                + self.xy() * operand.x() * self.yz()
                - self.xy() * operand.y() * self.xz()
                + self.xy() * operand.z() * self.xy()
                + self.xyzt() * operand.t() * self.xy()
                + self.xyzt() * operand.x() * self.yt()
                - self.xyzt() * operand.y() * self.xt()
                + self.xyzt() * operand.z() * self.xyzt()
                + self.xz() * operand.t() * self.xt()
                + self.xz() * operand.x() * self.s()
                - self.xz() * operand.y() * self.xy()
                - self.xz() * operand.z() * self.xz()
                + self.yt() * operand.t() * self.yz()
                + self.yt() * operand.x() * self.xyzt()
                + self.yt() * operand.y() * self.zt()
                - self.yt() * operand.z() * self.yt()
                + self.yz() * operand.t() * self.yt()
                + self.yz() * operand.x() * self.xy()
                + self.yz() * operand.y() * self.s()
                - self.yz() * operand.z() * self.yz()
                + self.zt() * operand.t() * self.s()
                + self.zt() * operand.x() * self.xt()
                + self.zt() * operand.y() * self.yt()
                + self.zt() * operand.z() * self.zt())
                * inv_norm_sq,
            (self.s() * operand.t() * self.s()
                + self.s() * operand.x() * self.xt()
                + self.s() * operand.y() * self.yt()
                + self.s() * operand.z() * self.zt()
                + self.xt() * operand.t() * self.xt()
                + self.xt() * operand.x() * self.s()
                - self.xt() * operand.y() * self.xy()
                - self.xt() * operand.z() * self.xz()
                + self.xy() * operand.t() * self.xy()
                + self.xy() * operand.x() * self.yt()
                - self.xy() * operand.y() * self.xt()
                + self.xy() * operand.z() * self.xyzt()
                + self.xyzt() * operand.t() * self.xyzt()
                + self.xyzt() * operand.x() * self.yz()
                - self.xyzt() * operand.y() * self.xz()
                + self.xyzt() * operand.z() * self.xy()
                + self.xz() * operand.t() * self.xz()
                + self.xz() * operand.x() * self.zt()
                - self.xz() * operand.y() * self.xyzt()
                - self.xz() * operand.z() * self.xt()
                + self.yt() * operand.t() * self.yt()
                + self.yt() * operand.x() * self.xy()
                + self.yt() * operand.y() * self.s()
                - self.yt() * operand.z() * self.yz()
                + self.yz() * operand.t() * self.yz()
                + self.yz() * operand.x() * self.xyzt()
                + self.yz() * operand.y() * self.zt()
                - self.yz() * operand.z() * self.yt()
                + self.zt() * operand.t() * self.zt()
                + self.zt() * operand.x() * self.xz()
                + self.zt() * operand.y() * self.yz()
                + self.zt() * operand.z() * self.s())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Bivector<T>> for Pseudoscalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (self.xyzt() * operand.xy() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.xz() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.xt() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.yz() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.yt() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.zt() * self.xyzt()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Eventor<T>> for Pseudoscalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (self.xyzt() * operand.s() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.xy() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.xz() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.xt() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.yz() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.yt() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.zt() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.xyzt() * self.xyzt()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (self.xyzt() * operand.xyzt() * self.xyzt()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.xyzt() * operand.s() * self.xyzt()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Trivector<T>> for Pseudoscalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked(
            (self.xyzt() * operand.xyz() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.xyt() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.xzt() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.yzt() * self.xyzt()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Vector<T>> for Pseudoscalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (self.xyzt() * operand.x() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.y() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.z() * self.xyzt()) * inv_norm_sq,
            (self.xyzt() * operand.t() * self.xyzt()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (-(self.s() * operand.xy() * self.s())) * inv_norm_sq,
            (-(self.s() * operand.xz() * self.s())) * inv_norm_sq,
            (-(self.s() * operand.xt() * self.s())) * inv_norm_sq,
            (-(self.s() * operand.yz() * self.s())) * inv_norm_sq,
            (-(self.s() * operand.yt() * self.s())) * inv_norm_sq,
            (-(self.s() * operand.zt() * self.s())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Eventor<T>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (-(self.s() * operand.s() * self.s())) * inv_norm_sq,
            (-(self.s() * operand.xy() * self.s())) * inv_norm_sq,
            (-(self.s() * operand.xz() * self.s())) * inv_norm_sq,
            (-(self.s() * operand.xt() * self.s())) * inv_norm_sq,
            (-(self.s() * operand.yz() * self.s())) * inv_norm_sq,
            (-(self.s() * operand.yt() * self.s())) * inv_norm_sq,
            (-(self.s() * operand.zt() * self.s())) * inv_norm_sq,
            (-(self.s() * operand.xyzt() * self.s())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Pseudoscalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (-(self.s() * operand.xyzt() * self.s())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (-(self.s() * operand.s() * self.s())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked(
            (self.s() * operand.xyz() * self.s()) * inv_norm_sq,
            (self.s() * operand.xyt() * self.s()) * inv_norm_sq,
            (self.s() * operand.xzt() * self.s()) * inv_norm_sq,
            (self.s() * operand.yzt() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (self.s() * operand.x() * self.s()) * inv_norm_sq,
            (self.s() * operand.y() * self.s()) * inv_norm_sq,
            (self.s() * operand.z() * self.s()) * inv_norm_sq,
            (self.s() * operand.t() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Bivector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (self.xyt() * operand.xy() * self.xyt()
                + self.xyt() * operand.xz() * self.xzt()
                + self.xyt() * operand.yz() * self.yzt()
                - self.xyz() * operand.xt() * self.xzt()
                - self.xyz() * operand.xy() * self.xyz()
                - self.xyz() * operand.yt() * self.yzt()
                - self.xzt() * operand.xt() * self.xyz()
                - self.xzt() * operand.xy() * self.xzt()
                + self.xzt() * operand.xz() * self.xyt()
                - self.yzt() * operand.xy() * self.yzt()
                - self.yzt() * operand.yt() * self.xyz()
                + self.yzt() * operand.yz() * self.xyt())
                * inv_norm_sq,
            (self.xyt() * operand.xt() * self.xyz() + self.xyt() * operand.xy() * self.xzt()
                - self.xyt() * operand.xz() * self.xyt()
                + self.xyz() * operand.xt() * self.xyt()
                - self.xyz() * operand.xz() * self.xyz()
                - self.xyz() * operand.zt() * self.yzt()
                + self.xzt() * operand.xy() * self.xyt()
                + self.xzt() * operand.xz() * self.xzt()
                + self.xzt() * operand.yz() * self.yzt()
                - self.yzt() * operand.xz() * self.yzt()
                + self.yzt() * operand.yz() * self.xzt()
                - self.yzt() * operand.zt() * self.xyz())
                * inv_norm_sq,
            (self.xyt() * operand.xt() * self.xyt()
                - self.xyt() * operand.xz() * self.xyz()
                - self.xyt() * operand.zt() * self.yzt()
                + self.xyz() * operand.xt() * self.xyz()
                + self.xyz() * operand.xy() * self.xzt()
                - self.xyz() * operand.xz() * self.xyt()
                + self.xzt() * operand.xt() * self.xzt()
                + self.xzt() * operand.xy() * self.xyz()
                + self.xzt() * operand.yt() * self.yzt()
                - self.yzt() * operand.xt() * self.yzt()
                + self.yzt() * operand.yt() * self.xzt()
                - self.yzt() * operand.zt() * self.xyt())
                * inv_norm_sq,
            (self.xyt() * operand.xy() * self.yzt() + self.xyt() * operand.yt() * self.xyz()
                - self.xyt() * operand.yz() * self.xyt()
                + self.xyz() * operand.yt() * self.xyt()
                - self.xyz() * operand.yz() * self.xyz()
                + self.xyz() * operand.zt() * self.xzt()
                + self.xzt() * operand.xz() * self.yzt()
                - self.xzt() * operand.yz() * self.xzt()
                + self.xzt() * operand.zt() * self.xyz()
                + self.yzt() * operand.xy() * self.xyt()
                + self.yzt() * operand.xz() * self.xzt()
                + self.yzt() * operand.yz() * self.yzt())
                * inv_norm_sq,
            (self.xyt() * operand.yt() * self.xyt() - self.xyt() * operand.yz() * self.xyz()
                + self.xyt() * operand.zt() * self.xzt()
                + self.xyz() * operand.xy() * self.yzt()
                + self.xyz() * operand.yt() * self.xyz()
                - self.xyz() * operand.yz() * self.xyt()
                + self.xzt() * operand.xt() * self.yzt()
                - self.xzt() * operand.yt() * self.xzt()
                + self.xzt() * operand.zt() * self.xyt()
                + self.yzt() * operand.xt() * self.xzt()
                + self.yzt() * operand.xy() * self.xyz()
                + self.yzt() * operand.yt() * self.yzt())
                * inv_norm_sq,
            (-(self.xyt() * operand.xt() * self.yzt()) + self.xyt() * operand.yt() * self.xzt()
                - self.xyt() * operand.zt() * self.xyt()
                + self.xyz() * operand.xz() * self.yzt()
                - self.xyz() * operand.yz() * self.xzt()
                + self.xyz() * operand.zt() * self.xyz()
                + self.xzt() * operand.yt() * self.xyt()
                - self.xzt() * operand.yz() * self.xyz()
                + self.xzt() * operand.zt() * self.xzt()
                - self.yzt() * operand.xt() * self.xyt()
                + self.yzt() * operand.xz() * self.xyz()
                + self.yzt() * operand.zt() * self.yzt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Eventor<T>> for Trivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (self.xyt() * operand.s() * self.xyt() + self.xyt() * operand.xz() * self.yzt()
                - self.xyt() * operand.yz() * self.xzt()
                + self.xyt() * operand.zt() * self.xyz()
                - self.xyz() * operand.s() * self.xyz()
                - self.xyz() * operand.xt() * self.yzt()
                + self.xyz() * operand.yt() * self.xzt()
                - self.xyz() * operand.zt() * self.xyt()
                + self.xzt() * operand.s() * self.xzt()
                - self.xzt() * operand.xy() * self.yzt()
                - self.xzt() * operand.yt() * self.xyz()
                + self.xzt() * operand.yz() * self.xyt()
                + self.yzt() * operand.s() * self.yzt()
                + self.yzt() * operand.xt() * self.xyz()
                + self.yzt() * operand.xy() * self.xzt()
                - self.yzt() * operand.xz() * self.xyt())
                * inv_norm_sq,
            (self.xyt() * operand.xy() * self.xyt()
                + self.xyt() * operand.xyzt() * self.xyz()
                + self.xyt() * operand.xz() * self.xzt()
                + self.xyt() * operand.yz() * self.yzt()
                - self.xyz() * operand.xt() * self.xzt()
                - self.xyz() * operand.xy() * self.xyz()
                - self.xyz() * operand.xyzt() * self.xyt()
                - self.xyz() * operand.yt() * self.yzt()
                - self.xzt() * operand.s() * self.yzt()
                - self.xzt() * operand.xt() * self.xyz()
                - self.xzt() * operand.xy() * self.xzt()
                + self.xzt() * operand.xz() * self.xyt()
                + self.yzt() * operand.s() * self.xzt()
                - self.yzt() * operand.xy() * self.yzt()
                - self.yzt() * operand.yt() * self.xyz()
                + self.yzt() * operand.yz() * self.xyt())
                * inv_norm_sq,
            (self.xyt() * operand.s() * self.yzt()
                + self.xyt() * operand.xt() * self.xyz()
                + self.xyt() * operand.xy() * self.xzt()
                - self.xyt() * operand.xz() * self.xyt()
                + self.xyz() * operand.xt() * self.xyt()
                - self.xyz() * operand.xyzt() * self.xzt()
                - self.xyz() * operand.xz() * self.xyz()
                - self.xyz() * operand.zt() * self.yzt()
                + self.xzt() * operand.xy() * self.xyt()
                + self.xzt() * operand.xyzt() * self.xyz()
                + self.xzt() * operand.xz() * self.xzt()
                + self.xzt() * operand.yz() * self.yzt()
                - self.yzt() * operand.s() * self.xyt()
                - self.yzt() * operand.xz() * self.yzt()
                + self.yzt() * operand.yz() * self.xzt()
                - self.yzt() * operand.zt() * self.xyz())
                * inv_norm_sq,
            (self.xyt() * operand.xt() * self.xyt()
                - self.xyt() * operand.xyzt() * self.xzt()
                - self.xyt() * operand.xz() * self.xyz()
                - self.xyt() * operand.zt() * self.yzt()
                + self.xyz() * operand.s() * self.yzt()
                + self.xyz() * operand.xt() * self.xyz()
                + self.xyz() * operand.xy() * self.xzt()
                - self.xyz() * operand.xz() * self.xyt()
                + self.xzt() * operand.xt() * self.xzt()
                + self.xzt() * operand.xy() * self.xyz()
                + self.xzt() * operand.xyzt() * self.xyt()
                + self.xzt() * operand.yt() * self.yzt()
                - self.yzt() * operand.s() * self.xyz()
                - self.yzt() * operand.xt() * self.yzt()
                + self.yzt() * operand.yt() * self.xzt()
                - self.yzt() * operand.zt() * self.xyt())
                * inv_norm_sq,
            (-(self.xyt() * operand.s() * self.xzt())
                + self.xyt() * operand.xy() * self.yzt()
                + self.xyt() * operand.yt() * self.xyz()
                - self.xyt() * operand.yz() * self.xyt()
                - self.xyz() * operand.xyzt() * self.yzt()
                + self.xyz() * operand.yt() * self.xyt()
                - self.xyz() * operand.yz() * self.xyz()
                + self.xyz() * operand.zt() * self.xzt()
                + self.xzt() * operand.s() * self.xyt()
                + self.xzt() * operand.xz() * self.yzt()
                - self.xzt() * operand.yz() * self.xzt()
                + self.xzt() * operand.zt() * self.xyz()
                + self.yzt() * operand.xy() * self.xyt()
                + self.yzt() * operand.xyzt() * self.xyz()
                + self.yzt() * operand.xz() * self.xzt()
                + self.yzt() * operand.yz() * self.yzt())
                * inv_norm_sq,
            (-(self.xyt() * operand.xyzt() * self.yzt()) + self.xyt() * operand.yt() * self.xyt()
                - self.xyt() * operand.yz() * self.xyz()
                + self.xyt() * operand.zt() * self.xzt()
                - self.xyz() * operand.s() * self.xzt()
                + self.xyz() * operand.xy() * self.yzt()
                + self.xyz() * operand.yt() * self.xyz()
                - self.xyz() * operand.yz() * self.xyt()
                + self.xzt() * operand.s() * self.xyz()
                + self.xzt() * operand.xt() * self.yzt()
                - self.xzt() * operand.yt() * self.xzt()
                + self.xzt() * operand.zt() * self.xyt()
                + self.yzt() * operand.xt() * self.xzt()
                + self.yzt() * operand.xy() * self.xyz()
                + self.yzt() * operand.xyzt() * self.xyt()
                + self.yzt() * operand.yt() * self.yzt())
                * inv_norm_sq,
            (-(self.xyt() * operand.s() * self.xyz()) - self.xyt() * operand.xt() * self.yzt()
                + self.xyt() * operand.yt() * self.xzt()
                - self.xyt() * operand.zt() * self.xyt()
                + self.xyz() * operand.s() * self.xyt()
                + self.xyz() * operand.xz() * self.yzt()
                - self.xyz() * operand.yz() * self.xzt()
                + self.xyz() * operand.zt() * self.xyz()
                - self.xzt() * operand.xyzt() * self.yzt()
                + self.xzt() * operand.yt() * self.xyt()
                - self.xzt() * operand.yz() * self.xyz()
                + self.xzt() * operand.zt() * self.xzt()
                - self.yzt() * operand.xt() * self.xyt()
                + self.yzt() * operand.xyzt() * self.xzt()
                + self.yzt() * operand.xz() * self.xyz()
                + self.yzt() * operand.zt() * self.yzt())
                * inv_norm_sq,
            (-(self.xyt() * operand.xt() * self.xzt())
                - self.xyt() * operand.xy() * self.xyz()
                - self.xyt() * operand.xyzt() * self.xyt()
                - self.xyt() * operand.yt() * self.yzt()
                + self.xyz() * operand.xy() * self.xyt()
                + self.xyz() * operand.xyzt() * self.xyz()
                + self.xyz() * operand.xz() * self.xzt()
                + self.xyz() * operand.yz() * self.yzt()
                + self.xzt() * operand.xt() * self.xyt()
                - self.xzt() * operand.xyzt() * self.xzt()
                - self.xzt() * operand.xz() * self.xyz()
                - self.xzt() * operand.zt() * self.yzt()
                - self.yzt() * operand.xyzt() * self.yzt()
                + self.yzt() * operand.yt() * self.xyt()
                - self.yzt() * operand.yz() * self.xyz()
                + self.yzt() * operand.zt() * self.xzt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Pseudoscalar<T>> for Trivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (-(self.xyt() * operand.xyzt() * self.xyt())
                + self.xyz() * operand.xyzt() * self.xyz()
                - self.xzt() * operand.xyzt() * self.xzt()
                - self.yzt() * operand.xyzt() * self.yzt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.xyt() * operand.s() * self.xyt() - self.xyz() * operand.s() * self.xyz()
                + self.xzt() * operand.s() * self.xzt()
                + self.yzt() * operand.s() * self.yzt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Trivector<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked(
            (-(self.xyt() * operand.xyt() * self.xyz()) + self.xyt() * operand.xyz() * self.xyt()
                - self.xyz() * operand.xyt() * self.xyt()
                + self.xyz() * operand.xyz() * self.xyz()
                - self.xyz() * operand.xzt() * self.xzt()
                - self.xyz() * operand.yzt() * self.yzt()
                + self.xzt() * operand.xyz() * self.xzt()
                - self.xzt() * operand.xzt() * self.xyz()
                + self.yzt() * operand.xyz() * self.yzt()
                - self.yzt() * operand.yzt() * self.xyz())
                * inv_norm_sq,
            (-(self.xyt() * operand.xyt() * self.xyt()) + self.xyt() * operand.xyz() * self.xyz()
                - self.xyt() * operand.xzt() * self.xzt()
                - self.xyt() * operand.yzt() * self.yzt()
                - self.xyz() * operand.xyt() * self.xyz()
                + self.xyz() * operand.xyz() * self.xyt()
                + self.xzt() * operand.xyt() * self.xzt()
                - self.xzt() * operand.xzt() * self.xyt()
                + self.yzt() * operand.xyt() * self.yzt()
                - self.yzt() * operand.yzt() * self.xyt())
                * inv_norm_sq,
            (-(self.xyt() * operand.xyt() * self.xzt())
                + self.xyt() * operand.xzt() * self.xyt()
                + self.xyz() * operand.xyz() * self.xzt()
                - self.xyz() * operand.xzt() * self.xyz()
                - self.xzt() * operand.xyt() * self.xyt()
                + self.xzt() * operand.xyz() * self.xyz()
                - self.xzt() * operand.xzt() * self.xzt()
                - self.xzt() * operand.yzt() * self.yzt()
                + self.yzt() * operand.xzt() * self.yzt()
                - self.yzt() * operand.yzt() * self.xzt())
                * inv_norm_sq,
            (-(self.xyt() * operand.xyt() * self.yzt())
                + self.xyt() * operand.yzt() * self.xyt()
                + self.xyz() * operand.xyz() * self.yzt()
                - self.xyz() * operand.yzt() * self.xyz()
                - self.xzt() * operand.xzt() * self.yzt()
                + self.xzt() * operand.yzt() * self.xzt()
                - self.yzt() * operand.xyt() * self.xyt()
                + self.yzt() * operand.xyz() * self.xyz()
                - self.yzt() * operand.xzt() * self.xzt()
                - self.yzt() * operand.yzt() * self.yzt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Vector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (-(self.xyt() * operand.x() * self.xyt()) + self.xyt() * operand.z() * self.yzt()
                - self.xyz() * operand.t() * self.yzt()
                + self.xyz() * operand.x() * self.xyz()
                - self.xzt() * operand.x() * self.xzt()
                - self.xzt() * operand.y() * self.yzt()
                - self.yzt() * operand.t() * self.xyz()
                + self.yzt() * operand.x() * self.yzt()
                - self.yzt() * operand.y() * self.xzt()
                + self.yzt() * operand.z() * self.xyt())
                * inv_norm_sq,
            (-(self.xyt() * operand.y() * self.xyt()) - self.xyt() * operand.z() * self.xzt()
                + self.xyz() * operand.t() * self.xzt()
                + self.xyz() * operand.y() * self.xyz()
                + self.xzt() * operand.t() * self.xyz()
                - self.xzt() * operand.x() * self.yzt()
                + self.xzt() * operand.y() * self.xzt()
                - self.xzt() * operand.z() * self.xyt()
                - self.yzt() * operand.x() * self.xzt()
                - self.yzt() * operand.y() * self.yzt())
                * inv_norm_sq,
            (-(self.xyt() * operand.t() * self.xyz()) + self.xyt() * operand.x() * self.yzt()
                - self.xyt() * operand.y() * self.xzt()
                + self.xyt() * operand.z() * self.xyt()
                - self.xyz() * operand.t() * self.xyt()
                + self.xyz() * operand.z() * self.xyz()
                - self.xzt() * operand.y() * self.xyt()
                - self.xzt() * operand.z() * self.xzt()
                + self.yzt() * operand.x() * self.xyt()
                - self.yzt() * operand.z() * self.yzt())
                * inv_norm_sq,
            (-(self.xyt() * operand.t() * self.xyt()) + self.xyt() * operand.z() * self.xyz()
                - self.xyz() * operand.t() * self.xyz()
                + self.xyz() * operand.x() * self.yzt()
                - self.xyz() * operand.y() * self.xzt()
                + self.xyz() * operand.z() * self.xyt()
                - self.xzt() * operand.t() * self.xzt()
                - self.xzt() * operand.y() * self.xyz()
                - self.yzt() * operand.t() * self.yzt()
                + self.yzt() * operand.x() * self.xyz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Bivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (-(self.t() * operand.xt() * self.y())
                + self.t() * operand.xy() * self.t()
                + self.t() * operand.yt() * self.x()
                + self.x() * operand.xy() * self.x()
                + self.x() * operand.yt() * self.t()
                - self.x() * operand.yz() * self.z()
                - self.y() * operand.xt() * self.t()
                + self.y() * operand.xy() * self.y()
                + self.y() * operand.xz() * self.z()
                - self.z() * operand.xy() * self.z()
                + self.z() * operand.xz() * self.y()
                - self.z() * operand.yz() * self.x())
                * inv_norm_sq,
            (-(self.t() * operand.xt() * self.z())
                + self.t() * operand.xz() * self.t()
                + self.t() * operand.zt() * self.x()
                + self.x() * operand.xz() * self.x()
                + self.x() * operand.yz() * self.y()
                + self.x() * operand.zt() * self.t()
                + self.y() * operand.xy() * self.z()
                - self.y() * operand.xz() * self.y()
                + self.y() * operand.yz() * self.x()
                - self.z() * operand.xt() * self.t()
                + self.z() * operand.xy() * self.y()
                + self.z() * operand.xz() * self.z())
                * inv_norm_sq,
            (-(self.t() * operand.xt() * self.t())
                + self.t() * operand.xy() * self.y()
                + self.t() * operand.xz() * self.z()
                + self.x() * operand.xt() * self.x()
                + self.x() * operand.yt() * self.y()
                + self.x() * operand.zt() * self.z()
                - self.y() * operand.xt() * self.y()
                + self.y() * operand.xy() * self.t()
                + self.y() * operand.yt() * self.x()
                - self.z() * operand.xt() * self.z()
                + self.z() * operand.xz() * self.t()
                + self.z() * operand.zt() * self.x())
                * inv_norm_sq,
            (-(self.t() * operand.yt() * self.z())
                + self.t() * operand.yz() * self.t()
                + self.t() * operand.zt() * self.y()
                - self.x() * operand.xy() * self.z()
                + self.x() * operand.xz() * self.y()
                - self.x() * operand.yz() * self.x()
                + self.y() * operand.xz() * self.x()
                + self.y() * operand.yz() * self.y()
                + self.y() * operand.zt() * self.t()
                - self.z() * operand.xy() * self.x()
                - self.z() * operand.yt() * self.t()
                + self.z() * operand.yz() * self.z())
                * inv_norm_sq,
            (-(self.t() * operand.xy() * self.x()) - self.t() * operand.yt() * self.t()
                + self.t() * operand.yz() * self.z()
                + self.x() * operand.xt() * self.y()
                - self.x() * operand.xy() * self.t()
                - self.x() * operand.yt() * self.x()
                + self.y() * operand.xt() * self.x()
                + self.y() * operand.yt() * self.y()
                + self.y() * operand.zt() * self.z()
                - self.z() * operand.yt() * self.z()
                + self.z() * operand.yz() * self.t()
                + self.z() * operand.zt() * self.y())
                * inv_norm_sq,
            (-(self.t() * operand.xz() * self.x())
                - self.t() * operand.yz() * self.y()
                - self.t() * operand.zt() * self.t()
                + self.x() * operand.xt() * self.z()
                - self.x() * operand.xz() * self.t()
                - self.x() * operand.zt() * self.x()
                + self.y() * operand.yt() * self.z()
                - self.y() * operand.yz() * self.t()
                - self.y() * operand.zt() * self.y()
                + self.z() * operand.xt() * self.x()
                + self.z() * operand.yt() * self.y()
                + self.z() * operand.zt() * self.z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Eventor<T>> for Vector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (self.t() * operand.s() * self.t()
                + self.t() * operand.xt() * self.x()
                + self.t() * operand.yt() * self.y()
                + self.t() * operand.zt() * self.z()
                - self.x() * operand.s() * self.x()
                - self.x() * operand.xt() * self.t()
                + self.x() * operand.xy() * self.y()
                + self.x() * operand.xz() * self.z()
                - self.y() * operand.s() * self.y()
                - self.y() * operand.xy() * self.x()
                - self.y() * operand.yt() * self.t()
                + self.y() * operand.yz() * self.z()
                - self.z() * operand.s() * self.z()
                - self.z() * operand.xz() * self.x()
                - self.z() * operand.yz() * self.y()
                - self.z() * operand.zt() * self.t())
                * inv_norm_sq,
            (-(self.t() * operand.xt() * self.y())
                + self.t() * operand.xy() * self.t()
                + self.t() * operand.xyzt() * self.z()
                + self.t() * operand.yt() * self.x()
                + self.x() * operand.s() * self.y()
                + self.x() * operand.xy() * self.x()
                + self.x() * operand.yt() * self.t()
                - self.x() * operand.yz() * self.z()
                - self.y() * operand.s() * self.x()
                - self.y() * operand.xt() * self.t()
                + self.y() * operand.xy() * self.y()
                + self.y() * operand.xz() * self.z()
                - self.z() * operand.xy() * self.z()
                - self.z() * operand.xyzt() * self.t()
                + self.z() * operand.xz() * self.y()
                - self.z() * operand.yz() * self.x())
                * inv_norm_sq,
            (-(self.t() * operand.xt() * self.z()) - self.t() * operand.xyzt() * self.y()
                + self.t() * operand.xz() * self.t()
                + self.t() * operand.zt() * self.x()
                + self.x() * operand.s() * self.z()
                + self.x() * operand.xz() * self.x()
                + self.x() * operand.yz() * self.y()
                + self.x() * operand.zt() * self.t()
                + self.y() * operand.xy() * self.z()
                + self.y() * operand.xyzt() * self.t()
                - self.y() * operand.xz() * self.y()
                + self.y() * operand.yz() * self.x()
                - self.z() * operand.s() * self.x()
                - self.z() * operand.xt() * self.t()
                + self.z() * operand.xy() * self.y()
                + self.z() * operand.xz() * self.z())
                * inv_norm_sq,
            (-(self.t() * operand.s() * self.x()) - self.t() * operand.xt() * self.t()
                + self.t() * operand.xy() * self.y()
                + self.t() * operand.xz() * self.z()
                + self.x() * operand.s() * self.t()
                + self.x() * operand.xt() * self.x()
                + self.x() * operand.yt() * self.y()
                + self.x() * operand.zt() * self.z()
                - self.y() * operand.xt() * self.y()
                + self.y() * operand.xy() * self.t()
                + self.y() * operand.xyzt() * self.z()
                + self.y() * operand.yt() * self.x()
                - self.z() * operand.xt() * self.z()
                - self.z() * operand.xyzt() * self.y()
                + self.z() * operand.xz() * self.t()
                + self.z() * operand.zt() * self.x())
                * inv_norm_sq,
            (self.t() * operand.xyzt() * self.x() - self.t() * operand.yt() * self.z()
                + self.t() * operand.yz() * self.t()
                + self.t() * operand.zt() * self.y()
                - self.x() * operand.xy() * self.z()
                - self.x() * operand.xyzt() * self.t()
                + self.x() * operand.xz() * self.y()
                - self.x() * operand.yz() * self.x()
                + self.y() * operand.s() * self.z()
                + self.y() * operand.xz() * self.x()
                + self.y() * operand.yz() * self.y()
                + self.y() * operand.zt() * self.t()
                - self.z() * operand.s() * self.y()
                - self.z() * operand.xy() * self.x()
                - self.z() * operand.yt() * self.t()
                + self.z() * operand.yz() * self.z())
                * inv_norm_sq,
            (-(self.t() * operand.s() * self.y())
                - self.t() * operand.xy() * self.x()
                - self.t() * operand.yt() * self.t()
                + self.t() * operand.yz() * self.z()
                + self.x() * operand.xt() * self.y()
                - self.x() * operand.xy() * self.t()
                - self.x() * operand.xyzt() * self.z()
                - self.x() * operand.yt() * self.x()
                + self.y() * operand.s() * self.t()
                + self.y() * operand.xt() * self.x()
                + self.y() * operand.yt() * self.y()
                + self.y() * operand.zt() * self.z()
                + self.z() * operand.xyzt() * self.x()
                - self.z() * operand.yt() * self.z()
                + self.z() * operand.yz() * self.t()
                + self.z() * operand.zt() * self.y())
                * inv_norm_sq,
            (-(self.t() * operand.s() * self.z())
                - self.t() * operand.xz() * self.x()
                - self.t() * operand.yz() * self.y()
                - self.t() * operand.zt() * self.t()
                + self.x() * operand.xt() * self.z()
                + self.x() * operand.xyzt() * self.y()
                - self.x() * operand.xz() * self.t()
                - self.x() * operand.zt() * self.x()
                - self.y() * operand.xyzt() * self.x()
                + self.y() * operand.yt() * self.z()
                - self.y() * operand.yz() * self.t()
                - self.y() * operand.zt() * self.y()
                + self.z() * operand.s() * self.t()
                + self.z() * operand.xt() * self.x()
                + self.z() * operand.yt() * self.y()
                + self.z() * operand.zt() * self.z())
                * inv_norm_sq,
            (-(self.t() * operand.xy() * self.z()) - self.t() * operand.xyzt() * self.t()
                + self.t() * operand.xz() * self.y()
                - self.t() * operand.yz() * self.x()
                + self.x() * operand.xyzt() * self.x()
                - self.x() * operand.yt() * self.z()
                + self.x() * operand.yz() * self.t()
                + self.x() * operand.zt() * self.y()
                + self.y() * operand.xt() * self.z()
                + self.y() * operand.xyzt() * self.y()
                - self.y() * operand.xz() * self.t()
                - self.y() * operand.zt() * self.x()
                - self.z() * operand.xt() * self.y()
                + self.z() * operand.xy() * self.t()
                + self.z() * operand.xyzt() * self.z()
                + self.z() * operand.yt() * self.x())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Pseudoscalar<T>> for Vector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (-(self.t() * operand.xyzt() * self.t())
                + self.x() * operand.xyzt() * self.x()
                + self.y() * operand.xyzt() * self.y()
                + self.z() * operand.xyzt() * self.z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.t() * operand.s() * self.t()
                - self.x() * operand.s() * self.x()
                - self.y() * operand.s() * self.y()
                - self.z() * operand.s() * self.z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Trivector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Trivector<T>) -> Option<Trivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Trivector::new_unchecked(
            (-(self.t() * operand.xyt() * self.z())
                + self.t() * operand.xyz() * self.t()
                + self.t() * operand.xzt() * self.y()
                - self.t() * operand.yzt() * self.x()
                + self.x() * operand.xyz() * self.x()
                - self.x() * operand.yzt() * self.t()
                + self.y() * operand.xyz() * self.y()
                + self.y() * operand.xzt() * self.t()
                - self.z() * operand.xyt() * self.t()
                + self.z() * operand.xyz() * self.z())
                * inv_norm_sq,
            (-(self.t() * operand.xyt() * self.t())
                + self.t() * operand.xyz() * self.z()
                + self.x() * operand.xyt() * self.x()
                - self.x() * operand.yzt() * self.z()
                + self.y() * operand.xyt() * self.y()
                + self.y() * operand.xzt() * self.z()
                - self.z() * operand.xyt() * self.z()
                + self.z() * operand.xyz() * self.t()
                + self.z() * operand.xzt() * self.y()
                - self.z() * operand.yzt() * self.x())
                * inv_norm_sq,
            (-(self.t() * operand.xyz() * self.y()) - self.t() * operand.xzt() * self.t()
                + self.x() * operand.xzt() * self.x()
                + self.x() * operand.yzt() * self.y()
                + self.y() * operand.xyt() * self.z()
                - self.y() * operand.xyz() * self.t()
                - self.y() * operand.xzt() * self.y()
                + self.y() * operand.yzt() * self.x()
                + self.z() * operand.xyt() * self.y()
                + self.z() * operand.xzt() * self.z())
                * inv_norm_sq,
            (self.t() * operand.xyz() * self.x()
                - self.t() * operand.yzt() * self.t()
                - self.x() * operand.xyt() * self.z()
                + self.x() * operand.xyz() * self.t()
                + self.x() * operand.xzt() * self.y()
                - self.x() * operand.yzt() * self.x()
                + self.y() * operand.xzt() * self.x()
                + self.y() * operand.yzt() * self.y()
                - self.z() * operand.xyt() * self.x()
                + self.z() * operand.yzt() * self.z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Vector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (-(self.t() * operand.t() * self.x()) + self.t() * operand.x() * self.t()
                - self.x() * operand.t() * self.t()
                + self.x() * operand.x() * self.x()
                + self.x() * operand.y() * self.y()
                + self.x() * operand.z() * self.z()
                - self.y() * operand.x() * self.y()
                + self.y() * operand.y() * self.x()
                - self.z() * operand.x() * self.z()
                + self.z() * operand.z() * self.x())
                * inv_norm_sq,
            (-(self.t() * operand.t() * self.y())
                + self.t() * operand.y() * self.t()
                + self.x() * operand.x() * self.y()
                - self.x() * operand.y() * self.x()
                - self.y() * operand.t() * self.t()
                + self.y() * operand.x() * self.x()
                + self.y() * operand.y() * self.y()
                + self.y() * operand.z() * self.z()
                - self.z() * operand.y() * self.z()
                + self.z() * operand.z() * self.y())
                * inv_norm_sq,
            (-(self.t() * operand.t() * self.z())
                + self.t() * operand.z() * self.t()
                + self.x() * operand.x() * self.z()
                - self.x() * operand.z() * self.x()
                + self.y() * operand.y() * self.z()
                - self.y() * operand.z() * self.y()
                - self.z() * operand.t() * self.t()
                + self.z() * operand.x() * self.x()
                + self.z() * operand.y() * self.y()
                + self.z() * operand.z() * self.z())
                * inv_norm_sq,
            (-(self.t() * operand.t() * self.t())
                + self.t() * operand.x() * self.x()
                + self.t() * operand.y() * self.y()
                + self.t() * operand.z() * self.z()
                - self.x() * operand.t() * self.x()
                + self.x() * operand.x() * self.t()
                - self.y() * operand.t() * self.y()
                + self.y() * operand.y() * self.t()
                - self.z() * operand.t() * self.z()
                + self.z() * operand.z() * self.t())
                * inv_norm_sq,
        ))
    }
}
impl<T: Float> Versor<Bivector<T>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn compose(&self, other: &Bivector<T>) -> Eventor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Eventor<T>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn compose(&self, other: &Eventor<T>) -> Eventor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Pseudoscalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn compose(&self, other: &Pseudoscalar<T>) -> Bivector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Bivector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Bivector<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn compose(&self, other: &Bivector<T>) -> Eventor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Eventor<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn compose(&self, other: &Eventor<T>) -> Eventor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Pseudoscalar<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn compose(&self, other: &Pseudoscalar<T>) -> Eventor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Eventor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Bivector<T>> for Pseudoscalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn compose(&self, other: &Bivector<T>) -> Bivector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Eventor<T>> for Pseudoscalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn compose(&self, other: &Eventor<T>) -> Eventor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn compose(&self, other: &Pseudoscalar<T>) -> Scalar<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Pseudoscalar<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Trivector<T>> for Pseudoscalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn compose(&self, other: &Trivector<T>) -> Vector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Vector<T>> for Pseudoscalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn compose(&self, other: &Vector<T>) -> Trivector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn compose(&self, other: &Bivector<T>) -> Bivector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Eventor<T>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn compose(&self, other: &Eventor<T>) -> Eventor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Pseudoscalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn compose(&self, other: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Scalar<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Trivector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn compose(&self, other: &Trivector<T>) -> Trivector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn compose(&self, other: &Vector<T>) -> Vector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Pseudoscalar<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn compose(&self, other: &Pseudoscalar<T>) -> Vector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Trivector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Pseudoscalar<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn compose(&self, other: &Pseudoscalar<T>) -> Trivector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Vector<T> {
        *self * *other
    }
}
impl<T: Float> ScalarProduct<Bivector<T>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Bivector<T>) -> T {
        -(self.xy() * rhs.xy()) - self.xz() * rhs.xz() + self.xt() * rhs.xt() - self.yz() * rhs.yz()
            + self.yt() * rhs.yt()
            + self.zt() * rhs.zt()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Bivector<T>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Bivector<T>) -> T {
        -(rhs.xy() * self.as_inner().xy())
            + -(rhs.xz() * self.as_inner().xz())
            + -(rhs.yz() * self.as_inner().yz())
            + rhs.xt() * self.as_inner().xt()
            + rhs.yt() * self.as_inner().yt()
            + rhs.zt() * self.as_inner().zt()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Bivector<T>>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Bivector<T>>) -> T {
        -(rhs.as_inner().xy() * self.xy())
            + -(rhs.as_inner().xz() * self.xz())
            + -(rhs.as_inner().yz() * self.yz())
            + rhs.as_inner().xt() * self.xt()
            + rhs.as_inner().yt() * self.yt()
            + rhs.as_inner().zt() * self.zt()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Bivector<T>>) -> T {
        -(rhs.as_inner().xy() * self.as_inner().xy())
            + -(rhs.as_inner().xz() * self.as_inner().xz())
            + -(rhs.as_inner().yz() * self.as_inner().yz())
            + rhs.as_inner().xt() * self.as_inner().xt()
            + rhs.as_inner().yt() * self.as_inner().yt()
            + rhs.as_inner().zt() * self.as_inner().zt()
    }
}
impl<T: Float> ScalarProduct<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Pseudoscalar<T>) -> T {
        -(self.xyzt() * rhs.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Pseudoscalar<T>) -> T {
        -(rhs.xyzt() * self.as_inner().xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Pseudoscalar<T>>) -> T {
        -(rhs.as_inner().xyzt() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Pseudoscalar<T>>) -> T {
        -(rhs.as_inner().xyzt() * self.as_inner().xyzt())
    }
}
impl<T: Float> ScalarProduct<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Scalar<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Scalar<T>) -> T {
        rhs.s() * self.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Scalar<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Scalar<T>>) -> T {
        rhs.as_inner().s() * self.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Scalar<T>>) -> T {
        rhs.as_inner().s() * self.as_inner().s()
    }
}
impl<T: Float> ScalarProduct<Trivector<T>> for Trivector<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Trivector<T>) -> T {
        -(self.xyz() * rhs.xyz())
            + self.xyt() * rhs.xyt()
            + self.xzt() * rhs.xzt()
            + self.yzt() * rhs.yzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Trivector<T>> for Unit<Trivector<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Trivector<T>) -> T {
        -(rhs.xyz() * self.as_inner().xyz())
            + rhs.xyt() * self.as_inner().xyt()
            + rhs.xzt() * self.as_inner().xzt()
            + rhs.yzt() * self.as_inner().yzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Trivector<T>>> for Trivector<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Trivector<T>>) -> T {
        -(rhs.as_inner().xyz() * self.xyz())
            + rhs.as_inner().xyt() * self.xyt()
            + rhs.as_inner().xzt() * self.xzt()
            + rhs.as_inner().yzt() * self.yzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Trivector<T>>> for Unit<Trivector<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Trivector<T>>) -> T {
        -(rhs.as_inner().xyz() * self.as_inner().xyz())
            + rhs.as_inner().xyt() * self.as_inner().xyt()
            + rhs.as_inner().xzt() * self.as_inner().xzt()
            + rhs.as_inner().yzt() * self.as_inner().yzt()
    }
}
impl<T: Float> ScalarProduct<Vector<T>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Vector<T>) -> T {
        self.x() * rhs.x() + self.y() * rhs.y() + self.z() * rhs.z() - self.t() * rhs.t()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Vector<T>> for Unit<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Vector<T>) -> T {
        -(rhs.t() * self.as_inner().t())
            + rhs.x() * self.as_inner().x()
            + rhs.y() * self.as_inner().y()
            + rhs.z() * self.as_inner().z()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Vector<T>>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Vector<T>>) -> T {
        -(rhs.as_inner().t() * self.t())
            + rhs.as_inner().x() * self.x()
            + rhs.as_inner().y() * self.y()
            + rhs.as_inner().z() * self.z()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Vector<T>>) -> T {
        -(rhs.as_inner().t() * self.as_inner().t())
            + rhs.as_inner().x() * self.as_inner().x()
            + rhs.as_inner().y() * self.as_inner().y()
            + rhs.as_inner().z() * self.as_inner().z()
    }
}
impl<T: Float> BulkContract<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xt() * self.xt())
                + -(rhs.yt() * self.yt())
                + -(rhs.zt() * self.zt())
                + rhs.xy() * self.xy()
                + rhs.xz() * self.xz()
                + rhs.yz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xt() * self.as_inner().xt())
                + -(rhs.yt() * self.as_inner().yt())
                + -(rhs.zt() * self.as_inner().zt())
                + rhs.xy() * self.as_inner().xy()
                + rhs.xz() * self.as_inner().xz()
                + rhs.yz() * self.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xt() * self.xt())
                + -(rhs.as_inner().yt() * self.yt())
                + -(rhs.as_inner().zt() * self.zt())
                + rhs.as_inner().xy() * self.xy()
                + rhs.as_inner().xz() * self.xz()
                + rhs.as_inner().yz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xt() * self.as_inner().xt())
                + -(rhs.as_inner().yt() * self.as_inner().yt())
                + -(rhs.as_inner().zt() * self.as_inner().zt())
                + rhs.as_inner().xy() * self.as_inner().xy()
                + rhs.as_inner().xz() * self.as_inner().xz()
                + rhs.as_inner().yz() * self.as_inner().yz(),
        )
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.s() * self.xy(),
            rhs.s() * self.xz(),
            rhs.s() * self.xt(),
            rhs.s() * self.yz(),
            rhs.s() * self.yt(),
            rhs.s() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.s() * self.as_inner().xy(),
            rhs.s() * self.as_inner().xz(),
            rhs.s() * self.as_inner().xt(),
            rhs.s() * self.as_inner().yz(),
            rhs.s() * self.as_inner().yt(),
            rhs.s() * self.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().s() * self.xy(),
            rhs.as_inner().s() * self.xz(),
            rhs.as_inner().s() * self.xt(),
            rhs.as_inner().s() * self.yz(),
            rhs.as_inner().s() * self.yt(),
            rhs.as_inner().s() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().s() * self.as_inner().xy(),
            rhs.as_inner().s() * self.as_inner().xz(),
            rhs.as_inner().s() * self.as_inner().xt(),
            rhs.as_inner().s() * self.as_inner().yz(),
            rhs.as_inner().s() * self.as_inner().yt(),
            rhs.as_inner().s() * self.as_inner().zt(),
        )
    }
}
impl<T: Float> BulkContract<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.t() * self.xt()) + rhs.y() * self.xy() + rhs.z() * self.xz(),
            -(rhs.t() * self.yt()) + -(rhs.x() * self.xy()) + rhs.z() * self.yz(),
            -(rhs.t() * self.zt()) + -(rhs.x() * self.xz()) + -(rhs.y() * self.yz()),
            -(rhs.x() * self.xt()) + -(rhs.y() * self.yt()) + -(rhs.z() * self.zt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Vector<T>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.t() * self.as_inner().xt())
                + rhs.y() * self.as_inner().xy()
                + rhs.z() * self.as_inner().xz(),
            -(rhs.t() * self.as_inner().yt())
                + -(rhs.x() * self.as_inner().xy())
                + rhs.z() * self.as_inner().yz(),
            -(rhs.t() * self.as_inner().zt())
                + -(rhs.x() * self.as_inner().xz())
                + -(rhs.y() * self.as_inner().yz()),
            -(rhs.x() * self.as_inner().xt())
                + -(rhs.y() * self.as_inner().yt())
                + -(rhs.z() * self.as_inner().zt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Vector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().t() * self.xt())
                + rhs.as_inner().y() * self.xy()
                + rhs.as_inner().z() * self.xz(),
            -(rhs.as_inner().t() * self.yt())
                + -(rhs.as_inner().x() * self.xy())
                + rhs.as_inner().z() * self.yz(),
            -(rhs.as_inner().t() * self.zt())
                + -(rhs.as_inner().x() * self.xz())
                + -(rhs.as_inner().y() * self.yz()),
            -(rhs.as_inner().x() * self.xt())
                + -(rhs.as_inner().y() * self.yt())
                + -(rhs.as_inner().z() * self.zt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Vector<T>>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().t() * self.as_inner().xt())
                + rhs.as_inner().y() * self.as_inner().xy()
                + rhs.as_inner().z() * self.as_inner().xz(),
            -(rhs.as_inner().t() * self.as_inner().yt())
                + -(rhs.as_inner().x() * self.as_inner().xy())
                + rhs.as_inner().z() * self.as_inner().yz(),
            -(rhs.as_inner().t() * self.as_inner().zt())
                + -(rhs.as_inner().x() * self.as_inner().xz())
                + -(rhs.as_inner().y() * self.as_inner().yz()),
            -(rhs.as_inner().x() * self.as_inner().xt())
                + -(rhs.as_inner().y() * self.as_inner().yt())
                + -(rhs.as_inner().z() * self.as_inner().zt()),
        )
    }
}
impl<T: Float> BulkContract<Bivector<T>> for Pseudoscalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.zt() * self.xyzt()),
            rhs.yt() * self.xyzt(),
            rhs.yz() * self.xyzt(),
            -(rhs.xt() * self.xyzt()),
            -(rhs.xz() * self.xyzt()),
            rhs.xy() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Bivector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.zt() * self.as_inner().xyzt()),
            rhs.yt() * self.as_inner().xyzt(),
            rhs.yz() * self.as_inner().xyzt(),
            -(rhs.xt() * self.as_inner().xyzt()),
            -(rhs.xz() * self.as_inner().xyzt()),
            rhs.xy() * self.as_inner().xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Bivector<T>>> for Pseudoscalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().zt() * self.xyzt()),
            rhs.as_inner().yt() * self.xyzt(),
            rhs.as_inner().yz() * self.xyzt(),
            -(rhs.as_inner().xt() * self.xyzt()),
            -(rhs.as_inner().xz() * self.xyzt()),
            rhs.as_inner().xy() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Bivector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().zt() * self.as_inner().xyzt()),
            rhs.as_inner().yt() * self.as_inner().xyzt(),
            rhs.as_inner().yz() * self.as_inner().xyzt(),
            -(rhs.as_inner().xt() * self.as_inner().xyzt()),
            -(rhs.as_inner().xz() * self.as_inner().xyzt()),
            rhs.as_inner().xy() * self.as_inner().xyzt(),
        )
    }
}
impl<T: Float> BulkContract<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.xyzt() * self.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.xyzt() * self.as_inner().xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().xyzt() * self.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().xyzt() * self.as_inner().xyzt()))
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.s() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.s() * self.as_inner().xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().s() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().s() * self.as_inner().xyzt())
    }
}
impl<T: Float> BulkContract<Trivector<T>> for Pseudoscalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.yzt() * self.xyzt()),
            rhs.xzt() * self.xyzt(),
            -(rhs.xyt() * self.xyzt()),
            -(rhs.xyz() * self.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Trivector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.yzt() * self.as_inner().xyzt()),
            rhs.xzt() * self.as_inner().xyzt(),
            -(rhs.xyt() * self.as_inner().xyzt()),
            -(rhs.xyz() * self.as_inner().xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Trivector<T>>> for Pseudoscalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().yzt() * self.xyzt()),
            rhs.as_inner().xzt() * self.xyzt(),
            -(rhs.as_inner().xyt() * self.xyzt()),
            -(rhs.as_inner().xyz() * self.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Trivector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().yzt() * self.as_inner().xyzt()),
            rhs.as_inner().xzt() * self.as_inner().xyzt(),
            -(rhs.as_inner().xyt() * self.as_inner().xyzt()),
            -(rhs.as_inner().xyz() * self.as_inner().xyzt()),
        )
    }
}
impl<T: Float> BulkContract<Vector<T>> for Pseudoscalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.t() * self.xyzt()),
            -(rhs.z() * self.xyzt()),
            rhs.y() * self.xyzt(),
            -(rhs.x() * self.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Vector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.t() * self.as_inner().xyzt()),
            -(rhs.z() * self.as_inner().xyzt()),
            rhs.y() * self.as_inner().xyzt(),
            -(rhs.x() * self.as_inner().xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Vector<T>>> for Pseudoscalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Vector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().t() * self.xyzt()),
            -(rhs.as_inner().z() * self.xyzt()),
            rhs.as_inner().y() * self.xyzt(),
            -(rhs.as_inner().x() * self.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Vector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Vector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().t() * self.as_inner().xyzt()),
            -(rhs.as_inner().z() * self.as_inner().xyzt()),
            rhs.as_inner().y() * self.as_inner().xyzt(),
            -(rhs.as_inner().x() * self.as_inner().xyzt()),
        )
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().s() * self.as_inner().s())
    }
}
impl<T: Float> BulkContract<Bivector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.yz() * self.xyz()) + rhs.yt() * self.xyt() + rhs.zt() * self.xzt(),
            -(rhs.xt() * self.xyt()) + rhs.xz() * self.xyz() + rhs.zt() * self.yzt(),
            -(rhs.xt() * self.xzt()) + -(rhs.xy() * self.xyz()) + -(rhs.yt() * self.yzt()),
            -(rhs.xy() * self.xyt()) + -(rhs.xz() * self.xzt()) + -(rhs.yz() * self.yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Bivector<T>> for Unit<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.yz() * self.as_inner().xyz())
                + rhs.yt() * self.as_inner().xyt()
                + rhs.zt() * self.as_inner().xzt(),
            -(rhs.xt() * self.as_inner().xyt())
                + rhs.xz() * self.as_inner().xyz()
                + rhs.zt() * self.as_inner().yzt(),
            -(rhs.xt() * self.as_inner().xzt())
                + -(rhs.xy() * self.as_inner().xyz())
                + -(rhs.yt() * self.as_inner().yzt()),
            -(rhs.xy() * self.as_inner().xyt())
                + -(rhs.xz() * self.as_inner().xzt())
                + -(rhs.yz() * self.as_inner().yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Bivector<T>>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().yz() * self.xyz())
                + rhs.as_inner().yt() * self.xyt()
                + rhs.as_inner().zt() * self.xzt(),
            -(rhs.as_inner().xt() * self.xyt())
                + rhs.as_inner().xz() * self.xyz()
                + rhs.as_inner().zt() * self.yzt(),
            -(rhs.as_inner().xt() * self.xzt())
                + -(rhs.as_inner().xy() * self.xyz())
                + -(rhs.as_inner().yt() * self.yzt()),
            -(rhs.as_inner().xy() * self.xyt())
                + -(rhs.as_inner().xz() * self.xzt())
                + -(rhs.as_inner().yz() * self.yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Bivector<T>>> for Unit<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().yz() * self.as_inner().xyz())
                + rhs.as_inner().yt() * self.as_inner().xyt()
                + rhs.as_inner().zt() * self.as_inner().xzt(),
            -(rhs.as_inner().xt() * self.as_inner().xyt())
                + rhs.as_inner().xz() * self.as_inner().xyz()
                + rhs.as_inner().zt() * self.as_inner().yzt(),
            -(rhs.as_inner().xt() * self.as_inner().xzt())
                + -(rhs.as_inner().xy() * self.as_inner().xyz())
                + -(rhs.as_inner().yt() * self.as_inner().yzt()),
            -(rhs.as_inner().xy() * self.as_inner().xyt())
                + -(rhs.as_inner().xz() * self.as_inner().xzt())
                + -(rhs.as_inner().yz() * self.as_inner().yzt()),
        )
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.s() * self.xyz()),
            -(rhs.s() * self.xyt()),
            -(rhs.s() * self.xzt()),
            -(rhs.s() * self.yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.s() * self.as_inner().xyz()),
            -(rhs.s() * self.as_inner().xyt()),
            -(rhs.s() * self.as_inner().xzt()),
            -(rhs.s() * self.as_inner().yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().s() * self.xyz()),
            -(rhs.as_inner().s() * self.xyt()),
            -(rhs.as_inner().s() * self.xzt()),
            -(rhs.as_inner().s() * self.yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().s() * self.as_inner().xyz()),
            -(rhs.as_inner().s() * self.as_inner().xyt()),
            -(rhs.as_inner().s() * self.as_inner().xzt()),
            -(rhs.as_inner().s() * self.as_inner().yzt()),
        )
    }
}
impl<T: Float> BulkContract<Trivector<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Trivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xyt() * self.xyt())
                + -(rhs.xzt() * self.xzt())
                + -(rhs.yzt() * self.yzt())
                + rhs.xyz() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Trivector<T>> for Unit<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Trivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xyt() * self.as_inner().xyt())
                + -(rhs.xzt() * self.as_inner().xzt())
                + -(rhs.yzt() * self.as_inner().yzt())
                + rhs.xyz() * self.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Trivector<T>>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Trivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xyt() * self.xyt())
                + -(rhs.as_inner().xzt() * self.xzt())
                + -(rhs.as_inner().yzt() * self.yzt())
                + rhs.as_inner().xyz() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Trivector<T>>> for Unit<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Trivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xyt() * self.as_inner().xyt())
                + -(rhs.as_inner().xzt() * self.as_inner().xzt())
                + -(rhs.as_inner().yzt() * self.as_inner().yzt())
                + rhs.as_inner().xyz() * self.as_inner().xyz(),
        )
    }
}
impl<T: Float> BulkContract<Vector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.t() * self.xyt()) + rhs.z() * self.xyz(),
            -(rhs.t() * self.xzt()) + -(rhs.y() * self.xyz()),
            -(rhs.y() * self.xyt()) + -(rhs.z() * self.xzt()),
            -(rhs.t() * self.yzt()) + rhs.x() * self.xyz(),
            -(rhs.z() * self.yzt()) + rhs.x() * self.xyt(),
            rhs.x() * self.xzt() + rhs.y() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Vector<T>> for Unit<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.t() * self.as_inner().xyt()) + rhs.z() * self.as_inner().xyz(),
            -(rhs.t() * self.as_inner().xzt()) + -(rhs.y() * self.as_inner().xyz()),
            -(rhs.y() * self.as_inner().xyt()) + -(rhs.z() * self.as_inner().xzt()),
            -(rhs.t() * self.as_inner().yzt()) + rhs.x() * self.as_inner().xyz(),
            -(rhs.z() * self.as_inner().yzt()) + rhs.x() * self.as_inner().xyt(),
            rhs.x() * self.as_inner().xzt() + rhs.y() * self.as_inner().yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Vector<T>>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().t() * self.xyt()) + rhs.as_inner().z() * self.xyz(),
            -(rhs.as_inner().t() * self.xzt()) + -(rhs.as_inner().y() * self.xyz()),
            -(rhs.as_inner().y() * self.xyt()) + -(rhs.as_inner().z() * self.xzt()),
            -(rhs.as_inner().t() * self.yzt()) + rhs.as_inner().x() * self.xyz(),
            -(rhs.as_inner().z() * self.yzt()) + rhs.as_inner().x() * self.xyt(),
            rhs.as_inner().x() * self.xzt() + rhs.as_inner().y() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Vector<T>>> for Unit<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().t() * self.as_inner().xyt())
                + rhs.as_inner().z() * self.as_inner().xyz(),
            -(rhs.as_inner().t() * self.as_inner().xzt())
                + -(rhs.as_inner().y() * self.as_inner().xyz()),
            -(rhs.as_inner().y() * self.as_inner().xyt())
                + -(rhs.as_inner().z() * self.as_inner().xzt()),
            -(rhs.as_inner().t() * self.as_inner().yzt())
                + rhs.as_inner().x() * self.as_inner().xyz(),
            -(rhs.as_inner().z() * self.as_inner().yzt())
                + rhs.as_inner().x() * self.as_inner().xyt(),
            rhs.as_inner().x() * self.as_inner().xzt() + rhs.as_inner().y() * self.as_inner().yzt(),
        )
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.s() * self.x()),
            -(rhs.s() * self.y()),
            -(rhs.s() * self.z()),
            -(rhs.s() * self.t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.s() * self.as_inner().x()),
            -(rhs.s() * self.as_inner().y()),
            -(rhs.s() * self.as_inner().z()),
            -(rhs.s() * self.as_inner().t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().s() * self.x()),
            -(rhs.as_inner().s() * self.y()),
            -(rhs.as_inner().s() * self.z()),
            -(rhs.as_inner().s() * self.t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().s() * self.as_inner().x()),
            -(rhs.as_inner().s() * self.as_inner().y()),
            -(rhs.as_inner().s() * self.as_inner().z()),
            -(rhs.as_inner().s() * self.as_inner().t()),
        )
    }
}
impl<T: Float> BulkContract<Vector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.t() * self.t()) + rhs.x() * self.x() + rhs.y() * self.y() + rhs.z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Vector<T>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.t() * self.as_inner().t())
                + rhs.x() * self.as_inner().x()
                + rhs.y() * self.as_inner().y()
                + rhs.z() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Vector<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().t() * self.t())
                + rhs.as_inner().x() * self.x()
                + rhs.as_inner().y() * self.y()
                + rhs.as_inner().z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().t() * self.as_inner().t())
                + rhs.as_inner().x() * self.as_inner().x()
                + rhs.as_inner().y() * self.as_inner().y()
                + rhs.as_inner().z() * self.as_inner().z(),
        )
    }
}
impl<T: Float> WeightContract<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xy() * self.xy())
                + -(rhs.xz() * self.xz())
                + -(rhs.yz() * self.yz())
                + rhs.xt() * self.xt()
                + rhs.yt() * self.yt()
                + rhs.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xy() * self.as_inner().xy())
                + -(rhs.xz() * self.as_inner().xz())
                + -(rhs.yz() * self.as_inner().yz())
                + rhs.xt() * self.as_inner().xt()
                + rhs.yt() * self.as_inner().yt()
                + rhs.zt() * self.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xy() * self.xy())
                + -(rhs.as_inner().xz() * self.xz())
                + -(rhs.as_inner().yz() * self.yz())
                + rhs.as_inner().xt() * self.xt()
                + rhs.as_inner().yt() * self.yt()
                + rhs.as_inner().zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xy() * self.as_inner().xy())
                + -(rhs.as_inner().xz() * self.as_inner().xz())
                + -(rhs.as_inner().yz() * self.as_inner().yz())
                + rhs.as_inner().xt() * self.as_inner().xt()
                + rhs.as_inner().yt() * self.as_inner().yt()
                + rhs.as_inner().zt() * self.as_inner().zt(),
        )
    }
}
impl<T: Float> WeightContract<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.s() * self.xy()),
            -(rhs.s() * self.xz()),
            -(rhs.s() * self.xt()),
            -(rhs.s() * self.yz()),
            -(rhs.s() * self.yt()),
            -(rhs.s() * self.zt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Scalar<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.s() * self.as_inner().xy()),
            -(rhs.s() * self.as_inner().xz()),
            -(rhs.s() * self.as_inner().xt()),
            -(rhs.s() * self.as_inner().yz()),
            -(rhs.s() * self.as_inner().yt()),
            -(rhs.s() * self.as_inner().zt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().s() * self.xy()),
            -(rhs.as_inner().s() * self.xz()),
            -(rhs.as_inner().s() * self.xt()),
            -(rhs.as_inner().s() * self.yz()),
            -(rhs.as_inner().s() * self.yt()),
            -(rhs.as_inner().s() * self.zt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().s() * self.as_inner().xy()),
            -(rhs.as_inner().s() * self.as_inner().xz()),
            -(rhs.as_inner().s() * self.as_inner().xt()),
            -(rhs.as_inner().s() * self.as_inner().yz()),
            -(rhs.as_inner().s() * self.as_inner().yt()),
            -(rhs.as_inner().s() * self.as_inner().zt()),
        )
    }
}
impl<T: Float> WeightContract<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.y() * self.xy()) + -(rhs.z() * self.xz()) + rhs.t() * self.xt(),
            -(rhs.z() * self.yz()) + rhs.t() * self.yt() + rhs.x() * self.xy(),
            rhs.t() * self.zt() + rhs.x() * self.xz() + rhs.y() * self.yz(),
            rhs.x() * self.xt() + rhs.y() * self.yt() + rhs.z() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Vector<T>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.y() * self.as_inner().xy())
                + -(rhs.z() * self.as_inner().xz())
                + rhs.t() * self.as_inner().xt(),
            -(rhs.z() * self.as_inner().yz())
                + rhs.t() * self.as_inner().yt()
                + rhs.x() * self.as_inner().xy(),
            rhs.t() * self.as_inner().zt()
                + rhs.x() * self.as_inner().xz()
                + rhs.y() * self.as_inner().yz(),
            rhs.x() * self.as_inner().xt()
                + rhs.y() * self.as_inner().yt()
                + rhs.z() * self.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Vector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().y() * self.xy())
                + -(rhs.as_inner().z() * self.xz())
                + rhs.as_inner().t() * self.xt(),
            -(rhs.as_inner().z() * self.yz())
                + rhs.as_inner().t() * self.yt()
                + rhs.as_inner().x() * self.xy(),
            rhs.as_inner().t() * self.zt()
                + rhs.as_inner().x() * self.xz()
                + rhs.as_inner().y() * self.yz(),
            rhs.as_inner().x() * self.xt()
                + rhs.as_inner().y() * self.yt()
                + rhs.as_inner().z() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Vector<T>>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().y() * self.as_inner().xy())
                + -(rhs.as_inner().z() * self.as_inner().xz())
                + rhs.as_inner().t() * self.as_inner().xt(),
            -(rhs.as_inner().z() * self.as_inner().yz())
                + rhs.as_inner().t() * self.as_inner().yt()
                + rhs.as_inner().x() * self.as_inner().xy(),
            rhs.as_inner().t() * self.as_inner().zt()
                + rhs.as_inner().x() * self.as_inner().xz()
                + rhs.as_inner().y() * self.as_inner().yz(),
            rhs.as_inner().x() * self.as_inner().xt()
                + rhs.as_inner().y() * self.as_inner().yt()
                + rhs.as_inner().z() * self.as_inner().zt(),
        )
    }
}
impl<T: Float> WeightContract<Bivector<T>> for Pseudoscalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.zt() * self.xyzt(),
            -(rhs.yt() * self.xyzt()),
            -(rhs.yz() * self.xyzt()),
            rhs.xt() * self.xyzt(),
            rhs.xz() * self.xyzt(),
            -(rhs.xy() * self.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Bivector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.zt() * self.as_inner().xyzt(),
            -(rhs.yt() * self.as_inner().xyzt()),
            -(rhs.yz() * self.as_inner().xyzt()),
            rhs.xt() * self.as_inner().xyzt(),
            rhs.xz() * self.as_inner().xyzt(),
            -(rhs.xy() * self.as_inner().xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Bivector<T>>> for Pseudoscalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().zt() * self.xyzt(),
            -(rhs.as_inner().yt() * self.xyzt()),
            -(rhs.as_inner().yz() * self.xyzt()),
            rhs.as_inner().xt() * self.xyzt(),
            rhs.as_inner().xz() * self.xyzt(),
            -(rhs.as_inner().xy() * self.xyzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Bivector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().zt() * self.as_inner().xyzt(),
            -(rhs.as_inner().yt() * self.as_inner().xyzt()),
            -(rhs.as_inner().yz() * self.as_inner().xyzt()),
            rhs.as_inner().xt() * self.as_inner().xyzt(),
            rhs.as_inner().xz() * self.as_inner().xyzt(),
            -(rhs.as_inner().xy() * self.as_inner().xyzt()),
        )
    }
}
impl<T: Float> WeightContract<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.xyzt() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.xyzt() * self.as_inner().xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().xyzt() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().xyzt() * self.as_inner().xyzt())
    }
}
impl<T: Float> WeightContract<Scalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(rhs.s() * self.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Scalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(rhs.s() * self.as_inner().xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(rhs.as_inner().s() * self.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(rhs.as_inner().s() * self.as_inner().xyzt()))
    }
}
impl<T: Float> WeightContract<Trivector<T>> for Pseudoscalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.yzt() * self.xyzt(),
            -(rhs.xzt() * self.xyzt()),
            rhs.xyt() * self.xyzt(),
            rhs.xyz() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Trivector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.yzt() * self.as_inner().xyzt(),
            -(rhs.xzt() * self.as_inner().xyzt()),
            rhs.xyt() * self.as_inner().xyzt(),
            rhs.xyz() * self.as_inner().xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Trivector<T>>> for Pseudoscalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().yzt() * self.xyzt(),
            -(rhs.as_inner().xzt() * self.xyzt()),
            rhs.as_inner().xyt() * self.xyzt(),
            rhs.as_inner().xyz() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Trivector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().yzt() * self.as_inner().xyzt(),
            -(rhs.as_inner().xzt() * self.as_inner().xyzt()),
            rhs.as_inner().xyt() * self.as_inner().xyzt(),
            rhs.as_inner().xyz() * self.as_inner().xyzt(),
        )
    }
}
impl<T: Float> WeightContract<Vector<T>> for Pseudoscalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.t() * self.xyzt(),
            rhs.z() * self.xyzt(),
            -(rhs.y() * self.xyzt()),
            rhs.x() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Vector<T>> for Unit<Pseudoscalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.t() * self.as_inner().xyzt(),
            rhs.z() * self.as_inner().xyzt(),
            -(rhs.y() * self.as_inner().xyzt()),
            rhs.x() * self.as_inner().xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Vector<T>>> for Pseudoscalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Vector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().t() * self.xyzt(),
            rhs.as_inner().z() * self.xyzt(),
            -(rhs.as_inner().y() * self.xyzt()),
            rhs.as_inner().x() * self.xyzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Vector<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Vector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().t() * self.as_inner().xyzt(),
            rhs.as_inner().z() * self.as_inner().xyzt(),
            -(rhs.as_inner().y() * self.as_inner().xyzt()),
            rhs.as_inner().x() * self.as_inner().xyzt(),
        )
    }
}
impl<T: Float> WeightContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.s() * self.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.s() * self.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().s() * self.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().s() * self.as_inner().s()))
    }
}
impl<T: Float> WeightContract<Bivector<T>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.yt() * self.xyt()) + -(rhs.zt() * self.xzt()) + rhs.yz() * self.xyz(),
            -(rhs.xz() * self.xyz()) + -(rhs.zt() * self.yzt()) + rhs.xt() * self.xyt(),
            rhs.xt() * self.xzt() + rhs.xy() * self.xyz() + rhs.yt() * self.yzt(),
            rhs.xy() * self.xyt() + rhs.xz() * self.xzt() + rhs.yz() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Bivector<T>> for Unit<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.yt() * self.as_inner().xyt())
                + -(rhs.zt() * self.as_inner().xzt())
                + rhs.yz() * self.as_inner().xyz(),
            -(rhs.xz() * self.as_inner().xyz())
                + -(rhs.zt() * self.as_inner().yzt())
                + rhs.xt() * self.as_inner().xyt(),
            rhs.xt() * self.as_inner().xzt()
                + rhs.xy() * self.as_inner().xyz()
                + rhs.yt() * self.as_inner().yzt(),
            rhs.xy() * self.as_inner().xyt()
                + rhs.xz() * self.as_inner().xzt()
                + rhs.yz() * self.as_inner().yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Bivector<T>>> for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().yt() * self.xyt())
                + -(rhs.as_inner().zt() * self.xzt())
                + rhs.as_inner().yz() * self.xyz(),
            -(rhs.as_inner().xz() * self.xyz())
                + -(rhs.as_inner().zt() * self.yzt())
                + rhs.as_inner().xt() * self.xyt(),
            rhs.as_inner().xt() * self.xzt()
                + rhs.as_inner().xy() * self.xyz()
                + rhs.as_inner().yt() * self.yzt(),
            rhs.as_inner().xy() * self.xyt()
                + rhs.as_inner().xz() * self.xzt()
                + rhs.as_inner().yz() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Bivector<T>>> for Unit<Trivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().yt() * self.as_inner().xyt())
                + -(rhs.as_inner().zt() * self.as_inner().xzt())
                + rhs.as_inner().yz() * self.as_inner().xyz(),
            -(rhs.as_inner().xz() * self.as_inner().xyz())
                + -(rhs.as_inner().zt() * self.as_inner().yzt())
                + rhs.as_inner().xt() * self.as_inner().xyt(),
            rhs.as_inner().xt() * self.as_inner().xzt()
                + rhs.as_inner().xy() * self.as_inner().xyz()
                + rhs.as_inner().yt() * self.as_inner().yzt(),
            rhs.as_inner().xy() * self.as_inner().xyt()
                + rhs.as_inner().xz() * self.as_inner().xzt()
                + rhs.as_inner().yz() * self.as_inner().yzt(),
        )
    }
}
impl<T: Float> WeightContract<Scalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.s() * self.xyz(),
            rhs.s() * self.xyt(),
            rhs.s() * self.xzt(),
            rhs.s() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Scalar<T>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.s() * self.as_inner().xyz(),
            rhs.s() * self.as_inner().xyt(),
            rhs.s() * self.as_inner().xzt(),
            rhs.s() * self.as_inner().yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().s() * self.xyz(),
            rhs.as_inner().s() * self.xyt(),
            rhs.as_inner().s() * self.xzt(),
            rhs.as_inner().s() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().s() * self.as_inner().xyz(),
            rhs.as_inner().s() * self.as_inner().xyt(),
            rhs.as_inner().s() * self.as_inner().xzt(),
            rhs.as_inner().s() * self.as_inner().yzt(),
        )
    }
}
impl<T: Float> WeightContract<Trivector<T>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Trivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xyz() * self.xyz())
                + rhs.xyt() * self.xyt()
                + rhs.xzt() * self.xzt()
                + rhs.yzt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Trivector<T>> for Unit<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Trivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.xyz() * self.as_inner().xyz())
                + rhs.xyt() * self.as_inner().xyt()
                + rhs.xzt() * self.as_inner().xzt()
                + rhs.yzt() * self.as_inner().yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Trivector<T>>> for Trivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Trivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xyz() * self.xyz())
                + rhs.as_inner().xyt() * self.xyt()
                + rhs.as_inner().xzt() * self.xzt()
                + rhs.as_inner().yzt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Trivector<T>>> for Unit<Trivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Trivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().xyz() * self.as_inner().xyz())
                + rhs.as_inner().xyt() * self.as_inner().xyt()
                + rhs.as_inner().xzt() * self.as_inner().xzt()
                + rhs.as_inner().yzt() * self.as_inner().yzt(),
        )
    }
}
impl<T: Float> WeightContract<Vector<T>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.z() * self.xyz()) + rhs.t() * self.xyt(),
            rhs.t() * self.xzt() + rhs.y() * self.xyz(),
            rhs.y() * self.xyt() + rhs.z() * self.xzt(),
            -(rhs.x() * self.xyz()) + rhs.t() * self.yzt(),
            -(rhs.x() * self.xyt()) + rhs.z() * self.yzt(),
            -(rhs.x() * self.xzt()) + -(rhs.y() * self.yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Vector<T>> for Unit<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.z() * self.as_inner().xyz()) + rhs.t() * self.as_inner().xyt(),
            rhs.t() * self.as_inner().xzt() + rhs.y() * self.as_inner().xyz(),
            rhs.y() * self.as_inner().xyt() + rhs.z() * self.as_inner().xzt(),
            -(rhs.x() * self.as_inner().xyz()) + rhs.t() * self.as_inner().yzt(),
            -(rhs.x() * self.as_inner().xyt()) + rhs.z() * self.as_inner().yzt(),
            -(rhs.x() * self.as_inner().xzt()) + -(rhs.y() * self.as_inner().yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Vector<T>>> for Trivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().z() * self.xyz()) + rhs.as_inner().t() * self.xyt(),
            rhs.as_inner().t() * self.xzt() + rhs.as_inner().y() * self.xyz(),
            rhs.as_inner().y() * self.xyt() + rhs.as_inner().z() * self.xzt(),
            -(rhs.as_inner().x() * self.xyz()) + rhs.as_inner().t() * self.yzt(),
            -(rhs.as_inner().x() * self.xyt()) + rhs.as_inner().z() * self.yzt(),
            -(rhs.as_inner().x() * self.xzt()) + -(rhs.as_inner().y() * self.yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Vector<T>>> for Unit<Trivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().z() * self.as_inner().xyz())
                + rhs.as_inner().t() * self.as_inner().xyt(),
            rhs.as_inner().t() * self.as_inner().xzt() + rhs.as_inner().y() * self.as_inner().xyz(),
            rhs.as_inner().y() * self.as_inner().xyt() + rhs.as_inner().z() * self.as_inner().xzt(),
            -(rhs.as_inner().x() * self.as_inner().xyz())
                + rhs.as_inner().t() * self.as_inner().yzt(),
            -(rhs.as_inner().x() * self.as_inner().xyt())
                + rhs.as_inner().z() * self.as_inner().yzt(),
            -(rhs.as_inner().x() * self.as_inner().xzt())
                + -(rhs.as_inner().y() * self.as_inner().yzt()),
        )
    }
}
impl<T: Float> WeightContract<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.s() * self.x(),
            rhs.s() * self.y(),
            rhs.s() * self.z(),
            rhs.s() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Scalar<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.s() * self.as_inner().x(),
            rhs.s() * self.as_inner().y(),
            rhs.s() * self.as_inner().z(),
            rhs.s() * self.as_inner().t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().s() * self.x(),
            rhs.as_inner().s() * self.y(),
            rhs.as_inner().s() * self.z(),
            rhs.as_inner().s() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().s() * self.as_inner().x(),
            rhs.as_inner().s() * self.as_inner().y(),
            rhs.as_inner().s() * self.as_inner().z(),
            rhs.as_inner().s() * self.as_inner().t(),
        )
    }
}
impl<T: Float> WeightContract<Vector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.x() * self.x())
                + -(rhs.y() * self.y())
                + -(rhs.z() * self.z())
                + rhs.t() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Vector<T>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.x() * self.as_inner().x())
                + -(rhs.y() * self.as_inner().y())
                + -(rhs.z() * self.as_inner().z())
                + rhs.t() * self.as_inner().t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Vector<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().x() * self.x())
                + -(rhs.as_inner().y() * self.y())
                + -(rhs.as_inner().z() * self.z())
                + rhs.as_inner().t() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(rhs.as_inner().x() * self.as_inner().x())
                + -(rhs.as_inner().y() * self.as_inner().y())
                + -(rhs.as_inner().z() * self.as_inner().z())
                + rhs.as_inner().t() * self.as_inner().t(),
        )
    }
}
impl<T: Float> BulkExpand<Bivector<T>> for Bivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.xt() * self.xt())
                + -(rhs.yt() * self.yt())
                + -(rhs.zt() * self.zt())
                + rhs.xy() * self.xy()
                + rhs.xz() * self.xz()
                + rhs.yz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.xt() * self.as_inner().xt())
                + -(rhs.yt() * self.as_inner().yt())
                + -(rhs.zt() * self.as_inner().zt())
                + rhs.xy() * self.as_inner().xy()
                + rhs.xz() * self.as_inner().xz()
                + rhs.yz() * self.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Bivector<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.as_inner().xt() * self.xt())
                + -(rhs.as_inner().yt() * self.yt())
                + -(rhs.as_inner().zt() * self.zt())
                + rhs.as_inner().xy() * self.xy()
                + rhs.as_inner().xz() * self.xz()
                + rhs.as_inner().yz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Bivector<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.as_inner().xt() * self.as_inner().xt())
                + -(rhs.as_inner().yt() * self.as_inner().yt())
                + -(rhs.as_inner().zt() * self.as_inner().zt())
                + rhs.as_inner().xy() * self.as_inner().xy()
                + rhs.as_inner().xz() * self.as_inner().xz()
                + rhs.as_inner().yz() * self.as_inner().yz(),
        )
    }
}
impl<T: Float> BulkExpand<Pseudoscalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Pseudoscalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.xyzt() * self.xy()),
            -(rhs.xyzt() * self.xz()),
            -(rhs.xyzt() * self.xt()),
            -(rhs.xyzt() * self.yz()),
            -(rhs.xyzt() * self.yt()),
            -(rhs.xyzt() * self.zt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Pseudoscalar<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Pseudoscalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.xyzt() * self.as_inner().xy()),
            -(rhs.xyzt() * self.as_inner().xz()),
            -(rhs.xyzt() * self.as_inner().xt()),
            -(rhs.xyzt() * self.as_inner().yz()),
            -(rhs.xyzt() * self.as_inner().yt()),
            -(rhs.xyzt() * self.as_inner().zt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Pseudoscalar<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().xyzt() * self.xy()),
            -(rhs.as_inner().xyzt() * self.xz()),
            -(rhs.as_inner().xyzt() * self.xt()),
            -(rhs.as_inner().xyzt() * self.yz()),
            -(rhs.as_inner().xyzt() * self.yt()),
            -(rhs.as_inner().xyzt() * self.zt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Pseudoscalar<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().xyzt() * self.as_inner().xy()),
            -(rhs.as_inner().xyzt() * self.as_inner().xz()),
            -(rhs.as_inner().xyzt() * self.as_inner().xt()),
            -(rhs.as_inner().xyzt() * self.as_inner().yz()),
            -(rhs.as_inner().xyzt() * self.as_inner().yt()),
            -(rhs.as_inner().xyzt() * self.as_inner().zt()),
        )
    }
}
impl<T: Float> BulkExpand<Trivector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.xyt() * self.xy() + rhs.xzt() * self.xz() + rhs.yzt() * self.yz(),
            rhs.xyz() * self.xy() + rhs.xzt() * self.xt() + rhs.yzt() * self.yt(),
            -(rhs.xyt() * self.xt()) + rhs.xyz() * self.xz() + rhs.yzt() * self.zt(),
            -(rhs.xyt() * self.yt()) + -(rhs.xzt() * self.zt()) + rhs.xyz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Trivector<T>> for Unit<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.xyt() * self.as_inner().xy()
                + rhs.xzt() * self.as_inner().xz()
                + rhs.yzt() * self.as_inner().yz(),
            rhs.xyz() * self.as_inner().xy()
                + rhs.xzt() * self.as_inner().xt()
                + rhs.yzt() * self.as_inner().yt(),
            -(rhs.xyt() * self.as_inner().xt())
                + rhs.xyz() * self.as_inner().xz()
                + rhs.yzt() * self.as_inner().zt(),
            -(rhs.xyt() * self.as_inner().yt())
                + -(rhs.xzt() * self.as_inner().zt())
                + rhs.xyz() * self.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Trivector<T>>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().xyt() * self.xy()
                + rhs.as_inner().xzt() * self.xz()
                + rhs.as_inner().yzt() * self.yz(),
            rhs.as_inner().xyz() * self.xy()
                + rhs.as_inner().xzt() * self.xt()
                + rhs.as_inner().yzt() * self.yt(),
            -(rhs.as_inner().xyt() * self.xt())
                + rhs.as_inner().xyz() * self.xz()
                + rhs.as_inner().yzt() * self.zt(),
            -(rhs.as_inner().xyt() * self.yt())
                + -(rhs.as_inner().xzt() * self.zt())
                + rhs.as_inner().xyz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Trivector<T>>> for Unit<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().xyt() * self.as_inner().xy()
                + rhs.as_inner().xzt() * self.as_inner().xz()
                + rhs.as_inner().yzt() * self.as_inner().yz(),
            rhs.as_inner().xyz() * self.as_inner().xy()
                + rhs.as_inner().xzt() * self.as_inner().xt()
                + rhs.as_inner().yzt() * self.as_inner().yt(),
            -(rhs.as_inner().xyt() * self.as_inner().xt())
                + rhs.as_inner().xyz() * self.as_inner().xz()
                + rhs.as_inner().yzt() * self.as_inner().zt(),
            -(rhs.as_inner().xyt() * self.as_inner().yt())
                + -(rhs.as_inner().xzt() * self.as_inner().zt())
                + rhs.as_inner().xyz() * self.as_inner().yz(),
        )
    }
}
impl<T: Float> BulkExpand<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(rhs.xyzt() * self.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(rhs.xyzt() * self.as_inner().xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(rhs.as_inner().xyzt() * self.xyzt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(rhs.as_inner().xyzt() * self.as_inner().xyzt()))
    }
}
impl<T: Float> BulkExpand<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.zt() * self.s()),
            rhs.yt() * self.s(),
            rhs.yz() * self.s(),
            -(rhs.xt() * self.s()),
            -(rhs.xz() * self.s()),
            rhs.xy() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Bivector<T>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.zt() * self.as_inner().s()),
            rhs.yt() * self.as_inner().s(),
            rhs.yz() * self.as_inner().s(),
            -(rhs.xt() * self.as_inner().s()),
            -(rhs.xz() * self.as_inner().s()),
            rhs.xy() * self.as_inner().s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Bivector<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().zt() * self.s()),
            rhs.as_inner().yt() * self.s(),
            rhs.as_inner().yz() * self.s(),
            -(rhs.as_inner().xt() * self.s()),
            -(rhs.as_inner().xz() * self.s()),
            rhs.as_inner().xy() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Bivector<T>>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().zt() * self.as_inner().s()),
            rhs.as_inner().yt() * self.as_inner().s(),
            rhs.as_inner().yz() * self.as_inner().s(),
            -(rhs.as_inner().xt() * self.as_inner().s()),
            -(rhs.as_inner().xz() * self.as_inner().s()),
            rhs.as_inner().xy() * self.as_inner().s(),
        )
    }
}
impl<T: Float> BulkExpand<Pseudoscalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.xyzt() * self.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Pseudoscalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.xyzt() * self.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Pseudoscalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().xyzt() * self.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Pseudoscalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(rhs.as_inner().xyzt() * self.as_inner().s()))
    }
}
impl<T: Float> BulkExpand<Scalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.s() * self.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().s() * self.as_inner().s())
    }
}
impl<T: Float> BulkExpand<Trivector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.yzt() * self.s(),
            -(rhs.xzt() * self.s()),
            rhs.xyt() * self.s(),
            rhs.xyz() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Trivector<T>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.yzt() * self.as_inner().s(),
            -(rhs.xzt() * self.as_inner().s()),
            rhs.xyt() * self.as_inner().s(),
            rhs.xyz() * self.as_inner().s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Trivector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().yzt() * self.s(),
            -(rhs.as_inner().xzt() * self.s()),
            rhs.as_inner().xyt() * self.s(),
            rhs.as_inner().xyz() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Trivector<T>>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().yzt() * self.as_inner().s(),
            -(rhs.as_inner().xzt() * self.as_inner().s()),
            rhs.as_inner().xyt() * self.as_inner().s(),
            rhs.as_inner().xyz() * self.as_inner().s(),
        )
    }
}
impl<T: Float> BulkExpand<Vector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.t() * self.s(),
            rhs.z() * self.s(),
            -(rhs.y() * self.s()),
            rhs.x() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Vector<T>> for Unit<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.t() * self.as_inner().s(),
            rhs.z() * self.as_inner().s(),
            -(rhs.y() * self.as_inner().s()),
            rhs.x() * self.as_inner().s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Vector<T>>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Vector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().t() * self.s(),
            rhs.as_inner().z() * self.s(),
            -(rhs.as_inner().y() * self.s()),
            rhs.as_inner().x() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Vector<T>>> for Unit<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Vector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().t() * self.as_inner().s(),
            rhs.as_inner().z() * self.as_inner().s(),
            -(rhs.as_inner().y() * self.as_inner().s()),
            rhs.as_inner().x() * self.as_inner().s(),
        )
    }
}
impl<T: Float> BulkExpand<Pseudoscalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Pseudoscalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.xyzt() * self.xyz()),
            -(rhs.xyzt() * self.xyt()),
            -(rhs.xyzt() * self.xzt()),
            -(rhs.xyzt() * self.yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Pseudoscalar<T>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Pseudoscalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.xyzt() * self.as_inner().xyz()),
            -(rhs.xyzt() * self.as_inner().xyt()),
            -(rhs.xyzt() * self.as_inner().xzt()),
            -(rhs.xyzt() * self.as_inner().yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Pseudoscalar<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().xyzt() * self.xyz()),
            -(rhs.as_inner().xyzt() * self.xyt()),
            -(rhs.as_inner().xyzt() * self.xzt()),
            -(rhs.as_inner().xyzt() * self.yzt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Pseudoscalar<T>>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().xyzt() * self.as_inner().xyz()),
            -(rhs.as_inner().xyzt() * self.as_inner().xyt()),
            -(rhs.as_inner().xyzt() * self.as_inner().xzt()),
            -(rhs.as_inner().xyzt() * self.as_inner().yzt()),
        )
    }
}
impl<T: Float> BulkExpand<Trivector<T>> for Trivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Trivector<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.xyt() * self.xyt())
                + -(rhs.xzt() * self.xzt())
                + -(rhs.yzt() * self.yzt())
                + rhs.xyz() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Trivector<T>> for Unit<Trivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Trivector<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.xyt() * self.as_inner().xyt())
                + -(rhs.xzt() * self.as_inner().xzt())
                + -(rhs.yzt() * self.as_inner().yzt())
                + rhs.xyz() * self.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Trivector<T>>> for Trivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Trivector<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.as_inner().xyt() * self.xyt())
                + -(rhs.as_inner().xzt() * self.xzt())
                + -(rhs.as_inner().yzt() * self.yzt())
                + rhs.as_inner().xyz() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Trivector<T>>> for Unit<Trivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Trivector<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.as_inner().xyt() * self.as_inner().xyt())
                + -(rhs.as_inner().xzt() * self.as_inner().xzt())
                + -(rhs.as_inner().yzt() * self.as_inner().yzt())
                + rhs.as_inner().xyz() * self.as_inner().xyz(),
        )
    }
}
impl<T: Float> BulkExpand<Bivector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.xt() * self.x()) + -(rhs.yt() * self.y()) + -(rhs.zt() * self.z()),
            -(rhs.xz() * self.x()) + -(rhs.yz() * self.y()) + -(rhs.zt() * self.t()),
            -(rhs.yz() * self.z()) + rhs.xy() * self.x() + rhs.yt() * self.t(),
            -(rhs.xt() * self.t()) + rhs.xy() * self.y() + rhs.xz() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Bivector<T>> for Unit<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.xt() * self.as_inner().x())
                + -(rhs.yt() * self.as_inner().y())
                + -(rhs.zt() * self.as_inner().z()),
            -(rhs.xz() * self.as_inner().x())
                + -(rhs.yz() * self.as_inner().y())
                + -(rhs.zt() * self.as_inner().t()),
            -(rhs.yz() * self.as_inner().z())
                + rhs.xy() * self.as_inner().x()
                + rhs.yt() * self.as_inner().t(),
            -(rhs.xt() * self.as_inner().t())
                + rhs.xy() * self.as_inner().y()
                + rhs.xz() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Bivector<T>>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Bivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().xt() * self.x())
                + -(rhs.as_inner().yt() * self.y())
                + -(rhs.as_inner().zt() * self.z()),
            -(rhs.as_inner().xz() * self.x())
                + -(rhs.as_inner().yz() * self.y())
                + -(rhs.as_inner().zt() * self.t()),
            -(rhs.as_inner().yz() * self.z())
                + rhs.as_inner().xy() * self.x()
                + rhs.as_inner().yt() * self.t(),
            -(rhs.as_inner().xt() * self.t())
                + rhs.as_inner().xy() * self.y()
                + rhs.as_inner().xz() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Bivector<T>>> for Unit<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Bivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().xt() * self.as_inner().x())
                + -(rhs.as_inner().yt() * self.as_inner().y())
                + -(rhs.as_inner().zt() * self.as_inner().z()),
            -(rhs.as_inner().xz() * self.as_inner().x())
                + -(rhs.as_inner().yz() * self.as_inner().y())
                + -(rhs.as_inner().zt() * self.as_inner().t()),
            -(rhs.as_inner().yz() * self.as_inner().z())
                + rhs.as_inner().xy() * self.as_inner().x()
                + rhs.as_inner().yt() * self.as_inner().t(),
            -(rhs.as_inner().xt() * self.as_inner().t())
                + rhs.as_inner().xy() * self.as_inner().y()
                + rhs.as_inner().xz() * self.as_inner().z(),
        )
    }
}
impl<T: Float> BulkExpand<Pseudoscalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Pseudoscalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.xyzt() * self.x()),
            -(rhs.xyzt() * self.y()),
            -(rhs.xyzt() * self.z()),
            -(rhs.xyzt() * self.t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Pseudoscalar<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Pseudoscalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.xyzt() * self.as_inner().x()),
            -(rhs.xyzt() * self.as_inner().y()),
            -(rhs.xyzt() * self.as_inner().z()),
            -(rhs.xyzt() * self.as_inner().t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Pseudoscalar<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().xyzt() * self.x()),
            -(rhs.as_inner().xyzt() * self.y()),
            -(rhs.as_inner().xyzt() * self.z()),
            -(rhs.as_inner().xyzt() * self.t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Pseudoscalar<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().xyzt() * self.as_inner().x()),
            -(rhs.as_inner().xyzt() * self.as_inner().y()),
            -(rhs.as_inner().xyzt() * self.as_inner().z()),
            -(rhs.as_inner().xyzt() * self.as_inner().t()),
        )
    }
}
impl<T: Float> BulkExpand<Trivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Trivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.xzt() * self.x()) + -(rhs.yzt() * self.y()),
            -(rhs.yzt() * self.z()) + rhs.xyt() * self.x(),
            -(rhs.yzt() * self.t()) + rhs.xyz() * self.x(),
            rhs.xyt() * self.y() + rhs.xzt() * self.z(),
            rhs.xyz() * self.y() + rhs.xzt() * self.t(),
            -(rhs.xyt() * self.t()) + rhs.xyz() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Trivector<T>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Trivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.xzt() * self.as_inner().x()) + -(rhs.yzt() * self.as_inner().y()),
            -(rhs.yzt() * self.as_inner().z()) + rhs.xyt() * self.as_inner().x(),
            -(rhs.yzt() * self.as_inner().t()) + rhs.xyz() * self.as_inner().x(),
            rhs.xyt() * self.as_inner().y() + rhs.xzt() * self.as_inner().z(),
            rhs.xyz() * self.as_inner().y() + rhs.xzt() * self.as_inner().t(),
            -(rhs.xyt() * self.as_inner().t()) + rhs.xyz() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Trivector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Trivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().xzt() * self.x()) + -(rhs.as_inner().yzt() * self.y()),
            -(rhs.as_inner().yzt() * self.z()) + rhs.as_inner().xyt() * self.x(),
            -(rhs.as_inner().yzt() * self.t()) + rhs.as_inner().xyz() * self.x(),
            rhs.as_inner().xyt() * self.y() + rhs.as_inner().xzt() * self.z(),
            rhs.as_inner().xyz() * self.y() + rhs.as_inner().xzt() * self.t(),
            -(rhs.as_inner().xyt() * self.t()) + rhs.as_inner().xyz() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Trivector<T>>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Trivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(rhs.as_inner().xzt() * self.as_inner().x())
                + -(rhs.as_inner().yzt() * self.as_inner().y()),
            -(rhs.as_inner().yzt() * self.as_inner().z())
                + rhs.as_inner().xyt() * self.as_inner().x(),
            -(rhs.as_inner().yzt() * self.as_inner().t())
                + rhs.as_inner().xyz() * self.as_inner().x(),
            rhs.as_inner().xyt() * self.as_inner().y() + rhs.as_inner().xzt() * self.as_inner().z(),
            rhs.as_inner().xyz() * self.as_inner().y() + rhs.as_inner().xzt() * self.as_inner().t(),
            -(rhs.as_inner().xyt() * self.as_inner().t())
                + rhs.as_inner().xyz() * self.as_inner().z(),
        )
    }
}
impl<T: Float> BulkExpand<Vector<T>> for Vector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Vector<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.t() * self.t()) + rhs.x() * self.x() + rhs.y() * self.y() + rhs.z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Vector<T>> for Unit<Vector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Vector<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.t() * self.as_inner().t())
                + rhs.x() * self.as_inner().x()
                + rhs.y() * self.as_inner().y()
                + rhs.z() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Vector<T>>> for Vector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Vector<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.as_inner().t() * self.t())
                + rhs.as_inner().x() * self.x()
                + rhs.as_inner().y() * self.y()
                + rhs.as_inner().z() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Vector<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.as_inner().t() * self.as_inner().t())
                + rhs.as_inner().x() * self.as_inner().x()
                + rhs.as_inner().y() * self.as_inner().y()
                + rhs.as_inner().z() * self.as_inner().z(),
        )
    }
}
impl<T: Float> WeightExpand<Bivector<T>> for Bivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.xy() * self.xy())
                + -(rhs.xz() * self.xz())
                + -(rhs.yz() * self.yz())
                + rhs.xt() * self.xt()
                + rhs.yt() * self.yt()
                + rhs.zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.xy() * self.as_inner().xy())
                + -(rhs.xz() * self.as_inner().xz())
                + -(rhs.yz() * self.as_inner().yz())
                + rhs.xt() * self.as_inner().xt()
                + rhs.yt() * self.as_inner().yt()
                + rhs.zt() * self.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Bivector<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.as_inner().xy() * self.xy())
                + -(rhs.as_inner().xz() * self.xz())
                + -(rhs.as_inner().yz() * self.yz())
                + rhs.as_inner().xt() * self.xt()
                + rhs.as_inner().yt() * self.yt()
                + rhs.as_inner().zt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Bivector<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.as_inner().xy() * self.as_inner().xy())
                + -(rhs.as_inner().xz() * self.as_inner().xz())
                + -(rhs.as_inner().yz() * self.as_inner().yz())
                + rhs.as_inner().xt() * self.as_inner().xt()
                + rhs.as_inner().yt() * self.as_inner().yt()
                + rhs.as_inner().zt() * self.as_inner().zt(),
        )
    }
}
impl<T: Float> WeightExpand<Pseudoscalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Pseudoscalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.xyzt() * self.xy(),
            rhs.xyzt() * self.xz(),
            rhs.xyzt() * self.xt(),
            rhs.xyzt() * self.yz(),
            rhs.xyzt() * self.yt(),
            rhs.xyzt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Pseudoscalar<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Pseudoscalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.xyzt() * self.as_inner().xy(),
            rhs.xyzt() * self.as_inner().xz(),
            rhs.xyzt() * self.as_inner().xt(),
            rhs.xyzt() * self.as_inner().yz(),
            rhs.xyzt() * self.as_inner().yt(),
            rhs.xyzt() * self.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Pseudoscalar<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().xyzt() * self.xy(),
            rhs.as_inner().xyzt() * self.xz(),
            rhs.as_inner().xyzt() * self.xt(),
            rhs.as_inner().xyzt() * self.yz(),
            rhs.as_inner().xyzt() * self.yt(),
            rhs.as_inner().xyzt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Pseudoscalar<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().xyzt() * self.as_inner().xy(),
            rhs.as_inner().xyzt() * self.as_inner().xz(),
            rhs.as_inner().xyzt() * self.as_inner().xt(),
            rhs.as_inner().xyzt() * self.as_inner().yz(),
            rhs.as_inner().xyzt() * self.as_inner().yt(),
            rhs.as_inner().xyzt() * self.as_inner().zt(),
        )
    }
}
impl<T: Float> WeightExpand<Trivector<T>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.xyt() * self.xy()) + -(rhs.xzt() * self.xz()) + -(rhs.yzt() * self.yz()),
            -(rhs.xyz() * self.xy()) + -(rhs.xzt() * self.xt()) + -(rhs.yzt() * self.yt()),
            -(rhs.xyz() * self.xz()) + -(rhs.yzt() * self.zt()) + rhs.xyt() * self.xt(),
            -(rhs.xyz() * self.yz()) + rhs.xyt() * self.yt() + rhs.xzt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Trivector<T>> for Unit<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.xyt() * self.as_inner().xy())
                + -(rhs.xzt() * self.as_inner().xz())
                + -(rhs.yzt() * self.as_inner().yz()),
            -(rhs.xyz() * self.as_inner().xy())
                + -(rhs.xzt() * self.as_inner().xt())
                + -(rhs.yzt() * self.as_inner().yt()),
            -(rhs.xyz() * self.as_inner().xz())
                + -(rhs.yzt() * self.as_inner().zt())
                + rhs.xyt() * self.as_inner().xt(),
            -(rhs.xyz() * self.as_inner().yz())
                + rhs.xyt() * self.as_inner().yt()
                + rhs.xzt() * self.as_inner().zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Trivector<T>>> for Bivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().xyt() * self.xy())
                + -(rhs.as_inner().xzt() * self.xz())
                + -(rhs.as_inner().yzt() * self.yz()),
            -(rhs.as_inner().xyz() * self.xy())
                + -(rhs.as_inner().xzt() * self.xt())
                + -(rhs.as_inner().yzt() * self.yt()),
            -(rhs.as_inner().xyz() * self.xz())
                + -(rhs.as_inner().yzt() * self.zt())
                + rhs.as_inner().xyt() * self.xt(),
            -(rhs.as_inner().xyz() * self.yz())
                + rhs.as_inner().xyt() * self.yt()
                + rhs.as_inner().xzt() * self.zt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Trivector<T>>> for Unit<Bivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Trivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().xyt() * self.as_inner().xy())
                + -(rhs.as_inner().xzt() * self.as_inner().xz())
                + -(rhs.as_inner().yzt() * self.as_inner().yz()),
            -(rhs.as_inner().xyz() * self.as_inner().xy())
                + -(rhs.as_inner().xzt() * self.as_inner().xt())
                + -(rhs.as_inner().yzt() * self.as_inner().yt()),
            -(rhs.as_inner().xyz() * self.as_inner().xz())
                + -(rhs.as_inner().yzt() * self.as_inner().zt())
                + rhs.as_inner().xyt() * self.as_inner().xt(),
            -(rhs.as_inner().xyz() * self.as_inner().yz())
                + rhs.as_inner().xyt() * self.as_inner().yt()
                + rhs.as_inner().xzt() * self.as_inner().zt(),
        )
    }
}
impl<T: Float> WeightExpand<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.xyzt() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.xyzt() * self.as_inner().xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().xyzt() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().xyzt() * self.as_inner().xyzt())
    }
}
impl<T: Float> WeightExpand<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.zt() * self.s(),
            -(rhs.yt() * self.s()),
            -(rhs.yz() * self.s()),
            rhs.xt() * self.s(),
            rhs.xz() * self.s(),
            -(rhs.xy() * self.s()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Bivector<T>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.zt() * self.as_inner().s(),
            -(rhs.yt() * self.as_inner().s()),
            -(rhs.yz() * self.as_inner().s()),
            rhs.xt() * self.as_inner().s(),
            rhs.xz() * self.as_inner().s(),
            -(rhs.xy() * self.as_inner().s()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Bivector<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().zt() * self.s(),
            -(rhs.as_inner().yt() * self.s()),
            -(rhs.as_inner().yz() * self.s()),
            rhs.as_inner().xt() * self.s(),
            rhs.as_inner().xz() * self.s(),
            -(rhs.as_inner().xy() * self.s()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Bivector<T>>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().zt() * self.as_inner().s(),
            -(rhs.as_inner().yt() * self.as_inner().s()),
            -(rhs.as_inner().yz() * self.as_inner().s()),
            rhs.as_inner().xt() * self.as_inner().s(),
            rhs.as_inner().xz() * self.as_inner().s(),
            -(rhs.as_inner().xy() * self.as_inner().s()),
        )
    }
}
impl<T: Float> WeightExpand<Pseudoscalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.xyzt() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Pseudoscalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.xyzt() * self.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Pseudoscalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().xyzt() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Pseudoscalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().xyzt() * self.as_inner().s())
    }
}
impl<T: Float> WeightExpand<Scalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(rhs.s() * self.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(rhs.s() * self.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(rhs.as_inner().s() * self.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(rhs.as_inner().s() * self.as_inner().s()))
    }
}
impl<T: Float> WeightExpand<Trivector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.yzt() * self.s()),
            rhs.xzt() * self.s(),
            -(rhs.xyt() * self.s()),
            -(rhs.xyz() * self.s()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Trivector<T>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.yzt() * self.as_inner().s()),
            rhs.xzt() * self.as_inner().s(),
            -(rhs.xyt() * self.as_inner().s()),
            -(rhs.xyz() * self.as_inner().s()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Trivector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().yzt() * self.s()),
            rhs.as_inner().xzt() * self.s(),
            -(rhs.as_inner().xyt() * self.s()),
            -(rhs.as_inner().xyz() * self.s()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Trivector<T>>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Trivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().yzt() * self.as_inner().s()),
            rhs.as_inner().xzt() * self.as_inner().s(),
            -(rhs.as_inner().xyt() * self.as_inner().s()),
            -(rhs.as_inner().xyz() * self.as_inner().s()),
        )
    }
}
impl<T: Float> WeightExpand<Vector<T>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.t() * self.s()),
            -(rhs.z() * self.s()),
            rhs.y() * self.s(),
            -(rhs.x() * self.s()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Vector<T>> for Unit<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Vector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.t() * self.as_inner().s()),
            -(rhs.z() * self.as_inner().s()),
            rhs.y() * self.as_inner().s(),
            -(rhs.x() * self.as_inner().s()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Vector<T>>> for Scalar<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Vector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().t() * self.s()),
            -(rhs.as_inner().z() * self.s()),
            rhs.as_inner().y() * self.s(),
            -(rhs.as_inner().x() * self.s()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Vector<T>>> for Unit<Scalar<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Vector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            -(rhs.as_inner().t() * self.as_inner().s()),
            -(rhs.as_inner().z() * self.as_inner().s()),
            rhs.as_inner().y() * self.as_inner().s(),
            -(rhs.as_inner().x() * self.as_inner().s()),
        )
    }
}
impl<T: Float> WeightExpand<Pseudoscalar<T>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Pseudoscalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.xyzt() * self.xyz(),
            rhs.xyzt() * self.xyt(),
            rhs.xyzt() * self.xzt(),
            rhs.xyzt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Pseudoscalar<T>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Pseudoscalar<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.xyzt() * self.as_inner().xyz(),
            rhs.xyzt() * self.as_inner().xyt(),
            rhs.xyzt() * self.as_inner().xzt(),
            rhs.xyzt() * self.as_inner().yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Pseudoscalar<T>>> for Trivector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().xyzt() * self.xyz(),
            rhs.as_inner().xyzt() * self.xyt(),
            rhs.as_inner().xyzt() * self.xzt(),
            rhs.as_inner().xyzt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Pseudoscalar<T>>> for Unit<Trivector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().xyzt() * self.as_inner().xyz(),
            rhs.as_inner().xyzt() * self.as_inner().xyt(),
            rhs.as_inner().xyzt() * self.as_inner().xzt(),
            rhs.as_inner().xyzt() * self.as_inner().yzt(),
        )
    }
}
impl<T: Float> WeightExpand<Trivector<T>> for Trivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.xyz() * self.xyz())
                + rhs.xyt() * self.xyt()
                + rhs.xzt() * self.xzt()
                + rhs.yzt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Trivector<T>> for Unit<Trivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.xyz() * self.as_inner().xyz())
                + rhs.xyt() * self.as_inner().xyt()
                + rhs.xzt() * self.as_inner().xzt()
                + rhs.yzt() * self.as_inner().yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Trivector<T>>> for Trivector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Trivector<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.as_inner().xyz() * self.xyz())
                + rhs.as_inner().xyt() * self.xyt()
                + rhs.as_inner().xzt() * self.xzt()
                + rhs.as_inner().yzt() * self.yzt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Trivector<T>>> for Unit<Trivector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Trivector<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.as_inner().xyz() * self.as_inner().xyz())
                + rhs.as_inner().xyt() * self.as_inner().xyt()
                + rhs.as_inner().xzt() * self.as_inner().xzt()
                + rhs.as_inner().yzt() * self.as_inner().yzt(),
        )
    }
}
impl<T: Float> WeightExpand<Bivector<T>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.xt() * self.x() + rhs.yt() * self.y() + rhs.zt() * self.z(),
            rhs.xz() * self.x() + rhs.yz() * self.y() + rhs.zt() * self.t(),
            -(rhs.xy() * self.x()) + -(rhs.yt() * self.t()) + rhs.yz() * self.z(),
            -(rhs.xy() * self.y()) + -(rhs.xz() * self.z()) + rhs.xt() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Bivector<T>> for Unit<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.xt() * self.as_inner().x()
                + rhs.yt() * self.as_inner().y()
                + rhs.zt() * self.as_inner().z(),
            rhs.xz() * self.as_inner().x()
                + rhs.yz() * self.as_inner().y()
                + rhs.zt() * self.as_inner().t(),
            -(rhs.xy() * self.as_inner().x())
                + -(rhs.yt() * self.as_inner().t())
                + rhs.yz() * self.as_inner().z(),
            -(rhs.xy() * self.as_inner().y())
                + -(rhs.xz() * self.as_inner().z())
                + rhs.xt() * self.as_inner().t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Bivector<T>>> for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Bivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().xt() * self.x()
                + rhs.as_inner().yt() * self.y()
                + rhs.as_inner().zt() * self.z(),
            rhs.as_inner().xz() * self.x()
                + rhs.as_inner().yz() * self.y()
                + rhs.as_inner().zt() * self.t(),
            -(rhs.as_inner().xy() * self.x())
                + -(rhs.as_inner().yt() * self.t())
                + rhs.as_inner().yz() * self.z(),
            -(rhs.as_inner().xy() * self.y())
                + -(rhs.as_inner().xz() * self.z())
                + rhs.as_inner().xt() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Bivector<T>>> for Unit<Vector<T>> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Bivector<T>>) -> Trivector<T> {
        Trivector::new_unchecked(
            rhs.as_inner().xt() * self.as_inner().x()
                + rhs.as_inner().yt() * self.as_inner().y()
                + rhs.as_inner().zt() * self.as_inner().z(),
            rhs.as_inner().xz() * self.as_inner().x()
                + rhs.as_inner().yz() * self.as_inner().y()
                + rhs.as_inner().zt() * self.as_inner().t(),
            -(rhs.as_inner().xy() * self.as_inner().x())
                + -(rhs.as_inner().yt() * self.as_inner().t())
                + rhs.as_inner().yz() * self.as_inner().z(),
            -(rhs.as_inner().xy() * self.as_inner().y())
                + -(rhs.as_inner().xz() * self.as_inner().z())
                + rhs.as_inner().xt() * self.as_inner().t(),
        )
    }
}
impl<T: Float> WeightExpand<Pseudoscalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Pseudoscalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.xyzt() * self.x(),
            rhs.xyzt() * self.y(),
            rhs.xyzt() * self.z(),
            rhs.xyzt() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Pseudoscalar<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Pseudoscalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.xyzt() * self.as_inner().x(),
            rhs.xyzt() * self.as_inner().y(),
            rhs.xyzt() * self.as_inner().z(),
            rhs.xyzt() * self.as_inner().t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Pseudoscalar<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().xyzt() * self.x(),
            rhs.as_inner().xyzt() * self.y(),
            rhs.as_inner().xyzt() * self.z(),
            rhs.as_inner().xyzt() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Pseudoscalar<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            rhs.as_inner().xyzt() * self.as_inner().x(),
            rhs.as_inner().xyzt() * self.as_inner().y(),
            rhs.as_inner().xyzt() * self.as_inner().z(),
            rhs.as_inner().xyzt() * self.as_inner().t(),
        )
    }
}
impl<T: Float> WeightExpand<Trivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.xzt() * self.x() + rhs.yzt() * self.y(),
            -(rhs.xyt() * self.x()) + rhs.yzt() * self.z(),
            -(rhs.xyz() * self.x()) + rhs.yzt() * self.t(),
            -(rhs.xyt() * self.y()) + -(rhs.xzt() * self.z()),
            -(rhs.xyz() * self.y()) + -(rhs.xzt() * self.t()),
            -(rhs.xyz() * self.z()) + rhs.xyt() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Trivector<T>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Trivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.xzt() * self.as_inner().x() + rhs.yzt() * self.as_inner().y(),
            -(rhs.xyt() * self.as_inner().x()) + rhs.yzt() * self.as_inner().z(),
            -(rhs.xyz() * self.as_inner().x()) + rhs.yzt() * self.as_inner().t(),
            -(rhs.xyt() * self.as_inner().y()) + -(rhs.xzt() * self.as_inner().z()),
            -(rhs.xyz() * self.as_inner().y()) + -(rhs.xzt() * self.as_inner().t()),
            -(rhs.xyz() * self.as_inner().z()) + rhs.xyt() * self.as_inner().t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Trivector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Trivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().xzt() * self.x() + rhs.as_inner().yzt() * self.y(),
            -(rhs.as_inner().xyt() * self.x()) + rhs.as_inner().yzt() * self.z(),
            -(rhs.as_inner().xyz() * self.x()) + rhs.as_inner().yzt() * self.t(),
            -(rhs.as_inner().xyt() * self.y()) + -(rhs.as_inner().xzt() * self.z()),
            -(rhs.as_inner().xyz() * self.y()) + -(rhs.as_inner().xzt() * self.t()),
            -(rhs.as_inner().xyz() * self.z()) + rhs.as_inner().xyt() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Trivector<T>>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Trivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            rhs.as_inner().xzt() * self.as_inner().x() + rhs.as_inner().yzt() * self.as_inner().y(),
            -(rhs.as_inner().xyt() * self.as_inner().x())
                + rhs.as_inner().yzt() * self.as_inner().z(),
            -(rhs.as_inner().xyz() * self.as_inner().x())
                + rhs.as_inner().yzt() * self.as_inner().t(),
            -(rhs.as_inner().xyt() * self.as_inner().y())
                + -(rhs.as_inner().xzt() * self.as_inner().z()),
            -(rhs.as_inner().xyz() * self.as_inner().y())
                + -(rhs.as_inner().xzt() * self.as_inner().t()),
            -(rhs.as_inner().xyz() * self.as_inner().z())
                + rhs.as_inner().xyt() * self.as_inner().t(),
        )
    }
}
impl<T: Float> WeightExpand<Vector<T>> for Vector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Vector<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.x() * self.x())
                + -(rhs.y() * self.y())
                + -(rhs.z() * self.z())
                + rhs.t() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Vector<T>> for Unit<Vector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Vector<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.x() * self.as_inner().x())
                + -(rhs.y() * self.as_inner().y())
                + -(rhs.z() * self.as_inner().z())
                + rhs.t() * self.as_inner().t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Vector<T>>> for Vector<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Vector<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.as_inner().x() * self.x())
                + -(rhs.as_inner().y() * self.y())
                + -(rhs.as_inner().z() * self.z())
                + rhs.as_inner().t() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Vector<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(rhs.as_inner().x() * self.as_inner().x())
                + -(rhs.as_inner().y() * self.as_inner().y())
                + -(rhs.as_inner().z() * self.as_inner().z())
                + rhs.as_inner().t() * self.as_inner().t(),
        )
    }
}
impl<T: Float> Dot<Bivector<T>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Bivector<T>) -> T {
        -(self.xy() * rhs.xy()) - self.xz() * rhs.xz() + self.xt() * rhs.xt() - self.yz() * rhs.yz()
            + self.yt() * rhs.yt()
            + self.zt() * rhs.zt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Bivector<T>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Bivector<T>) -> T {
        -(rhs.xy() * self.as_inner().xy())
            + -(rhs.xz() * self.as_inner().xz())
            + -(rhs.yz() * self.as_inner().yz())
            + rhs.xt() * self.as_inner().xt()
            + rhs.yt() * self.as_inner().yt()
            + rhs.zt() * self.as_inner().zt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Bivector<T>>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Bivector<T>>) -> T {
        -(rhs.as_inner().xy() * self.xy())
            + -(rhs.as_inner().xz() * self.xz())
            + -(rhs.as_inner().yz() * self.yz())
            + rhs.as_inner().xt() * self.xt()
            + rhs.as_inner().yt() * self.yt()
            + rhs.as_inner().zt() * self.zt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Bivector<T>>) -> T {
        -(rhs.as_inner().xy() * self.as_inner().xy())
            + -(rhs.as_inner().xz() * self.as_inner().xz())
            + -(rhs.as_inner().yz() * self.as_inner().yz())
            + rhs.as_inner().xt() * self.as_inner().xt()
            + rhs.as_inner().yt() * self.as_inner().yt()
            + rhs.as_inner().zt() * self.as_inner().zt()
    }
}
impl<T: Float> Dot<Eventor<T>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Eventor<T>) -> T {
        -(self.xy() * rhs.xy()) - self.xz() * rhs.xz() + self.xt() * rhs.xt() - self.yz() * rhs.yz()
            + self.yt() * rhs.yt()
            + self.zt() * rhs.zt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Eventor<T>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Eventor<T>) -> T {
        -(rhs.xy() * self.as_inner().xy())
            + -(rhs.xz() * self.as_inner().xz())
            + -(rhs.yz() * self.as_inner().yz())
            + rhs.xt() * self.as_inner().xt()
            + rhs.yt() * self.as_inner().yt()
            + rhs.zt() * self.as_inner().zt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Eventor<T>>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Eventor<T>>) -> T {
        -(rhs.as_inner().xy() * self.xy())
            + -(rhs.as_inner().xz() * self.xz())
            + -(rhs.as_inner().yz() * self.yz())
            + rhs.as_inner().xt() * self.xt()
            + rhs.as_inner().yt() * self.yt()
            + rhs.as_inner().zt() * self.zt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Eventor<T>>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Eventor<T>>) -> T {
        -(rhs.as_inner().xy() * self.as_inner().xy())
            + -(rhs.as_inner().xz() * self.as_inner().xz())
            + -(rhs.as_inner().yz() * self.as_inner().yz())
            + rhs.as_inner().xt() * self.as_inner().xt()
            + rhs.as_inner().yt() * self.as_inner().yt()
            + rhs.as_inner().zt() * self.as_inner().zt()
    }
}
impl<T: Float> Dot<Bivector<T>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Bivector<T>) -> T {
        -(self.xy() * rhs.xy()) - self.xz() * rhs.xz() + self.xt() * rhs.xt() - self.yz() * rhs.yz()
            + self.yt() * rhs.yt()
            + self.zt() * rhs.zt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Bivector<T>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Bivector<T>) -> T {
        -(rhs.xy() * self.as_inner().xy())
            + -(rhs.xz() * self.as_inner().xz())
            + -(rhs.yz() * self.as_inner().yz())
            + rhs.xt() * self.as_inner().xt()
            + rhs.yt() * self.as_inner().yt()
            + rhs.zt() * self.as_inner().zt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Bivector<T>>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Bivector<T>>) -> T {
        -(rhs.as_inner().xy() * self.xy())
            + -(rhs.as_inner().xz() * self.xz())
            + -(rhs.as_inner().yz() * self.yz())
            + rhs.as_inner().xt() * self.xt()
            + rhs.as_inner().yt() * self.yt()
            + rhs.as_inner().zt() * self.zt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Bivector<T>>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Bivector<T>>) -> T {
        -(rhs.as_inner().xy() * self.as_inner().xy())
            + -(rhs.as_inner().xz() * self.as_inner().xz())
            + -(rhs.as_inner().yz() * self.as_inner().yz())
            + rhs.as_inner().xt() * self.as_inner().xt()
            + rhs.as_inner().yt() * self.as_inner().yt()
            + rhs.as_inner().zt() * self.as_inner().zt()
    }
}
impl<T: Float> Dot<Eventor<T>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Eventor<T>) -> T {
        self.s() * rhs.s() - self.xy() * rhs.xy() - self.xz() * rhs.xz() + self.xt() * rhs.xt()
            - self.yz() * rhs.yz()
            + self.yt() * rhs.yt()
            + self.zt() * rhs.zt()
            - self.xyzt() * rhs.xyzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Eventor<T>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Eventor<T>) -> T {
        -(rhs.xy() * self.as_inner().xy())
            + -(rhs.xyzt() * self.as_inner().xyzt())
            + -(rhs.xz() * self.as_inner().xz())
            + -(rhs.yz() * self.as_inner().yz())
            + rhs.s() * self.as_inner().s()
            + rhs.xt() * self.as_inner().xt()
            + rhs.yt() * self.as_inner().yt()
            + rhs.zt() * self.as_inner().zt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Eventor<T>>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Eventor<T>>) -> T {
        -(rhs.as_inner().xy() * self.xy())
            + -(rhs.as_inner().xyzt() * self.xyzt())
            + -(rhs.as_inner().xz() * self.xz())
            + -(rhs.as_inner().yz() * self.yz())
            + rhs.as_inner().s() * self.s()
            + rhs.as_inner().xt() * self.xt()
            + rhs.as_inner().yt() * self.yt()
            + rhs.as_inner().zt() * self.zt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Eventor<T>>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Eventor<T>>) -> T {
        -(rhs.as_inner().xy() * self.as_inner().xy())
            + -(rhs.as_inner().xyzt() * self.as_inner().xyzt())
            + -(rhs.as_inner().xz() * self.as_inner().xz())
            + -(rhs.as_inner().yz() * self.as_inner().yz())
            + rhs.as_inner().s() * self.as_inner().s()
            + rhs.as_inner().xt() * self.as_inner().xt()
            + rhs.as_inner().yt() * self.as_inner().yt()
            + rhs.as_inner().zt() * self.as_inner().zt()
    }
}
impl<T: Float> Dot<Pseudoscalar<T>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Pseudoscalar<T>) -> T {
        -(self.xyzt() * rhs.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Pseudoscalar<T>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Pseudoscalar<T>) -> T {
        -(rhs.xyzt() * self.as_inner().xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Pseudoscalar<T>>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Pseudoscalar<T>>) -> T {
        -(rhs.as_inner().xyzt() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Pseudoscalar<T>>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Pseudoscalar<T>>) -> T {
        -(rhs.as_inner().xyzt() * self.as_inner().xyzt())
    }
}
impl<T: Float> Dot<Scalar<T>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Scalar<T>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        rhs.s() * self.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Scalar<T>>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Scalar<T>>) -> T {
        rhs.as_inner().s() * self.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Scalar<T>>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Scalar<T>>) -> T {
        rhs.as_inner().s() * self.as_inner().s()
    }
}
impl<T: Float> Dot<Eventor<T>> for Pseudoscalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Eventor<T>) -> T {
        -(self.xyzt() * rhs.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Eventor<T>> for Unit<Pseudoscalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Eventor<T>) -> T {
        -(rhs.xyzt() * self.as_inner().xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Eventor<T>>> for Pseudoscalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Eventor<T>>) -> T {
        -(rhs.as_inner().xyzt() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Eventor<T>>> for Unit<Pseudoscalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Eventor<T>>) -> T {
        -(rhs.as_inner().xyzt() * self.as_inner().xyzt())
    }
}
impl<T: Float> Dot<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Pseudoscalar<T>) -> T {
        -(self.xyzt() * rhs.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Pseudoscalar<T>) -> T {
        -(rhs.xyzt() * self.as_inner().xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Pseudoscalar<T>>) -> T {
        -(rhs.as_inner().xyzt() * self.xyzt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Pseudoscalar<T>>) -> T {
        -(rhs.as_inner().xyzt() * self.as_inner().xyzt())
    }
}
impl<T: Float> Dot<Eventor<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Eventor<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Eventor<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Eventor<T>) -> T {
        rhs.s() * self.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Eventor<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Eventor<T>>) -> T {
        rhs.as_inner().s() * self.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Eventor<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Eventor<T>>) -> T {
        rhs.as_inner().s() * self.as_inner().s()
    }
}
impl<T: Float> Dot<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Scalar<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        rhs.s() * self.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Scalar<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Scalar<T>>) -> T {
        rhs.as_inner().s() * self.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Scalar<T>>) -> T {
        rhs.as_inner().s() * self.as_inner().s()
    }
}
impl<T: Float> Dot<Trivector<T>> for Trivector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Trivector<T>) -> T {
        -(self.xyz() * rhs.xyz())
            + self.xyt() * rhs.xyt()
            + self.xzt() * rhs.xzt()
            + self.yzt() * rhs.yzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Trivector<T>> for Unit<Trivector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Trivector<T>) -> T {
        -(rhs.xyz() * self.as_inner().xyz())
            + rhs.xyt() * self.as_inner().xyt()
            + rhs.xzt() * self.as_inner().xzt()
            + rhs.yzt() * self.as_inner().yzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Trivector<T>>> for Trivector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Trivector<T>>) -> T {
        -(rhs.as_inner().xyz() * self.xyz())
            + rhs.as_inner().xyt() * self.xyt()
            + rhs.as_inner().xzt() * self.xzt()
            + rhs.as_inner().yzt() * self.yzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Trivector<T>>> for Unit<Trivector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Trivector<T>>) -> T {
        -(rhs.as_inner().xyz() * self.as_inner().xyz())
            + rhs.as_inner().xyt() * self.as_inner().xyt()
            + rhs.as_inner().xzt() * self.as_inner().xzt()
            + rhs.as_inner().yzt() * self.as_inner().yzt()
    }
}
impl<T: Float> Dot<Vector<T>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Vector<T>) -> T {
        self.x() * rhs.x() + self.y() * rhs.y() + self.z() * rhs.z() - self.t() * rhs.t()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Vector<T>> for Unit<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Vector<T>) -> T {
        -(rhs.t() * self.as_inner().t())
            + rhs.x() * self.as_inner().x()
            + rhs.y() * self.as_inner().y()
            + rhs.z() * self.as_inner().z()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Vector<T>>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Vector<T>>) -> T {
        -(rhs.as_inner().t() * self.t())
            + rhs.as_inner().x() * self.x()
            + rhs.as_inner().y() * self.y()
            + rhs.as_inner().z() * self.z()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Vector<T>>) -> T {
        -(rhs.as_inner().t() * self.as_inner().t())
            + rhs.as_inner().x() * self.as_inner().x()
            + rhs.as_inner().y() * self.as_inner().y()
            + rhs.as_inner().z() * self.as_inner().z()
    }
}
impl<T: Float> Antidot<Bivector<T>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Bivector<T>) -> T {
        self.xy() * rhs.xy() + self.xz() * rhs.xz() - self.xt() * rhs.xt() + self.yz() * rhs.yz()
            - self.yt() * rhs.yt()
            - self.zt() * rhs.zt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Bivector<T>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Bivector<T>) -> T {
        -(rhs.xt() * self.as_inner().xt())
            + -(rhs.yt() * self.as_inner().yt())
            + -(rhs.zt() * self.as_inner().zt())
            + rhs.xy() * self.as_inner().xy()
            + rhs.xz() * self.as_inner().xz()
            + rhs.yz() * self.as_inner().yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Bivector<T>>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Bivector<T>>) -> T {
        -(rhs.as_inner().xt() * self.xt())
            + -(rhs.as_inner().yt() * self.yt())
            + -(rhs.as_inner().zt() * self.zt())
            + rhs.as_inner().xy() * self.xy()
            + rhs.as_inner().xz() * self.xz()
            + rhs.as_inner().yz() * self.yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Bivector<T>>) -> T {
        -(rhs.as_inner().xt() * self.as_inner().xt())
            + -(rhs.as_inner().yt() * self.as_inner().yt())
            + -(rhs.as_inner().zt() * self.as_inner().zt())
            + rhs.as_inner().xy() * self.as_inner().xy()
            + rhs.as_inner().xz() * self.as_inner().xz()
            + rhs.as_inner().yz() * self.as_inner().yz()
    }
}
impl<T: Float> Antidot<Eventor<T>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Eventor<T>) -> T {
        self.xy() * rhs.xy() + self.xz() * rhs.xz() - self.xt() * rhs.xt() + self.yz() * rhs.yz()
            - self.yt() * rhs.yt()
            - self.zt() * rhs.zt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Eventor<T>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Eventor<T>) -> T {
        -(rhs.xt() * self.as_inner().xt())
            + -(rhs.yt() * self.as_inner().yt())
            + -(rhs.zt() * self.as_inner().zt())
            + rhs.xy() * self.as_inner().xy()
            + rhs.xz() * self.as_inner().xz()
            + rhs.yz() * self.as_inner().yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Eventor<T>>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Eventor<T>>) -> T {
        -(rhs.as_inner().xt() * self.xt())
            + -(rhs.as_inner().yt() * self.yt())
            + -(rhs.as_inner().zt() * self.zt())
            + rhs.as_inner().xy() * self.xy()
            + rhs.as_inner().xz() * self.xz()
            + rhs.as_inner().yz() * self.yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Eventor<T>>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Eventor<T>>) -> T {
        -(rhs.as_inner().xt() * self.as_inner().xt())
            + -(rhs.as_inner().yt() * self.as_inner().yt())
            + -(rhs.as_inner().zt() * self.as_inner().zt())
            + rhs.as_inner().xy() * self.as_inner().xy()
            + rhs.as_inner().xz() * self.as_inner().xz()
            + rhs.as_inner().yz() * self.as_inner().yz()
    }
}
impl<T: Float> Antidot<Bivector<T>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Bivector<T>) -> T {
        self.xy() * rhs.xy() + self.xz() * rhs.xz() - self.xt() * rhs.xt() + self.yz() * rhs.yz()
            - self.yt() * rhs.yt()
            - self.zt() * rhs.zt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Bivector<T>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Bivector<T>) -> T {
        -(rhs.xt() * self.as_inner().xt())
            + -(rhs.yt() * self.as_inner().yt())
            + -(rhs.zt() * self.as_inner().zt())
            + rhs.xy() * self.as_inner().xy()
            + rhs.xz() * self.as_inner().xz()
            + rhs.yz() * self.as_inner().yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Bivector<T>>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Bivector<T>>) -> T {
        -(rhs.as_inner().xt() * self.xt())
            + -(rhs.as_inner().yt() * self.yt())
            + -(rhs.as_inner().zt() * self.zt())
            + rhs.as_inner().xy() * self.xy()
            + rhs.as_inner().xz() * self.xz()
            + rhs.as_inner().yz() * self.yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Bivector<T>>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Bivector<T>>) -> T {
        -(rhs.as_inner().xt() * self.as_inner().xt())
            + -(rhs.as_inner().yt() * self.as_inner().yt())
            + -(rhs.as_inner().zt() * self.as_inner().zt())
            + rhs.as_inner().xy() * self.as_inner().xy()
            + rhs.as_inner().xz() * self.as_inner().xz()
            + rhs.as_inner().yz() * self.as_inner().yz()
    }
}
impl<T: Float> Antidot<Eventor<T>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Eventor<T>) -> T {
        -(self.s() * rhs.s()) + self.xy() * rhs.xy() + self.xz() * rhs.xz() - self.xt() * rhs.xt()
            + self.yz() * rhs.yz()
            - self.yt() * rhs.yt()
            - self.zt() * rhs.zt()
            + self.xyzt() * rhs.xyzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Eventor<T>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Eventor<T>) -> T {
        -(rhs.s() * self.as_inner().s())
            + -(rhs.xt() * self.as_inner().xt())
            + -(rhs.yt() * self.as_inner().yt())
            + -(rhs.zt() * self.as_inner().zt())
            + rhs.xy() * self.as_inner().xy()
            + rhs.xyzt() * self.as_inner().xyzt()
            + rhs.xz() * self.as_inner().xz()
            + rhs.yz() * self.as_inner().yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Eventor<T>>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Eventor<T>>) -> T {
        -(rhs.as_inner().s() * self.s())
            + -(rhs.as_inner().xt() * self.xt())
            + -(rhs.as_inner().yt() * self.yt())
            + -(rhs.as_inner().zt() * self.zt())
            + rhs.as_inner().xy() * self.xy()
            + rhs.as_inner().xyzt() * self.xyzt()
            + rhs.as_inner().xz() * self.xz()
            + rhs.as_inner().yz() * self.yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Eventor<T>>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Eventor<T>>) -> T {
        -(rhs.as_inner().s() * self.as_inner().s())
            + -(rhs.as_inner().xt() * self.as_inner().xt())
            + -(rhs.as_inner().yt() * self.as_inner().yt())
            + -(rhs.as_inner().zt() * self.as_inner().zt())
            + rhs.as_inner().xy() * self.as_inner().xy()
            + rhs.as_inner().xyzt() * self.as_inner().xyzt()
            + rhs.as_inner().xz() * self.as_inner().xz()
            + rhs.as_inner().yz() * self.as_inner().yz()
    }
}
impl<T: Float> Antidot<Pseudoscalar<T>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Pseudoscalar<T>) -> T {
        self.xyzt() * rhs.xyzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Pseudoscalar<T>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Pseudoscalar<T>) -> T {
        rhs.xyzt() * self.as_inner().xyzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Pseudoscalar<T>>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Pseudoscalar<T>>) -> T {
        rhs.as_inner().xyzt() * self.xyzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Pseudoscalar<T>>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Pseudoscalar<T>>) -> T {
        rhs.as_inner().xyzt() * self.as_inner().xyzt()
    }
}
impl<T: Float> Antidot<Scalar<T>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        -(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Scalar<T>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        -(rhs.s() * self.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Scalar<T>>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Scalar<T>>) -> T {
        -(rhs.as_inner().s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Scalar<T>>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Scalar<T>>) -> T {
        -(rhs.as_inner().s() * self.as_inner().s())
    }
}
impl<T: Float> Antidot<Eventor<T>> for Pseudoscalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Eventor<T>) -> T {
        self.xyzt() * rhs.xyzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Eventor<T>> for Unit<Pseudoscalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Eventor<T>) -> T {
        rhs.xyzt() * self.as_inner().xyzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Eventor<T>>> for Pseudoscalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Eventor<T>>) -> T {
        rhs.as_inner().xyzt() * self.xyzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Eventor<T>>> for Unit<Pseudoscalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Eventor<T>>) -> T {
        rhs.as_inner().xyzt() * self.as_inner().xyzt()
    }
}
impl<T: Float> Antidot<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Pseudoscalar<T>) -> T {
        self.xyzt() * rhs.xyzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Pseudoscalar<T>) -> T {
        rhs.xyzt() * self.as_inner().xyzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Pseudoscalar<T>>) -> T {
        rhs.as_inner().xyzt() * self.xyzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Pseudoscalar<T>>) -> T {
        rhs.as_inner().xyzt() * self.as_inner().xyzt()
    }
}
impl<T: Float> Antidot<Eventor<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Eventor<T>) -> T {
        -(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Eventor<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Eventor<T>) -> T {
        -(rhs.s() * self.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Eventor<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Eventor<T>>) -> T {
        -(rhs.as_inner().s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Eventor<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Eventor<T>>) -> T {
        -(rhs.as_inner().s() * self.as_inner().s())
    }
}
impl<T: Float> Antidot<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        -(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Scalar<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        -(rhs.s() * self.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Scalar<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Scalar<T>>) -> T {
        -(rhs.as_inner().s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Scalar<T>>) -> T {
        -(rhs.as_inner().s() * self.as_inner().s())
    }
}
impl<T: Float> Antidot<Trivector<T>> for Trivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Trivector<T>) -> T {
        -(self.xyz() * rhs.xyz())
            + self.xyt() * rhs.xyt()
            + self.xzt() * rhs.xzt()
            + self.yzt() * rhs.yzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Trivector<T>> for Unit<Trivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Trivector<T>) -> T {
        -(rhs.xyz() * self.as_inner().xyz())
            + rhs.xyt() * self.as_inner().xyt()
            + rhs.xzt() * self.as_inner().xzt()
            + rhs.yzt() * self.as_inner().yzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Trivector<T>>> for Trivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Trivector<T>>) -> T {
        -(rhs.as_inner().xyz() * self.xyz())
            + rhs.as_inner().xyt() * self.xyt()
            + rhs.as_inner().xzt() * self.xzt()
            + rhs.as_inner().yzt() * self.yzt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Trivector<T>>> for Unit<Trivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Trivector<T>>) -> T {
        -(rhs.as_inner().xyz() * self.as_inner().xyz())
            + rhs.as_inner().xyt() * self.as_inner().xyt()
            + rhs.as_inner().xzt() * self.as_inner().xzt()
            + rhs.as_inner().yzt() * self.as_inner().yzt()
    }
}
impl<T: Float> Antidot<Vector<T>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Vector<T>) -> T {
        self.x() * rhs.x() + self.y() * rhs.y() + self.z() * rhs.z() - self.t() * rhs.t()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Vector<T>> for Unit<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Vector<T>) -> T {
        -(rhs.t() * self.as_inner().t())
            + rhs.x() * self.as_inner().x()
            + rhs.y() * self.as_inner().y()
            + rhs.z() * self.as_inner().z()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Vector<T>>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Vector<T>>) -> T {
        -(rhs.as_inner().t() * self.t())
            + rhs.as_inner().x() * self.x()
            + rhs.as_inner().y() * self.y()
            + rhs.as_inner().z() * self.z()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Vector<T>>) -> T {
        -(rhs.as_inner().t() * self.as_inner().t())
            + rhs.as_inner().x() * self.as_inner().x()
            + rhs.as_inner().y() * self.as_inner().y()
            + rhs.as_inner().z() * self.as_inner().z()
    }
}
impl<T: Float> Reverse for Bivector<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(
            -self.xy(),
            -self.xz(),
            -self.xt(),
            -self.yz(),
            -self.yt(),
            -self.zt(),
        )
    }
}
impl<T: Float> Reverse for Eventor<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(
            self.s(),
            -self.xy(),
            -self.xz(),
            -self.xt(),
            -self.yz(),
            -self.yt(),
            -self.zt(),
            self.xyzt(),
        )
    }
}
impl<T: Float> Reverse for Pseudoscalar<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.xyzt())
    }
}
impl<T: Float> Reverse for Scalar<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> Reverse for Trivector<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(-self.xyz(), -self.xyt(), -self.xzt(), -self.yzt())
    }
}
impl<T: Float> Reverse for Vector<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.x(), self.y(), self.z(), self.t())
    }
}
impl<T: Float> Antireverse for Bivector<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(
            -self.xy(),
            -self.xz(),
            -self.xt(),
            -self.yz(),
            -self.yt(),
            -self.zt(),
        )
    }
}
impl<T: Float> Antireverse for Eventor<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(
            self.s(),
            -self.xy(),
            -self.xz(),
            -self.xt(),
            -self.yz(),
            -self.yt(),
            -self.zt(),
            self.xyzt(),
        )
    }
}
impl<T: Float> Antireverse for Pseudoscalar<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.xyzt())
    }
}
impl<T: Float> Antireverse for Scalar<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> Antireverse for Trivector<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.xyz(), self.xyt(), self.xzt(), self.yzt())
    }
}
impl<T: Float> Antireverse for Vector<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(-self.x(), -self.y(), -self.z(), -self.t())
    }
}
impl<T: Float> Involute for Bivector<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(
            -self.xy(),
            -self.xz(),
            -self.xt(),
            -self.yz(),
            -self.yt(),
            -self.zt(),
        )
    }
}
impl<T: Float> Involute for Eventor<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(
            self.s(),
            -self.xy(),
            -self.xz(),
            -self.xt(),
            -self.yz(),
            -self.yt(),
            -self.zt(),
            self.xyzt(),
        )
    }
}
impl<T: Float> Involute for Pseudoscalar<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.xyzt())
    }
}
impl<T: Float> Involute for Scalar<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> Involute for Trivector<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(-self.xyz(), -self.xyt(), -self.xzt(), -self.yzt())
    }
}
impl<T: Float> Involute for Vector<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.x(), self.y(), self.z(), self.t())
    }
}
impl<T: Float> RightComplement for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn right_complement(&self) -> Bivector<T> {
        Bivector::new_unchecked(
            self.zt(),
            -self.yt(),
            self.yz(),
            self.xt(),
            -self.xz(),
            self.xy(),
        )
    }
}
impl<T: Float> RightComplement for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn right_complement(&self) -> Eventor<T> {
        Eventor::new_unchecked(
            self.xyzt(),
            self.zt(),
            -self.yt(),
            self.yz(),
            self.xt(),
            -self.xz(),
            self.xy(),
            self.s(),
        )
    }
}
impl<T: Float> RightComplement for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_complement(&self) -> Scalar<T> {
        Scalar::new_unchecked(self.xyzt())
    }
}
impl<T: Float> RightComplement for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn right_complement(&self) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.s())
    }
}
impl<T: Float> RightComplement for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_complement(&self) -> Vector<T> {
        Vector::new_unchecked(-self.yzt(), self.xzt(), -self.xyt(), self.xyz())
    }
}
impl<T: Float> RightComplement for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn right_complement(&self) -> Trivector<T> {
        Trivector::new_unchecked(-self.t(), self.z(), -self.y(), self.x())
    }
}
impl<T: Float> WeightDual for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_dual(&self) -> Bivector<T> {
        Bivector::new_unchecked(
            self.zt(),
            -self.yt(),
            -self.yz(),
            self.xt(),
            self.xz(),
            -self.xy(),
        )
    }
}
impl<T: Float> WeightDual for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn weight_dual(&self) -> Eventor<T> {
        Eventor::new_unchecked(
            self.xyzt(),
            self.zt(),
            -self.yt(),
            -self.yz(),
            self.xt(),
            self.xz(),
            -self.xy(),
            -self.s(),
        )
    }
}
impl<T: Float> WeightDual for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_dual(&self) -> Scalar<T> {
        Scalar::new_unchecked(self.xyzt())
    }
}
impl<T: Float> WeightDual for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_dual(&self) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-self.s())
    }
}
impl<T: Float> WeightDual for Trivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_dual(&self) -> Vector<T> {
        Vector::new_unchecked(-self.yzt(), self.xzt(), -self.xyt(), -self.xyz())
    }
}
impl<T: Float> WeightDual for Vector<T> {
    type Output = Trivector<T>;
    #[inline]
    fn weight_dual(&self) -> Trivector<T> {
        Trivector::new_unchecked(-self.t(), -self.z(), self.y(), -self.x())
    }
}
impl<T: Float> VersorInverse for Bivector<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(
            -self.xy() * inv_norm_sq,
            -self.xz() * inv_norm_sq,
            -self.xt() * inv_norm_sq,
            -self.yz() * inv_norm_sq,
            -self.yt() * inv_norm_sq,
            -self.zt() * inv_norm_sq,
        ))
    }
}
impl<T: Float> VersorInverse for Eventor<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(
            self.s() * inv_norm_sq,
            -self.xy() * inv_norm_sq,
            -self.xz() * inv_norm_sq,
            -self.xt() * inv_norm_sq,
            -self.yz() * inv_norm_sq,
            -self.yt() * inv_norm_sq,
            -self.zt() * inv_norm_sq,
            self.xyzt() * inv_norm_sq,
        ))
    }
}
impl<T: Float> VersorInverse for Pseudoscalar<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(self.xyzt() * inv_norm_sq))
    }
}
impl<T: Float> VersorInverse for Scalar<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(self.s() * inv_norm_sq))
    }
}
impl<T: Float> VersorInverse for Trivector<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(
            -self.xyz() * inv_norm_sq,
            -self.xyt() * inv_norm_sq,
            -self.xzt() * inv_norm_sq,
            -self.yzt() * inv_norm_sq,
        ))
    }
}
impl<T: Float> VersorInverse for Vector<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(
            self.x() * inv_norm_sq,
            self.y() * inv_norm_sq,
            self.z() * inv_norm_sq,
            self.t() * inv_norm_sq,
        ))
    }
}
impl<T: Float> crate::norm::Normed for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.xy() * self.xy()
            + self.xz() * self.xz()
            + -self.xt() * self.xt()
            + self.yz() * self.yz()
            + -self.yt() * self.yt()
            + -self.zt() * self.zt()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(
            self.xy() * factor,
            self.xz() * factor,
            self.xt() * factor,
            self.yz() * factor,
            self.yt() * factor,
            self.zt() * factor,
        )
    }
}
impl<T: Float> crate::norm::Normed for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.s() * self.s()
            + self.xy() * self.xy()
            + self.xz() * self.xz()
            + -self.xt() * self.xt()
            + self.yz() * self.yz()
            + -self.yt() * self.yt()
            + -self.zt() * self.zt()
            + -self.xyzt() * self.xyzt()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(
            self.s() * factor,
            self.xy() * factor,
            self.xz() * factor,
            self.xt() * factor,
            self.yz() * factor,
            self.yt() * factor,
            self.zt() * factor,
            self.xyzt() * factor,
        )
    }
}
impl<T: Float> crate::norm::Normed for Pseudoscalar<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        -self.xyzt() * self.xyzt()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.xyzt() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.s() * self.s()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.s() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Trivector<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.xyz() * self.xyz()
            + -self.xyt() * self.xyt()
            + -self.xzt() * self.xzt()
            + -self.yzt() * self.yzt()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(
            self.xyz() * factor,
            self.xyt() * factor,
            self.xzt() * factor,
            self.yzt() * factor,
        )
    }
}
impl<T: Float> crate::norm::Normed for Vector<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.x() * self.x() + self.y() * self.y() + self.z() * self.z() + -self.t() * self.t()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(
            self.x() * factor,
            self.y() * factor,
            self.z() * factor,
            self.t() * factor,
        )
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Bivector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.xy().abs_diff_eq(&other.xy(), epsilon)
            && self.xz().abs_diff_eq(&other.xz(), epsilon)
            && self.xt().abs_diff_eq(&other.xt(), epsilon)
            && self.yz().abs_diff_eq(&other.yz(), epsilon)
            && self.yt().abs_diff_eq(&other.yt(), epsilon)
            && self.zt().abs_diff_eq(&other.zt(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Bivector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.xy().relative_eq(&other.xy(), epsilon, max_relative)
            && self.xz().relative_eq(&other.xz(), epsilon, max_relative)
            && self.xt().relative_eq(&other.xt(), epsilon, max_relative)
            && self.yz().relative_eq(&other.yz(), epsilon, max_relative)
            && self.yt().relative_eq(&other.yt(), epsilon, max_relative)
            && self.zt().relative_eq(&other.zt(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Bivector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.xy().ulps_eq(&other.xy(), epsilon, max_ulps)
            && self.xz().ulps_eq(&other.xz(), epsilon, max_ulps)
            && self.xt().ulps_eq(&other.xt(), epsilon, max_ulps)
            && self.yz().ulps_eq(&other.yz(), epsilon, max_ulps)
            && self.yt().ulps_eq(&other.yt(), epsilon, max_ulps)
            && self.zt().ulps_eq(&other.zt(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Eventor<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon)
            && self.xy().abs_diff_eq(&other.xy(), epsilon)
            && self.xz().abs_diff_eq(&other.xz(), epsilon)
            && self.xt().abs_diff_eq(&other.xt(), epsilon)
            && self.yz().abs_diff_eq(&other.yz(), epsilon)
            && self.yt().abs_diff_eq(&other.yt(), epsilon)
            && self.zt().abs_diff_eq(&other.zt(), epsilon)
            && self.xyzt().abs_diff_eq(&other.xyzt(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Eventor<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
            && self.xy().relative_eq(&other.xy(), epsilon, max_relative)
            && self.xz().relative_eq(&other.xz(), epsilon, max_relative)
            && self.xt().relative_eq(&other.xt(), epsilon, max_relative)
            && self.yz().relative_eq(&other.yz(), epsilon, max_relative)
            && self.yt().relative_eq(&other.yt(), epsilon, max_relative)
            && self.zt().relative_eq(&other.zt(), epsilon, max_relative)
            && self
                .xyzt()
                .relative_eq(&other.xyzt(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Eventor<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
            && self.xy().ulps_eq(&other.xy(), epsilon, max_ulps)
            && self.xz().ulps_eq(&other.xz(), epsilon, max_ulps)
            && self.xt().ulps_eq(&other.xt(), epsilon, max_ulps)
            && self.yz().ulps_eq(&other.yz(), epsilon, max_ulps)
            && self.yt().ulps_eq(&other.yt(), epsilon, max_ulps)
            && self.zt().ulps_eq(&other.zt(), epsilon, max_ulps)
            && self.xyzt().ulps_eq(&other.xyzt(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Pseudoscalar<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.xyzt().abs_diff_eq(&other.xyzt(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Pseudoscalar<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.xyzt()
            .relative_eq(&other.xyzt(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Pseudoscalar<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.xyzt().ulps_eq(&other.xyzt(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Scalar<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Scalar<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Scalar<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Trivector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.xyz().abs_diff_eq(&other.xyz(), epsilon)
            && self.xyt().abs_diff_eq(&other.xyt(), epsilon)
            && self.xzt().abs_diff_eq(&other.xzt(), epsilon)
            && self.yzt().abs_diff_eq(&other.yzt(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Trivector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.xyz().relative_eq(&other.xyz(), epsilon, max_relative)
            && self.xyt().relative_eq(&other.xyt(), epsilon, max_relative)
            && self.xzt().relative_eq(&other.xzt(), epsilon, max_relative)
            && self.yzt().relative_eq(&other.yzt(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Trivector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.xyz().ulps_eq(&other.xyz(), epsilon, max_ulps)
            && self.xyt().ulps_eq(&other.xyt(), epsilon, max_ulps)
            && self.xzt().ulps_eq(&other.xzt(), epsilon, max_ulps)
            && self.yzt().ulps_eq(&other.yzt(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Vector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.x().abs_diff_eq(&other.x(), epsilon)
            && self.y().abs_diff_eq(&other.y(), epsilon)
            && self.z().abs_diff_eq(&other.z(), epsilon)
            && self.t().abs_diff_eq(&other.t(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Vector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.x().relative_eq(&other.x(), epsilon, max_relative)
            && self.y().relative_eq(&other.y(), epsilon, max_relative)
            && self.z().relative_eq(&other.z(), epsilon, max_relative)
            && self.t().relative_eq(&other.t(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Vector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.x().ulps_eq(&other.x(), epsilon, max_ulps)
            && self.y().ulps_eq(&other.y(), epsilon, max_ulps)
            && self.z().ulps_eq(&other.z(), epsilon, max_ulps)
            && self.t().ulps_eq(&other.t(), epsilon, max_ulps)
    }
}
#[cfg(any(test, feature = "proptest-support"))]
#[allow(clippy::missing_docs_in_private_items)]
mod arbitrary_impls {
    use super::*;
    use proptest::prelude::*;
    use proptest::strategy::BoxedStrategy;
    use std::fmt::Debug;
    impl<T: Float + Debug + 'static> Arbitrary for Bivector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
            )
                .prop_filter("non-zero divisor", |(x0, _x1, _x2, _x3, _x4)| {
                    (x0).abs() > 0.1
                })
                .prop_map(|(x0, x1, x2, x3, x4)| {
                    Bivector::new_unchecked(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64(x3),
                        T::from_f64(x4),
                        T::from_f64((-x2 * x3 + x1 * x4) / (x0)),
                    )
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Eventor<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
            )
                .prop_filter("non-zero divisor", |(x0, _x1, _x2, _x3, _x4, _x5, _x6)| {
                    (x0).abs() > 0.1
                })
                .prop_map(|(x0, x1, x2, x3, x4, x5, x6)| {
                    Eventor::new_unchecked(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64(x3),
                        T::from_f64(x4),
                        T::from_f64(x5),
                        T::from_f64(x6),
                        T::from_f64((x3 * x4 + x1 * x6 - x2 * x5) / (x0)),
                    )
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Pseudoscalar<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| Pseudoscalar::new_unchecked(T::from_f64(x0)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Scalar<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| Scalar::new_unchecked(T::from_f64(x0)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Trivector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
            )
                .prop_map(|(x0, x1, x2, x3)| {
                    Trivector::new_unchecked(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64(x3),
                    )
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Vector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
            )
                .prop_map(|(x0, x1, x2, x3)| {
                    Vector::new_unchecked(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64(x3),
                    )
                })
                .boxed()
        }
    }
}

// ============================================================
// Verification Tests (compare against Multivector)
// ============================================================

#[cfg(test)]
#[allow(clippy::missing_docs_in_private_items)]
mod verification_tests {
    use super::*;
    use crate::algebra::Multivector;
    #[allow(unused_imports)]
    use crate::norm::{DegenerateNormed, Normed};
    use crate::signature::Cl3_1_0;
    #[allow(unused_imports)]
    use crate::wrappers::Unit;
    use approx::relative_eq;
    use proptest::prelude::*;

    /// Relative epsilon for floating-point comparisons in verification tests.
    /// Using relative comparison handles varying magnitudes better than absolute.
    const REL_EPSILON: f64 = 1e-10;

    proptest! {
        #[test]
        fn bivector_add_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn bivector_sub_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn bivector_neg_matches_multivector(a in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn eventor_add_matches_multivector(a in any::<Eventor<f64>>(), b in any::<Eventor<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn eventor_sub_matches_multivector(a in any::<Eventor<f64>>(), b in any::<Eventor<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn eventor_neg_matches_multivector(a in any::<Eventor<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn pseudoscalar_add_matches_multivector(a in any::<Pseudoscalar<f64>>(), b in any::<Pseudoscalar<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn pseudoscalar_sub_matches_multivector(a in any::<Pseudoscalar<f64>>(), b in any::<Pseudoscalar<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn pseudoscalar_neg_matches_multivector(a in any::<Pseudoscalar<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn scalar_add_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn scalar_sub_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn scalar_neg_matches_multivector(a in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn trivector_add_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn trivector_sub_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn trivector_neg_matches_multivector(a in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn vector_add_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn vector_sub_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn vector_neg_matches_multivector(a in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_bivector_bivector_pseudoscalar_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Pseudoscalar<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_bivector_scalar_bivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Bivector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_bivector_vector_trivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Trivector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_pseudoscalar_scalar_pseudoscalar_matches_multivector(a in any::<Pseudoscalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Pseudoscalar<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_scalar_bivector_bivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Bivector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_scalar_pseudoscalar_pseudoscalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Pseudoscalar<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Pseudoscalar<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_scalar_scalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Scalar<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_scalar_trivector_trivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Trivector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_scalar_vector_vector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Vector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_trivector_scalar_trivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Trivector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_trivector_vector_pseudoscalar_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Pseudoscalar<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_vector_bivector_trivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Trivector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_vector_scalar_vector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Vector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_vector_trivector_pseudoscalar_matches_multivector(a in any::<Vector<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Pseudoscalar<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_vector_vector_bivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Bivector<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_bivector_bivector_scalar_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Scalar<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_bivector_scalar_bivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Bivector<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_bivector_vector_vector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Vector<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_pseudoscalar_bivector_bivector_matches_multivector(a in any::<Pseudoscalar<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Bivector<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_pseudoscalar_pseudoscalar_scalar_matches_multivector(a in any::<Pseudoscalar<f64>>(), b in any::<Pseudoscalar<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Scalar<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_pseudoscalar_scalar_pseudoscalar_matches_multivector(a in any::<Pseudoscalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Pseudoscalar<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_pseudoscalar_trivector_vector_matches_multivector(a in any::<Pseudoscalar<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Vector<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_pseudoscalar_vector_trivector_matches_multivector(a in any::<Pseudoscalar<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Trivector<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_scalar_scalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Scalar<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_trivector_bivector_vector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Vector<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_trivector_scalar_trivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Trivector<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_trivector_trivector_scalar_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Scalar<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_trivector_vector_bivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Bivector<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_vector_scalar_vector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Vector<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_vector_vector_scalar_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Scalar<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_bivector_bivector_scalar_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Scalar<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_bivector_scalar_bivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Bivector<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_bivector_vector_vector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Vector<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_pseudoscalar_bivector_bivector_matches_multivector(a in any::<Pseudoscalar<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Bivector<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_pseudoscalar_pseudoscalar_scalar_matches_multivector(a in any::<Pseudoscalar<f64>>(), b in any::<Pseudoscalar<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Scalar<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_pseudoscalar_scalar_pseudoscalar_matches_multivector(a in any::<Pseudoscalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Pseudoscalar<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_pseudoscalar_trivector_vector_matches_multivector(a in any::<Pseudoscalar<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Vector<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_pseudoscalar_vector_trivector_matches_multivector(a in any::<Pseudoscalar<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Trivector<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_scalar_scalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Scalar<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_trivector_bivector_vector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Vector<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_trivector_scalar_trivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Trivector<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_trivector_trivector_scalar_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Scalar<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_trivector_vector_bivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Bivector<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_vector_scalar_vector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Vector<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_vector_vector_scalar_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Scalar<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_bivector_bivector_pseudoscalar_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Pseudoscalar<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_bivector_pseudoscalar_bivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Pseudoscalar<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Bivector<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_bivector_trivector_trivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Trivector<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_pseudoscalar_pseudoscalar_pseudoscalar_matches_multivector(a in any::<Pseudoscalar<f64>>(), b in any::<Pseudoscalar<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Pseudoscalar<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_scalar_bivector_bivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Bivector<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_scalar_pseudoscalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Pseudoscalar<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Scalar<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_scalar_scalar_pseudoscalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Pseudoscalar<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_scalar_trivector_vector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Vector<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_scalar_vector_trivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Trivector<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_trivector_pseudoscalar_trivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Pseudoscalar<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Trivector<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_trivector_trivector_pseudoscalar_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Pseudoscalar<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_vector_bivector_trivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Trivector<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_vector_pseudoscalar_vector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Pseudoscalar<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Vector<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_vector_trivector_bivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Bivector<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_vector_vector_pseudoscalar_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Pseudoscalar<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_bivector_bivector_pseudoscalar_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Pseudoscalar<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_bivector_pseudoscalar_bivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Pseudoscalar<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Bivector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_bivector_trivector_trivector_matches_multivector(a in any::<Bivector<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Trivector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_pseudoscalar_pseudoscalar_pseudoscalar_matches_multivector(a in any::<Pseudoscalar<f64>>(), b in any::<Pseudoscalar<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Pseudoscalar<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_scalar_bivector_bivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Bivector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_scalar_pseudoscalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Pseudoscalar<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Scalar<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_scalar_scalar_pseudoscalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Pseudoscalar<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_scalar_trivector_vector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Vector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_scalar_vector_trivector_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Trivector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_trivector_pseudoscalar_trivector_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Pseudoscalar<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Trivector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_trivector_trivector_pseudoscalar_matches_multivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Pseudoscalar<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_vector_bivector_trivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Bivector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Trivector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_vector_pseudoscalar_vector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Pseudoscalar<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Vector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_vector_trivector_bivector_matches_multivector(a in any::<Vector<f64>>(), b in any::<Trivector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Bivector<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_vector_vector_pseudoscalar_matches_multivector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            let specialized_result: Pseudoscalar<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl3_1_0> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_bivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            // LHS: complement(a * b)
            let lhs = (mv_a * mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_bivector(a in any::<Bivector<f64>>(), b in any::<Bivector<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = mv_a.complement() * mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_pseudoscalar(a in any::<Pseudoscalar<f64>>(), b in any::<Pseudoscalar<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            // LHS: complement(a * b)
            let lhs = (mv_a * mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_pseudoscalar(a in any::<Pseudoscalar<f64>>(), b in any::<Pseudoscalar<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = mv_a.complement() * mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_scalar(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            // LHS: complement(a * b)
            let lhs = (mv_a * mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_scalar(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = mv_a.complement() * mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_trivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            // LHS: complement(a * b)
            let lhs = (mv_a * mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_trivector(a in any::<Trivector<f64>>(), b in any::<Trivector<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = mv_a.complement() * mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_vector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            // LHS: complement(a * b)
            let lhs = (mv_a * mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_vector(a in any::<Vector<f64>>(), b in any::<Vector<f64>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = mv_a.complement() * mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// Project idempotency with normalized target: project(project(a, unit_b), unit_b) == project(a, unit_b)
        #[test]
        fn project_idempotent_bivector_vector(a in any::<Bivector<f64>>(), unit_b in any::<Unit<Vector<f64>>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = unit_b.into_inner().into();

            let first = mv_a.project(&mv_b);
            let second = first.project(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Project idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Project idempotency with normalized target: project(project(a, unit_b), unit_b) == project(a, unit_b)
        #[test]
        fn project_idempotent_pseudoscalar_bivector(a in any::<Pseudoscalar<f64>>(), unit_b in any::<Unit<Bivector<f64>>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = unit_b.into_inner().into();

            let first = mv_a.project(&mv_b);
            let second = first.project(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Project idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Project idempotency with normalized target: project(project(a, unit_b), unit_b) == project(a, unit_b)
        #[test]
        fn project_idempotent_pseudoscalar_trivector(a in any::<Pseudoscalar<f64>>(), unit_b in any::<Unit<Trivector<f64>>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = unit_b.into_inner().into();

            let first = mv_a.project(&mv_b);
            let second = first.project(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Project idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Project idempotency with normalized target: project(project(a, unit_b), unit_b) == project(a, unit_b)
        #[test]
        fn project_idempotent_pseudoscalar_vector(a in any::<Pseudoscalar<f64>>(), unit_b in any::<Unit<Vector<f64>>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = unit_b.into_inner().into();

            let first = mv_a.project(&mv_b);
            let second = first.project(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Project idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Project idempotency with normalized target: project(project(a, unit_b), unit_b) == project(a, unit_b)
        #[test]
        fn project_idempotent_trivector_bivector(a in any::<Trivector<f64>>(), unit_b in any::<Unit<Bivector<f64>>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = unit_b.into_inner().into();

            let first = mv_a.project(&mv_b);
            let second = first.project(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Project idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Project idempotency with normalized target: project(project(a, unit_b), unit_b) == project(a, unit_b)
        #[test]
        fn project_idempotent_trivector_vector(a in any::<Trivector<f64>>(), unit_b in any::<Unit<Vector<f64>>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = unit_b.into_inner().into();

            let first = mv_a.project(&mv_b);
            let second = first.project(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Project idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Antiproject idempotency with normalized target: antiproject(antiproject(a, unit_b), unit_b) == antiproject(a, unit_b)
        #[test]
        fn antiproject_idempotent_bivector_pseudoscalar(a in any::<Bivector<f64>>(), unit_b in any::<Unit<Pseudoscalar<f64>>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = unit_b.into_inner().into();

            let first = mv_a.antiproject(&mv_b);
            let second = first.antiproject(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Antiproject idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Antiproject idempotency with normalized target: antiproject(antiproject(a, unit_b), unit_b) == antiproject(a, unit_b)
        #[test]
        fn antiproject_idempotent_bivector_trivector(a in any::<Bivector<f64>>(), unit_b in any::<Unit<Trivector<f64>>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = unit_b.into_inner().into();

            let first = mv_a.antiproject(&mv_b);
            let second = first.antiproject(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Antiproject idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Antiproject idempotency with normalized target: antiproject(antiproject(a, unit_b), unit_b) == antiproject(a, unit_b)
        #[test]
        fn antiproject_idempotent_trivector_pseudoscalar(a in any::<Trivector<f64>>(), unit_b in any::<Unit<Pseudoscalar<f64>>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = unit_b.into_inner().into();

            let first = mv_a.antiproject(&mv_b);
            let second = first.antiproject(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Antiproject idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Antiproject idempotency with normalized target: antiproject(antiproject(a, unit_b), unit_b) == antiproject(a, unit_b)
        #[test]
        fn antiproject_idempotent_vector_bivector(a in any::<Vector<f64>>(), unit_b in any::<Unit<Bivector<f64>>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = unit_b.into_inner().into();

            let first = mv_a.antiproject(&mv_b);
            let second = first.antiproject(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Antiproject idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Antiproject idempotency with normalized target: antiproject(antiproject(a, unit_b), unit_b) == antiproject(a, unit_b)
        #[test]
        fn antiproject_idempotent_vector_pseudoscalar(a in any::<Vector<f64>>(), unit_b in any::<Unit<Pseudoscalar<f64>>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = unit_b.into_inner().into();

            let first = mv_a.antiproject(&mv_b);
            let second = first.antiproject(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Antiproject idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }

    proptest! {
        /// Antiproject idempotency with normalized target: antiproject(antiproject(a, unit_b), unit_b) == antiproject(a, unit_b)
        #[test]
        fn antiproject_idempotent_vector_trivector(a in any::<Vector<f64>>(), unit_b in any::<Unit<Trivector<f64>>>()) {
            let mv_a: Multivector<f64, Cl3_1_0> = a.into();
            let mv_b: Multivector<f64, Cl3_1_0> = unit_b.into_inner().into();

            let first = mv_a.antiproject(&mv_b);
            let second = first.antiproject(&mv_b);

            prop_assert!(
                relative_eq!(first, second, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Antiproject idempotency failed: first={:?}, second={:?}",
                first, second
            );
        }
    }
}
