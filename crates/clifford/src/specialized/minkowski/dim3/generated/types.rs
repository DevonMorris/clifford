#![doc = " Type definitions for minkowski3."]
#![doc = ""]
#![doc = " 3D Minkowski spacetime Cl(3,1,0)"]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
#![allow(clippy::too_many_arguments)]
use crate::scalar::Float;
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
#[doc = "Bivector (spatial rotations + spacetime boosts)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 3 | e1e2 | `xy` |\n| 5 | e1e3 | `xz` |\n| 9 | e1e4 | `xt` |\n| 6 | e2e3 | `yz` |\n| 10 | e2e4 | `yt` |\n| 12 | e3e4 | `zt` |\n\n\n# Example\n\n```\nuse clifford::specialized::minkowski::dim3::Bivector;\n\nlet v = Bivector::new_unchecked(1.0, 2.0, 3.0, 4.0, 5.0, 6.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Bivector<T: Float> {
    #[doc = "Coefficient of `xy`."]
    xy: T,
    #[doc = "Coefficient of `xz`."]
    xz: T,
    #[doc = "Coefficient of `xt`."]
    xt: T,
    #[doc = "Coefficient of `yz`."]
    yz: T,
    #[doc = "Coefficient of `yt`."]
    yt: T,
    #[doc = "Coefficient of `zt`."]
    zt: T,
}
impl<T: Float> Bivector<T> {
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" **Warning:** This does not validate the geometric constraint."]
    #[doc = r" Use `new_checked()` to validate, or `from_components()` to"]
    #[doc = r" construct from independent parameters."]
    #[inline]
    pub fn new_unchecked(xy: T, xz: T, xt: T, yz: T, yt: T, zt: T) -> Self {
        Self {
            xy,
            xz,
            xt,
            yz,
            yt,
            zt,
        }
    }
    #[doc = r" Creates a new element, validating the geometric constraint."]
    #[doc = r""]
    #[doc = r" Returns `Err` if the constraint is violated beyond the given tolerance."]
    #[inline]
    pub fn new_checked(
        xy: T,
        xz: T,
        xt: T,
        yz: T,
        yt: T,
        zt: T,
        tolerance: T,
    ) -> Result<Self, &'static str> {
        let expected = (-xt * yz + xz * yt) / (xy);
        let actual = zt;
        if (actual - expected).abs() > tolerance {
            return Err("Bivector constraint");
        }
        Ok(Self::new_unchecked(xy, xz, xt, yz, yt, zt))
    }
    #[doc = "Creates a Bivector from 5 independent components, computing `zt`.\n\nReturns `None` if the divisor would be zero (unstable computation)."]
    #[inline]
    pub fn from_components(xy: T, xz: T, xt: T, yz: T, yt: T) -> Option<Self> {
        if (xy).abs() < T::epsilon() {
            return None;
        }
        Some(Self::new_unchecked(
            xy,
            xz,
            xt,
            yz,
            yt,
            (-xt * yz + xz * yt) / (xy),
        ))
    }
    #[doc = "Returns the `xy` coefficient."]
    #[inline]
    pub fn xy(&self) -> T {
        self.xy
    }
    #[doc = "Returns the `xz` coefficient."]
    #[inline]
    pub fn xz(&self) -> T {
        self.xz
    }
    #[doc = "Returns the `xt` coefficient."]
    #[inline]
    pub fn xt(&self) -> T {
        self.xt
    }
    #[doc = "Returns the `yz` coefficient."]
    #[inline]
    pub fn yz(&self) -> T {
        self.yz
    }
    #[doc = "Returns the `yt` coefficient."]
    #[inline]
    pub fn yt(&self) -> T {
        self.yt
    }
    #[doc = "Returns the `zt` coefficient."]
    #[inline]
    pub fn zt(&self) -> T {
        self.zt
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e2 element."]
    #[inline]
    pub fn unit_xy() -> Self {
        Self::new_unchecked(
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e3 element."]
    #[inline]
    pub fn unit_xz() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e4 element."]
    #[inline]
    pub fn unit_xt() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e2e3 element."]
    #[inline]
    pub fn unit_yz() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e2e4 element."]
    #[inline]
    pub fn unit_yt() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e3e4 element."]
    #[inline]
    pub fn unit_zt() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
        )
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.xy * self.xy
            + self.xz * self.xz
            + self.xt * self.xt
            + self.yz * self.yz
            + self.yt * self.yt
            + self.zt * self.zt
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(
            self.xy * s,
            self.xz * s,
            self.xt * s,
            self.yz * s,
            self.yt * s,
            self.zt * s,
        )
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(-self.xy, -self.xz, -self.xt, -self.yz, -self.yt, -self.zt)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(-self.xy, -self.xz, -self.xt, -self.yz, -self.yt, -self.zt)
    }
}
impl<T: Float> Default for Bivector<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Even-graded element (Lorentz transformations)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 0 | s | `s` |\n| 3 | e1e2 | `xy` |\n| 5 | e1e3 | `xz` |\n| 9 | e1e4 | `xt` |\n| 6 | e2e3 | `yz` |\n| 10 | e2e4 | `yt` |\n| 12 | e3e4 | `zt` |\n| 15 | e1e2e3e4 | `xyzt` |\n\n\n# Example\n\n```\nuse clifford::specialized::minkowski::dim3::Eventor;\n\nlet v = Eventor::new_unchecked(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Eventor<T: Float> {
    #[doc = "Coefficient of `s`."]
    s: T,
    #[doc = "Coefficient of `xy`."]
    xy: T,
    #[doc = "Coefficient of `xz`."]
    xz: T,
    #[doc = "Coefficient of `xt`."]
    xt: T,
    #[doc = "Coefficient of `yz`."]
    yz: T,
    #[doc = "Coefficient of `yt`."]
    yt: T,
    #[doc = "Coefficient of `zt`."]
    zt: T,
    #[doc = "Coefficient of `xyzt`."]
    xyzt: T,
}
impl<T: Float> Eventor<T> {
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" **Warning:** This does not validate the geometric constraint."]
    #[doc = r" Use `new_checked()` to validate, or `from_components()` to"]
    #[doc = r" construct from independent parameters."]
    #[inline]
    pub fn new_unchecked(s: T, xy: T, xz: T, xt: T, yz: T, yt: T, zt: T, xyzt: T) -> Self {
        Self {
            s,
            xy,
            xz,
            xt,
            yz,
            yt,
            zt,
            xyzt,
        }
    }
    #[doc = r" Creates a new element, validating the geometric constraint."]
    #[doc = r""]
    #[doc = r" Returns `Err` if the constraint is violated beyond the given tolerance."]
    #[inline]
    pub fn new_checked(
        s: T,
        xy: T,
        xz: T,
        xt: T,
        yz: T,
        yt: T,
        zt: T,
        xyzt: T,
        tolerance: T,
    ) -> Result<Self, &'static str> {
        let expected = (xt * yz + xy * zt - xz * yt) / (s);
        let actual = xyzt;
        if (actual - expected).abs() > tolerance {
            return Err("Eventor constraint");
        }
        Ok(Self::new_unchecked(s, xy, xz, xt, yz, yt, zt, xyzt))
    }
    #[doc = "Creates a Eventor from 7 independent components, computing `xyzt`.\n\nReturns `None` if the divisor would be zero (unstable computation)."]
    #[inline]
    pub fn from_components(s: T, xy: T, xz: T, xt: T, yz: T, yt: T, zt: T) -> Option<Self> {
        if (s).abs() < T::epsilon() {
            return None;
        }
        Some(Self::new_unchecked(
            s,
            xy,
            xz,
            xt,
            yz,
            yt,
            zt,
            (xt * yz + xy * zt - xz * yt) / (s),
        ))
    }
    #[doc = "Returns the `s` coefficient."]
    #[inline]
    pub fn s(&self) -> T {
        self.s
    }
    #[doc = "Returns the `xy` coefficient."]
    #[inline]
    pub fn xy(&self) -> T {
        self.xy
    }
    #[doc = "Returns the `xz` coefficient."]
    #[inline]
    pub fn xz(&self) -> T {
        self.xz
    }
    #[doc = "Returns the `xt` coefficient."]
    #[inline]
    pub fn xt(&self) -> T {
        self.xt
    }
    #[doc = "Returns the `yz` coefficient."]
    #[inline]
    pub fn yz(&self) -> T {
        self.yz
    }
    #[doc = "Returns the `yt` coefficient."]
    #[inline]
    pub fn yt(&self) -> T {
        self.yt
    }
    #[doc = "Returns the `zt` coefficient."]
    #[inline]
    pub fn zt(&self) -> T {
        self.zt
    }
    #[doc = "Returns the `xyzt` coefficient."]
    #[inline]
    pub fn xyzt(&self) -> T {
        self.xyzt
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.s * self.s
            + self.xy * self.xy
            + self.xz * self.xz
            + self.xt * self.xt
            + self.yz * self.yz
            + self.yt * self.yt
            + self.zt * self.zt
            + self.xyzt * self.xyzt
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(
            self.s * s,
            self.xy * s,
            self.xz * s,
            self.xt * s,
            self.yz * s,
            self.yt * s,
            self.zt * s,
            self.xyzt * s,
        )
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(
            self.s, -self.xy, -self.xz, -self.xt, -self.yz, -self.yt, -self.zt, self.xyzt,
        )
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(
            self.s, -self.xy, -self.xz, -self.xt, -self.yz, -self.yt, -self.zt, self.xyzt,
        )
    }
}
impl<T: Float> Default for Eventor<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Pseudoscalar (oriented 4-volume)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 15 | e1e2e3e4 | `xyzt` |\n\n\n# Example\n\n```\nuse clifford::specialized::minkowski::dim3::Pseudoscalar;\n\nlet v = Pseudoscalar::new_unchecked(1.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Pseudoscalar<T: Float> {
    #[doc = "Coefficient of `xyzt`."]
    xyzt: T,
}
impl<T: Float> Pseudoscalar<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(xyzt: T) -> Self {
        Self { xyzt }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(xyzt: T) -> Self {
        Self::new(xyzt)
    }
    #[doc = "Returns the `xyzt` coefficient."]
    #[inline]
    pub fn xyzt(&self) -> T {
        self.xyzt
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero())
    }
    #[doc = "Creates the unit e1e2e3e4 element."]
    #[inline]
    pub fn unit_xyzt() -> Self {
        Self::new_unchecked(T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.xyzt * self.xyzt
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.xyzt * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.xyzt)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.xyzt)
    }
}
impl<T: Float> Default for Pseudoscalar<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Scalar (grade-0 element)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 0 | s | `s` |\n\n\n# Example\n\n```\nuse clifford::specialized::minkowski::dim3::Scalar;\n\nlet v = Scalar::new_unchecked(1.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Scalar<T: Float> {
    #[doc = "Coefficient of `s`."]
    s: T,
}
impl<T: Float> Scalar<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(s: T) -> Self {
        Self { s }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(s: T) -> Self {
        Self::new(s)
    }
    #[doc = "Returns the `s` coefficient."]
    #[inline]
    pub fn s(&self) -> T {
        self.s
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero())
    }
    #[doc = "Creates the unit s element."]
    #[inline]
    pub fn unit_s() -> Self {
        Self::new_unchecked(T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.s * self.s
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.s * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.s)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.s)
    }
}
impl<T: Float> Default for Scalar<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Trivector (spacetime volumes)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 7 | e1e2e3 | `xyz` |\n| 11 | e1e2e4 | `xyt` |\n| 13 | e1e3e4 | `xzt` |\n| 14 | e2e3e4 | `yzt` |\n\n\n# Example\n\n```\nuse clifford::specialized::minkowski::dim3::Trivector;\n\nlet v = Trivector::new_unchecked(1.0, 2.0, 3.0, 4.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Trivector<T: Float> {
    #[doc = "Coefficient of `xyz`."]
    xyz: T,
    #[doc = "Coefficient of `xyt`."]
    xyt: T,
    #[doc = "Coefficient of `xzt`."]
    xzt: T,
    #[doc = "Coefficient of `yzt`."]
    yzt: T,
}
impl<T: Float> Trivector<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(xyz: T, xyt: T, xzt: T, yzt: T) -> Self {
        Self { xyz, xyt, xzt, yzt }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(xyz: T, xyt: T, xzt: T, yzt: T) -> Self {
        Self::new(xyz, xyt, xzt, yzt)
    }
    #[doc = "Returns the `xyz` coefficient."]
    #[inline]
    pub fn xyz(&self) -> T {
        self.xyz
    }
    #[doc = "Returns the `xyt` coefficient."]
    #[inline]
    pub fn xyt(&self) -> T {
        self.xyt
    }
    #[doc = "Returns the `xzt` coefficient."]
    #[inline]
    pub fn xzt(&self) -> T {
        self.xzt
    }
    #[doc = "Returns the `yzt` coefficient."]
    #[inline]
    pub fn yzt(&self) -> T {
        self.yzt
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e2e3 element."]
    #[inline]
    pub fn unit_xyz() -> Self {
        Self::new_unchecked(T::one(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e2e4 element."]
    #[inline]
    pub fn unit_xyt() -> Self {
        Self::new_unchecked(T::zero(), T::one(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e3e4 element."]
    #[inline]
    pub fn unit_xzt() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::one(), T::zero())
    }
    #[doc = "Creates the unit e2e3e4 element."]
    #[inline]
    pub fn unit_yzt() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.xyz * self.xyz + self.xyt * self.xyt + self.xzt * self.xzt + self.yzt * self.yzt
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.xyz * s, self.xyt * s, self.xzt * s, self.yzt * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(-self.xyz, -self.xyt, -self.xzt, -self.yzt)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.xyz, self.xyt, self.xzt, self.yzt)
    }
}
impl<T: Float> Default for Trivector<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Spacetime vector (can be spacelike, timelike, or null)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 1 | e1 | `x` |\n| 2 | e2 | `y` |\n| 4 | e3 | `z` |\n| 8 | e4 | `t` |\n\n\n# Example\n\n```\nuse clifford::specialized::minkowski::dim3::Vector;\n\nlet v = Vector::new_unchecked(1.0, 2.0, 3.0, 4.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Vector<T: Float> {
    #[doc = "Coefficient of `x`."]
    x: T,
    #[doc = "Coefficient of `y`."]
    y: T,
    #[doc = "Coefficient of `z`."]
    z: T,
    #[doc = "Coefficient of `t`."]
    t: T,
}
impl<T: Float> Vector<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(x: T, y: T, z: T, t: T) -> Self {
        Self { x, y, z, t }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(x: T, y: T, z: T, t: T) -> Self {
        Self::new(x, y, z, t)
    }
    #[doc = "Returns the `x` coefficient."]
    #[inline]
    pub fn x(&self) -> T {
        self.x
    }
    #[doc = "Returns the `y` coefficient."]
    #[inline]
    pub fn y(&self) -> T {
        self.y
    }
    #[doc = "Returns the `z` coefficient."]
    #[inline]
    pub fn z(&self) -> T {
        self.z
    }
    #[doc = "Returns the `t` coefficient."]
    #[inline]
    pub fn t(&self) -> T {
        self.t
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1 element."]
    #[inline]
    pub fn unit_x() -> Self {
        Self::new_unchecked(T::one(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e2 element."]
    #[inline]
    pub fn unit_y() -> Self {
        Self::new_unchecked(T::zero(), T::one(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e3 element."]
    #[inline]
    pub fn unit_z() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::one(), T::zero())
    }
    #[doc = "Creates the unit e4 element."]
    #[inline]
    pub fn unit_t() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.x * self.x + self.y * self.y + self.z * self.z + self.t * self.t
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.x * s, self.y * s, self.z * s, self.t * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.x, self.y, self.z, self.t)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(-self.x, -self.y, -self.z, -self.t)
    }
}
impl<T: Float> Default for Vector<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "A unit Bivector (norm = 1).\n\nThis type alias provides compile-time documentation that the Bivector has been normalized."]
pub type UnitBivector<T> = crate::wrappers::Unit<Bivector<T>>;
#[doc = "A Bivector with positive norm squared (timelike in Minkowski).\n\nThis type alias wraps Bivector in `Proper<T>`, guaranteeing norm² > 0."]
pub type ProperBivector<T> = crate::wrappers::Proper<Bivector<T>>;
#[doc = "A Bivector with negative norm squared (spacelike in Minkowski).\n\nThis type alias wraps Bivector in `Spacelike<T>`, guaranteeing norm² < 0."]
pub type SpacelikeBivector<T> = crate::wrappers::Spacelike<Bivector<T>>;
#[doc = "A Bivector with zero norm squared (lightlike/null in Minkowski).\n\nThis type alias wraps Bivector in `Null<T>`, guaranteeing norm² = 0."]
pub type NullBivector<T> = crate::wrappers::Null<Bivector<T>>;
#[doc = "A unit Pseudoscalar (norm = 1).\n\nThis type alias provides compile-time documentation that the Pseudoscalar has been normalized."]
pub type UnitPseudoscalar<T> = crate::wrappers::Unit<Pseudoscalar<T>>;
#[doc = "A Pseudoscalar with positive norm squared (timelike in Minkowski).\n\nThis type alias wraps Pseudoscalar in `Proper<T>`, guaranteeing norm² > 0."]
pub type ProperPseudoscalar<T> = crate::wrappers::Proper<Pseudoscalar<T>>;
#[doc = "A Pseudoscalar with negative norm squared (spacelike in Minkowski).\n\nThis type alias wraps Pseudoscalar in `Spacelike<T>`, guaranteeing norm² < 0."]
pub type SpacelikePseudoscalar<T> = crate::wrappers::Spacelike<Pseudoscalar<T>>;
#[doc = "A Pseudoscalar with zero norm squared (lightlike/null in Minkowski).\n\nThis type alias wraps Pseudoscalar in `Null<T>`, guaranteeing norm² = 0."]
pub type NullPseudoscalar<T> = crate::wrappers::Null<Pseudoscalar<T>>;
#[doc = "A unit Trivector (norm = 1).\n\nThis type alias provides compile-time documentation that the Trivector has been normalized."]
pub type UnitTrivector<T> = crate::wrappers::Unit<Trivector<T>>;
#[doc = "A Trivector with positive norm squared (timelike in Minkowski).\n\nThis type alias wraps Trivector in `Proper<T>`, guaranteeing norm² > 0."]
pub type ProperTrivector<T> = crate::wrappers::Proper<Trivector<T>>;
#[doc = "A Trivector with negative norm squared (spacelike in Minkowski).\n\nThis type alias wraps Trivector in `Spacelike<T>`, guaranteeing norm² < 0."]
pub type SpacelikeTrivector<T> = crate::wrappers::Spacelike<Trivector<T>>;
#[doc = "A Trivector with zero norm squared (lightlike/null in Minkowski).\n\nThis type alias wraps Trivector in `Null<T>`, guaranteeing norm² = 0."]
pub type NullTrivector<T> = crate::wrappers::Null<Trivector<T>>;
#[doc = "A unit Vector (norm = 1).\n\nThis type alias provides compile-time documentation that the Vector has been normalized."]
pub type UnitVector<T> = crate::wrappers::Unit<Vector<T>>;
#[doc = "A Vector with positive norm squared (timelike in Minkowski).\n\nThis type alias wraps Vector in `Proper<T>`, guaranteeing norm² > 0."]
pub type ProperVector<T> = crate::wrappers::Proper<Vector<T>>;
#[doc = "A Vector with negative norm squared (spacelike in Minkowski).\n\nThis type alias wraps Vector in `Spacelike<T>`, guaranteeing norm² < 0."]
pub type SpacelikeVector<T> = crate::wrappers::Spacelike<Vector<T>>;
#[doc = "A Vector with zero norm squared (lightlike/null in Minkowski).\n\nThis type alias wraps Vector in `Null<T>`, guaranteeing norm² = 0."]
pub type NullVector<T> = crate::wrappers::Null<Vector<T>>;
