#![doc = " Trait implementations for minkowski2."]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
use super::types::{Bivector, Eventor, Scalar, Spacetime, Vector};
#[allow(unused_imports)]
use crate::ops::{
    Antidot, Antireverse, Antisandwich, Antiwedge, BulkContract, BulkExpand, Dot,
    InverseAntisandwich, InverseSandwich, Involute, LeftContract, Reverse, RightComplement,
    RightContract, Sandwich, ScalarProduct, Transform, Versor, VersorInverse, Wedge,
    WeightContract, WeightDual, WeightExpand,
};
use crate::scalar::Float;
#[allow(unused_imports)]
use crate::wrappers::Unit;
use approx::{AbsDiffEq, RelativeEq, UlpsEq};
use std::ops::{Add, Mul, Neg, Sub};
impl<T: Float> Add for Bivector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.xt() + rhs.xt())
    }
}
impl<T: Float> Sub for Bivector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.xt() - rhs.xt())
    }
}
impl<T: Float> Neg for Bivector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.xt())
    }
}
impl<T: Float> Mul<T> for Bivector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Bivector<f32>> for f32 {
    type Output = Bivector<f32>;
    #[inline]
    fn mul(self, v: Bivector<f32>) -> Bivector<f32> {
        v.scale(self)
    }
}
impl Mul<Bivector<f64>> for f64 {
    type Output = Bivector<f64>;
    #[inline]
    fn mul(self, v: Bivector<f64>) -> Bivector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.xt() * rhs.xt())
    }
}
impl<T: Float> Mul<Eventor<T>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn mul(self, rhs: Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(self.xt() * rhs.xt(), rhs.s() * self.xt())
    }
}
impl<T: Float> Mul<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.s() * self.xt())
    }
}
impl<T: Float> Mul<Spacetime<T>> for Bivector<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn mul(self, rhs: Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            self.xt() * rhs.xt(),
            -(self.xt() * rhs.t()),
            -(rhs.x() * self.xt()),
            rhs.s() * self.xt(),
        )
    }
}
impl<T: Float> Mul<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Vector<T>) -> Vector<T> {
        Vector::new_unchecked(-(self.xt() * rhs.t()), -(rhs.x() * self.xt()))
    }
}
impl<T: Float> Add for Eventor<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.s() + rhs.s(), self.xt() + rhs.xt())
    }
}
impl<T: Float> Sub for Eventor<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.s() - rhs.s(), self.xt() - rhs.xt())
    }
}
impl<T: Float> Neg for Eventor<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.s(), -self.xt())
    }
}
impl<T: Float> Mul<T> for Eventor<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Eventor<f32>> for f32 {
    type Output = Eventor<f32>;
    #[inline]
    fn mul(self, v: Eventor<f32>) -> Eventor<f32> {
        v.scale(self)
    }
}
impl Mul<Eventor<f64>> for f64 {
    type Output = Eventor<f64>;
    #[inline]
    fn mul(self, v: Eventor<f64>) -> Eventor<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Eventor<T> {
        Eventor::new_unchecked(self.xt() * rhs.xt(), self.s() * rhs.xt())
    }
}
impl<T: Float> Mul<Eventor<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn mul(self, rhs: Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            self.s() * rhs.xt() + rhs.s() * self.xt(),
            self.s() * rhs.s() + self.xt() * rhs.xt(),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Eventor<T> {
        Eventor::new_unchecked(self.s() * rhs.s(), rhs.s() * self.xt())
    }
}
impl<T: Float> Mul<Spacetime<T>> for Eventor<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn mul(self, rhs: Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            self.s() * rhs.s() + self.xt() * rhs.xt(),
            self.s() * rhs.x() + -(self.xt() * rhs.t()),
            self.s() * rhs.t() + -(rhs.x() * self.xt()),
            self.s() * rhs.xt() + rhs.s() * self.xt(),
        )
    }
}
impl<T: Float> Mul<Vector<T>> for Eventor<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.s() * rhs.t()) + -(rhs.x() * self.xt()),
            -(self.s() * rhs.x()) + -(self.xt() * rhs.t()),
        )
    }
}
impl<T: Float> Add for Scalar<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.s() + rhs.s())
    }
}
impl<T: Float> Sub for Scalar<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.s() - rhs.s())
    }
}
impl<T: Float> Neg for Scalar<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.s())
    }
}
impl<T: Float> Mul<T> for Scalar<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Scalar<f32>> for f32 {
    type Output = Scalar<f32>;
    #[inline]
    fn mul(self, v: Scalar<f32>) -> Scalar<f32> {
        v.scale(self)
    }
}
impl Mul<Scalar<f64>> for f64 {
    type Output = Scalar<f64>;
    #[inline]
    fn mul(self, v: Scalar<f64>) -> Scalar<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(self.s() * rhs.xt())
    }
}
impl<T: Float> Mul<Eventor<T>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn mul(self, rhs: Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(self.s() * rhs.s(), self.s() * rhs.xt())
    }
}
impl<T: Float> Mul<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
impl<T: Float> Mul<Spacetime<T>> for Scalar<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn mul(self, rhs: Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            self.s() * rhs.s(),
            self.s() * rhs.x(),
            self.s() * rhs.t(),
            self.s() * rhs.xt(),
        )
    }
}
impl<T: Float> Mul<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Vector<T>) -> Vector<T> {
        Vector::new_unchecked(self.s() * rhs.x(), self.s() * rhs.t())
    }
}
impl<T: Float> Add for Spacetime<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.s() + rhs.s(),
            self.x() + rhs.x(),
            self.t() + rhs.t(),
            self.xt() + rhs.xt(),
        )
    }
}
impl<T: Float> Sub for Spacetime<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.s() - rhs.s(),
            self.x() - rhs.x(),
            self.t() - rhs.t(),
            self.xt() - rhs.xt(),
        )
    }
}
impl<T: Float> Neg for Spacetime<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.s(), -self.x(), -self.t(), -self.xt())
    }
}
impl<T: Float> Mul<T> for Spacetime<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Spacetime<f32>> for f32 {
    type Output = Spacetime<f32>;
    #[inline]
    fn mul(self, v: Spacetime<f32>) -> Spacetime<f32> {
        v.scale(self)
    }
}
impl Mul<Spacetime<f64>> for f64 {
    type Output = Spacetime<f64>;
    #[inline]
    fn mul(self, v: Spacetime<f64>) -> Spacetime<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Spacetime<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            self.xt() * rhs.xt(),
            self.t() * rhs.xt(),
            self.x() * rhs.xt(),
            self.s() * rhs.xt(),
        )
    }
}
impl<T: Float> Mul<Eventor<T>> for Spacetime<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn mul(self, rhs: Eventor<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            self.s() * rhs.s() + self.xt() * rhs.xt(),
            self.x() * rhs.s() + self.t() * rhs.xt(),
            self.x() * rhs.xt() + rhs.s() * self.t(),
            self.s() * rhs.xt() + rhs.s() * self.xt(),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Spacetime<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            self.s() * rhs.s(),
            self.x() * rhs.s(),
            rhs.s() * self.t(),
            rhs.s() * self.xt(),
        )
    }
}
impl<T: Float> Mul<Spacetime<T>> for Spacetime<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn mul(self, rhs: Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            self.s() * rhs.s() + self.x() * rhs.x() + self.xt() * rhs.xt() + -(self.t() * rhs.t()),
            self.s() * rhs.x() + self.x() * rhs.s() + -(self.xt() * rhs.t()) + self.t() * rhs.xt(),
            self.s() * rhs.t() + self.x() * rhs.xt() + rhs.s() * self.t() + -(rhs.x() * self.xt()),
            self.s() * rhs.xt() + self.x() * rhs.t() + rhs.s() * self.xt() + -(rhs.x() * self.t()),
        )
    }
}
impl<T: Float> Mul<Vector<T>> for Spacetime<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn mul(self, rhs: Vector<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            self.x() * rhs.x() + -(self.t() * rhs.t()),
            self.s() * rhs.x() + -(self.xt() * rhs.t()),
            self.s() * rhs.t() + -(rhs.x() * self.xt()),
            self.x() * rhs.t() + -(rhs.x() * self.t()),
        )
    }
}
impl<T: Float> Add for Vector<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.x() + rhs.x(), self.t() + rhs.t())
    }
}
impl<T: Float> Sub for Vector<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.x() - rhs.x(), self.t() - rhs.t())
    }
}
impl<T: Float> Neg for Vector<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.x(), -self.t())
    }
}
impl<T: Float> Mul<T> for Vector<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Vector<f32>> for f32 {
    type Output = Vector<f32>;
    #[inline]
    fn mul(self, v: Vector<f32>) -> Vector<f32> {
        v.scale(self)
    }
}
impl Mul<Vector<f64>> for f64 {
    type Output = Vector<f64>;
    #[inline]
    fn mul(self, v: Vector<f64>) -> Vector<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Bivector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(self.t() * rhs.xt(), self.x() * rhs.xt())
    }
}
impl<T: Float> Mul<Eventor<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Eventor<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.x() * rhs.xt()) + rhs.s() * self.t(),
            self.x() * rhs.s() + -(self.t() * rhs.xt()),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(self.x() * rhs.s(), rhs.s() * self.t())
    }
}
impl<T: Float> Mul<Spacetime<T>> for Vector<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn mul(self, rhs: Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            self.x() * rhs.x() + -(self.t() * rhs.t()),
            self.x() * rhs.s() + self.t() * rhs.xt(),
            self.x() * rhs.xt() + rhs.s() * self.t(),
            self.x() * rhs.t() + -(rhs.x() * self.t()),
        )
    }
}
impl<T: Float> Mul<Vector<T>> for Vector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn mul(self, rhs: Vector<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            self.x() * rhs.t() + -(rhs.x() * self.t()),
            -(self.x() * rhs.x()) + self.t() * rhs.t(),
        )
    }
}
impl<T: Float> Wedge<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.s() * self.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.s() * self.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.as_inner().s() * self.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.as_inner().s() * self.as_inner().xt())
    }
}
impl<T: Float> Wedge<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(self.s() * rhs.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Bivector<T>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(self.as_inner().s() * rhs.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Bivector<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(self.s() * rhs.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Bivector<T>>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(self.as_inner().s() * rhs.as_inner().xt())
    }
}
impl<T: Float> Wedge<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.as_inner().s())
    }
}
impl<T: Float> Wedge<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(self.s() * rhs.x(), self.s() * rhs.t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Vector<T>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(self.as_inner().s() * rhs.x(), self.as_inner().s() * rhs.t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Vector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(self.s() * rhs.as_inner().x(), self.s() * rhs.as_inner().t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Vector<T>>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            self.as_inner().s() * rhs.as_inner().x(),
            self.as_inner().s() * rhs.as_inner().t(),
        )
    }
}
impl<T: Float> Wedge<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(self.x() * rhs.s(), rhs.s() * self.t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(self.as_inner().x() * rhs.s(), rhs.s() * self.as_inner().t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(self.x() * rhs.as_inner().s(), rhs.as_inner().s() * self.t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            self.as_inner().x() * rhs.as_inner().s(),
            rhs.as_inner().s() * self.as_inner().t(),
        )
    }
}
impl<T: Float> Wedge<Vector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(self.x() * rhs.t() + -(rhs.x() * self.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Vector<T>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(self.as_inner().x() * rhs.t() + -(rhs.x() * self.as_inner().t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Vector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(self.x() * rhs.as_inner().t() + -(rhs.as_inner().x() * self.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.as_inner().x() * rhs.as_inner().t() + -(rhs.as_inner().x() * self.as_inner().t()),
        )
    }
}
impl<T: Float> Antiwedge<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(self.xt() * rhs.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(self.as_inner().xt() * rhs.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(self.xt() * rhs.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(self.as_inner().xt() * rhs.as_inner().xt())
    }
}
impl<T: Float> Antiwedge<Scalar<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Scalar<T>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Scalar<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().s() * self.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Scalar<T>>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().s() * self.as_inner().xt())
    }
}
impl<T: Float> Antiwedge<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(-(rhs.x() * self.xt()), -(self.xt() * rhs.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Vector<T>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.x() * self.as_inner().xt()),
            -(self.as_inner().xt() * rhs.t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Vector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().x() * self.xt()),
            -(self.xt() * rhs.as_inner().t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Vector<T>>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(rhs.as_inner().x() * self.as_inner().xt()),
            -(self.as_inner().xt() * rhs.as_inner().t()),
        )
    }
}
impl<T: Float> Antiwedge<Bivector<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Bivector<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Bivector<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Bivector<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.as_inner().xt())
    }
}
impl<T: Float> Antiwedge<Bivector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(-(self.x() * rhs.xt()), -(self.t() * rhs.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Bivector<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.as_inner().x() * rhs.xt()),
            -(self.as_inner().t() * rhs.xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Bivector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.x() * rhs.as_inner().xt()),
            -(self.t() * rhs.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Bivector<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.as_inner().x() * rhs.as_inner().xt()),
            -(self.as_inner().t() * rhs.as_inner().xt()),
        )
    }
}
impl<T: Float> Antiwedge<Vector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.x() * rhs.t() + -(rhs.x() * self.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Vector<T>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().x() * rhs.t() + -(rhs.x() * self.as_inner().t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Vector<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.x() * rhs.as_inner().t() + -(rhs.as_inner().x() * self.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.as_inner().x() * rhs.as_inner().t() + -(rhs.as_inner().x() * self.as_inner().t()),
        )
    }
}
impl<T: Float> LeftContract<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.xt() * rhs.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().xt() * rhs.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.xt() * rhs.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().xt() * rhs.as_inner().xt())
    }
}
impl<T: Float> LeftContract<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(self.s() * rhs.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Bivector<T>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(self.as_inner().s() * rhs.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Bivector<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(self.s() * rhs.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Bivector<T>>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(self.as_inner().s() * rhs.as_inner().xt())
    }
}
impl<T: Float> LeftContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.as_inner().s())
    }
}
impl<T: Float> LeftContract<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(self.s() * rhs.x(), self.s() * rhs.t())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Vector<T>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(self.as_inner().s() * rhs.x(), self.as_inner().s() * rhs.t())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Vector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(self.s() * rhs.as_inner().x(), self.s() * rhs.as_inner().t())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Vector<T>>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            self.as_inner().s() * rhs.as_inner().x(),
            self.as_inner().s() * rhs.as_inner().t(),
        )
    }
}
impl<T: Float> LeftContract<Bivector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(self.t() * rhs.xt(), self.x() * rhs.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Bivector<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            self.as_inner().t() * rhs.xt(),
            self.as_inner().x() * rhs.xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Bivector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            self.t() * rhs.as_inner().xt(),
            self.x() * rhs.as_inner().xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Bivector<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            self.as_inner().t() * rhs.as_inner().xt(),
            self.as_inner().x() * rhs.as_inner().xt(),
        )
    }
}
impl<T: Float> LeftContract<Vector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.x() * rhs.x() + -(self.t() * rhs.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Vector<T>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().x() * rhs.x() + -(self.as_inner().t() * rhs.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Vector<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.x() * rhs.as_inner().x() + -(self.t() * rhs.as_inner().t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.as_inner().x() * rhs.as_inner().x() + -(self.as_inner().t() * rhs.as_inner().t()),
        )
    }
}
impl<T: Float> RightContract<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.xt() * rhs.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().xt() * rhs.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.xt() * rhs.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().xt() * rhs.as_inner().xt())
    }
}
impl<T: Float> RightContract<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.s() * self.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.s() * self.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.as_inner().s() * self.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.as_inner().s() * self.as_inner().xt())
    }
}
impl<T: Float> RightContract<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(-(self.xt() * rhs.t()), -(rhs.x() * self.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Vector<T>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.as_inner().xt() * rhs.t()),
            -(rhs.x() * self.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Vector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.xt() * rhs.as_inner().t()),
            -(rhs.as_inner().x() * self.xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Vector<T>>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.as_inner().xt() * rhs.as_inner().t()),
            -(rhs.as_inner().x() * self.as_inner().xt()),
        )
    }
}
impl<T: Float> RightContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.as_inner().s())
    }
}
impl<T: Float> RightContract<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(self.x() * rhs.s(), rhs.s() * self.t())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(self.as_inner().x() * rhs.s(), rhs.s() * self.as_inner().t())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(self.x() * rhs.as_inner().s(), rhs.as_inner().s() * self.t())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            self.as_inner().x() * rhs.as_inner().s(),
            rhs.as_inner().s() * self.as_inner().t(),
        )
    }
}
impl<T: Float> RightContract<Vector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.x() * rhs.x() + -(self.t() * rhs.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Vector<T>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().x() * rhs.x() + -(self.as_inner().t() * rhs.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Vector<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.x() * rhs.as_inner().x() + -(self.t() * rhs.as_inner().t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.as_inner().x() * rhs.as_inner().x() + -(self.as_inner().t() * rhs.as_inner().t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(-(self.xt() * operand.xt() * self.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(operand.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(-(self.xt() * self.xt() * operand.as_inner().xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(operand.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(self.xt() * operand.s() * self.xt()),
            -(self.xt() * operand.xt() * self.xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Unit<Bivector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(operand.s(), operand.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.as_inner().s() * self.xt() * self.xt()),
            -(self.xt() * self.xt() * operand.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Unit<Bivector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(operand.as_inner().s(), operand.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.xt() * operand.s() * self.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.as_inner().s() * self.xt() * self.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Spacetime<T>> for Bivector<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn sandwich(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            -(self.xt() * operand.s() * self.xt()),
            self.xt() * operand.x() * self.xt(),
            self.xt() * operand.t() * self.xt(),
            -(self.xt() * operand.xt() * self.xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Spacetime<T>> for Unit<Bivector<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn sandwich(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(operand.s(), -(operand.x()), -(operand.t()), operand.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Spacetime<T>>> for Bivector<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            -(operand.as_inner().s() * self.xt() * self.xt()),
            operand.as_inner().x() * self.xt() * self.xt(),
            self.xt() * self.xt() * operand.as_inner().t(),
            -(self.xt() * self.xt() * operand.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Spacetime<T>>> for Unit<Bivector<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            operand.as_inner().s(),
            -(operand.as_inner().x()),
            -(operand.as_inner().t()),
            operand.as_inner().xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            self.xt() * operand.x() * self.xt(),
            self.xt() * operand.t() * self.xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(-(operand.x()), -(operand.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            operand.as_inner().x() * self.xt() * self.xt(),
            self.xt() * self.xt() * operand.as_inner().t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(-(operand.as_inner().x()), -(operand.as_inner().t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Eventor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.s() * operand.xt() * self.s() - self.xt() * operand.xt() * self.xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Unit<Eventor<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(operand.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Eventor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.s() * self.s() * operand.as_inner().xt()
                + -(self.xt() * self.xt() * operand.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Unit<Eventor<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(operand.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(self.xt() * operand.s() * self.xt()) - self.s() * operand.xt() * self.xt()
                + self.xt() * operand.xt() * self.s()
                + self.s() * operand.s() * self.s(),
            self.s() * operand.xt() * self.s() + self.xt() * operand.s() * self.s()
                - self.s() * operand.s() * self.xt()
                - self.xt() * operand.xt() * self.xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Unit<Eventor<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(operand.s(), operand.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.as_inner().s() * self.xt() * self.xt())
                + self.s() * self.s() * operand.as_inner().s(),
            self.s() * self.s() * operand.as_inner().xt()
                + -(self.xt() * self.xt() * operand.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Unit<Eventor<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(operand.as_inner().s(), operand.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Eventor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.s() * operand.s() * self.s() - self.xt() * operand.s() * self.xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unit<Eventor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Eventor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(operand.as_inner().s() * self.xt() * self.xt())
                + self.s() * self.s() * operand.as_inner().s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Unit<Eventor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Spacetime<T>> for Eventor<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn sandwich(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            -(self.s() * operand.xt() * self.xt()) - self.xt() * operand.s() * self.xt()
                + self.s() * operand.s() * self.s()
                + self.xt() * operand.xt() * self.s(),
            -(self.xt() * operand.t() * self.s())
                + self.xt() * operand.x() * self.xt()
                + self.s() * operand.x() * self.s()
                - self.s() * operand.t() * self.xt(),
            -(self.xt() * operand.x() * self.s()) - self.s() * operand.x() * self.xt()
                + self.s() * operand.t() * self.s()
                + self.xt() * operand.t() * self.xt(),
            -(self.xt() * operand.xt() * self.xt()) + self.xt() * operand.s() * self.s()
                - self.s() * operand.s() * self.xt()
                + self.s() * operand.xt() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Spacetime<T>> for Unit<Eventor<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn sandwich(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            operand.s(),
            operand.x()
                + T::TWO * operand.x() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * self.as_inner().s() * self.as_inner().xt() * operand.t(),
            operand.t()
                + T::TWO * self.as_inner().xt() * self.as_inner().xt() * operand.t()
                + -T::TWO * self.as_inner().s() * operand.x() * self.as_inner().xt(),
            operand.xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Spacetime<T>>> for Eventor<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            -(operand.as_inner().s() * self.xt() * self.xt())
                + self.s() * self.s() * operand.as_inner().s(),
            operand.as_inner().x() * self.xt() * self.xt()
                + self.s() * self.s() * operand.as_inner().x()
                + -T::TWO * self.s() * self.xt() * operand.as_inner().t(),
            self.s() * self.s() * operand.as_inner().t()
                + self.xt() * self.xt() * operand.as_inner().t()
                + -T::TWO * self.s() * operand.as_inner().x() * self.xt(),
            self.s() * self.s() * operand.as_inner().xt()
                + -(self.xt() * self.xt() * operand.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Spacetime<T>>> for Unit<Eventor<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            operand.as_inner().s(),
            operand.as_inner().x()
                + T::TWO * operand.as_inner().x() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * self.as_inner().s() * self.as_inner().xt() * operand.as_inner().t(),
            operand.as_inner().t()
                + T::TWO * self.as_inner().xt() * self.as_inner().xt() * operand.as_inner().t()
                + -T::TWO * self.as_inner().s() * operand.as_inner().x() * self.as_inner().xt(),
            operand.as_inner().xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Eventor<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            self.s() * operand.x() * self.s()
                - self.xt() * operand.t() * self.s()
                - self.s() * operand.t() * self.xt()
                + self.xt() * operand.x() * self.xt(),
            self.s() * operand.t() * self.s() - self.s() * operand.x() * self.xt()
                + self.xt() * operand.t() * self.xt()
                - self.xt() * operand.x() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Unit<Eventor<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            operand.x()
                + T::TWO * operand.x() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * self.as_inner().s() * self.as_inner().xt() * operand.t(),
            operand.t()
                + T::TWO * self.as_inner().xt() * self.as_inner().xt() * operand.t()
                + -T::TWO * self.as_inner().s() * operand.x() * self.as_inner().xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Eventor<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            operand.as_inner().x() * self.xt() * self.xt()
                + self.s() * self.s() * operand.as_inner().x()
                + -T::TWO * self.s() * self.xt() * operand.as_inner().t(),
            self.s() * self.s() * operand.as_inner().t()
                + self.xt() * self.xt() * operand.as_inner().t()
                + -T::TWO * self.s() * operand.as_inner().x() * self.xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Unit<Eventor<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            operand.as_inner().x()
                + T::TWO * operand.as_inner().x() * self.as_inner().xt() * self.as_inner().xt()
                + -T::TWO * self.as_inner().s() * self.as_inner().xt() * operand.as_inner().t(),
            operand.as_inner().t()
                + T::TWO * self.as_inner().xt() * self.as_inner().xt() * operand.as_inner().t()
                + -T::TWO * self.as_inner().s() * operand.as_inner().x() * self.as_inner().xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(self.s() * operand.xt() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(operand.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(self.s() * self.s() * operand.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(operand.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            self.s() * operand.s() * self.s(),
            self.s() * operand.xt() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Unit<Scalar<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(operand.s(), operand.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            self.s() * self.s() * operand.as_inner().s(),
            self.s() * self.s() * operand.as_inner().xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Unit<Scalar<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(operand.as_inner().s(), operand.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * operand.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * self.s() * operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Spacetime<T>> for Scalar<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn sandwich(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            self.s() * operand.s() * self.s(),
            self.s() * operand.x() * self.s(),
            self.s() * operand.t() * self.s(),
            self.s() * operand.xt() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Spacetime<T>> for Unit<Scalar<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn sandwich(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(operand.s(), operand.x(), operand.t(), operand.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Spacetime<T>>> for Scalar<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            self.s() * self.s() * operand.as_inner().s(),
            self.s() * self.s() * operand.as_inner().x(),
            self.s() * self.s() * operand.as_inner().t(),
            self.s() * self.s() * operand.as_inner().xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Spacetime<T>>> for Unit<Scalar<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            operand.as_inner().s(),
            operand.as_inner().x(),
            operand.as_inner().t(),
            operand.as_inner().xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            self.s() * operand.x() * self.s(),
            self.s() * operand.t() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(operand.x(), operand.t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            self.s() * self.s() * operand.as_inner().x(),
            self.s() * self.s() * operand.as_inner().t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(operand.as_inner().x(), operand.as_inner().t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(self.x() * operand.xt() * self.x()) + self.t() * operand.xt() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Bivector<T>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(-(operand.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(self.x() * self.x() * operand.as_inner().xt())
                + self.t() * self.t() * operand.as_inner().xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Bivector<T>>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(-(operand.as_inner().xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Vector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            self.t() * operand.xt() * self.x() - self.x() * operand.xt() * self.t()
                + self.x() * operand.s() * self.x()
                - self.t() * operand.s() * self.t(),
            -(self.t() * operand.s() * self.x())
                + self.x() * operand.s() * self.t()
                + self.t() * operand.xt() * self.t()
                - self.x() * operand.xt() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Eventor<T>> for Unit<Vector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(operand.s(), -(operand.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Vector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(operand.as_inner().s() * self.t() * self.t())
                + self.x() * self.x() * operand.as_inner().s(),
            -(self.x() * self.x() * operand.as_inner().xt())
                + self.t() * self.t() * operand.as_inner().xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Eventor<T>>> for Unit<Vector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(operand.as_inner().s(), -(operand.as_inner().xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.t() * operand.s() * self.t()) + self.x() * operand.s() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(operand.as_inner().s() * self.t() * self.t())
                + self.x() * self.x() * operand.as_inner().s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Spacetime<T>> for Vector<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn sandwich(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            -(self.t() * operand.s() * self.t()) - self.x() * operand.xt() * self.t()
                + self.x() * operand.s() * self.x()
                + self.t() * operand.xt() * self.x(),
            -(self.t() * operand.t() * self.x())
                + self.x() * operand.x() * self.x()
                + self.t() * operand.x() * self.t()
                - self.x() * operand.t() * self.t(),
            self.x() * operand.x() * self.t()
                - self.x() * operand.t() * self.x()
                - self.t() * operand.t() * self.t()
                + self.t() * operand.x() * self.x(),
            -(self.t() * operand.s() * self.x()) - self.x() * operand.xt() * self.x()
                + self.x() * operand.s() * self.t()
                + self.t() * operand.xt() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Spacetime<T>> for Unit<Vector<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn sandwich(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            operand.s(),
            operand.x()
                + T::TWO * operand.x() * self.as_inner().t() * self.as_inner().t()
                + -T::TWO * self.as_inner().x() * self.as_inner().t() * operand.t(),
            -(operand.t())
                + -T::TWO * self.as_inner().t() * self.as_inner().t() * operand.t()
                + T::TWO * self.as_inner().x() * operand.x() * self.as_inner().t(),
            -(operand.xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Spacetime<T>>> for Vector<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            -(operand.as_inner().s() * self.t() * self.t())
                + self.x() * self.x() * operand.as_inner().s(),
            operand.as_inner().x() * self.t() * self.t()
                + self.x() * self.x() * operand.as_inner().x()
                + -T::TWO * self.x() * self.t() * operand.as_inner().t(),
            -(self.x() * self.x() * operand.as_inner().t())
                + -(self.t() * self.t() * operand.as_inner().t())
                + T::TWO * self.x() * operand.as_inner().x() * self.t(),
            -(self.x() * self.x() * operand.as_inner().xt())
                + self.t() * self.t() * operand.as_inner().xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Spacetime<T>>> for Unit<Vector<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            operand.as_inner().s(),
            operand.as_inner().x()
                + T::TWO * operand.as_inner().x() * self.as_inner().t() * self.as_inner().t()
                + -T::TWO * self.as_inner().x() * self.as_inner().t() * operand.as_inner().t(),
            -(operand.as_inner().t())
                + -T::TWO * self.as_inner().t() * self.as_inner().t() * operand.as_inner().t()
                + T::TWO * self.as_inner().x() * operand.as_inner().x() * self.as_inner().t(),
            -(operand.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.t() * operand.t() * self.x())
                + self.t() * operand.x() * self.t()
                + self.x() * operand.x() * self.x()
                - self.x() * operand.t() * self.t(),
            self.t() * operand.x() * self.x() - self.x() * operand.t() * self.x()
                + self.x() * operand.x() * self.t()
                - self.t() * operand.t() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Vector<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            operand.x()
                + T::TWO * operand.x() * self.as_inner().t() * self.as_inner().t()
                + -T::TWO * self.as_inner().x() * self.as_inner().t() * operand.t(),
            -(operand.t())
                + -T::TWO * self.as_inner().t() * self.as_inner().t() * operand.t()
                + T::TWO * self.as_inner().x() * operand.x() * self.as_inner().t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            operand.as_inner().x() * self.t() * self.t()
                + self.x() * self.x() * operand.as_inner().x()
                + -T::TWO * self.x() * self.t() * operand.as_inner().t(),
            -(self.x() * self.x() * operand.as_inner().t())
                + -(self.t() * self.t() * operand.as_inner().t())
                + T::TWO * self.x() * operand.as_inner().x() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            operand.as_inner().x()
                + T::TWO * operand.as_inner().x() * self.as_inner().t() * self.as_inner().t()
                + -T::TWO * self.as_inner().x() * self.as_inner().t() * operand.as_inner().t(),
            -(operand.as_inner().t())
                + -T::TWO * self.as_inner().t() * self.as_inner().t() * operand.as_inner().t()
                + T::TWO * self.as_inner().x() * operand.as_inner().x() * self.as_inner().t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(self.xt() * operand.xt() * self.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(-(operand.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(self.xt() * self.xt() * operand.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(-(operand.as_inner().xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            self.xt() * operand.s() * self.xt(),
            self.xt() * operand.xt() * self.xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Unit<Bivector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(-(operand.s()), -(operand.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            operand.as_inner().s() * self.xt() * self.xt(),
            self.xt() * self.xt() * operand.as_inner().xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Unit<Bivector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(-(operand.as_inner().s()), -(operand.as_inner().xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.xt() * operand.s() * self.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s() * self.xt() * self.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Spacetime<T>> for Bivector<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn antisandwich(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            self.xt() * operand.s() * self.xt(),
            self.xt() * operand.x() * self.xt(),
            self.xt() * operand.t() * self.xt(),
            self.xt() * operand.xt() * self.xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Spacetime<T>> for Unit<Bivector<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn antisandwich(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            -(operand.s()),
            -(operand.x()),
            -(operand.t()),
            -(operand.xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Spacetime<T>>> for Bivector<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            operand.as_inner().s() * self.xt() * self.xt(),
            operand.as_inner().x() * self.xt() * self.xt(),
            self.xt() * self.xt() * operand.as_inner().t(),
            self.xt() * self.xt() * operand.as_inner().xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Spacetime<T>>> for Unit<Bivector<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            -(operand.as_inner().s()),
            -(operand.as_inner().x()),
            -(operand.as_inner().t()),
            -(operand.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            self.xt() * operand.x() * self.xt(),
            self.xt() * operand.t() * self.xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(-(operand.x()), -(operand.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            operand.as_inner().x() * self.xt() * self.xt(),
            self.xt() * self.xt() * operand.as_inner().t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(-(operand.as_inner().x()), -(operand.as_inner().t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Eventor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.xt() * operand.xt() * self.xt() - self.s() * operand.xt() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Unit<Eventor<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(-(operand.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Eventor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            -(self.s() * self.s() * operand.as_inner().xt())
                + self.xt() * self.xt() * operand.as_inner().xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Unit<Eventor<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(-(operand.as_inner().xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(self.s() * operand.s() * self.s()) + self.xt() * operand.s() * self.xt()
                - self.xt() * operand.xt() * self.s()
                + self.s() * operand.xt() * self.xt(),
            -(self.s() * operand.xt() * self.s()) + self.s() * operand.s() * self.xt()
                - self.xt() * operand.s() * self.s()
                + self.xt() * operand.xt() * self.xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Unit<Eventor<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(-(operand.s()), -(operand.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            operand.as_inner().s() * self.xt() * self.xt()
                + -(self.s() * self.s() * operand.as_inner().s()),
            -(self.s() * self.s() * operand.as_inner().xt())
                + self.xt() * self.xt() * operand.as_inner().xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Unit<Eventor<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(-(operand.as_inner().s()), -(operand.as_inner().xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Eventor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.s() * operand.s() * self.s()) + self.xt() * operand.s() * self.xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unit<Eventor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Eventor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            operand.as_inner().s() * self.xt() * self.xt()
                + -(self.s() * self.s() * operand.as_inner().s()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Unit<Eventor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Spacetime<T>> for Eventor<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn antisandwich(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            self.xt() * operand.s() * self.xt() - self.s() * operand.s() * self.s()
                + self.s() * operand.xt() * self.xt()
                - self.xt() * operand.xt() * self.s(),
            self.s() * operand.x() * self.s()
                + self.xt() * operand.t() * self.s()
                + self.s() * operand.t() * self.xt()
                + self.xt() * operand.x() * self.xt(),
            self.xt() * operand.t() * self.xt()
                + self.xt() * operand.x() * self.s()
                + self.s() * operand.x() * self.xt()
                + self.s() * operand.t() * self.s(),
            -(self.xt() * operand.s() * self.s())
                + self.xt() * operand.xt() * self.xt()
                + self.s() * operand.s() * self.xt()
                - self.s() * operand.xt() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Spacetime<T>> for Unit<Eventor<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn antisandwich(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            -(operand.s()),
            operand.x()
                + T::TWO * operand.x() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * self.as_inner().s() * self.as_inner().xt() * operand.t(),
            operand.t()
                + T::TWO * self.as_inner().xt() * self.as_inner().xt() * operand.t()
                + T::TWO * self.as_inner().s() * operand.x() * self.as_inner().xt(),
            -(operand.xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Spacetime<T>>> for Eventor<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            operand.as_inner().s() * self.xt() * self.xt()
                + -(self.s() * self.s() * operand.as_inner().s()),
            operand.as_inner().x() * self.xt() * self.xt()
                + self.s() * self.s() * operand.as_inner().x()
                + T::TWO * self.s() * self.xt() * operand.as_inner().t(),
            self.s() * self.s() * operand.as_inner().t()
                + self.xt() * self.xt() * operand.as_inner().t()
                + T::TWO * self.s() * operand.as_inner().x() * self.xt(),
            -(self.s() * self.s() * operand.as_inner().xt())
                + self.xt() * self.xt() * operand.as_inner().xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Spacetime<T>>> for Unit<Eventor<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            -(operand.as_inner().s()),
            operand.as_inner().x()
                + T::TWO * operand.as_inner().x() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * self.as_inner().s() * self.as_inner().xt() * operand.as_inner().t(),
            operand.as_inner().t()
                + T::TWO * self.as_inner().xt() * self.as_inner().xt() * operand.as_inner().t()
                + T::TWO * self.as_inner().s() * operand.as_inner().x() * self.as_inner().xt(),
            -(operand.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Eventor<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            self.xt() * operand.t() * self.s()
                + self.xt() * operand.x() * self.xt()
                + self.s() * operand.x() * self.s()
                + self.s() * operand.t() * self.xt(),
            self.s() * operand.t() * self.s()
                + self.s() * operand.x() * self.xt()
                + self.xt() * operand.t() * self.xt()
                + self.xt() * operand.x() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Unit<Eventor<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            operand.x()
                + T::TWO * operand.x() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * self.as_inner().s() * self.as_inner().xt() * operand.t(),
            operand.t()
                + T::TWO * self.as_inner().xt() * self.as_inner().xt() * operand.t()
                + T::TWO * self.as_inner().s() * operand.x() * self.as_inner().xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Eventor<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            operand.as_inner().x() * self.xt() * self.xt()
                + self.s() * self.s() * operand.as_inner().x()
                + T::TWO * self.s() * self.xt() * operand.as_inner().t(),
            self.s() * self.s() * operand.as_inner().t()
                + self.xt() * self.xt() * operand.as_inner().t()
                + T::TWO * self.s() * operand.as_inner().x() * self.xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Unit<Eventor<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            operand.as_inner().x()
                + T::TWO * operand.as_inner().x() * self.as_inner().xt() * self.as_inner().xt()
                + T::TWO * self.as_inner().s() * self.as_inner().xt() * operand.as_inner().t(),
            operand.as_inner().t()
                + T::TWO * self.as_inner().xt() * self.as_inner().xt() * operand.as_inner().t()
                + T::TWO * self.as_inner().s() * operand.as_inner().x() * self.as_inner().xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(-(self.s() * operand.xt() * self.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(-(operand.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(-(self.s() * self.s() * operand.as_inner().xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(-(operand.as_inner().xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(self.s() * operand.s() * self.s()),
            -(self.s() * operand.xt() * self.s()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Unit<Scalar<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(-(operand.s()), -(operand.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            -(self.s() * self.s() * operand.as_inner().s()),
            -(self.s() * self.s() * operand.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Unit<Scalar<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(-(operand.as_inner().s()), -(operand.as_inner().xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.s() * operand.s() * self.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.s() * self.s() * operand.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Spacetime<T>> for Scalar<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn antisandwich(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            -(self.s() * operand.s() * self.s()),
            self.s() * operand.x() * self.s(),
            self.s() * operand.t() * self.s(),
            -(self.s() * operand.xt() * self.s()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Spacetime<T>> for Unit<Scalar<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn antisandwich(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(-(operand.s()), operand.x(), operand.t(), -(operand.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Spacetime<T>>> for Scalar<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            -(self.s() * self.s() * operand.as_inner().s()),
            self.s() * self.s() * operand.as_inner().x(),
            self.s() * self.s() * operand.as_inner().t(),
            -(self.s() * self.s() * operand.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Spacetime<T>>> for Unit<Scalar<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            -(operand.as_inner().s()),
            operand.as_inner().x(),
            operand.as_inner().t(),
            -(operand.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            self.s() * operand.x() * self.s(),
            self.s() * operand.t() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(operand.x(), operand.t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            self.s() * self.s() * operand.as_inner().x(),
            self.s() * self.s() * operand.as_inner().t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(operand.as_inner().x(), operand.as_inner().t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.x() * operand.xt() * self.x() - self.t() * operand.xt() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Bivector<T>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(operand.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.x() * self.x() * operand.as_inner().xt()
                + -(self.t() * self.t() * operand.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Bivector<T>>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(operand.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Vector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(
            self.t() * operand.s() * self.t() + self.t() * operand.xt() * self.x()
                - self.x() * operand.xt() * self.t()
                - self.x() * operand.s() * self.x(),
            self.x() * operand.xt() * self.x() + self.x() * operand.s() * self.t()
                - self.t() * operand.s() * self.x()
                - self.t() * operand.xt() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Eventor<T>> for Unit<Vector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Eventor<T>) -> Eventor<T> {
        Eventor::new_unchecked(-(operand.s()), operand.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Vector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(
            operand.as_inner().s() * self.t() * self.t()
                + -(self.x() * self.x() * operand.as_inner().s()),
            self.x() * self.x() * operand.as_inner().xt()
                + -(self.t() * self.t() * operand.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Eventor<T>>> for Unit<Vector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        Eventor::new_unchecked(-(operand.as_inner().s()), operand.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.x() * operand.s() * self.x()) + self.t() * operand.s() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            operand.as_inner().s() * self.t() * self.t()
                + -(self.x() * self.x() * operand.as_inner().s()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(operand.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Spacetime<T>> for Vector<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn antisandwich(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            self.t() * operand.s() * self.t() - self.x() * operand.s() * self.x()
                + self.t() * operand.xt() * self.x()
                - self.x() * operand.xt() * self.t(),
            -(self.t() * operand.t() * self.x())
                + self.t() * operand.x() * self.t()
                + self.x() * operand.x() * self.x()
                - self.x() * operand.t() * self.t(),
            -(self.t() * operand.t() * self.t()) - self.x() * operand.t() * self.x()
                + self.t() * operand.x() * self.x()
                + self.x() * operand.x() * self.t(),
            self.x() * operand.s() * self.t() - self.t() * operand.xt() * self.t()
                + self.x() * operand.xt() * self.x()
                - self.t() * operand.s() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Spacetime<T>> for Unit<Vector<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn antisandwich(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            -(operand.s()),
            operand.x()
                + T::TWO * operand.x() * self.as_inner().t() * self.as_inner().t()
                + -T::TWO * self.as_inner().x() * self.as_inner().t() * operand.t(),
            -(operand.t())
                + -T::TWO * self.as_inner().t() * self.as_inner().t() * operand.t()
                + T::TWO * self.as_inner().x() * operand.x() * self.as_inner().t(),
            operand.xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Spacetime<T>>> for Vector<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            operand.as_inner().s() * self.t() * self.t()
                + -(self.x() * self.x() * operand.as_inner().s()),
            operand.as_inner().x() * self.t() * self.t()
                + self.x() * self.x() * operand.as_inner().x()
                + -T::TWO * self.x() * self.t() * operand.as_inner().t(),
            -(self.x() * self.x() * operand.as_inner().t())
                + -(self.t() * self.t() * operand.as_inner().t())
                + T::TWO * self.x() * operand.as_inner().x() * self.t(),
            self.x() * self.x() * operand.as_inner().xt()
                + -(self.t() * self.t() * operand.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Spacetime<T>>> for Unit<Vector<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        Spacetime::new_unchecked(
            -(operand.as_inner().s()),
            operand.as_inner().x()
                + T::TWO * operand.as_inner().x() * self.as_inner().t() * self.as_inner().t()
                + -T::TWO * self.as_inner().x() * self.as_inner().t() * operand.as_inner().t(),
            -(operand.as_inner().t())
                + -T::TWO * self.as_inner().t() * self.as_inner().t() * operand.as_inner().t()
                + T::TWO * self.as_inner().x() * operand.as_inner().x() * self.as_inner().t(),
            operand.as_inner().xt(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.x() * operand.t() * self.t()) + self.t() * operand.x() * self.t()
                - self.t() * operand.t() * self.x()
                + self.x() * operand.x() * self.x(),
            -(self.x() * operand.t() * self.x())
                + self.t() * operand.x() * self.x()
                + self.x() * operand.x() * self.t()
                - self.t() * operand.t() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Vector<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            operand.x()
                + T::TWO * operand.x() * self.as_inner().t() * self.as_inner().t()
                + -T::TWO * self.as_inner().x() * self.as_inner().t() * operand.t(),
            -(operand.t())
                + -T::TWO * self.as_inner().t() * self.as_inner().t() * operand.t()
                + T::TWO * self.as_inner().x() * operand.x() * self.as_inner().t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            operand.as_inner().x() * self.t() * self.t()
                + self.x() * self.x() * operand.as_inner().x()
                + -T::TWO * self.x() * self.t() * operand.as_inner().t(),
            -(self.x() * self.x() * operand.as_inner().t())
                + -(self.t() * self.t() * operand.as_inner().t())
                + T::TWO * self.x() * operand.as_inner().x() * self.t(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            operand.as_inner().x()
                + T::TWO * operand.as_inner().x() * self.as_inner().t() * self.as_inner().t()
                + -T::TWO * self.as_inner().x() * self.as_inner().t() * operand.as_inner().t(),
            -(operand.as_inner().t())
                + -T::TWO * self.as_inner().t() * self.as_inner().t() * operand.as_inner().t()
                + T::TWO * self.as_inner().x() * operand.as_inner().x() * self.as_inner().t(),
        )
    }
}
impl<T: Float> Transform<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Unit<Bivector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Unit<Bivector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Spacetime<T>> for Bivector<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn transform(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Spacetime<T>> for Unit<Bivector<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn transform(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Spacetime<T>>> for Bivector<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Spacetime<T>>> for Unit<Bivector<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Eventor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Unit<Eventor<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Eventor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Unit<Eventor<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Unit<Eventor<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Unit<Eventor<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Eventor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unit<Eventor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Eventor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Unit<Eventor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Spacetime<T>> for Eventor<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn transform(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Spacetime<T>> for Unit<Eventor<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn transform(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Spacetime<T>>> for Eventor<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Spacetime<T>>> for Unit<Eventor<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Eventor<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Unit<Eventor<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Eventor<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Unit<Eventor<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Unit<Scalar<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Unit<Scalar<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Spacetime<T>> for Scalar<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn transform(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Spacetime<T>> for Unit<Scalar<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn transform(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Spacetime<T>>> for Scalar<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Spacetime<T>>> for Unit<Scalar<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Bivector<T>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Bivector<T>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Bivector<T>>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Bivector<T>>) -> Bivector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Vector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Eventor<T>> for Unit<Vector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Eventor<T>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Vector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Eventor<T>>> for Unit<Vector<T>> {
    type Output = Eventor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Eventor<T>>) -> Eventor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Spacetime<T>> for Vector<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn transform(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Spacetime<T>> for Unit<Vector<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn transform(&self, operand: &Spacetime<T>) -> Spacetime<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Spacetime<T>>> for Vector<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Spacetime<T>>> for Unit<Vector<T>> {
    type Output = Spacetime<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Spacetime<T>>) -> Spacetime<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Vector<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Vector<T>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Vector<T>>) -> Vector<T> {
        self.sandwich(operand)
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (-(self.xt() * operand.xt() * self.xt())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Eventor<T>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (-(self.xt() * operand.s() * self.xt())) * inv_norm_sq,
            (-(self.xt() * operand.xt() * self.xt())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (-(self.xt() * operand.s() * self.xt())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Spacetime<T>> for Bivector<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Spacetime<T>) -> Option<Spacetime<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Spacetime::new_unchecked(
            (-(self.xt() * operand.s() * self.xt())) * inv_norm_sq,
            (self.xt() * operand.x() * self.xt()) * inv_norm_sq,
            (self.xt() * operand.t() * self.xt()) * inv_norm_sq,
            (-(self.xt() * operand.xt() * self.xt())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (self.xt() * operand.x() * self.xt()) * inv_norm_sq,
            (self.xt() * operand.t() * self.xt()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Bivector<T>> for Eventor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (-(self.xt() * operand.xt() * self.xt()) + self.s() * operand.xt() * self.s())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Eventor<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (self.s() * operand.s() * self.s() + self.xt() * operand.xt() * self.s()
                - self.xt() * operand.s() * self.xt()
                - self.s() * operand.xt() * self.xt())
                * inv_norm_sq,
            (-(self.s() * operand.s() * self.xt()) - self.xt() * operand.xt() * self.xt()
                + self.xt() * operand.s() * self.s()
                + self.s() * operand.xt() * self.s())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Eventor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.s() * operand.s() * self.s() - self.xt() * operand.s() * self.xt()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Spacetime<T>> for Eventor<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Spacetime<T>) -> Option<Spacetime<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Spacetime::new_unchecked(
            (-(self.xt() * operand.s() * self.xt())
                + self.xt() * operand.xt() * self.s()
                + self.s() * operand.s() * self.s()
                - self.s() * operand.xt() * self.xt())
                * inv_norm_sq,
            (-(self.xt() * operand.t() * self.s()) + self.s() * operand.x() * self.s()
                - self.s() * operand.t() * self.xt()
                + self.xt() * operand.x() * self.xt())
                * inv_norm_sq,
            (self.xt() * operand.t() * self.xt() - self.s() * operand.x() * self.xt()
                + self.s() * operand.t() * self.s()
                - self.xt() * operand.x() * self.s())
                * inv_norm_sq,
            (self.xt() * operand.s() * self.s() - self.s() * operand.s() * self.xt()
                + self.s() * operand.xt() * self.s()
                - self.xt() * operand.xt() * self.xt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Vector<T>> for Eventor<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (-(self.s() * operand.t() * self.xt()) + self.xt() * operand.x() * self.xt()
                - self.xt() * operand.t() * self.s()
                + self.s() * operand.x() * self.s())
                * inv_norm_sq,
            (-(self.xt() * operand.x() * self.s()) + self.s() * operand.t() * self.s()
                - self.s() * operand.x() * self.xt()
                + self.xt() * operand.t() * self.xt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (self.s() * operand.xt() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Eventor<T>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (self.s() * operand.s() * self.s()) * inv_norm_sq,
            (self.s() * operand.xt() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.s() * operand.s() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Spacetime<T>> for Scalar<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Spacetime<T>) -> Option<Spacetime<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Spacetime::new_unchecked(
            (self.s() * operand.s() * self.s()) * inv_norm_sq,
            (self.s() * operand.x() * self.s()) * inv_norm_sq,
            (self.s() * operand.t() * self.s()) * inv_norm_sq,
            (self.s() * operand.xt() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (self.s() * operand.x() * self.s()) * inv_norm_sq,
            (self.s() * operand.t() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Bivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (-(self.x() * operand.xt() * self.x()) + self.t() * operand.xt() * self.t())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Eventor<T>> for Vector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (self.t() * operand.xt() * self.x() + self.x() * operand.s() * self.x()
                - self.t() * operand.s() * self.t()
                - self.x() * operand.xt() * self.t())
                * inv_norm_sq,
            (-(self.t() * operand.s() * self.x()) + self.t() * operand.xt() * self.t()
                - self.x() * operand.xt() * self.x()
                + self.x() * operand.s() * self.t())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.x() * operand.s() * self.x() - self.t() * operand.s() * self.t()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Spacetime<T>> for Vector<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Spacetime<T>) -> Option<Spacetime<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Spacetime::new_unchecked(
            (-(self.x() * operand.xt() * self.t()) + self.x() * operand.s() * self.x()
                - self.t() * operand.s() * self.t()
                + self.t() * operand.xt() * self.x())
                * inv_norm_sq,
            (-(self.x() * operand.t() * self.t())
                + self.x() * operand.x() * self.x()
                + self.t() * operand.x() * self.t()
                - self.t() * operand.t() * self.x())
                * inv_norm_sq,
            (-(self.x() * operand.t() * self.x()) + self.t() * operand.x() * self.x()
                - self.t() * operand.t() * self.t()
                + self.x() * operand.x() * self.t())
                * inv_norm_sq,
            (self.x() * operand.s() * self.t() + self.t() * operand.xt() * self.t()
                - self.t() * operand.s() * self.x()
                - self.x() * operand.xt() * self.x())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Vector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (self.t() * operand.x() * self.t() - self.x() * operand.t() * self.t()
                + self.x() * operand.x() * self.x()
                - self.t() * operand.t() * self.x())
                * inv_norm_sq,
            (-(self.x() * operand.t() * self.x()) - self.t() * operand.t() * self.t()
                + self.x() * operand.x() * self.t()
                + self.t() * operand.x() * self.x())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (self.xt() * operand.xt() * self.xt()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Eventor<T>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (self.xt() * operand.s() * self.xt()) * inv_norm_sq,
            (self.xt() * operand.xt() * self.xt()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.xt() * operand.s() * self.xt()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Spacetime<T>> for Bivector<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Spacetime<T>) -> Option<Spacetime<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Spacetime::new_unchecked(
            (self.xt() * operand.s() * self.xt()) * inv_norm_sq,
            (self.xt() * operand.x() * self.xt()) * inv_norm_sq,
            (self.xt() * operand.t() * self.xt()) * inv_norm_sq,
            (self.xt() * operand.xt() * self.xt()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (self.xt() * operand.x() * self.xt()) * inv_norm_sq,
            (self.xt() * operand.t() * self.xt()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Bivector<T>> for Eventor<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (self.xt() * operand.xt() * self.xt() - self.s() * operand.xt() * self.s())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Eventor<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (-(self.s() * operand.s() * self.s()) + self.s() * operand.xt() * self.xt()
                - self.xt() * operand.xt() * self.s()
                + self.xt() * operand.s() * self.xt())
                * inv_norm_sq,
            (self.xt() * operand.xt() * self.xt() + self.s() * operand.s() * self.xt()
                - self.s() * operand.xt() * self.s()
                - self.xt() * operand.s() * self.s())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Eventor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.xt() * operand.s() * self.xt() - self.s() * operand.s() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Spacetime<T>> for Eventor<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Spacetime<T>) -> Option<Spacetime<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Spacetime::new_unchecked(
            (-(self.s() * operand.s() * self.s()) + self.xt() * operand.s() * self.xt()
                - self.xt() * operand.xt() * self.s()
                + self.s() * operand.xt() * self.xt())
                * inv_norm_sq,
            (self.xt() * operand.x() * self.xt()
                + self.xt() * operand.t() * self.s()
                + self.s() * operand.x() * self.s()
                + self.s() * operand.t() * self.xt())
                * inv_norm_sq,
            (self.s() * operand.t() * self.s()
                + self.xt() * operand.x() * self.s()
                + self.s() * operand.x() * self.xt()
                + self.xt() * operand.t() * self.xt())
                * inv_norm_sq,
            (self.xt() * operand.xt() * self.xt() + self.s() * operand.s() * self.xt()
                - self.xt() * operand.s() * self.s()
                - self.s() * operand.xt() * self.s())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Vector<T>> for Eventor<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (self.xt() * operand.t() * self.s()
                + self.s() * operand.x() * self.s()
                + self.xt() * operand.x() * self.xt()
                + self.s() * operand.t() * self.xt())
                * inv_norm_sq,
            (self.s() * operand.t() * self.s()
                + self.s() * operand.x() * self.xt()
                + self.xt() * operand.x() * self.s()
                + self.xt() * operand.t() * self.xt())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (-(self.s() * operand.xt() * self.s())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Eventor<T>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (-(self.s() * operand.s() * self.s())) * inv_norm_sq,
            (-(self.s() * operand.xt() * self.s())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (-(self.s() * operand.s() * self.s())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Spacetime<T>> for Scalar<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Spacetime<T>) -> Option<Spacetime<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Spacetime::new_unchecked(
            (-(self.s() * operand.s() * self.s())) * inv_norm_sq,
            (self.s() * operand.x() * self.s()) * inv_norm_sq,
            (self.s() * operand.t() * self.s()) * inv_norm_sq,
            (-(self.s() * operand.xt() * self.s())) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (self.s() * operand.x() * self.s()) * inv_norm_sq,
            (self.s() * operand.t() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Bivector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Bivector<T>) -> Option<Bivector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Bivector::new_unchecked(
            (-(self.t() * operand.xt() * self.t()) + self.x() * operand.xt() * self.x())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Eventor<T>> for Vector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Eventor<T>) -> Option<Eventor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Eventor::new_unchecked(
            (-(self.x() * operand.s() * self.x()) + self.t() * operand.s() * self.t()
                - self.x() * operand.xt() * self.t()
                + self.t() * operand.xt() * self.x())
                * inv_norm_sq,
            (-(self.t() * operand.s() * self.x()) - self.t() * operand.xt() * self.t()
                + self.x() * operand.s() * self.t()
                + self.x() * operand.xt() * self.x())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (-(self.x() * operand.s() * self.x()) + self.t() * operand.s() * self.t())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Spacetime<T>> for Vector<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Spacetime<T>) -> Option<Spacetime<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Spacetime::new_unchecked(
            (self.t() * operand.s() * self.t()
                - self.x() * operand.s() * self.x()
                - self.x() * operand.xt() * self.t()
                + self.t() * operand.xt() * self.x())
                * inv_norm_sq,
            (self.x() * operand.x() * self.x() + self.t() * operand.x() * self.t()
                - self.t() * operand.t() * self.x()
                - self.x() * operand.t() * self.t())
                * inv_norm_sq,
            (self.x() * operand.x() * self.t() + self.t() * operand.x() * self.x()
                - self.x() * operand.t() * self.x()
                - self.t() * operand.t() * self.t())
                * inv_norm_sq,
            (self.x() * operand.xt() * self.x()
                - self.t() * operand.s() * self.x()
                - self.t() * operand.xt() * self.t()
                + self.x() * operand.s() * self.t())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Vector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Vector<T>) -> Option<Vector<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Vector::new_unchecked(
            (self.t() * operand.x() * self.t() - self.x() * operand.t() * self.t()
                + self.x() * operand.x() * self.x()
                - self.t() * operand.t() * self.x())
                * inv_norm_sq,
            (self.x() * operand.x() * self.t() - self.t() * operand.t() * self.t()
                + self.t() * operand.x() * self.x()
                - self.x() * operand.t() * self.x())
                * inv_norm_sq,
        ))
    }
}
impl<T: Float> Versor<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn compose(&self, other: &Bivector<T>) -> Scalar<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Eventor<T>> for Bivector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn compose(&self, other: &Eventor<T>) -> Eventor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Bivector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn compose(&self, other: &Vector<T>) -> Vector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Bivector<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn compose(&self, other: &Bivector<T>) -> Eventor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Eventor<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn compose(&self, other: &Eventor<T>) -> Eventor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Eventor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Vector<T>> for Eventor<T> {
    type Output = Vector<T>;
    #[inline]
    fn compose(&self, other: &Vector<T>) -> Vector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Bivector<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn compose(&self, other: &Bivector<T>) -> Bivector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Eventor<T>> for Scalar<T> {
    type Output = Eventor<T>;
    #[inline]
    fn compose(&self, other: &Eventor<T>) -> Eventor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Scalar<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn compose(&self, other: &Vector<T>) -> Vector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Bivector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn compose(&self, other: &Bivector<T>) -> Vector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Eventor<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn compose(&self, other: &Eventor<T>) -> Vector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Vector<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Vector<T>> for Vector<T> {
    type Output = Eventor<T>;
    #[inline]
    fn compose(&self, other: &Vector<T>) -> Eventor<T> {
        *self * *other
    }
}
impl<T: Float> ScalarProduct<Bivector<T>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Bivector<T>) -> T {
        self.xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Bivector<T>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Bivector<T>) -> T {
        self.as_inner().xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Bivector<T>>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Bivector<T>>) -> T {
        self.xt() * rhs.as_inner().xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Bivector<T>>) -> T {
        self.as_inner().xt() * rhs.as_inner().xt()
    }
}
impl<T: Float> ScalarProduct<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Scalar<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Scalar<T>) -> T {
        self.as_inner().s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Scalar<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.s() * rhs.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
    }
}
impl<T: Float> ScalarProduct<Vector<T>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Vector<T>) -> T {
        self.x() * rhs.x() - self.t() * rhs.t()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Vector<T>> for Unit<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Vector<T>) -> T {
        self.as_inner().x() * rhs.x() + -(self.as_inner().t() * rhs.t())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Vector<T>>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Vector<T>>) -> T {
        self.x() * rhs.as_inner().x() + -(self.t() * rhs.as_inner().t())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Vector<T>>) -> T {
        self.as_inner().x() * rhs.as_inner().x() + -(self.as_inner().t() * rhs.as_inner().t())
    }
}
impl<T: Float> BulkContract<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.xt() * rhs.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().xt() * rhs.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.xt() * rhs.as_inner().xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().xt() * rhs.as_inner().xt()))
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.s() * self.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.s() * self.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.as_inner().s() * self.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.as_inner().s() * self.as_inner().xt())
    }
}
impl<T: Float> BulkContract<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(-(self.xt() * rhs.t()), -(rhs.x() * self.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Vector<T>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.as_inner().xt() * rhs.t()),
            -(rhs.x() * self.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Vector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.xt() * rhs.as_inner().t()),
            -(rhs.as_inner().x() * self.xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Vector<T>>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.as_inner().xt() * rhs.as_inner().t()),
            -(rhs.as_inner().x() * self.as_inner().xt()),
        )
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.as_inner().s())
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(-(self.x() * rhs.s()), -(rhs.s() * self.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.as_inner().x() * rhs.s()),
            -(rhs.s() * self.as_inner().t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.x() * rhs.as_inner().s()),
            -(rhs.as_inner().s() * self.t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.as_inner().x() * rhs.as_inner().s()),
            -(rhs.as_inner().s() * self.as_inner().t()),
        )
    }
}
impl<T: Float> BulkContract<Vector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.x() * rhs.x() + -(self.t() * rhs.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Vector<T>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().x() * rhs.x() + -(self.as_inner().t() * rhs.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Vector<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.x() * rhs.as_inner().x() + -(self.t() * rhs.as_inner().t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.as_inner().x() * rhs.as_inner().x() + -(self.as_inner().t() * rhs.as_inner().t()),
        )
    }
}
impl<T: Float> WeightContract<Bivector<T>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.xt() * rhs.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().xt() * rhs.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.xt() * rhs.as_inner().xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().xt() * rhs.as_inner().xt()))
    }
}
impl<T: Float> WeightContract<Scalar<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.s() * self.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Scalar<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.s() * self.as_inner().xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.as_inner().s() * self.xt())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(rhs.as_inner().s() * self.as_inner().xt())
    }
}
impl<T: Float> WeightContract<Vector<T>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(-(self.xt() * rhs.t()), -(rhs.x() * self.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Vector<T>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.as_inner().xt() * rhs.t()),
            -(rhs.x() * self.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Vector<T>>> for Bivector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.xt() * rhs.as_inner().t()),
            -(rhs.as_inner().x() * self.xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Vector<T>>> for Unit<Bivector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.as_inner().xt() * rhs.as_inner().t()),
            -(rhs.as_inner().x() * self.as_inner().xt()),
        )
    }
}
impl<T: Float> WeightContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.as_inner().s())
    }
}
impl<T: Float> WeightContract<Scalar<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(-(self.x() * rhs.s()), -(rhs.s() * self.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Scalar<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.as_inner().x() * rhs.s()),
            -(rhs.s() * self.as_inner().t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.x() * rhs.as_inner().s()),
            -(rhs.as_inner().s() * self.t()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.as_inner().x() * rhs.as_inner().s()),
            -(rhs.as_inner().s() * self.as_inner().t()),
        )
    }
}
impl<T: Float> WeightContract<Vector<T>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.x() * rhs.x() + -(self.t() * rhs.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Vector<T>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Vector<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().x() * rhs.x() + -(self.as_inner().t() * rhs.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Vector<T>>> for Vector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.x() * rhs.as_inner().x() + -(self.t() * rhs.as_inner().t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Vector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.as_inner().x() * rhs.as_inner().x() + -(self.as_inner().t() * rhs.as_inner().t()),
        )
    }
}
impl<T: Float> BulkExpand<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(-(self.xt() * rhs.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(-(self.as_inner().xt() * rhs.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(-(self.xt() * rhs.as_inner().xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(-(self.as_inner().xt() * rhs.as_inner().xt()))
    }
}
impl<T: Float> BulkExpand<Bivector<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.s() * rhs.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Bivector<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().s() * rhs.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Bivector<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.s() * rhs.as_inner().xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Bivector<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().s() * rhs.as_inner().xt()))
    }
}
impl<T: Float> BulkExpand<Scalar<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(self.as_inner().s() * rhs.as_inner().s())
    }
}
impl<T: Float> BulkExpand<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(self.s() * rhs.t(), self.s() * rhs.x())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Vector<T>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(self.as_inner().s() * rhs.t(), self.as_inner().s() * rhs.x())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Vector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(self.s() * rhs.as_inner().t(), self.s() * rhs.as_inner().x())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Vector<T>>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            self.as_inner().s() * rhs.as_inner().t(),
            self.as_inner().s() * rhs.as_inner().x(),
        )
    }
}
impl<T: Float> BulkExpand<Bivector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(-(self.x() * rhs.xt()), -(self.t() * rhs.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Bivector<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.as_inner().x() * rhs.xt()),
            -(self.as_inner().t() * rhs.xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Bivector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.x() * rhs.as_inner().xt()),
            -(self.t() * rhs.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Bivector<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.as_inner().x() * rhs.as_inner().xt()),
            -(self.as_inner().t() * rhs.as_inner().xt()),
        )
    }
}
impl<T: Float> BulkExpand<Vector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(self.x() * rhs.x() + -(self.t() * rhs.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Vector<T>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(self.as_inner().x() * rhs.x() + -(self.as_inner().t() * rhs.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Vector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(self.x() * rhs.as_inner().x() + -(self.t() * rhs.as_inner().t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.as_inner().x() * rhs.as_inner().x() + -(self.as_inner().t() * rhs.as_inner().t()),
        )
    }
}
impl<T: Float> WeightExpand<Bivector<T>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(-(self.xt() * rhs.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Bivector<T>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Bivector<T> {
        Bivector::new_unchecked(-(self.as_inner().xt() * rhs.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Bivector<T>>> for Bivector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(-(self.xt() * rhs.as_inner().xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Bivector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(-(self.as_inner().xt() * rhs.as_inner().xt()))
    }
}
impl<T: Float> WeightExpand<Bivector<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.s() * rhs.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Bivector<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().s() * rhs.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Bivector<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.s() * rhs.as_inner().xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Bivector<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Bivector<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().s() * rhs.as_inner().xt()))
    }
}
impl<T: Float> WeightExpand<Scalar<T>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Scalar<T>) -> Bivector<T> {
        Bivector::new_unchecked(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Scalar<T>>) -> Bivector<T> {
        Bivector::new_unchecked(self.as_inner().s() * rhs.as_inner().s())
    }
}
impl<T: Float> WeightExpand<Vector<T>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(self.s() * rhs.t(), self.s() * rhs.x())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Vector<T>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Vector<T>) -> Vector<T> {
        Vector::new_unchecked(self.as_inner().s() * rhs.t(), self.as_inner().s() * rhs.x())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Vector<T>>> for Scalar<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(self.s() * rhs.as_inner().t(), self.s() * rhs.as_inner().x())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Vector<T>>> for Unit<Scalar<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Vector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            self.as_inner().s() * rhs.as_inner().t(),
            self.as_inner().s() * rhs.as_inner().x(),
        )
    }
}
impl<T: Float> WeightExpand<Bivector<T>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(-(self.x() * rhs.xt()), -(self.t() * rhs.xt()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Bivector<T>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Bivector<T>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.as_inner().x() * rhs.xt()),
            -(self.as_inner().t() * rhs.xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Bivector<T>>> for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.x() * rhs.as_inner().xt()),
            -(self.t() * rhs.as_inner().xt()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Bivector<T>>> for Unit<Vector<T>> {
    type Output = Vector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Bivector<T>>) -> Vector<T> {
        Vector::new_unchecked(
            -(self.as_inner().x() * rhs.as_inner().xt()),
            -(self.as_inner().t() * rhs.as_inner().xt()),
        )
    }
}
impl<T: Float> WeightExpand<Vector<T>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(self.x() * rhs.x() + -(self.t() * rhs.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Vector<T>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Vector<T>) -> Bivector<T> {
        Bivector::new_unchecked(self.as_inner().x() * rhs.x() + -(self.as_inner().t() * rhs.t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Vector<T>>> for Vector<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(self.x() * rhs.as_inner().x() + -(self.t() * rhs.as_inner().t()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Vector<T>>) -> Bivector<T> {
        Bivector::new_unchecked(
            self.as_inner().x() * rhs.as_inner().x() + -(self.as_inner().t() * rhs.as_inner().t()),
        )
    }
}
impl<T: Float> Dot<Bivector<T>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Bivector<T>) -> T {
        self.xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Bivector<T>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Bivector<T>) -> T {
        self.as_inner().xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Bivector<T>>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Bivector<T>>) -> T {
        self.xt() * rhs.as_inner().xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Bivector<T>>) -> T {
        self.as_inner().xt() * rhs.as_inner().xt()
    }
}
impl<T: Float> Dot<Eventor<T>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Eventor<T>) -> T {
        self.xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Eventor<T>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Eventor<T>) -> T {
        self.as_inner().xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Eventor<T>>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Eventor<T>>) -> T {
        self.xt() * rhs.as_inner().xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Eventor<T>>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Eventor<T>>) -> T {
        self.as_inner().xt() * rhs.as_inner().xt()
    }
}
impl<T: Float> Dot<Spacetime<T>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Spacetime<T>) -> T {
        self.xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Spacetime<T>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Spacetime<T>) -> T {
        self.as_inner().xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Spacetime<T>>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        self.xt() * rhs.as_inner().xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Spacetime<T>>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        self.as_inner().xt() * rhs.as_inner().xt()
    }
}
impl<T: Float> Dot<Bivector<T>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Bivector<T>) -> T {
        self.xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Bivector<T>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Bivector<T>) -> T {
        self.as_inner().xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Bivector<T>>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Bivector<T>>) -> T {
        self.xt() * rhs.as_inner().xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Bivector<T>>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Bivector<T>>) -> T {
        self.as_inner().xt() * rhs.as_inner().xt()
    }
}
impl<T: Float> Dot<Eventor<T>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Eventor<T>) -> T {
        self.s() * rhs.s() + self.xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Eventor<T>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Eventor<T>) -> T {
        self.as_inner().s() * rhs.s() + self.as_inner().xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Eventor<T>>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Eventor<T>>) -> T {
        self.s() * rhs.as_inner().s() + self.xt() * rhs.as_inner().xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Eventor<T>>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Eventor<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s() + self.as_inner().xt() * rhs.as_inner().xt()
    }
}
impl<T: Float> Dot<Scalar<T>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Scalar<T>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.as_inner().s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Scalar<T>>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.s() * rhs.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Scalar<T>>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
    }
}
impl<T: Float> Dot<Spacetime<T>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Spacetime<T>) -> T {
        self.s() * rhs.s() + self.xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Spacetime<T>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Spacetime<T>) -> T {
        self.as_inner().s() * rhs.s() + self.as_inner().xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Spacetime<T>>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        self.s() * rhs.as_inner().s() + self.xt() * rhs.as_inner().xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Spacetime<T>>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s() + self.as_inner().xt() * rhs.as_inner().xt()
    }
}
impl<T: Float> Dot<Eventor<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Eventor<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Eventor<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Eventor<T>) -> T {
        self.as_inner().s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Eventor<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Eventor<T>>) -> T {
        self.s() * rhs.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Eventor<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Eventor<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
    }
}
impl<T: Float> Dot<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Scalar<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.as_inner().s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Scalar<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.s() * rhs.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
    }
}
impl<T: Float> Dot<Spacetime<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Spacetime<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Spacetime<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Spacetime<T>) -> T {
        self.as_inner().s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Spacetime<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        self.s() * rhs.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Spacetime<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
    }
}
impl<T: Float> Dot<Bivector<T>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Bivector<T>) -> T {
        self.xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Bivector<T>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Bivector<T>) -> T {
        self.as_inner().xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Bivector<T>>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Bivector<T>>) -> T {
        self.xt() * rhs.as_inner().xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Bivector<T>>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Bivector<T>>) -> T {
        self.as_inner().xt() * rhs.as_inner().xt()
    }
}
impl<T: Float> Dot<Eventor<T>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Eventor<T>) -> T {
        self.s() * rhs.s() + self.xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Eventor<T>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Eventor<T>) -> T {
        self.as_inner().s() * rhs.s() + self.as_inner().xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Eventor<T>>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Eventor<T>>) -> T {
        self.s() * rhs.as_inner().s() + self.xt() * rhs.as_inner().xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Eventor<T>>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Eventor<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s() + self.as_inner().xt() * rhs.as_inner().xt()
    }
}
impl<T: Float> Dot<Scalar<T>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Scalar<T>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.as_inner().s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Scalar<T>>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.s() * rhs.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Scalar<T>>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
    }
}
impl<T: Float> Dot<Spacetime<T>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Spacetime<T>) -> T {
        self.s() * rhs.s() + self.x() * rhs.x() - self.t() * rhs.t() + self.xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Spacetime<T>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Spacetime<T>) -> T {
        self.as_inner().s() * rhs.s()
            + self.as_inner().x() * rhs.x()
            + self.as_inner().xt() * rhs.xt()
            + -(self.as_inner().t() * rhs.t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Spacetime<T>>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        self.s() * rhs.as_inner().s()
            + self.x() * rhs.as_inner().x()
            + self.xt() * rhs.as_inner().xt()
            + -(self.t() * rhs.as_inner().t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Spacetime<T>>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
            + self.as_inner().x() * rhs.as_inner().x()
            + self.as_inner().xt() * rhs.as_inner().xt()
            + -(self.as_inner().t() * rhs.as_inner().t())
    }
}
impl<T: Float> Dot<Vector<T>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Vector<T>) -> T {
        self.x() * rhs.x() - self.t() * rhs.t()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Vector<T>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Vector<T>) -> T {
        self.as_inner().x() * rhs.x() + -(self.as_inner().t() * rhs.t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Vector<T>>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Vector<T>>) -> T {
        self.x() * rhs.as_inner().x() + -(self.t() * rhs.as_inner().t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Vector<T>>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Vector<T>>) -> T {
        self.as_inner().x() * rhs.as_inner().x() + -(self.as_inner().t() * rhs.as_inner().t())
    }
}
impl<T: Float> Dot<Spacetime<T>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Spacetime<T>) -> T {
        self.x() * rhs.x() - self.t() * rhs.t()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Spacetime<T>> for Unit<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Spacetime<T>) -> T {
        self.as_inner().x() * rhs.x() + -(self.as_inner().t() * rhs.t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Spacetime<T>>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        self.x() * rhs.as_inner().x() + -(self.t() * rhs.as_inner().t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Spacetime<T>>> for Unit<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        self.as_inner().x() * rhs.as_inner().x() + -(self.as_inner().t() * rhs.as_inner().t())
    }
}
impl<T: Float> Dot<Vector<T>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Vector<T>) -> T {
        self.x() * rhs.x() - self.t() * rhs.t()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Vector<T>> for Unit<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Vector<T>) -> T {
        self.as_inner().x() * rhs.x() + -(self.as_inner().t() * rhs.t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Vector<T>>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Vector<T>>) -> T {
        self.x() * rhs.as_inner().x() + -(self.t() * rhs.as_inner().t())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Vector<T>>) -> T {
        self.as_inner().x() * rhs.as_inner().x() + -(self.as_inner().t() * rhs.as_inner().t())
    }
}
impl<T: Float> Antidot<Bivector<T>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Bivector<T>) -> T {
        self.xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Bivector<T>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Bivector<T>) -> T {
        self.as_inner().xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Bivector<T>>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Bivector<T>>) -> T {
        self.xt() * rhs.as_inner().xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Bivector<T>>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Bivector<T>>) -> T {
        self.as_inner().xt() * rhs.as_inner().xt()
    }
}
impl<T: Float> Antidot<Eventor<T>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Eventor<T>) -> T {
        self.xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Eventor<T>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Eventor<T>) -> T {
        self.as_inner().xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Eventor<T>>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Eventor<T>>) -> T {
        self.xt() * rhs.as_inner().xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Eventor<T>>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Eventor<T>>) -> T {
        self.as_inner().xt() * rhs.as_inner().xt()
    }
}
impl<T: Float> Antidot<Spacetime<T>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Spacetime<T>) -> T {
        self.xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Spacetime<T>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Spacetime<T>) -> T {
        self.as_inner().xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Spacetime<T>>> for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        self.xt() * rhs.as_inner().xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Spacetime<T>>> for Unit<Bivector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        self.as_inner().xt() * rhs.as_inner().xt()
    }
}
impl<T: Float> Antidot<Bivector<T>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Bivector<T>) -> T {
        self.xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Bivector<T>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Bivector<T>) -> T {
        self.as_inner().xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Bivector<T>>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Bivector<T>>) -> T {
        self.xt() * rhs.as_inner().xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Bivector<T>>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Bivector<T>>) -> T {
        self.as_inner().xt() * rhs.as_inner().xt()
    }
}
impl<T: Float> Antidot<Eventor<T>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Eventor<T>) -> T {
        self.s() * rhs.s() + self.xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Eventor<T>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Eventor<T>) -> T {
        self.as_inner().s() * rhs.s() + self.as_inner().xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Eventor<T>>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Eventor<T>>) -> T {
        self.s() * rhs.as_inner().s() + self.xt() * rhs.as_inner().xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Eventor<T>>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Eventor<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s() + self.as_inner().xt() * rhs.as_inner().xt()
    }
}
impl<T: Float> Antidot<Scalar<T>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Scalar<T>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        self.as_inner().s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Scalar<T>>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.s() * rhs.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Scalar<T>>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
    }
}
impl<T: Float> Antidot<Spacetime<T>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Spacetime<T>) -> T {
        self.s() * rhs.s() + self.xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Spacetime<T>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Spacetime<T>) -> T {
        self.as_inner().s() * rhs.s() + self.as_inner().xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Spacetime<T>>> for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        self.s() * rhs.as_inner().s() + self.xt() * rhs.as_inner().xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Spacetime<T>>> for Unit<Eventor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s() + self.as_inner().xt() * rhs.as_inner().xt()
    }
}
impl<T: Float> Antidot<Eventor<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Eventor<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Eventor<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Eventor<T>) -> T {
        self.as_inner().s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Eventor<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Eventor<T>>) -> T {
        self.s() * rhs.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Eventor<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Eventor<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
    }
}
impl<T: Float> Antidot<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Scalar<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        self.as_inner().s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Scalar<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.s() * rhs.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
    }
}
impl<T: Float> Antidot<Spacetime<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Spacetime<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Spacetime<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Spacetime<T>) -> T {
        self.as_inner().s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Spacetime<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        self.s() * rhs.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Spacetime<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
    }
}
impl<T: Float> Antidot<Bivector<T>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Bivector<T>) -> T {
        self.xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Bivector<T>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Bivector<T>) -> T {
        self.as_inner().xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Bivector<T>>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Bivector<T>>) -> T {
        self.xt() * rhs.as_inner().xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Bivector<T>>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Bivector<T>>) -> T {
        self.as_inner().xt() * rhs.as_inner().xt()
    }
}
impl<T: Float> Antidot<Eventor<T>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Eventor<T>) -> T {
        self.s() * rhs.s() + self.xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Eventor<T>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Eventor<T>) -> T {
        self.as_inner().s() * rhs.s() + self.as_inner().xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Eventor<T>>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Eventor<T>>) -> T {
        self.s() * rhs.as_inner().s() + self.xt() * rhs.as_inner().xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Eventor<T>>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Eventor<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s() + self.as_inner().xt() * rhs.as_inner().xt()
    }
}
impl<T: Float> Antidot<Scalar<T>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Scalar<T>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        self.as_inner().s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Scalar<T>>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.s() * rhs.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Scalar<T>>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
    }
}
impl<T: Float> Antidot<Spacetime<T>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Spacetime<T>) -> T {
        self.s() * rhs.s() - self.x() * rhs.x() + self.t() * rhs.t() + self.xt() * rhs.xt()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Spacetime<T>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Spacetime<T>) -> T {
        self.as_inner().s() * rhs.s()
            + -(self.as_inner().x() * rhs.x())
            + self.as_inner().xt() * rhs.xt()
            + self.as_inner().t() * rhs.t()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Spacetime<T>>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        self.s() * rhs.as_inner().s()
            + -(self.x() * rhs.as_inner().x())
            + self.xt() * rhs.as_inner().xt()
            + self.t() * rhs.as_inner().t()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Spacetime<T>>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
            + -(self.as_inner().x() * rhs.as_inner().x())
            + self.as_inner().xt() * rhs.as_inner().xt()
            + self.as_inner().t() * rhs.as_inner().t()
    }
}
impl<T: Float> Antidot<Vector<T>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Vector<T>) -> T {
        -(self.x() * rhs.x()) + self.t() * rhs.t()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Vector<T>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Vector<T>) -> T {
        -(self.as_inner().x() * rhs.x()) + self.as_inner().t() * rhs.t()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Vector<T>>> for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Vector<T>>) -> T {
        -(self.x() * rhs.as_inner().x()) + self.t() * rhs.as_inner().t()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Vector<T>>> for Unit<Spacetime<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Vector<T>>) -> T {
        -(self.as_inner().x() * rhs.as_inner().x()) + self.as_inner().t() * rhs.as_inner().t()
    }
}
impl<T: Float> Antidot<Spacetime<T>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Spacetime<T>) -> T {
        -(self.x() * rhs.x()) + self.t() * rhs.t()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Spacetime<T>> for Unit<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Spacetime<T>) -> T {
        -(self.as_inner().x() * rhs.x()) + self.as_inner().t() * rhs.t()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Spacetime<T>>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        -(self.x() * rhs.as_inner().x()) + self.t() * rhs.as_inner().t()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Spacetime<T>>> for Unit<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Spacetime<T>>) -> T {
        -(self.as_inner().x() * rhs.as_inner().x()) + self.as_inner().t() * rhs.as_inner().t()
    }
}
impl<T: Float> Antidot<Vector<T>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Vector<T>) -> T {
        -(self.x() * rhs.x()) + self.t() * rhs.t()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Vector<T>> for Unit<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Vector<T>) -> T {
        -(self.as_inner().x() * rhs.x()) + self.as_inner().t() * rhs.t()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Vector<T>>> for Vector<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Vector<T>>) -> T {
        -(self.x() * rhs.as_inner().x()) + self.t() * rhs.as_inner().t()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Vector<T>>> for Unit<Vector<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Vector<T>>) -> T {
        -(self.as_inner().x() * rhs.as_inner().x()) + self.as_inner().t() * rhs.as_inner().t()
    }
}
impl<T: Float> Reverse for Bivector<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(-self.xt())
    }
}
impl<T: Float> Reverse for Eventor<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.s(), -self.xt())
    }
}
impl<T: Float> Reverse for Scalar<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> Reverse for Spacetime<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.s(), self.x(), self.t(), -self.xt())
    }
}
impl<T: Float> Reverse for Vector<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.x(), self.t())
    }
}
impl<T: Float> Antireverse for Bivector<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.xt())
    }
}
impl<T: Float> Antireverse for Eventor<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(-self.s(), self.xt())
    }
}
impl<T: Float> Antireverse for Scalar<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(-self.s())
    }
}
impl<T: Float> Antireverse for Spacetime<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(-self.s(), self.x(), self.t(), self.xt())
    }
}
impl<T: Float> Antireverse for Vector<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.x(), self.t())
    }
}
impl<T: Float> Involute for Bivector<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(-self.xt())
    }
}
impl<T: Float> Involute for Eventor<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.s(), -self.xt())
    }
}
impl<T: Float> Involute for Scalar<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> Involute for Spacetime<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.s(), self.x(), self.t(), -self.xt())
    }
}
impl<T: Float> Involute for Vector<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.x(), self.t())
    }
}
impl<T: Float> RightComplement for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_complement(&self) -> Scalar<T> {
        Scalar::new_unchecked(self.xt())
    }
}
impl<T: Float> RightComplement for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn right_complement(&self) -> Eventor<T> {
        Eventor::new_unchecked(self.xt(), self.s())
    }
}
impl<T: Float> RightComplement for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn right_complement(&self) -> Bivector<T> {
        Bivector::new_unchecked(self.s())
    }
}
impl<T: Float> RightComplement for Spacetime<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn right_complement(&self) -> Spacetime<T> {
        Spacetime::new_unchecked(self.xt(), -self.t(), self.x(), self.s())
    }
}
impl<T: Float> RightComplement for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn right_complement(&self) -> Vector<T> {
        Vector::new_unchecked(-self.t(), self.x())
    }
}
impl<T: Float> WeightDual for Bivector<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_dual(&self) -> Scalar<T> {
        Scalar::new_unchecked(-self.xt())
    }
}
impl<T: Float> WeightDual for Eventor<T> {
    type Output = Eventor<T>;
    #[inline]
    fn weight_dual(&self) -> Eventor<T> {
        Eventor::new_unchecked(-self.xt(), self.s())
    }
}
impl<T: Float> WeightDual for Scalar<T> {
    type Output = Bivector<T>;
    #[inline]
    fn weight_dual(&self) -> Bivector<T> {
        Bivector::new_unchecked(self.s())
    }
}
impl<T: Float> WeightDual for Spacetime<T> {
    type Output = Spacetime<T>;
    #[inline]
    fn weight_dual(&self) -> Spacetime<T> {
        Spacetime::new_unchecked(-self.xt(), self.t(), self.x(), self.s())
    }
}
impl<T: Float> WeightDual for Vector<T> {
    type Output = Vector<T>;
    #[inline]
    fn weight_dual(&self) -> Vector<T> {
        Vector::new_unchecked(self.t(), self.x())
    }
}
impl<T: Float> VersorInverse for Bivector<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(-self.xt() * inv_norm_sq))
    }
}
impl<T: Float> VersorInverse for Eventor<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(
            self.s() * inv_norm_sq,
            -self.xt() * inv_norm_sq,
        ))
    }
}
impl<T: Float> VersorInverse for Scalar<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(self.s() * inv_norm_sq))
    }
}
impl<T: Float> VersorInverse for Vector<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(
            self.x() * inv_norm_sq,
            self.t() * inv_norm_sq,
        ))
    }
}
impl<T: Float> crate::norm::Normed for Bivector<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        -self.xt() * self.xt()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.xt() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Eventor<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.s() * self.s() + -self.xt() * self.xt()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.s() * factor, self.xt() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.s() * self.s()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.s() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Spacetime<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.s() * self.s() + -self.x() * self.x() + self.t() * self.t() + -self.xt() * self.xt()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(
            self.s() * factor,
            self.x() * factor,
            self.t() * factor,
            self.xt() * factor,
        )
    }
}
impl<T: Float> crate::norm::Normed for Vector<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        -self.x() * self.x() + self.t() * self.t()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.x() * factor, self.t() * factor)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Bivector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.xt().abs_diff_eq(&other.xt(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Bivector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.xt().relative_eq(&other.xt(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Bivector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.xt().ulps_eq(&other.xt(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Eventor<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon) && self.xt().abs_diff_eq(&other.xt(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Eventor<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
            && self.xt().relative_eq(&other.xt(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Eventor<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
            && self.xt().ulps_eq(&other.xt(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Scalar<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Scalar<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Scalar<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Spacetime<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon)
            && self.x().abs_diff_eq(&other.x(), epsilon)
            && self.t().abs_diff_eq(&other.t(), epsilon)
            && self.xt().abs_diff_eq(&other.xt(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Spacetime<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
            && self.x().relative_eq(&other.x(), epsilon, max_relative)
            && self.t().relative_eq(&other.t(), epsilon, max_relative)
            && self.xt().relative_eq(&other.xt(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Spacetime<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
            && self.x().ulps_eq(&other.x(), epsilon, max_ulps)
            && self.t().ulps_eq(&other.t(), epsilon, max_ulps)
            && self.xt().ulps_eq(&other.xt(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Vector<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.x().abs_diff_eq(&other.x(), epsilon) && self.t().abs_diff_eq(&other.t(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Vector<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.x().relative_eq(&other.x(), epsilon, max_relative)
            && self.t().relative_eq(&other.t(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Vector<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.x().ulps_eq(&other.x(), epsilon, max_ulps)
            && self.t().ulps_eq(&other.t(), epsilon, max_ulps)
    }
}
#[cfg(any(test, feature = "proptest-support"))]
#[allow(clippy::missing_docs_in_private_items)]
mod arbitrary_impls {
    use super::*;
    use proptest::prelude::*;
    use proptest::strategy::BoxedStrategy;
    use std::fmt::Debug;
    impl<T: Float + Debug + 'static> Arbitrary for Bivector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| Bivector::new_unchecked(T::from_f64(x0)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Eventor<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0, -100.0f64..100.0)
                .prop_map(|(x0, x1)| Eventor::new_unchecked(T::from_f64(x0), T::from_f64(x1)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Scalar<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| Scalar::new_unchecked(T::from_f64(x0)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Spacetime<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0, -100.0f64..100.0, -100.0f64..100.0)
                .prop_filter("non-zero divisor", |(_x0, x1, _x2)| (x1).abs() > 0.1)
                .prop_map(|(x0, x1, x2)| {
                    Spacetime::new_unchecked(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64((x0 * x1 + x0 * x2) / (x1)),
                    )
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Vector<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0, -100.0f64..100.0)
                .prop_map(|(x0, x1)| Vector::new_unchecked(T::from_f64(x0), T::from_f64(x1)))
                .boxed()
        }
    }
}
