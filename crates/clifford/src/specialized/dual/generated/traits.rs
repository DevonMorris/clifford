#![doc = " Trait implementations for dual."]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
use super::types::{Dual, DualUnit, Scalar};
#[allow(unused_imports)]
use crate::ops::{
    Antidot, Antiproject, Antireverse, Antisandwich, Antiwedge, BulkContract, BulkExpand, Dot,
    InverseAntisandwich, InverseSandwich, Involute, LeftContract, Project, Reverse,
    RightComplement, RightContract, Sandwich, ScalarProduct, Transform, Versor, VersorInverse,
    Wedge, WeightContract, WeightDual, WeightExpand,
};
use crate::scalar::Float;
#[allow(unused_imports)]
use crate::wrappers::Unitized;
use approx::{AbsDiffEq, RelativeEq, UlpsEq};
use std::ops::{Add, Mul, Neg, Sub};
impl<T: Float> Add for Dual<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.real() + rhs.real(), self.dual() + rhs.dual())
    }
}
impl<T: Float> Sub for Dual<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.real() - rhs.real(), self.dual() - rhs.dual())
    }
}
impl<T: Float> Neg for Dual<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.real(), -self.dual())
    }
}
impl<T: Float> Mul<T> for Dual<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Dual<f32>> for f32 {
    type Output = Dual<f32>;
    #[inline]
    fn mul(self, v: Dual<f32>) -> Dual<f32> {
        v.scale(self)
    }
}
impl Mul<Dual<f64>> for f64 {
    type Output = Dual<f64>;
    #[inline]
    fn mul(self, v: Dual<f64>) -> Dual<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Dual<T>> for Dual<T> {
    type Output = Dual<T>;
    #[inline]
    fn mul(self, rhs: Dual<T>) -> Dual<T> {
        Dual::new_unchecked(
            rhs.real() * self.real(),
            rhs.dual() * self.real() + rhs.real() * self.dual(),
        )
    }
}
impl<T: Float> Mul<DualUnit<T>> for Dual<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn mul(self, rhs: DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.eps() * self.real())
    }
}
impl<T: Float> Mul<Scalar<T>> for Dual<T> {
    type Output = Dual<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Dual<T> {
        Dual::new_unchecked(rhs.s() * self.real(), rhs.s() * self.dual())
    }
}
impl<T: Float> Add for DualUnit<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.eps() + rhs.eps())
    }
}
impl<T: Float> Sub for DualUnit<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.eps() - rhs.eps())
    }
}
impl<T: Float> Neg for DualUnit<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.eps())
    }
}
impl<T: Float> Mul<T> for DualUnit<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<DualUnit<f32>> for f32 {
    type Output = DualUnit<f32>;
    #[inline]
    fn mul(self, v: DualUnit<f32>) -> DualUnit<f32> {
        v.scale(self)
    }
}
impl Mul<DualUnit<f64>> for f64 {
    type Output = DualUnit<f64>;
    #[inline]
    fn mul(self, v: DualUnit<f64>) -> DualUnit<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Dual<T>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn mul(self, rhs: Dual<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.real() * self.eps())
    }
}
impl<T: Float> Mul<Scalar<T>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.s() * self.eps())
    }
}
impl<T: Float> Add for Scalar<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.s() + rhs.s())
    }
}
impl<T: Float> Sub for Scalar<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.s() - rhs.s())
    }
}
impl<T: Float> Neg for Scalar<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.s())
    }
}
impl<T: Float> Mul<T> for Scalar<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Scalar<f32>> for f32 {
    type Output = Scalar<f32>;
    #[inline]
    fn mul(self, v: Scalar<f32>) -> Scalar<f32> {
        v.scale(self)
    }
}
impl Mul<Scalar<f64>> for f64 {
    type Output = Scalar<f64>;
    #[inline]
    fn mul(self, v: Scalar<f64>) -> Scalar<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Dual<T>> for Scalar<T> {
    type Output = Dual<T>;
    #[inline]
    fn mul(self, rhs: Dual<T>) -> Dual<T> {
        Dual::new_unchecked(rhs.real() * self.s(), rhs.dual() * self.s())
    }
}
impl<T: Float> Mul<DualUnit<T>> for Scalar<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn mul(self, rhs: DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.eps() * self.s())
    }
}
impl<T: Float> Mul<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
#[doc = "Wedge (exterior/outer) product of [`DualUnit`] and [`Scalar`].\n\nThe wedge product `a ^ b` computes the outer product, which represents\nthe oriented subspace spanned by both operands. The result grade is the\nsum of the input grades (or zero if they share common factors)."]
impl<T: Float> Wedge<Scalar<T>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.s() * self.eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.s() * self.as_inner().eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[doc = "Wedge (exterior/outer) product of [`Scalar`] and [`DualUnit`].\n\nThe wedge product `a ^ b` computes the outer product, which represents\nthe oriented subspace spanned by both operands. The result grade is the\nsum of the input grades (or zero if they share common factors)."]
impl<T: Float> Wedge<DualUnit<T>> for Scalar<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn wedge(&self, rhs: &DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.eps() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<DualUnit<T>> for Unitized<Scalar<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn wedge(&self, rhs: &DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<DualUnit<T>>> for Scalar<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.as_inner().eps() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<DualUnit<T>>> for Unitized<Scalar<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[doc = "Wedge (exterior/outer) product of [`Scalar`] and [`Scalar`].\n\nThe wedge product `a ^ b` computes the outer product, which represents\nthe oriented subspace spanned by both operands. The result grade is the\nsum of the input grades (or zero if they share common factors)."]
impl<T: Float> Wedge<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Antiwedge (regressive/meet) product of [`DualUnit`] and [`DualUnit`].\n\nThe antiwedge product `a v b` computes the meet of two subspaces,\nreturning the largest subspace contained in both. In projective geometry,\nthis finds intersections (e.g., where two planes meet to form a line)."]
impl<T: Float> Antiwedge<DualUnit<T>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn antiwedge(&self, rhs: &DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.eps() * self.eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<DualUnit<T>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn antiwedge(&self, rhs: &DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.eps() * self.as_inner().eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<DualUnit<T>>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.as_inner().eps() * self.eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<DualUnit<T>>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.as_inner().eps() * self.as_inner().eps())
    }
}
#[doc = "Antiwedge (regressive/meet) product of [`DualUnit`] and [`Scalar`].\n\nThe antiwedge product `a v b` computes the meet of two subspaces,\nreturning the largest subspace contained in both. In projective geometry,\nthis finds intersections (e.g., where two planes meet to form a line)."]
impl<T: Float> Antiwedge<Scalar<T>> for DualUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Scalar<T>> for Unitized<DualUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.as_inner().eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Scalar<T>>> for DualUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<Scalar<T>>> for Unitized<DualUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Antiwedge (regressive/meet) product of [`Scalar`] and [`DualUnit`].\n\nThe antiwedge product `a v b` computes the meet of two subspaces,\nreturning the largest subspace contained in both. In projective geometry,\nthis finds intersections (e.g., where two planes meet to form a line)."]
impl<T: Float> Antiwedge<DualUnit<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &DualUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.eps() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<DualUnit<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &DualUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<DualUnit<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<DualUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().eps() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unitized<DualUnit<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unitized<DualUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Left contraction of [`Scalar`] into [`DualUnit`].\n\nThe left contraction `a _| b` projects `a` onto `b`, returning the\ncomponent of `b` orthogonal to `a`. The result grade is grade(b) - grade(a)\n(or zero if grade(a) > grade(b))."]
impl<T: Float> LeftContract<DualUnit<T>> for Scalar<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn left_contract(&self, rhs: &DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.eps() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<DualUnit<T>> for Unitized<Scalar<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn left_contract(&self, rhs: &DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<DualUnit<T>>> for Scalar<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.as_inner().eps() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<DualUnit<T>>> for Unitized<Scalar<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[doc = "Left contraction of [`Scalar`] into [`Scalar`].\n\nThe left contraction `a _| b` projects `a` onto `b`, returning the\ncomponent of `b` orthogonal to `a`. The result grade is grade(b) - grade(a)\n(or zero if grade(a) > grade(b))."]
impl<T: Float> LeftContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Right contraction of [`DualUnit`] by [`Scalar`].\n\nThe right contraction `a |_ b` projects `b` onto `a`, returning the\ncomponent of `a` orthogonal to `b`. The result grade is grade(a) - grade(b)\n(or zero if grade(b) > grade(a))."]
impl<T: Float> RightContract<Scalar<T>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.s() * self.eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.s() * self.as_inner().eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[doc = "Right contraction of [`Scalar`] by [`Scalar`].\n\nThe right contraction `a |_ b` projects `b` onto `a`, returning the\ncomponent of `a` orthogonal to `b`. The result grade is grade(a) - grade(b)\n(or zero if grade(b) > grade(a))."]
impl<T: Float> RightContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Sandwich product: [`DualUnit`] x [`Dual`] x rev([`DualUnit`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Dual<T>> for DualUnit<T> {
    type Output = Dual<T>;
    #[inline]
    fn sandwich(&self, operand: &Dual<T>) -> Dual<T> {
        Dual::new_unchecked(T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Dual<T>> for Unitized<DualUnit<T>> {
    type Output = Dual<T>;
    #[inline]
    fn sandwich(&self, operand: &Dual<T>) -> Dual<T> {
        Dual::new_unchecked(T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Dual<T>>> for DualUnit<T> {
    type Output = Dual<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Dual<T>>) -> Dual<T> {
        Dual::new_unchecked(T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Dual<T>>> for Unitized<DualUnit<T>> {
    type Output = Dual<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Dual<T>>) -> Dual<T> {
        Dual::new_unchecked(T::zero(), T::zero())
    }
}
#[doc = "Sandwich product: [`DualUnit`] x [`DualUnit`] x rev([`DualUnit`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<DualUnit<T>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn sandwich(&self, operand: &DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<DualUnit<T>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn sandwich(&self, operand: &DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<DualUnit<T>>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<DualUnit<T>>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[doc = "Sandwich product: [`DualUnit`] x [`Scalar`] x rev([`DualUnit`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for DualUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unitized<DualUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for DualUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Unitized<DualUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Sandwich product: [`Scalar`] x [`Dual`] x rev([`Scalar`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Dual<T>> for Scalar<T> {
    type Output = Dual<T>;
    #[inline]
    fn sandwich(&self, operand: &Dual<T>) -> Dual<T> {
        Dual::new_unchecked(
            self.s() * operand.real() * self.s(),
            self.s() * operand.dual() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Dual<T>> for Unitized<Scalar<T>> {
    type Output = Dual<T>;
    #[inline]
    fn sandwich(&self, operand: &Dual<T>) -> Dual<T> {
        Dual::new_unchecked(T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Dual<T>>> for Scalar<T> {
    type Output = Dual<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Dual<T>>) -> Dual<T> {
        Dual::new_unchecked(T::zero(), operand.as_inner().dual() * self.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Dual<T>>> for Unitized<Scalar<T>> {
    type Output = Dual<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Dual<T>>) -> Dual<T> {
        Dual::new_unchecked(T::zero(), T::zero())
    }
}
#[doc = "Sandwich product: [`Scalar`] x [`DualUnit`] x rev([`Scalar`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<DualUnit<T>> for Scalar<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn sandwich(&self, operand: &DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(self.s() * operand.eps() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<DualUnit<T>> for Unitized<Scalar<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn sandwich(&self, operand: &DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<DualUnit<T>>> for Scalar<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(operand.as_inner().eps() * self.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<DualUnit<T>>> for Unitized<Scalar<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[doc = "Sandwich product: [`Scalar`] x [`Scalar`] x rev([`Scalar`]).\n\nThe sandwich product `v x a x rev(v)` applies the transformation\nrepresented by the versor `v` to the operand `a`. For rotors, this\nperforms rotation; for motors, it performs rigid body transformation."]
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * operand.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Antisandwich product: [`DualUnit`] x [`Dual`] x antirev([`DualUnit`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Dual<T>> for DualUnit<T> {
    type Output = Dual<T>;
    #[inline]
    fn antisandwich(&self, operand: &Dual<T>) -> Dual<T> {
        Dual::new_unchecked(
            self.eps() * operand.real() * self.eps(),
            self.eps() * operand.dual() * self.eps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Dual<T>> for Unitized<DualUnit<T>> {
    type Output = Dual<T>;
    #[inline]
    fn antisandwich(&self, operand: &Dual<T>) -> Dual<T> {
        Dual::new_unchecked(operand.real(), operand.dual())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Dual<T>>> for DualUnit<T> {
    type Output = Dual<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Dual<T>>) -> Dual<T> {
        Dual::new_unchecked(
            T::zero(),
            operand.as_inner().dual() * self.eps() * self.eps(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Dual<T>>> for Unitized<DualUnit<T>> {
    type Output = Dual<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Dual<T>>) -> Dual<T> {
        Dual::new_unchecked(T::zero(), operand.as_inner().dual())
    }
}
#[doc = "Antisandwich product: [`DualUnit`] x [`DualUnit`] x antirev([`DualUnit`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<DualUnit<T>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn antisandwich(&self, operand: &DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(self.eps() * operand.eps() * self.eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<DualUnit<T>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn antisandwich(&self, operand: &DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(operand.eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<DualUnit<T>>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(operand.as_inner().eps() * self.eps() * self.eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<DualUnit<T>>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(operand.as_inner().eps())
    }
}
#[doc = "Antisandwich product: [`DualUnit`] x [`Scalar`] x antirev([`DualUnit`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for DualUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.eps() * operand.s() * self.eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unitized<DualUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for DualUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Unitized<DualUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Antisandwich product: [`Scalar`] x [`Dual`] x antirev([`Scalar`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Dual<T>> for Scalar<T> {
    type Output = Dual<T>;
    #[inline]
    fn antisandwich(&self, operand: &Dual<T>) -> Dual<T> {
        Dual::new_unchecked(T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Dual<T>> for Unitized<Scalar<T>> {
    type Output = Dual<T>;
    #[inline]
    fn antisandwich(&self, operand: &Dual<T>) -> Dual<T> {
        Dual::new_unchecked(T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Dual<T>>> for Scalar<T> {
    type Output = Dual<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Dual<T>>) -> Dual<T> {
        Dual::new_unchecked(T::zero(), T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Dual<T>>> for Unitized<Scalar<T>> {
    type Output = Dual<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Dual<T>>) -> Dual<T> {
        Dual::new_unchecked(T::zero(), T::zero())
    }
}
#[doc = "Antisandwich product: [`Scalar`] x [`DualUnit`] x antirev([`Scalar`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<DualUnit<T>> for Scalar<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn antisandwich(&self, operand: &DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<DualUnit<T>> for Unitized<Scalar<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn antisandwich(&self, operand: &DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<DualUnit<T>>> for Scalar<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<DualUnit<T>>> for Unitized<Scalar<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[doc = "Antisandwich product: [`Scalar`] x [`Scalar`] x antirev([`Scalar`]).\n\nThe antisandwich product `v x a x antirev(v)` is the dual of the\nsandwich product, used in Projective GA for transforming dual objects\n(planes, ideal points). Motors use antisandwich for plane transforms."]
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Transform a [`Dual`] using this [`DualUnit`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Dual<T>> for DualUnit<T> {
    type Output = Dual<T>;
    #[inline]
    fn transform(&self, operand: &Dual<T>) -> Dual<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Dual<T>> for Unitized<DualUnit<T>> {
    type Output = Dual<T>;
    #[inline]
    fn transform(&self, operand: &Dual<T>) -> Dual<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Dual<T>>> for DualUnit<T> {
    type Output = Dual<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Dual<T>>) -> Dual<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Dual<T>>> for Unitized<DualUnit<T>> {
    type Output = Dual<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Dual<T>>) -> Dual<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`DualUnit`] using this [`DualUnit`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<DualUnit<T>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn transform(&self, operand: &DualUnit<T>) -> DualUnit<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<DualUnit<T>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn transform(&self, operand: &DualUnit<T>) -> DualUnit<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<DualUnit<T>>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<DualUnit<T>>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Scalar`] using this [`DualUnit`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Scalar<T>> for DualUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unitized<DualUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for DualUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Unitized<DualUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Dual`] using this [`Scalar`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Dual<T>> for Scalar<T> {
    type Output = Dual<T>;
    #[inline]
    fn transform(&self, operand: &Dual<T>) -> Dual<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Dual<T>> for Unitized<Scalar<T>> {
    type Output = Dual<T>;
    #[inline]
    fn transform(&self, operand: &Dual<T>) -> Dual<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Dual<T>>> for Scalar<T> {
    type Output = Dual<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Dual<T>>) -> Dual<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Dual<T>>> for Unitized<Scalar<T>> {
    type Output = Dual<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Dual<T>>) -> Dual<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`DualUnit`] using this [`Scalar`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<DualUnit<T>> for Scalar<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn transform(&self, operand: &DualUnit<T>) -> DualUnit<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<DualUnit<T>> for Unitized<Scalar<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn transform(&self, operand: &DualUnit<T>) -> DualUnit<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<DualUnit<T>>> for Scalar<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<DualUnit<T>>> for Unitized<Scalar<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        self.antisandwich(operand)
    }
}
#[doc = "Transform a [`Scalar`] using this [`Scalar`].\n\nApplies the geometric transformation represented by this versor.\nFor rotors, this performs rotation. For motors, this performs rigid\nbody transformation (rotation + translation). Internally uses the\nantisandwich product."]
impl<T: Float> Transform<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
impl<T: Float> Transform<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unitized<Scalar<T>>) -> Scalar<T> {
        self.antisandwich(operand)
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Dual<T>> for DualUnit<T> {
    type Output = Dual<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Dual<T>) -> Option<Dual<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Dual::new_unchecked(
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<DualUnit<T>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &DualUnit<T>) -> Option<DualUnit<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(DualUnit::new_unchecked((T::zero()) * inv_norm_sq))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for DualUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked((T::zero()) * inv_norm_sq))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Dual<T>> for Scalar<T> {
    type Output = Dual<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Dual<T>) -> Option<Dual<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Dual::new_unchecked(
            (self.s() * operand.real() * self.s()) * inv_norm_sq,
            (self.s() * operand.dual() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<DualUnit<T>> for Scalar<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &DualUnit<T>) -> Option<DualUnit<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(DualUnit::new_unchecked(
            (self.s() * operand.eps() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.s() * operand.s() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Dual<T>> for DualUnit<T> {
    type Output = Dual<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Dual<T>) -> Option<Dual<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Dual::new_unchecked(
            (self.eps() * operand.real() * self.eps()) * inv_norm_sq,
            (self.eps() * operand.dual() * self.eps()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<DualUnit<T>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &DualUnit<T>) -> Option<DualUnit<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(DualUnit::new_unchecked(
            (self.eps() * operand.eps() * self.eps()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for DualUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.eps() * operand.s() * self.eps()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Dual<T>> for Scalar<T> {
    type Output = Dual<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Dual<T>) -> Option<Dual<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Dual::new_unchecked(
            (T::zero()) * inv_norm_sq,
            (T::zero()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<DualUnit<T>> for Scalar<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &DualUnit<T>) -> Option<DualUnit<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(DualUnit::new_unchecked((T::zero()) * inv_norm_sq))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked((T::zero()) * inv_norm_sq))
    }
}
impl<T: Float> Versor<Scalar<T>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> DualUnit<T> {
        *self * *other
    }
}
impl<T: Float> Versor<DualUnit<T>> for Scalar<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn compose(&self, other: &DualUnit<T>) -> DualUnit<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Scalar<T> {
        *self * *other
    }
}
impl<T: Float> ScalarProduct<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Scalar<T>> for Unitized<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Scalar<T>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unitized<Scalar<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unitized<Scalar<T>>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unitized<Scalar<T>>) -> T {
        T::zero()
    }
}
#[doc = "Bulk contraction of [`DualUnit`] with [`Scalar`].\n\nThe bulk contraction extracts the Euclidean (non-degenerate) component\nof the interior product. In PGA, this isolates the finite/spatial part."]
impl<T: Float> BulkContract<Scalar<T>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.s() * self.eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.s() * self.as_inner().eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[doc = "Bulk contraction of [`Scalar`] with [`Scalar`].\n\nThe bulk contraction extracts the Euclidean (non-degenerate) component\nof the interior product. In PGA, this isolates the finite/spatial part."]
impl<T: Float> BulkContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unitized<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[doc = "Weight contraction of [`DualUnit`] with [`DualUnit`].\n\nThe weight contraction extracts the degenerate/ideal component of the\ninterior product. In PGA, this measures the 'weight' or projective part."]
impl<T: Float> WeightContract<DualUnit<T>> for DualUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &DualUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.eps() * self.eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<DualUnit<T>> for Unitized<DualUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &DualUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.eps() * self.as_inner().eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<DualUnit<T>>> for DualUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<DualUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().eps() * self.eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unitized<DualUnit<T>>> for Unitized<DualUnit<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unitized<DualUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().eps() * self.as_inner().eps())
    }
}
#[doc = "Bulk expansion of [`Scalar`] with [`Scalar`].\n\nThe bulk expansion is the dual of bulk contraction, extracting the\nEuclidean component of the exterior product complement."]
impl<T: Float> BulkExpand<Scalar<T>> for Scalar<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Scalar<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Scalar<T>> for Unitized<Scalar<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Scalar<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Scalar<T>>> for Scalar<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Scalar<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unitized<Scalar<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
#[doc = "Weight expansion of [`DualUnit`] with [`DualUnit`].\n\nThe weight expansion is the dual of weight contraction, extracting the\ndegenerate/ideal component of the exterior product complement."]
impl<T: Float> WeightExpand<DualUnit<T>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn weight_expand(&self, rhs: &DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.eps() * self.eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<DualUnit<T>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn weight_expand(&self, rhs: &DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.eps() * self.as_inner().eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<DualUnit<T>>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.as_inner().eps() * self.eps())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<DualUnit<T>>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        DualUnit::new_unchecked(rhs.as_inner().eps() * self.as_inner().eps())
    }
}
#[doc = "Weight expansion of [`Scalar`] with [`DualUnit`].\n\nThe weight expansion is the dual of weight contraction, extracting the\ndegenerate/ideal component of the exterior product complement."]
impl<T: Float> WeightExpand<DualUnit<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &DualUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.eps() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<DualUnit<T>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &DualUnit<T>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<DualUnit<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<DualUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().eps() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unitized<DualUnit<T>>> for Unitized<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unitized<DualUnit<T>>) -> Scalar<T> {
        Scalar::new_unchecked(T::zero())
    }
}
impl<T: Float> Dot<Dual<T>> for Dual<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Dual<T>) -> T {
        self.real() * rhs.real()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Dual<T>> for Unitized<Dual<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Dual<T>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Dual<T>>> for Dual<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Dual<T>>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Dual<T>>> for Unitized<Dual<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Dual<T>>) -> T {
        T::zero()
    }
}
impl<T: Float> Dot<Scalar<T>> for Dual<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.real() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Scalar<T>> for Unitized<Dual<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Scalar<T>>> for Dual<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Scalar<T>>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Scalar<T>>> for Unitized<Dual<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Scalar<T>>) -> T {
        T::zero()
    }
}
impl<T: Float> Dot<Dual<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Dual<T>) -> T {
        self.s() * rhs.real()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Dual<T>> for Unitized<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Dual<T>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Dual<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Dual<T>>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Dual<T>>> for Unitized<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Dual<T>>) -> T {
        T::zero()
    }
}
impl<T: Float> Dot<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Scalar<T>> for Unitized<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Scalar<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Scalar<T>>) -> T {
        T::zero()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unitized<Scalar<T>>> for Unitized<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unitized<Scalar<T>>) -> T {
        T::zero()
    }
}
impl<T: Float> Antidot<Dual<T>> for Dual<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Dual<T>) -> T {
        self.dual() * rhs.dual()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Dual<T>> for Unitized<Dual<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Dual<T>) -> T {
        rhs.dual() * self.as_inner().dual()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Dual<T>>> for Dual<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Dual<T>>) -> T {
        rhs.as_inner().dual() * self.dual()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Dual<T>>> for Unitized<Dual<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Dual<T>>) -> T {
        rhs.as_inner().dual() * self.as_inner().dual()
    }
}
impl<T: Float> Antidot<DualUnit<T>> for Dual<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &DualUnit<T>) -> T {
        self.dual() * rhs.eps()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<DualUnit<T>> for Unitized<Dual<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &DualUnit<T>) -> T {
        rhs.eps() * self.as_inner().dual()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<DualUnit<T>>> for Dual<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<DualUnit<T>>) -> T {
        rhs.as_inner().eps() * self.dual()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<DualUnit<T>>> for Unitized<Dual<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<DualUnit<T>>) -> T {
        rhs.as_inner().eps() * self.as_inner().dual()
    }
}
impl<T: Float> Antidot<Dual<T>> for DualUnit<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Dual<T>) -> T {
        self.eps() * rhs.dual()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Dual<T>> for Unitized<DualUnit<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Dual<T>) -> T {
        rhs.dual() * self.as_inner().eps()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Dual<T>>> for DualUnit<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Dual<T>>) -> T {
        rhs.as_inner().dual() * self.eps()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<Dual<T>>> for Unitized<DualUnit<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<Dual<T>>) -> T {
        rhs.as_inner().dual() * self.as_inner().eps()
    }
}
impl<T: Float> Antidot<DualUnit<T>> for DualUnit<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &DualUnit<T>) -> T {
        self.eps() * rhs.eps()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<DualUnit<T>> for Unitized<DualUnit<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &DualUnit<T>) -> T {
        rhs.eps() * self.as_inner().eps()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<DualUnit<T>>> for DualUnit<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<DualUnit<T>>) -> T {
        rhs.as_inner().eps() * self.eps()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unitized<DualUnit<T>>> for Unitized<DualUnit<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unitized<DualUnit<T>>) -> T {
        rhs.as_inner().eps() * self.as_inner().eps()
    }
}
impl<T: Float> Project<DualUnit<T>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn project(&self, target: &DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(self.eps() * target.eps() * target.eps())
    }
}
impl<T: Float> Project<DualUnit<T>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn project(&self, target: &DualUnit<T>) -> DualUnit<T> {
        self.as_inner().project(target)
    }
}
impl<T: Float> Project<Unitized<DualUnit<T>>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn project(&self, target: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        self.project(target.as_inner())
    }
}
impl<T: Float> Project<Unitized<DualUnit<T>>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn project(&self, target: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        self.as_inner().project(target.as_inner())
    }
}
impl<T: Float> Antiproject<DualUnit<T>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn antiproject(&self, target: &DualUnit<T>) -> DualUnit<T> {
        DualUnit::new_unchecked(self.eps() * target.eps() * target.eps())
    }
}
impl<T: Float> Antiproject<DualUnit<T>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn antiproject(&self, target: &DualUnit<T>) -> DualUnit<T> {
        self.as_inner().antiproject(target)
    }
}
impl<T: Float> Antiproject<Unitized<DualUnit<T>>> for DualUnit<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        self.antiproject(target.as_inner())
    }
}
impl<T: Float> Antiproject<Unitized<DualUnit<T>>> for Unitized<DualUnit<T>> {
    type Output = DualUnit<T>;
    #[inline]
    fn antiproject(&self, target: &Unitized<DualUnit<T>>) -> DualUnit<T> {
        self.as_inner().antiproject(target.as_inner())
    }
}
impl<T: Float> Reverse for Dual<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.real(), self.dual())
    }
}
impl<T: Float> Reverse for DualUnit<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.eps())
    }
}
impl<T: Float> Reverse for Scalar<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> Antireverse for Dual<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.real(), self.dual())
    }
}
impl<T: Float> Antireverse for DualUnit<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.eps())
    }
}
impl<T: Float> Antireverse for Scalar<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> Involute for Dual<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.real(), -self.dual())
    }
}
impl<T: Float> Involute for DualUnit<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(-self.eps())
    }
}
impl<T: Float> Involute for Scalar<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> RightComplement for Dual<T> {
    type Output = Dual<T>;
    #[inline]
    fn right_complement(&self) -> Dual<T> {
        Dual::new_unchecked(self.dual(), self.real())
    }
}
impl<T: Float> RightComplement for DualUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_complement(&self) -> Scalar<T> {
        Scalar::new_unchecked(self.eps())
    }
}
impl<T: Float> RightComplement for Scalar<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn right_complement(&self) -> DualUnit<T> {
        DualUnit::new_unchecked(self.s())
    }
}
impl<T: Float> WeightDual for Dual<T> {
    type Output = Dual<T>;
    #[inline]
    fn weight_dual(&self) -> Dual<T> {
        Dual::new_unchecked(self.dual(), T::zero())
    }
}
impl<T: Float> WeightDual for DualUnit<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_dual(&self) -> Scalar<T> {
        Scalar::new_unchecked(self.eps())
    }
}
impl<T: Float> WeightDual for Scalar<T> {
    type Output = DualUnit<T>;
    #[inline]
    fn weight_dual(&self) -> DualUnit<T> {
        DualUnit::new_unchecked(T::zero())
    }
}
impl<T: Float> VersorInverse for DualUnit<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(self.eps() * inv_norm_sq))
    }
}
impl<T: Float> VersorInverse for Scalar<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::DegenerateNormed>::bulk_norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(self.s() * inv_norm_sq))
    }
}
impl<T: Float> crate::norm::Normed for Dual<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.real() * self.real()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.real() * factor, self.dual() * factor)
    }
}
impl<T: Float> crate::norm::Normed for DualUnit<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        T::zero()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.eps() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.s() * self.s()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.s() * factor)
    }
}
impl<T: Float> crate::norm::DegenerateNormed for Dual<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        self.real() * self.real()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        self.dual() * self.dual()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new_unchecked(
                self.real() * inv_w,
                self.dual() * inv_w,
            ))
        }
    }
}
impl<T: Float> crate::norm::DegenerateNormed for DualUnit<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        T::zero()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        self.eps() * self.eps()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new_unchecked(self.eps() * inv_w))
        }
    }
}
impl<T: Float> crate::norm::DegenerateNormed for Scalar<T> {
    #[inline]
    fn bulk_norm_squared(&self) -> T {
        self.s() * self.s()
    }
    #[inline]
    fn weight_norm_squared(&self) -> T {
        T::zero()
    }
    fn try_unitize(&self) -> Option<Self> {
        let w = self.weight_norm();
        if w < T::epsilon() {
            None
        } else {
            let inv_w = T::one() / w;
            Some(Self::new_unchecked(self.s() * inv_w))
        }
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Dual<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.real().abs_diff_eq(&other.real(), epsilon)
            && self.dual().abs_diff_eq(&other.dual(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Dual<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.real()
            .relative_eq(&other.real(), epsilon, max_relative)
            && self
                .dual()
                .relative_eq(&other.dual(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Dual<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.real().ulps_eq(&other.real(), epsilon, max_ulps)
            && self.dual().ulps_eq(&other.dual(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for DualUnit<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.eps().abs_diff_eq(&other.eps(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for DualUnit<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.eps().relative_eq(&other.eps(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for DualUnit<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.eps().ulps_eq(&other.eps(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Scalar<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Scalar<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Scalar<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
    }
}
#[cfg(any(test, feature = "proptest-support"))]
#[allow(clippy::missing_docs_in_private_items)]
mod arbitrary_impls {
    use super::*;
    use proptest::prelude::*;
    use proptest::strategy::BoxedStrategy;
    use std::fmt::Debug;
    impl<T: Float + Debug + 'static> Arbitrary for Dual<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0, -100.0f64..100.0)
                .prop_map(|(x0, x1)| Dual::new_unchecked(T::from_f64(x0), T::from_f64(x1)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for DualUnit<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| DualUnit::new_unchecked(T::from_f64(x0)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Scalar<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| Scalar::new_unchecked(T::from_f64(x0)))
                .boxed()
        }
    }
}

// ============================================================
// Verification Tests (compare against Multivector)
// ============================================================

#[cfg(test)]
#[allow(clippy::missing_docs_in_private_items)]
mod verification_tests {
    use super::*;
    use crate::algebra::Multivector;
    #[allow(unused_imports)]
    use crate::norm::{DegenerateNormed, Normed};
    use crate::signature::Cl0_0_1;
    #[allow(unused_imports)]
    use crate::wrappers::{Bulk, Unit, Unitized};
    use approx::relative_eq;
    use proptest::prelude::*;

    /// Relative epsilon for floating-point comparisons in verification tests.
    /// Using relative comparison handles varying magnitudes better than absolute.
    const REL_EPSILON: f64 = 1e-10;

    proptest! {
        #[test]
        fn dual_add_matches_multivector(a in any::<Dual<f64>>(), b in any::<Dual<f64>>()) {
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();
            let mv_b: Multivector<f64, Cl0_0_1> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Cl0_0_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn dual_sub_matches_multivector(a in any::<Dual<f64>>(), b in any::<Dual<f64>>()) {
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();
            let mv_b: Multivector<f64, Cl0_0_1> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Cl0_0_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn dual_neg_matches_multivector(a in any::<Dual<f64>>()) {
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Cl0_0_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn dualunit_add_matches_multivector(a in any::<DualUnit<f64>>(), b in any::<DualUnit<f64>>()) {
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();
            let mv_b: Multivector<f64, Cl0_0_1> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Cl0_0_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn dualunit_sub_matches_multivector(a in any::<DualUnit<f64>>(), b in any::<DualUnit<f64>>()) {
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();
            let mv_b: Multivector<f64, Cl0_0_1> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Cl0_0_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn dualunit_neg_matches_multivector(a in any::<DualUnit<f64>>()) {
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Cl0_0_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn scalar_add_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();
            let mv_b: Multivector<f64, Cl0_0_1> = b.into();

            let specialized_result = a + b;
            let generic_result = mv_a + mv_b;

            let specialized_mv: Multivector<f64, Cl0_0_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Add mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn scalar_sub_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();
            let mv_b: Multivector<f64, Cl0_0_1> = b.into();

            let specialized_result = a - b;
            let generic_result = mv_a - mv_b;

            let specialized_mv: Multivector<f64, Cl0_0_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Sub mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }

        #[test]
        fn scalar_neg_matches_multivector(a in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();

            let specialized_result = -a;
            let generic_result = -mv_a;

            let specialized_mv: Multivector<f64, Cl0_0_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Neg mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_dualunit_scalar_dualunit_matches_multivector(a in any::<DualUnit<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();
            let mv_b: Multivector<f64, Cl0_0_1> = b.into();

            let specialized_result: DualUnit<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_0_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_scalar_dualunit_dualunit_matches_multivector(a in any::<Scalar<f64>>(), b in any::<DualUnit<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();
            let mv_b: Multivector<f64, Cl0_0_1> = b.into();

            let specialized_result: DualUnit<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_0_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn wedge_scalar_scalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::Wedge;
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();
            let mv_b: Multivector<f64, Cl0_0_1> = b.into();

            let specialized_result: Scalar<f64> = a.wedge(&b);
            let generic_result = mv_a.exterior(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_0_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wedge product mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_dualunit_scalar_dualunit_matches_multivector(a in any::<DualUnit<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();
            let mv_b: Multivector<f64, Cl0_0_1> = b.into();

            let specialized_result: DualUnit<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_0_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_contraction_scalar_scalar_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkContract;
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();
            let mv_b: Multivector<f64, Cl0_0_1> = b.into();

            let specialized_result: Scalar<f64> = a.bulk_contract(&b);
            let generic_result = mv_a.bulk_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_0_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_contraction_dualunit_dualunit_scalar_matches_multivector(a in any::<DualUnit<f64>>(), b in any::<DualUnit<f64>>()) {
            use crate::ops::WeightContract;
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();
            let mv_b: Multivector<f64, Cl0_0_1> = b.into();

            let specialized_result: Scalar<f64> = a.weight_contract(&b);
            let generic_result = mv_a.weight_contraction(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_0_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight contraction mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn bulk_expansion_scalar_scalar_dualunit_matches_multivector(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            use crate::ops::BulkExpand;
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();
            let mv_b: Multivector<f64, Cl0_0_1> = b.into();

            let specialized_result: DualUnit<f64> = a.bulk_expand(&b);
            let generic_result = mv_a.bulk_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_0_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Bulk expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_dualunit_dualunit_dualunit_matches_multivector(a in any::<DualUnit<f64>>(), b in any::<DualUnit<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();
            let mv_b: Multivector<f64, Cl0_0_1> = b.into();

            let specialized_result: DualUnit<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_0_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        #[test]
        fn weight_expansion_scalar_dualunit_scalar_matches_multivector(a in any::<Scalar<f64>>(), b in any::<DualUnit<f64>>()) {
            use crate::ops::WeightExpand;
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();
            let mv_b: Multivector<f64, Cl0_0_1> = b.into();

            let specialized_result: Scalar<f64> = a.weight_expand(&b);
            let generic_result = mv_a.weight_expansion(&mv_b);

            let specialized_mv: Multivector<f64, Cl0_0_1> = specialized_result.into();
            prop_assert!(
                relative_eq!(specialized_mv, generic_result, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight expansion mismatch: specialized={:?}, generic={:?}",
                specialized_mv, generic_result
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_dualunit(a in any::<DualUnit<f64>>(), b in any::<DualUnit<f64>>()) {
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();
            let mv_b: Multivector<f64, Cl0_0_1> = b.into();

            // LHS: complement(a * b)
            let lhs = (mv_a * mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_dualunit(a in any::<DualUnit<f64>>(), b in any::<DualUnit<f64>>()) {
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();
            let mv_b: Multivector<f64, Cl0_0_1> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = mv_a.complement() * mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// De Morgan: complement(a * b) = complement(a)  complement(b)
        #[test]
        fn de_morgan_geometric_scalar(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();
            let mv_b: Multivector<f64, Cl0_0_1> = b.into();

            // LHS: complement(a * b)
            let lhs = (mv_a * mv_b).complement();

            // RHS: complement(a)  complement(b)
            let rhs = mv_a.complement().antiproduct(&mv_b.complement());

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (geometric) failed: complement(a*b)={:?}, complement(a)complement(b)={:?}",
                lhs, rhs
            );
        }

        /// De Morgan: complement(a  b) = complement(a) * complement(b)
        #[test]
        fn de_morgan_antiproduct_scalar(a in any::<Scalar<f64>>(), b in any::<Scalar<f64>>()) {
            let mv_a: Multivector<f64, Cl0_0_1> = a.into();
            let mv_b: Multivector<f64, Cl0_0_1> = b.into();

            // LHS: complement(a  b)
            let lhs = mv_a.antiproduct(&mv_b).complement();

            // RHS: complement(a) * complement(b)
            let rhs = mv_a.complement() * mv_b.complement();

            prop_assert!(
                relative_eq!(lhs, rhs, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "De Morgan (antiproduct) failed: complement(ab)={:?}, complement(a)*complement(b)={:?}",
                lhs, rhs
            );
        }
    }

    proptest! {
        /// Bulk<Scalar>.bulk_norm() should equal 1.0 (by definition of Bulk wrapper).
        #[test]
        fn bulk_scalar_bulk_norm_matches_inner(b in any::<Bulk<Scalar<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_bulk = <Scalar<f64> as DegenerateNormed>::bulk_norm(b.as_inner());
            let wrapper_bulk = <Bulk<Scalar<f64>> as DegenerateNormed>::bulk_norm(&b);

            prop_assert!(
                relative_eq!(inner_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Inner bulk_norm should be 1.0, got {}", inner_bulk
            );
            prop_assert!(
                relative_eq!(wrapper_bulk, 1.0, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Wrapper bulk_norm should be 1.0, got {}", wrapper_bulk
            );
        }

        /// Bulk<Scalar>.weight_norm() should match inner's weight_norm (delegation).
        #[test]
        fn bulk_scalar_weight_norm_delegates(b in any::<Bulk<Scalar<f64>>>()) {
            // Use explicit trait syntax to specify the type
            let inner_weight = <Scalar<f64> as DegenerateNormed>::weight_norm(b.as_inner());
            let wrapper_weight = <Bulk<Scalar<f64>> as DegenerateNormed>::weight_norm(&b);

            prop_assert!(
                relative_eq!(inner_weight, wrapper_weight, epsilon = REL_EPSILON, max_relative = REL_EPSILON),
                "Weight norms should match: {} vs {}", inner_weight, wrapper_weight
            );
        }
    }
}
