#![doc = " Trait implementations for elliptic2."]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
use super::types::{Line, Point, Pseudoscalar, Rotor, Scalar};
#[allow(unused_imports)]
use crate::ops::{
    Antidot, Antireverse, Antisandwich, Antiwedge, BulkContract, BulkExpand, Dot,
    InverseAntisandwich, InverseSandwich, Involute, LeftContract, Reverse, RightComplement,
    RightContract, Sandwich, ScalarProduct, Transform, Versor, VersorInverse, Wedge,
    WeightContract, WeightDual, WeightExpand,
};
use crate::scalar::Float;
#[allow(unused_imports)]
use crate::wrappers::Unit;
use approx::{AbsDiffEq, RelativeEq, UlpsEq};
use std::ops::{Add, Mul, Neg, Sub};
impl<T: Float> Add for Line<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.xy() + rhs.xy(),
            self.xz() + rhs.xz(),
            self.yz() + rhs.yz(),
        )
    }
}
impl<T: Float> Sub for Line<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.xy() - rhs.xy(),
            self.xz() - rhs.xz(),
            self.yz() - rhs.yz(),
        )
    }
}
impl<T: Float> Neg for Line<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.xy(), -self.xz(), -self.yz())
    }
}
impl<T: Float> Mul<T> for Line<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Line<f32>> for f32 {
    type Output = Line<f32>;
    #[inline]
    fn mul(self, v: Line<f32>) -> Line<f32> {
        v.scale(self)
    }
}
impl Mul<Line<f64>> for f64 {
    type Output = Line<f64>;
    #[inline]
    fn mul(self, v: Line<f64>) -> Line<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Line<T>> for Line<T> {
    type Output = Rotor<T>;
    #[inline]
    fn mul(self, rhs: Line<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            -(self.xy() * rhs.xy()) + -(self.xz() * rhs.xz()) + -(self.yz() * rhs.yz()),
            -(self.xz() * rhs.yz()) + self.yz() * rhs.xz(),
            self.xy() * rhs.yz() + -(self.yz() * rhs.xy()),
            -(self.xy() * rhs.xz()) + self.xz() * rhs.xy(),
        )
    }
}
impl<T: Float> Mul<Pseudoscalar<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn mul(self, rhs: Pseudoscalar<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.yz() * rhs.xyz()),
            self.xz() * rhs.xyz(),
            -(self.xy() * rhs.xyz()),
        )
    }
}
impl<T: Float> Mul<Rotor<T>> for Line<T> {
    type Output = Rotor<T>;
    #[inline]
    fn mul(self, rhs: Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            -(self.xy() * rhs.xy()) + -(self.xz() * rhs.xz()) + -(self.yz() * rhs.yz()),
            rhs.s() * self.xy() + -(self.xz() * rhs.yz()) + self.yz() * rhs.xz(),
            rhs.s() * self.xz() + self.xy() * rhs.yz() + -(self.yz() * rhs.xy()),
            rhs.s() * self.yz() + -(self.xy() * rhs.xz()) + self.xz() * rhs.xy(),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.s() * self.xy(),
            rhs.s() * self.xz(),
            rhs.s() * self.yz(),
        )
    }
}
impl<T: Float> Add for Point<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.x() + rhs.x(), self.y() + rhs.y(), self.z() + rhs.z())
    }
}
impl<T: Float> Sub for Point<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.x() - rhs.x(), self.y() - rhs.y(), self.z() - rhs.z())
    }
}
impl<T: Float> Neg for Point<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.x(), -self.y(), -self.z())
    }
}
impl<T: Float> Mul<T> for Point<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Point<f32>> for f32 {
    type Output = Point<f32>;
    #[inline]
    fn mul(self, v: Point<f32>) -> Point<f32> {
        v.scale(self)
    }
}
impl Mul<Point<f64>> for f64 {
    type Output = Point<f64>;
    #[inline]
    fn mul(self, v: Point<f64>) -> Point<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Point<T>> for Point<T> {
    type Output = Rotor<T>;
    #[inline]
    fn mul(self, rhs: Point<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            self.x() * rhs.x() + self.y() * rhs.y() + self.z() * rhs.z(),
            self.x() * rhs.y() + -(self.y() * rhs.x()),
            self.x() * rhs.z() + -(rhs.x() * self.z()),
            self.y() * rhs.z() + -(rhs.y() * self.z()),
        )
    }
}
impl<T: Float> Mul<Pseudoscalar<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn mul(self, rhs: Pseudoscalar<T>) -> Line<T> {
        Line::new_unchecked(
            self.z() * rhs.xyz(),
            -(self.y() * rhs.xyz()),
            self.x() * rhs.xyz(),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Point<T> {
        Point::new_unchecked(self.x() * rhs.s(), self.y() * rhs.s(), rhs.s() * self.z())
    }
}
impl<T: Float> Add for Pseudoscalar<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.xyz() + rhs.xyz())
    }
}
impl<T: Float> Sub for Pseudoscalar<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.xyz() - rhs.xyz())
    }
}
impl<T: Float> Neg for Pseudoscalar<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.xyz())
    }
}
impl<T: Float> Mul<T> for Pseudoscalar<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Pseudoscalar<f32>> for f32 {
    type Output = Pseudoscalar<f32>;
    #[inline]
    fn mul(self, v: Pseudoscalar<f32>) -> Pseudoscalar<f32> {
        v.scale(self)
    }
}
impl Mul<Pseudoscalar<f64>> for f64 {
    type Output = Pseudoscalar<f64>;
    #[inline]
    fn mul(self, v: Pseudoscalar<f64>) -> Pseudoscalar<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Line<T>> for Pseudoscalar<T> {
    type Output = Point<T>;
    #[inline]
    fn mul(self, rhs: Line<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.xyz() * rhs.yz()),
            self.xyz() * rhs.xz(),
            -(self.xyz() * rhs.xy()),
        )
    }
}
impl<T: Float> Mul<Point<T>> for Pseudoscalar<T> {
    type Output = Line<T>;
    #[inline]
    fn mul(self, rhs: Point<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.z() * self.xyz(),
            -(rhs.y() * self.xyz()),
            rhs.x() * self.xyz(),
        )
    }
}
impl<T: Float> Mul<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn mul(self, rhs: Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.xyz() * rhs.xyz()))
    }
}
impl<T: Float> Mul<Scalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.s() * self.xyz())
    }
}
impl<T: Float> Add for Rotor<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.s() + rhs.s(),
            self.xy() + rhs.xy(),
            self.xz() + rhs.xz(),
            self.yz() + rhs.yz(),
        )
    }
}
impl<T: Float> Sub for Rotor<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(
            self.s() - rhs.s(),
            self.xy() - rhs.xy(),
            self.xz() - rhs.xz(),
            self.yz() - rhs.yz(),
        )
    }
}
impl<T: Float> Neg for Rotor<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.s(), -self.xy(), -self.xz(), -self.yz())
    }
}
impl<T: Float> Mul<T> for Rotor<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Rotor<f32>> for f32 {
    type Output = Rotor<f32>;
    #[inline]
    fn mul(self, v: Rotor<f32>) -> Rotor<f32> {
        v.scale(self)
    }
}
impl Mul<Rotor<f64>> for f64 {
    type Output = Rotor<f64>;
    #[inline]
    fn mul(self, v: Rotor<f64>) -> Rotor<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Line<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn mul(self, rhs: Line<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            -(self.xy() * rhs.xy()) + -(self.xz() * rhs.xz()) + -(self.yz() * rhs.yz()),
            self.s() * rhs.xy() + -(self.xz() * rhs.yz()) + self.yz() * rhs.xz(),
            self.s() * rhs.xz() + self.xy() * rhs.yz() + -(self.yz() * rhs.xy()),
            self.s() * rhs.yz() + -(self.xy() * rhs.xz()) + self.xz() * rhs.xy(),
        )
    }
}
impl<T: Float> Mul<Rotor<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn mul(self, rhs: Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            self.s() * rhs.s()
                + -(self.xy() * rhs.xy())
                + -(self.xz() * rhs.xz())
                + -(self.yz() * rhs.yz()),
            self.s() * rhs.xy()
                + rhs.s() * self.xy()
                + -(self.xz() * rhs.yz())
                + self.yz() * rhs.xz(),
            self.s() * rhs.xz()
                + rhs.s() * self.xz()
                + self.xy() * rhs.yz()
                + -(self.yz() * rhs.xy()),
            self.s() * rhs.yz()
                + rhs.s() * self.yz()
                + -(self.xy() * rhs.xz())
                + self.xz() * rhs.xy(),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            self.s() * rhs.s(),
            rhs.s() * self.xy(),
            rhs.s() * self.xz(),
            rhs.s() * self.yz(),
        )
    }
}
impl<T: Float> Add for Scalar<T> {
    type Output = Self;
    #[inline]
    fn add(self, rhs: Self) -> Self {
        Self::new_unchecked(self.s() + rhs.s())
    }
}
impl<T: Float> Sub for Scalar<T> {
    type Output = Self;
    #[inline]
    fn sub(self, rhs: Self) -> Self {
        Self::new_unchecked(self.s() - rhs.s())
    }
}
impl<T: Float> Neg for Scalar<T> {
    type Output = Self;
    #[inline]
    fn neg(self) -> Self {
        Self::new_unchecked(-self.s())
    }
}
impl<T: Float> Mul<T> for Scalar<T> {
    type Output = Self;
    #[inline]
    fn mul(self, scalar: T) -> Self {
        self.scale(scalar)
    }
}
impl Mul<Scalar<f32>> for f32 {
    type Output = Scalar<f32>;
    #[inline]
    fn mul(self, v: Scalar<f32>) -> Scalar<f32> {
        v.scale(self)
    }
}
impl Mul<Scalar<f64>> for f64 {
    type Output = Scalar<f64>;
    #[inline]
    fn mul(self, v: Scalar<f64>) -> Scalar<f64> {
        v.scale(self)
    }
}
impl<T: Float> Mul<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn mul(self, rhs: Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.s() * rhs.xy(),
            self.s() * rhs.xz(),
            self.s() * rhs.yz(),
        )
    }
}
impl<T: Float> Mul<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn mul(self, rhs: Point<T>) -> Point<T> {
        Point::new_unchecked(self.s() * rhs.x(), self.s() * rhs.y(), self.s() * rhs.z())
    }
}
impl<T: Float> Mul<Pseudoscalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn mul(self, rhs: Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.s() * rhs.xyz())
    }
}
impl<T: Float> Mul<Rotor<T>> for Scalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn mul(self, rhs: Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            self.s() * rhs.s(),
            self.s() * rhs.xy(),
            self.s() * rhs.xz(),
            self.s() * rhs.yz(),
        )
    }
}
impl<T: Float> Mul<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn mul(self, rhs: Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
impl<T: Float> Wedge<Point<T>> for Line<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Point<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            rhs.x() * self.yz() + -(rhs.y() * self.xz()) + rhs.z() * self.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Point<T>> for Unit<Line<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Point<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            rhs.x() * self.as_inner().yz()
                + -(rhs.y() * self.as_inner().xz())
                + rhs.z() * self.as_inner().xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Point<T>>> for Line<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Point<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            rhs.as_inner().x() * self.yz()
                + -(rhs.as_inner().y() * self.xz())
                + rhs.as_inner().z() * self.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Point<T>>> for Unit<Line<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Point<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            rhs.as_inner().x() * self.as_inner().yz()
                + -(rhs.as_inner().y() * self.as_inner().xz())
                + rhs.as_inner().z() * self.as_inner().xy(),
        )
    }
}
impl<T: Float> Wedge<Scalar<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.s() * self.xy(),
            rhs.s() * self.xz(),
            rhs.s() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.s() * self.as_inner().xy(),
            rhs.s() * self.as_inner().xz(),
            rhs.s() * self.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().s() * self.xy(),
            rhs.as_inner().s() * self.xz(),
            rhs.as_inner().s() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().s() * self.as_inner().xy(),
            rhs.as_inner().s() * self.as_inner().xz(),
            rhs.as_inner().s() * self.as_inner().yz(),
        )
    }
}
impl<T: Float> Wedge<Line<T>> for Point<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Line<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.x() * rhs.yz() + -(self.y() * rhs.xz()) + self.z() * rhs.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Line<T>> for Unit<Point<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Line<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.as_inner().x() * rhs.yz()
                + -(self.as_inner().y() * rhs.xz())
                + self.as_inner().z() * rhs.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Line<T>>> for Point<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Line<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.x() * rhs.as_inner().yz()
                + -(self.y() * rhs.as_inner().xz())
                + self.z() * rhs.as_inner().xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Line<T>>> for Unit<Point<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Line<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.as_inner().x() * rhs.as_inner().yz()
                + -(self.as_inner().y() * rhs.as_inner().xz())
                + self.as_inner().z() * rhs.as_inner().xy(),
        )
    }
}
impl<T: Float> Wedge<Point<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            self.x() * rhs.y() + -(self.y() * rhs.x()),
            self.x() * rhs.z() + -(rhs.x() * self.z()),
            self.y() * rhs.z() + -(rhs.y() * self.z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Point<T>> for Unit<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            self.as_inner().x() * rhs.y() + -(self.as_inner().y() * rhs.x()),
            self.as_inner().x() * rhs.z() + -(rhs.x() * self.as_inner().z()),
            self.as_inner().y() * rhs.z() + -(rhs.y() * self.as_inner().z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Point<T>>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            self.x() * rhs.as_inner().y() + -(self.y() * rhs.as_inner().x()),
            self.x() * rhs.as_inner().z() + -(rhs.as_inner().x() * self.z()),
            self.y() * rhs.as_inner().z() + -(rhs.as_inner().y() * self.z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Point<T>>> for Unit<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            self.as_inner().x() * rhs.as_inner().y() + -(self.as_inner().y() * rhs.as_inner().x()),
            self.as_inner().x() * rhs.as_inner().z() + -(rhs.as_inner().x() * self.as_inner().z()),
            self.as_inner().y() * rhs.as_inner().z() + -(rhs.as_inner().y() * self.as_inner().z()),
        )
    }
}
impl<T: Float> Wedge<Scalar<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Point<T> {
        Point::new_unchecked(self.x() * rhs.s(), self.y() * rhs.s(), rhs.s() * self.z())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().x() * rhs.s(),
            self.as_inner().y() * rhs.s(),
            rhs.s() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Point<T> {
        Point::new_unchecked(
            self.x() * rhs.as_inner().s(),
            self.y() * rhs.as_inner().s(),
            rhs.as_inner().s() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().x() * rhs.as_inner().s(),
            self.as_inner().y() * rhs.as_inner().s(),
            rhs.as_inner().s() * self.as_inner().z(),
        )
    }
}
impl<T: Float> Wedge<Scalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.s() * self.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.s() * self.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().s() * self.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().s() * self.as_inner().xyz())
    }
}
impl<T: Float> Wedge<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.s() * rhs.xy(),
            self.s() * rhs.xz(),
            self.s() * rhs.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Line<T>> for Unit<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.as_inner().s() * rhs.xy(),
            self.as_inner().s() * rhs.xz(),
            self.as_inner().s() * rhs.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Line<T>>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            self.s() * rhs.as_inner().xy(),
            self.s() * rhs.as_inner().xz(),
            self.s() * rhs.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Line<T>>> for Unit<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            self.as_inner().s() * rhs.as_inner().xy(),
            self.as_inner().s() * rhs.as_inner().xz(),
            self.as_inner().s() * rhs.as_inner().yz(),
        )
    }
}
impl<T: Float> Wedge<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn wedge(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(self.s() * rhs.x(), self.s() * rhs.y(), self.s() * rhs.z())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Point<T>> for Unit<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn wedge(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().s() * rhs.x(),
            self.as_inner().s() * rhs.y(),
            self.as_inner().s() * rhs.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Point<T>>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            self.s() * rhs.as_inner().x(),
            self.s() * rhs.as_inner().y(),
            self.s() * rhs.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Point<T>>> for Unit<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().s() * rhs.as_inner().x(),
            self.as_inner().s() * rhs.as_inner().y(),
            self.as_inner().s() * rhs.as_inner().z(),
        )
    }
}
impl<T: Float> Wedge<Pseudoscalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.s() * rhs.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Pseudoscalar<T>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.as_inner().s() * rhs.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Pseudoscalar<T>>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.s() * rhs.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Pseudoscalar<T>>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.as_inner().s() * rhs.as_inner().xyz())
    }
}
impl<T: Float> Wedge<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Wedge<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn wedge(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.as_inner().s())
    }
}
impl<T: Float> Antiwedge<Line<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            self.xy() * rhs.xz() + -(self.xz() * rhs.xy()),
            self.xy() * rhs.yz() + -(self.yz() * rhs.xy()),
            self.xz() * rhs.yz() + -(self.yz() * rhs.xz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Line<T>> for Unit<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().xy() * rhs.xz() + -(self.as_inner().xz() * rhs.xy()),
            self.as_inner().xy() * rhs.yz() + -(self.as_inner().yz() * rhs.xy()),
            self.as_inner().xz() * rhs.yz() + -(self.as_inner().yz() * rhs.xz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Line<T>>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            self.xy() * rhs.as_inner().xz() + -(self.xz() * rhs.as_inner().xy()),
            self.xy() * rhs.as_inner().yz() + -(self.yz() * rhs.as_inner().xy()),
            self.xz() * rhs.as_inner().yz() + -(self.yz() * rhs.as_inner().xz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Line<T>>> for Unit<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().xy() * rhs.as_inner().xz()
                + -(self.as_inner().xz() * rhs.as_inner().xy()),
            self.as_inner().xy() * rhs.as_inner().yz()
                + -(self.as_inner().yz() * rhs.as_inner().xy()),
            self.as_inner().xz() * rhs.as_inner().yz()
                + -(self.as_inner().yz() * rhs.as_inner().xz()),
        )
    }
}
impl<T: Float> Antiwedge<Point<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.x() * self.yz() + -(rhs.y() * self.xz()) + rhs.z() * self.xy())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Point<T>> for Unit<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.x() * self.as_inner().yz()
                + -(rhs.y() * self.as_inner().xz())
                + rhs.z() * self.as_inner().xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Point<T>>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.as_inner().x() * self.yz()
                + -(rhs.as_inner().y() * self.xz())
                + rhs.as_inner().z() * self.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Point<T>>> for Unit<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            rhs.as_inner().x() * self.as_inner().yz()
                + -(rhs.as_inner().y() * self.as_inner().xz())
                + rhs.as_inner().z() * self.as_inner().xy(),
        )
    }
}
impl<T: Float> Antiwedge<Pseudoscalar<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Pseudoscalar<T>) -> Line<T> {
        Line::new_unchecked(
            self.xy() * rhs.xyz(),
            self.xz() * rhs.xyz(),
            self.yz() * rhs.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Pseudoscalar<T>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Pseudoscalar<T>) -> Line<T> {
        Line::new_unchecked(
            self.as_inner().xy() * rhs.xyz(),
            self.as_inner().xz() * rhs.xyz(),
            self.as_inner().yz() * rhs.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Pseudoscalar<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Line<T> {
        Line::new_unchecked(
            self.xy() * rhs.as_inner().xyz(),
            self.xz() * rhs.as_inner().xyz(),
            self.yz() * rhs.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Pseudoscalar<T>>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Line<T> {
        Line::new_unchecked(
            self.as_inner().xy() * rhs.as_inner().xyz(),
            self.as_inner().xz() * rhs.as_inner().xyz(),
            self.as_inner().yz() * rhs.as_inner().xyz(),
        )
    }
}
impl<T: Float> Antiwedge<Line<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.x() * rhs.yz() + -(self.y() * rhs.xz()) + self.z() * rhs.xy())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Line<T>> for Unit<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.as_inner().x() * rhs.yz()
                + -(self.as_inner().y() * rhs.xz())
                + self.as_inner().z() * rhs.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Line<T>>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.x() * rhs.as_inner().yz()
                + -(self.y() * rhs.as_inner().xz())
                + self.z() * rhs.as_inner().xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Line<T>>> for Unit<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.as_inner().x() * rhs.as_inner().yz()
                + -(self.as_inner().y() * rhs.as_inner().xz())
                + self.as_inner().z() * rhs.as_inner().xy(),
        )
    }
}
impl<T: Float> Antiwedge<Pseudoscalar<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Pseudoscalar<T>) -> Point<T> {
        Point::new_unchecked(
            self.x() * rhs.xyz(),
            self.y() * rhs.xyz(),
            self.z() * rhs.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Pseudoscalar<T>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Pseudoscalar<T>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().x() * rhs.xyz(),
            self.as_inner().y() * rhs.xyz(),
            self.as_inner().z() * rhs.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Pseudoscalar<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Point<T> {
        Point::new_unchecked(
            self.x() * rhs.as_inner().xyz(),
            self.y() * rhs.as_inner().xyz(),
            self.z() * rhs.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Pseudoscalar<T>>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().x() * rhs.as_inner().xyz(),
            self.as_inner().y() * rhs.as_inner().xyz(),
            self.as_inner().z() * rhs.as_inner().xyz(),
        )
    }
}
impl<T: Float> Antiwedge<Line<T>> for Pseudoscalar<T> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.xyz() * rhs.xy(),
            self.xyz() * rhs.xz(),
            self.xyz() * rhs.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Line<T>> for Unit<Pseudoscalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.as_inner().xyz() * rhs.xy(),
            self.as_inner().xyz() * rhs.xz(),
            self.as_inner().xyz() * rhs.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Line<T>>> for Pseudoscalar<T> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            self.xyz() * rhs.as_inner().xy(),
            self.xyz() * rhs.as_inner().xz(),
            self.xyz() * rhs.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Line<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            self.as_inner().xyz() * rhs.as_inner().xy(),
            self.as_inner().xyz() * rhs.as_inner().xz(),
            self.as_inner().xyz() * rhs.as_inner().yz(),
        )
    }
}
impl<T: Float> Antiwedge<Point<T>> for Pseudoscalar<T> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.x() * self.xyz(),
            rhs.y() * self.xyz(),
            rhs.z() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Point<T>> for Unit<Pseudoscalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.x() * self.as_inner().xyz(),
            rhs.y() * self.as_inner().xyz(),
            rhs.z() * self.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Point<T>>> for Pseudoscalar<T> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            rhs.as_inner().x() * self.xyz(),
            rhs.as_inner().y() * self.xyz(),
            rhs.as_inner().z() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Point<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            rhs.as_inner().x() * self.as_inner().xyz(),
            rhs.as_inner().y() * self.as_inner().xyz(),
            rhs.as_inner().z() * self.as_inner().xyz(),
        )
    }
}
impl<T: Float> Antiwedge<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.xyz() * rhs.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.as_inner().xyz() * rhs.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.xyz() * rhs.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.as_inner().xyz() * rhs.as_inner().xyz())
    }
}
impl<T: Float> Antiwedge<Scalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Scalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.s() * self.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Scalar<T>>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().s() * self.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Scalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(rhs.as_inner().s() * self.as_inner().xyz())
    }
}
impl<T: Float> Antiwedge<Pseudoscalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Pseudoscalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Pseudoscalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antiwedge<Unit<Pseudoscalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antiwedge(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.as_inner().xyz())
    }
}
impl<T: Float> LeftContract<Line<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.xy() * rhs.xy()) + -(self.xz() * rhs.xz()) + -(self.yz() * rhs.yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Line<T>> for Unit<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.as_inner().xy() * rhs.xy())
                + -(self.as_inner().xz() * rhs.xz())
                + -(self.as_inner().yz() * rhs.yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Line<T>>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.xy() * rhs.as_inner().xy())
                + -(self.xz() * rhs.as_inner().xz())
                + -(self.yz() * rhs.as_inner().yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Line<T>>> for Unit<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.as_inner().xy() * rhs.as_inner().xy())
                + -(self.as_inner().xz() * rhs.as_inner().xz())
                + -(self.as_inner().yz() * rhs.as_inner().yz()),
        )
    }
}
impl<T: Float> LeftContract<Pseudoscalar<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Pseudoscalar<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.yz() * rhs.xyz()),
            self.xz() * rhs.xyz(),
            -(self.xy() * rhs.xyz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Pseudoscalar<T>> for Unit<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Pseudoscalar<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.as_inner().yz() * rhs.xyz()),
            self.as_inner().xz() * rhs.xyz(),
            -(self.as_inner().xy() * rhs.xyz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Pseudoscalar<T>>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Point<T> {
        Point::new_unchecked(
            -(self.yz() * rhs.as_inner().xyz()),
            self.xz() * rhs.as_inner().xyz(),
            -(self.xy() * rhs.as_inner().xyz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Pseudoscalar<T>>> for Unit<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Point<T> {
        Point::new_unchecked(
            -(self.as_inner().yz() * rhs.as_inner().xyz()),
            self.as_inner().xz() * rhs.as_inner().xyz(),
            -(self.as_inner().xy() * rhs.as_inner().xyz()),
        )
    }
}
impl<T: Float> LeftContract<Line<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.y() * rhs.xy()) + -(self.z() * rhs.xz()),
            self.x() * rhs.xy() + -(self.z() * rhs.yz()),
            self.x() * rhs.xz() + self.y() * rhs.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Line<T>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.as_inner().y() * rhs.xy()) + -(self.as_inner().z() * rhs.xz()),
            self.as_inner().x() * rhs.xy() + -(self.as_inner().z() * rhs.yz()),
            self.as_inner().x() * rhs.xz() + self.as_inner().y() * rhs.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Line<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            -(self.y() * rhs.as_inner().xy()) + -(self.z() * rhs.as_inner().xz()),
            self.x() * rhs.as_inner().xy() + -(self.z() * rhs.as_inner().yz()),
            self.x() * rhs.as_inner().xz() + self.y() * rhs.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Line<T>>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            -(self.as_inner().y() * rhs.as_inner().xy())
                + -(self.as_inner().z() * rhs.as_inner().xz()),
            self.as_inner().x() * rhs.as_inner().xy()
                + -(self.as_inner().z() * rhs.as_inner().yz()),
            self.as_inner().x() * rhs.as_inner().xz() + self.as_inner().y() * rhs.as_inner().yz(),
        )
    }
}
impl<T: Float> LeftContract<Point<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.x() * rhs.x() + self.y() * rhs.y() + self.z() * rhs.z())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Point<T>> for Unit<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.as_inner().x() * rhs.x()
                + self.as_inner().y() * rhs.y()
                + self.as_inner().z() * rhs.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Point<T>>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.x() * rhs.as_inner().x()
                + self.y() * rhs.as_inner().y()
                + self.z() * rhs.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Point<T>>> for Unit<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.as_inner().x() * rhs.as_inner().x()
                + self.as_inner().y() * rhs.as_inner().y()
                + self.as_inner().z() * rhs.as_inner().z(),
        )
    }
}
impl<T: Float> LeftContract<Pseudoscalar<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Pseudoscalar<T>) -> Line<T> {
        Line::new_unchecked(
            self.z() * rhs.xyz(),
            -(self.y() * rhs.xyz()),
            self.x() * rhs.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Pseudoscalar<T>> for Unit<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Pseudoscalar<T>) -> Line<T> {
        Line::new_unchecked(
            self.as_inner().z() * rhs.xyz(),
            -(self.as_inner().y() * rhs.xyz()),
            self.as_inner().x() * rhs.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Pseudoscalar<T>>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Line<T> {
        Line::new_unchecked(
            self.z() * rhs.as_inner().xyz(),
            -(self.y() * rhs.as_inner().xyz()),
            self.x() * rhs.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Pseudoscalar<T>>> for Unit<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Line<T> {
        Line::new_unchecked(
            self.as_inner().z() * rhs.as_inner().xyz(),
            -(self.as_inner().y() * rhs.as_inner().xyz()),
            self.as_inner().x() * rhs.as_inner().xyz(),
        )
    }
}
impl<T: Float> LeftContract<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.xyz() * rhs.xyz()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().xyz() * rhs.xyz()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.xyz() * rhs.as_inner().xyz()))
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().xyz() * rhs.as_inner().xyz()))
    }
}
impl<T: Float> LeftContract<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.s() * rhs.xy(),
            self.s() * rhs.xz(),
            self.s() * rhs.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Line<T>> for Unit<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.as_inner().s() * rhs.xy(),
            self.as_inner().s() * rhs.xz(),
            self.as_inner().s() * rhs.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Line<T>>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            self.s() * rhs.as_inner().xy(),
            self.s() * rhs.as_inner().xz(),
            self.s() * rhs.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Line<T>>> for Unit<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            self.as_inner().s() * rhs.as_inner().xy(),
            self.as_inner().s() * rhs.as_inner().xz(),
            self.as_inner().s() * rhs.as_inner().yz(),
        )
    }
}
impl<T: Float> LeftContract<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(self.s() * rhs.x(), self.s() * rhs.y(), self.s() * rhs.z())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Point<T>> for Unit<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().s() * rhs.x(),
            self.as_inner().s() * rhs.y(),
            self.as_inner().s() * rhs.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Point<T>>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            self.s() * rhs.as_inner().x(),
            self.s() * rhs.as_inner().y(),
            self.s() * rhs.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Point<T>>> for Unit<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().s() * rhs.as_inner().x(),
            self.as_inner().s() * rhs.as_inner().y(),
            self.as_inner().s() * rhs.as_inner().z(),
        )
    }
}
impl<T: Float> LeftContract<Pseudoscalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.s() * rhs.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Pseudoscalar<T>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.as_inner().s() * rhs.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Pseudoscalar<T>>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.s() * rhs.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Pseudoscalar<T>>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.as_inner().s() * rhs.as_inner().xyz())
    }
}
impl<T: Float> LeftContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> LeftContract<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn left_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.as_inner().s())
    }
}
impl<T: Float> RightContract<Line<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.xy() * rhs.xy()) + -(self.xz() * rhs.xz()) + -(self.yz() * rhs.yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Line<T>> for Unit<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.as_inner().xy() * rhs.xy())
                + -(self.as_inner().xz() * rhs.xz())
                + -(self.as_inner().yz() * rhs.yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Line<T>>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.xy() * rhs.as_inner().xy())
                + -(self.xz() * rhs.as_inner().xz())
                + -(self.yz() * rhs.as_inner().yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Line<T>>> for Unit<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.as_inner().xy() * rhs.as_inner().xy())
                + -(self.as_inner().xz() * rhs.as_inner().xz())
                + -(self.as_inner().yz() * rhs.as_inner().yz()),
        )
    }
}
impl<T: Float> RightContract<Point<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.y() * self.xy() + rhs.z() * self.xz(),
            -(rhs.x() * self.xy()) + rhs.z() * self.yz(),
            -(rhs.x() * self.xz()) + -(rhs.y() * self.yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Point<T>> for Unit<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.y() * self.as_inner().xy() + rhs.z() * self.as_inner().xz(),
            -(rhs.x() * self.as_inner().xy()) + rhs.z() * self.as_inner().yz(),
            -(rhs.x() * self.as_inner().xz()) + -(rhs.y() * self.as_inner().yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Point<T>>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            rhs.as_inner().y() * self.xy() + rhs.as_inner().z() * self.xz(),
            -(rhs.as_inner().x() * self.xy()) + rhs.as_inner().z() * self.yz(),
            -(rhs.as_inner().x() * self.xz()) + -(rhs.as_inner().y() * self.yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Point<T>>> for Unit<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            rhs.as_inner().y() * self.as_inner().xy() + rhs.as_inner().z() * self.as_inner().xz(),
            -(rhs.as_inner().x() * self.as_inner().xy())
                + rhs.as_inner().z() * self.as_inner().yz(),
            -(rhs.as_inner().x() * self.as_inner().xz())
                + -(rhs.as_inner().y() * self.as_inner().yz()),
        )
    }
}
impl<T: Float> RightContract<Scalar<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.s() * self.xy(),
            rhs.s() * self.xz(),
            rhs.s() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.s() * self.as_inner().xy(),
            rhs.s() * self.as_inner().xz(),
            rhs.s() * self.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().s() * self.xy(),
            rhs.as_inner().s() * self.xz(),
            rhs.as_inner().s() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().s() * self.as_inner().xy(),
            rhs.as_inner().s() * self.as_inner().xz(),
            rhs.as_inner().s() * self.as_inner().yz(),
        )
    }
}
impl<T: Float> RightContract<Point<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.x() * rhs.x() + self.y() * rhs.y() + self.z() * rhs.z())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Point<T>> for Unit<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.as_inner().x() * rhs.x()
                + self.as_inner().y() * rhs.y()
                + self.as_inner().z() * rhs.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Point<T>>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.x() * rhs.as_inner().x()
                + self.y() * rhs.as_inner().y()
                + self.z() * rhs.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Point<T>>> for Unit<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.as_inner().x() * rhs.as_inner().x()
                + self.as_inner().y() * rhs.as_inner().y()
                + self.as_inner().z() * rhs.as_inner().z(),
        )
    }
}
impl<T: Float> RightContract<Scalar<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Point<T> {
        Point::new_unchecked(self.x() * rhs.s(), self.y() * rhs.s(), rhs.s() * self.z())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().x() * rhs.s(),
            self.as_inner().y() * rhs.s(),
            rhs.s() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Point<T> {
        Point::new_unchecked(
            self.x() * rhs.as_inner().s(),
            self.y() * rhs.as_inner().s(),
            rhs.as_inner().s() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().x() * rhs.as_inner().s(),
            self.as_inner().y() * rhs.as_inner().s(),
            rhs.as_inner().s() * self.as_inner().z(),
        )
    }
}
impl<T: Float> RightContract<Line<T>> for Pseudoscalar<T> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.xyz() * rhs.yz()),
            self.xyz() * rhs.xz(),
            -(self.xyz() * rhs.xy()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Line<T>> for Unit<Pseudoscalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.as_inner().xyz() * rhs.yz()),
            self.as_inner().xyz() * rhs.xz(),
            -(self.as_inner().xyz() * rhs.xy()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Line<T>>> for Pseudoscalar<T> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            -(self.xyz() * rhs.as_inner().yz()),
            self.xyz() * rhs.as_inner().xz(),
            -(self.xyz() * rhs.as_inner().xy()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Line<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            -(self.as_inner().xyz() * rhs.as_inner().yz()),
            self.as_inner().xyz() * rhs.as_inner().xz(),
            -(self.as_inner().xyz() * rhs.as_inner().xy()),
        )
    }
}
impl<T: Float> RightContract<Point<T>> for Pseudoscalar<T> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.z() * self.xyz(),
            -(rhs.y() * self.xyz()),
            rhs.x() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Point<T>> for Unit<Pseudoscalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.z() * self.as_inner().xyz(),
            -(rhs.y() * self.as_inner().xyz()),
            rhs.x() * self.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Point<T>>> for Pseudoscalar<T> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().z() * self.xyz(),
            -(rhs.as_inner().y() * self.xyz()),
            rhs.as_inner().x() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Point<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().z() * self.as_inner().xyz(),
            -(rhs.as_inner().y() * self.as_inner().xyz()),
            rhs.as_inner().x() * self.as_inner().xyz(),
        )
    }
}
impl<T: Float> RightContract<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.xyz() * rhs.xyz()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().xyz() * rhs.xyz()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.xyz() * rhs.as_inner().xyz()))
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().xyz() * rhs.as_inner().xyz()))
    }
}
impl<T: Float> RightContract<Scalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.s() * self.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.s() * self.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().s() * self.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().s() * self.as_inner().xyz())
    }
}
impl<T: Float> RightContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> RightContract<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn right_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.yz() * operand.yz() * self.xy() + self.xy() * operand.yz() * self.yz()
                - self.xz() * operand.xy() * self.xz()
                + self.xz() * operand.xz() * self.xy()
                - self.yz() * operand.xy() * self.yz()
                + self.xy() * operand.xz() * self.xz()
                + self.xy() * operand.xy() * self.xy(),
            self.xz() * operand.xz() * self.xz()
                + self.xz() * operand.xy() * self.xy()
                + self.xz() * operand.yz() * self.yz()
                + self.xy() * operand.xy() * self.xz()
                + self.yz() * operand.yz() * self.xz()
                - self.xy() * operand.xz() * self.xy()
                - self.yz() * operand.xz() * self.yz(),
            -(self.xz() * operand.yz() * self.xz())
                + self.yz() * operand.xy() * self.xy()
                + self.yz() * operand.xz() * self.xz()
                + self.yz() * operand.yz() * self.yz()
                + self.xz() * operand.xz() * self.yz()
                + self.xy() * operand.xy() * self.yz()
                - self.xy() * operand.yz() * self.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            operand.xy()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.xy()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.yz(),
            -(operand.xz())
                + T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.yz(),
            -(operand.yz())
                + T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.yz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Line<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            self.xy() * self.xy() * operand.as_inner().xy()
                + -(self.xz() * self.xz() * operand.as_inner().xy())
                + -(self.yz() * self.yz() * operand.as_inner().xy())
                + T::TWO * self.xy() * self.xz() * operand.as_inner().xz()
                + T::TWO * self.xy() * self.yz() * operand.as_inner().yz(),
            -(self.xy() * self.xy() * operand.as_inner().xz())
                + self.xz() * self.xz() * operand.as_inner().xz()
                + -(self.yz() * self.yz() * operand.as_inner().xz())
                + T::TWO * self.xy() * self.xz() * operand.as_inner().xy()
                + T::TWO * self.xz() * self.yz() * operand.as_inner().yz(),
            -(self.xy() * self.xy() * operand.as_inner().yz())
                + -(self.xz() * self.xz() * operand.as_inner().yz())
                + self.yz() * self.yz() * operand.as_inner().yz()
                + T::TWO * self.xy() * self.yz() * operand.as_inner().xy()
                + T::TWO * self.xz() * self.yz() * operand.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Line<T>>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            operand.as_inner().xy()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.as_inner().xy()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.as_inner().xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.as_inner().yz(),
            -(operand.as_inner().xz())
                + T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.as_inner().xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.as_inner().yz(),
            -(operand.as_inner().yz())
                + T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.as_inner().yz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.yz() * operand.z() * self.xy() - self.xy() * operand.x() * self.xy()
                + self.xy() * operand.z() * self.yz()
                - self.xz() * operand.x() * self.xz()
                + self.yz() * operand.x() * self.yz()
                - self.yz() * operand.y() * self.xz()
                - self.xz() * operand.y() * self.yz(),
            -(self.xz() * operand.z() * self.xy())
                - self.yz() * operand.x() * self.xz()
                - self.yz() * operand.y() * self.yz()
                - self.xy() * operand.z() * self.xz()
                + self.xz() * operand.y() * self.xz()
                - self.xy() * operand.y() * self.xy()
                - self.xz() * operand.x() * self.yz(),
            self.xy() * operand.x() * self.yz()
                - self.xz() * operand.z() * self.xz()
                - self.yz() * operand.z() * self.yz()
                + self.yz() * operand.x() * self.xy()
                - self.xy() * operand.y() * self.xz()
                - self.xz() * operand.y() * self.xy()
                + self.xy() * operand.z() * self.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Unit<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -(operand.x())
                + T::TWO * operand.x() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.y() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.z() * self.as_inner().xy() * self.as_inner().yz(),
            -(operand.y())
                + T::TWO * operand.y() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.x() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.z() * self.as_inner().xy() * self.as_inner().xz(),
            operand.z()
                + -T::TWO * operand.z() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.z() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.x() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.y() * self.as_inner().xy() * self.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Point<T>>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x() * self.xy() * self.xy())
                + -(operand.as_inner().x() * self.xz() * self.xz())
                + operand.as_inner().x() * self.yz() * self.yz()
                + -T::TWO * operand.as_inner().y() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().z() * self.xy() * self.yz(),
            -(operand.as_inner().y() * self.xy() * self.xy())
                + operand.as_inner().y() * self.xz() * self.xz()
                + -(operand.as_inner().y() * self.yz() * self.yz())
                + -T::TWO * operand.as_inner().x() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().z() * self.xy() * self.xz(),
            operand.as_inner().z() * self.xy() * self.xy()
                + -(operand.as_inner().z() * self.xz() * self.xz())
                + -(operand.as_inner().z() * self.yz() * self.yz())
                + T::TWO * operand.as_inner().x() * self.xy() * self.yz()
                + -T::TWO * operand.as_inner().y() * self.xy() * self.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Point<T>>> for Unit<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x())
                + T::TWO * operand.as_inner().x() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().z() * self.as_inner().xy() * self.as_inner().yz(),
            -(operand.as_inner().y())
                + T::TWO * operand.as_inner().y() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().x() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xy() * self.as_inner().xz(),
            operand.as_inner().z()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().x() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xy() * self.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Line<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.yz() * operand.xyz() * self.yz()
                + self.xy() * operand.xyz() * self.xy()
                + self.xz() * operand.xyz() * self.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Unit<Line<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Line<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.xy() * self.xy() * operand.as_inner().xyz()
                + self.xz() * self.xz() * operand.as_inner().xyz()
                + self.yz() * self.yz() * operand.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Unit<Line<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Rotor<T>> for Line<T> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            self.xy() * operand.yz() * self.xz() - self.yz() * operand.xy() * self.xz()
                + self.xy() * operand.s() * self.xy()
                + self.xz() * operand.s() * self.xz()
                - self.xz() * operand.yz() * self.xy()
                + self.xz() * operand.xy() * self.yz()
                + self.yz() * operand.xz() * self.xy()
                - self.xy() * operand.xz() * self.yz()
                + self.yz() * operand.s() * self.yz(),
            self.xz() * operand.xz() * self.xy()
                + self.xz() * operand.s() * self.yz()
                + self.xy() * operand.xy() * self.xy()
                + self.xy() * operand.xz() * self.xz()
                - self.yz() * operand.xy() * self.yz()
                + self.xy() * operand.yz() * self.yz()
                - self.yz() * operand.s() * self.xz()
                + self.yz() * operand.yz() * self.xy()
                - self.xz() * operand.xy() * self.xz(),
            self.xy() * operand.xy() * self.xz() + self.xz() * operand.xy() * self.xy()
                - self.xy() * operand.xz() * self.xy()
                + self.xz() * operand.yz() * self.yz()
                + self.yz() * operand.yz() * self.xz()
                + self.xz() * operand.xz() * self.xz()
                + self.yz() * operand.s() * self.xy()
                - self.xy() * operand.s() * self.yz()
                - self.yz() * operand.xz() * self.yz(),
            self.xy() * operand.xy() * self.yz()
                - self.xz() * operand.s() * self.xy()
                - self.xy() * operand.yz() * self.xy()
                + self.xy() * operand.s() * self.xz()
                - self.xz() * operand.yz() * self.xz()
                + self.yz() * operand.xz() * self.xz()
                + self.yz() * operand.xy() * self.xy()
                + self.yz() * operand.yz() * self.yz()
                + self.xz() * operand.xz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Rotor<T>> for Unit<Line<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.s(),
            operand.xy()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.xy()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.yz(),
            -(operand.xz())
                + T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.yz(),
            -(operand.yz())
                + T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.yz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Rotor<T>>> for Line<T> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.as_inner().s() * self.xy() * self.xy()
                + operand.as_inner().s() * self.xz() * self.xz()
                + operand.as_inner().s() * self.yz() * self.yz(),
            self.xy() * self.xy() * operand.as_inner().xy()
                + -(self.xz() * self.xz() * operand.as_inner().xy())
                + -(self.yz() * self.yz() * operand.as_inner().xy())
                + T::TWO * self.xy() * self.xz() * operand.as_inner().xz()
                + T::TWO * self.xy() * self.yz() * operand.as_inner().yz(),
            -(self.xy() * self.xy() * operand.as_inner().xz())
                + self.xz() * self.xz() * operand.as_inner().xz()
                + -(self.yz() * self.yz() * operand.as_inner().xz())
                + T::TWO * self.xy() * self.xz() * operand.as_inner().xy()
                + T::TWO * self.xz() * self.yz() * operand.as_inner().yz(),
            -(self.xy() * self.xy() * operand.as_inner().yz())
                + -(self.xz() * self.xz() * operand.as_inner().yz())
                + self.yz() * self.yz() * operand.as_inner().yz()
                + T::TWO * self.xy() * self.yz() * operand.as_inner().xy()
                + T::TWO * self.xz() * self.yz() * operand.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Rotor<T>>> for Unit<Line<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.as_inner().s(),
            operand.as_inner().xy()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.as_inner().xy()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.as_inner().xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.as_inner().yz(),
            -(operand.as_inner().xz())
                + T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.as_inner().xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.as_inner().yz(),
            -(operand.as_inner().yz())
                + T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.as_inner().yz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.xz() * operand.s() * self.xz()
                + self.yz() * operand.s() * self.yz()
                + self.xy() * operand.s() * self.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unit<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            operand.as_inner().s() * self.xy() * self.xy()
                + operand.as_inner().s() * self.xz() * self.xz()
                + operand.as_inner().s() * self.yz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Unit<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.z() * operand.yz() * self.x() + self.x() * operand.yz() * self.z()
                - self.z() * operand.xz() * self.y()
                - self.x() * operand.xy() * self.x()
                - self.y() * operand.xy() * self.y()
                - self.y() * operand.xz() * self.z()
                + self.z() * operand.xy() * self.z(),
            -(self.x() * operand.yz() * self.y())
                - self.y() * operand.xy() * self.z()
                - self.y() * operand.yz() * self.x()
                - self.z() * operand.xy() * self.y()
                - self.x() * operand.xz() * self.x()
                - self.z() * operand.xz() * self.z()
                + self.y() * operand.xz() * self.y(),
            -(self.y() * operand.xz() * self.x()) + self.x() * operand.yz() * self.x()
                - self.y() * operand.yz() * self.y()
                + self.z() * operand.xy() * self.x()
                - self.z() * operand.yz() * self.z()
                + self.x() * operand.xy() * self.z()
                - self.x() * operand.xz() * self.y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Unit<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            -(operand.xy())
                + T::TWO * self.as_inner().z() * self.as_inner().z() * operand.xy()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().z() * operand.xz(),
            -(operand.xz())
                + T::TWO * self.as_inner().y() * self.as_inner().y() * operand.xz()
                + -T::TWO * self.as_inner().x() * self.as_inner().y() * operand.yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().z() * operand.xy(),
            operand.yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().y() * operand.yz()
                + -T::TWO * self.as_inner().z() * self.as_inner().z() * operand.yz()
                + -T::TWO * self.as_inner().x() * self.as_inner().y() * operand.xz()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Line<T>>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(self.x() * self.x() * operand.as_inner().xy())
                + -(self.y() * self.y() * operand.as_inner().xy())
                + self.z() * self.z() * operand.as_inner().xy()
                + T::TWO * self.x() * self.z() * operand.as_inner().yz()
                + -T::TWO * self.y() * self.z() * operand.as_inner().xz(),
            -(self.x() * self.x() * operand.as_inner().xz())
                + self.y() * self.y() * operand.as_inner().xz()
                + -(self.z() * self.z() * operand.as_inner().xz())
                + -T::TWO * self.x() * self.y() * operand.as_inner().yz()
                + -T::TWO * self.y() * self.z() * operand.as_inner().xy(),
            self.x() * self.x() * operand.as_inner().yz()
                + -(self.y() * self.y() * operand.as_inner().yz())
                + -(self.z() * self.z() * operand.as_inner().yz())
                + -T::TWO * self.x() * self.y() * operand.as_inner().xz()
                + T::TWO * self.x() * self.z() * operand.as_inner().xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Line<T>>> for Unit<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(operand.as_inner().xy())
                + T::TWO * self.as_inner().z() * self.as_inner().z() * operand.as_inner().xy()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().z() * operand.as_inner().xz(),
            -(operand.as_inner().xz())
                + T::TWO * self.as_inner().y() * self.as_inner().y() * operand.as_inner().xz()
                + -T::TWO * self.as_inner().x() * self.as_inner().y() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().z() * operand.as_inner().xy(),
            operand.as_inner().yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().y() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().z() * self.as_inner().z() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().x() * self.as_inner().y() * operand.as_inner().xz()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.as_inner().xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.x() * operand.y() * self.y()
                + self.x() * operand.z() * self.z()
                + self.x() * operand.x() * self.x()
                + self.y() * operand.y() * self.x()
                - self.z() * operand.x() * self.z()
                + self.z() * operand.z() * self.x()
                - self.y() * operand.x() * self.y(),
            self.y() * operand.y() * self.y() + self.y() * operand.z() * self.z()
                - self.x() * operand.y() * self.x()
                - self.z() * operand.y() * self.z()
                + self.z() * operand.z() * self.y()
                + self.x() * operand.x() * self.y()
                + self.y() * operand.x() * self.x(),
            self.x() * operand.x() * self.z()
                + self.z() * operand.y() * self.y()
                + self.z() * operand.z() * self.z()
                - self.x() * operand.z() * self.x()
                + self.y() * operand.y() * self.z()
                - self.y() * operand.z() * self.y()
                + self.z() * operand.x() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            operand.x()
                + -T::TWO * operand.x() * self.as_inner().z() * self.as_inner().z()
                + -T::TWO * self.as_inner().y() * self.as_inner().y() * operand.x()
                + T::TWO * self.as_inner().x() * self.as_inner().y() * operand.y()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.z(),
            -(operand.y())
                + T::TWO * self.as_inner().y() * self.as_inner().y() * operand.y()
                + T::TWO * self.as_inner().x() * self.as_inner().y() * operand.x()
                + T::TWO * self.as_inner().y() * self.as_inner().z() * operand.z(),
            -(operand.z())
                + T::TWO * self.as_inner().z() * self.as_inner().z() * operand.z()
                + T::TWO * self.as_inner().x() * operand.x() * self.as_inner().z()
                + T::TWO * self.as_inner().y() * operand.y() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Point<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x() * self.z() * self.z())
                + self.x() * self.x() * operand.as_inner().x()
                + -(self.y() * self.y() * operand.as_inner().x())
                + T::TWO * self.x() * self.y() * operand.as_inner().y()
                + T::TWO * self.x() * self.z() * operand.as_inner().z(),
            -(operand.as_inner().y() * self.z() * self.z())
                + -(self.x() * self.x() * operand.as_inner().y())
                + self.y() * self.y() * operand.as_inner().y()
                + T::TWO * self.x() * self.y() * operand.as_inner().x()
                + T::TWO * self.y() * self.z() * operand.as_inner().z(),
            -(self.x() * self.x() * operand.as_inner().z())
                + -(self.y() * self.y() * operand.as_inner().z())
                + self.z() * self.z() * operand.as_inner().z()
                + T::TWO * self.x() * operand.as_inner().x() * self.z()
                + T::TWO * self.y() * operand.as_inner().y() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Point<T>>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            operand.as_inner().x()
                + -T::TWO * operand.as_inner().x() * self.as_inner().z() * self.as_inner().z()
                + -T::TWO * self.as_inner().y() * self.as_inner().y() * operand.as_inner().x()
                + T::TWO * self.as_inner().x() * self.as_inner().y() * operand.as_inner().y()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.as_inner().z(),
            -(operand.as_inner().y())
                + T::TWO * self.as_inner().y() * self.as_inner().y() * operand.as_inner().y()
                + T::TWO * self.as_inner().x() * self.as_inner().y() * operand.as_inner().x()
                + T::TWO * self.as_inner().y() * self.as_inner().z() * operand.as_inner().z(),
            -(operand.as_inner().z())
                + T::TWO * self.as_inner().z() * self.as_inner().z() * operand.as_inner().z()
                + T::TWO * self.as_inner().x() * operand.as_inner().x() * self.as_inner().z()
                + T::TWO * self.as_inner().y() * operand.as_inner().y() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Point<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.y() * operand.xyz() * self.y()
                + self.z() * operand.xyz() * self.z()
                + self.x() * operand.xyz() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Unit<Point<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Point<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.x() * self.x() * operand.as_inner().xyz()
                + self.y() * self.y() * operand.as_inner().xyz()
                + self.z() * self.z() * operand.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Unit<Point<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Rotor<T>> for Point<T> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            self.x() * operand.xy() * self.y()
                + self.x() * operand.xz() * self.z()
                + self.y() * operand.yz() * self.z()
                - self.y() * operand.xy() * self.x()
                + self.x() * operand.s() * self.x()
                - self.z() * operand.xz() * self.x()
                + self.z() * operand.s() * self.z()
                + self.y() * operand.s() * self.y()
                - self.z() * operand.yz() * self.y(),
            -(self.x() * operand.xy() * self.x()) - self.y() * operand.xy() * self.y()
                + self.z() * operand.yz() * self.x()
                - self.z() * operand.xz() * self.y()
                + self.x() * operand.yz() * self.z()
                + self.x() * operand.s() * self.y()
                - self.y() * operand.xz() * self.z()
                - self.y() * operand.s() * self.x()
                + self.z() * operand.xy() * self.z(),
            -(self.z() * operand.xy() * self.y()) - self.z() * operand.s() * self.x()
                + self.y() * operand.xz() * self.y()
                - self.z() * operand.xz() * self.z()
                - self.y() * operand.yz() * self.x()
                - self.x() * operand.yz() * self.y()
                - self.y() * operand.xy() * self.z()
                + self.x() * operand.s() * self.z()
                - self.x() * operand.xz() * self.x(),
            -(self.x() * operand.xz() * self.y())
                + self.y() * operand.s() * self.z()
                + self.x() * operand.yz() * self.x()
                + self.x() * operand.xy() * self.z()
                - self.y() * operand.xz() * self.x()
                - self.y() * operand.yz() * self.y()
                + self.z() * operand.xy() * self.x()
                - self.z() * operand.yz() * self.z()
                - self.z() * operand.s() * self.y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Rotor<T>> for Unit<Point<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.s(),
            -(operand.xy())
                + T::TWO * self.as_inner().z() * self.as_inner().z() * operand.xy()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().z() * operand.xz(),
            -(operand.xz())
                + T::TWO * self.as_inner().y() * self.as_inner().y() * operand.xz()
                + -T::TWO * self.as_inner().x() * self.as_inner().y() * operand.yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().z() * operand.xy(),
            operand.yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().y() * operand.yz()
                + -T::TWO * self.as_inner().z() * self.as_inner().z() * operand.yz()
                + -T::TWO * self.as_inner().x() * self.as_inner().y() * operand.xz()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Rotor<T>>> for Point<T> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.as_inner().s() * self.z() * self.z()
                + self.x() * self.x() * operand.as_inner().s()
                + self.y() * self.y() * operand.as_inner().s(),
            -(self.x() * self.x() * operand.as_inner().xy())
                + -(self.y() * self.y() * operand.as_inner().xy())
                + self.z() * self.z() * operand.as_inner().xy()
                + T::TWO * self.x() * self.z() * operand.as_inner().yz()
                + -T::TWO * self.y() * self.z() * operand.as_inner().xz(),
            -(self.x() * self.x() * operand.as_inner().xz())
                + self.y() * self.y() * operand.as_inner().xz()
                + -(self.z() * self.z() * operand.as_inner().xz())
                + -T::TWO * self.x() * self.y() * operand.as_inner().yz()
                + -T::TWO * self.y() * self.z() * operand.as_inner().xy(),
            self.x() * self.x() * operand.as_inner().yz()
                + -(self.y() * self.y() * operand.as_inner().yz())
                + -(self.z() * self.z() * operand.as_inner().yz())
                + -T::TWO * self.x() * self.y() * operand.as_inner().xz()
                + T::TWO * self.x() * self.z() * operand.as_inner().xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Rotor<T>>> for Unit<Point<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.as_inner().s(),
            -(operand.as_inner().xy())
                + T::TWO * self.as_inner().z() * self.as_inner().z() * operand.as_inner().xy()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().z() * operand.as_inner().xz(),
            -(operand.as_inner().xz())
                + T::TWO * self.as_inner().y() * self.as_inner().y() * operand.as_inner().xz()
                + -T::TWO * self.as_inner().x() * self.as_inner().y() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().z() * operand.as_inner().xy(),
            operand.as_inner().yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().y() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().z() * self.as_inner().z() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().x() * self.as_inner().y() * operand.as_inner().xz()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.as_inner().xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.y() * operand.s() * self.y()
                + self.z() * operand.s() * self.z()
                + self.x() * operand.s() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unit<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            operand.as_inner().s() * self.z() * self.z()
                + self.x() * self.x() * operand.as_inner().s()
                + self.y() * self.y() * operand.as_inner().s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Unit<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Pseudoscalar<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.xyz() * operand.xy() * self.xyz(),
            self.xyz() * operand.xz() * self.xyz(),
            self.xyz() * operand.yz() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Unit<Pseudoscalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(operand.xy(), operand.xz(), operand.yz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Line<T>>> for Pseudoscalar<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            self.xyz() * self.xyz() * operand.as_inner().xy(),
            self.xyz() * self.xyz() * operand.as_inner().xz(),
            self.xyz() * self.xyz() * operand.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Line<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            operand.as_inner().xy(),
            operand.as_inner().xz(),
            operand.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Pseudoscalar<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.xyz() * operand.x() * self.xyz(),
            self.xyz() * operand.y() * self.xyz(),
            self.xyz() * operand.z() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Unit<Pseudoscalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(operand.x(), operand.y(), operand.z())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Point<T>>> for Pseudoscalar<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            operand.as_inner().x() * self.xyz() * self.xyz(),
            operand.as_inner().y() * self.xyz() * self.xyz(),
            operand.as_inner().z() * self.xyz() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Point<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            operand.as_inner().x(),
            operand.as_inner().y(),
            operand.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.xyz() * operand.xyz() * self.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.xyz() * self.xyz() * operand.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Rotor<T>> for Pseudoscalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            self.xyz() * operand.s() * self.xyz(),
            self.xyz() * operand.xy() * self.xyz(),
            self.xyz() * operand.xz() * self.xyz(),
            self.xyz() * operand.yz() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Rotor<T>> for Unit<Pseudoscalar<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(operand.s(), operand.xy(), operand.xz(), operand.yz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Rotor<T>>> for Pseudoscalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.as_inner().s() * self.xyz() * self.xyz(),
            self.xyz() * self.xyz() * operand.as_inner().xy(),
            self.xyz() * self.xyz() * operand.as_inner().xz(),
            self.xyz() * self.xyz() * operand.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Rotor<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.as_inner().s(),
            operand.as_inner().xy(),
            operand.as_inner().xz(),
            operand.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.xyz() * operand.s() * self.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s() * self.xyz() * self.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Rotor<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.xz() * operand.xz() * self.xy() - self.s() * operand.yz() * self.xz()
                + self.yz() * operand.yz() * self.xy()
                + self.s() * operand.xz() * self.yz()
                + self.xy() * operand.xy() * self.xy()
                - self.yz() * operand.xy() * self.yz()
                + self.xy() * operand.xz() * self.xz()
                + self.xy() * operand.yz() * self.yz()
                + self.s() * operand.xy() * self.s()
                - self.xz() * operand.xy() * self.xz()
                + self.yz() * operand.xz() * self.s()
                - self.xz() * operand.yz() * self.s(),
            self.xz() * operand.yz() * self.yz()
                - self.yz() * operand.xy() * self.s()
                - self.yz() * operand.xz() * self.yz()
                + self.xz() * operand.xz() * self.xz()
                + self.yz() * operand.yz() * self.xz()
                + self.xz() * operand.xy() * self.xy()
                - self.xy() * operand.xz() * self.xy()
                + self.s() * operand.xz() * self.s()
                - self.s() * operand.xy() * self.yz()
                + self.xy() * operand.xy() * self.xz()
                + self.s() * operand.yz() * self.xy()
                + self.xy() * operand.yz() * self.s(),
            self.xz() * operand.xy() * self.s() - self.xz() * operand.yz() * self.xz()
                + self.yz() * operand.xy() * self.xy()
                + self.s() * operand.yz() * self.s()
                - self.xy() * operand.xz() * self.s()
                + self.yz() * operand.yz() * self.yz()
                + self.xy() * operand.xy() * self.yz()
                - self.s() * operand.xz() * self.xy()
                + self.xz() * operand.xz() * self.yz()
                + self.yz() * operand.xz() * self.xz()
                - self.xy() * operand.yz() * self.xy()
                + self.s() * operand.xy() * self.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Unit<Rotor<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            operand.xy()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.xy()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.xy()
                + -T::TWO * self.as_inner().s() * self.as_inner().xz() * operand.yz()
                + T::TWO * self.as_inner().s() * self.as_inner().yz() * operand.xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.yz(),
            operand.xz()
                + -T::TWO * self.as_inner().xy() * self.as_inner().xy() * operand.xz()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.xz()
                + T::TWO * self.as_inner().s() * self.as_inner().xy() * operand.yz()
                + -T::TWO * self.as_inner().s() * self.as_inner().yz() * operand.xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.yz(),
            operand.yz()
                + -T::TWO * self.as_inner().xy() * self.as_inner().xy() * operand.yz()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.yz()
                + -T::TWO * self.as_inner().s() * self.as_inner().xy() * operand.xz()
                + T::TWO * self.as_inner().s() * self.as_inner().xz() * operand.xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Line<T>>> for Rotor<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            self.s() * self.s() * operand.as_inner().xy()
                + self.xy() * self.xy() * operand.as_inner().xy()
                + -(self.xz() * self.xz() * operand.as_inner().xy())
                + -(self.yz() * self.yz() * operand.as_inner().xy())
                + -T::TWO * self.s() * self.xz() * operand.as_inner().yz()
                + T::TWO * self.s() * self.yz() * operand.as_inner().xz()
                + T::TWO * self.xy() * self.xz() * operand.as_inner().xz()
                + T::TWO * self.xy() * self.yz() * operand.as_inner().yz(),
            self.s() * self.s() * operand.as_inner().xz()
                + -(self.xy() * self.xy() * operand.as_inner().xz())
                + self.xz() * self.xz() * operand.as_inner().xz()
                + -(self.yz() * self.yz() * operand.as_inner().xz())
                + T::TWO * self.s() * self.xy() * operand.as_inner().yz()
                + -T::TWO * self.s() * self.yz() * operand.as_inner().xy()
                + T::TWO * self.xy() * self.xz() * operand.as_inner().xy()
                + T::TWO * self.xz() * self.yz() * operand.as_inner().yz(),
            self.s() * self.s() * operand.as_inner().yz()
                + -(self.xy() * self.xy() * operand.as_inner().yz())
                + -(self.xz() * self.xz() * operand.as_inner().yz())
                + self.yz() * self.yz() * operand.as_inner().yz()
                + -T::TWO * self.s() * self.xy() * operand.as_inner().xz()
                + T::TWO * self.s() * self.xz() * operand.as_inner().xy()
                + T::TWO * self.xy() * self.yz() * operand.as_inner().xy()
                + T::TWO * self.xz() * self.yz() * operand.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Line<T>>> for Unit<Rotor<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            operand.as_inner().xy()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.as_inner().xy()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.as_inner().xy()
                + -T::TWO * self.as_inner().s() * self.as_inner().xz() * operand.as_inner().yz()
                + T::TWO * self.as_inner().s() * self.as_inner().yz() * operand.as_inner().xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.as_inner().xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.as_inner().yz(),
            operand.as_inner().xz()
                + -T::TWO * self.as_inner().xy() * self.as_inner().xy() * operand.as_inner().xz()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.as_inner().xz()
                + T::TWO * self.as_inner().s() * self.as_inner().xy() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().s() * self.as_inner().yz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.as_inner().yz(),
            operand.as_inner().yz()
                + -T::TWO * self.as_inner().xy() * self.as_inner().xy() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().s() * self.as_inner().xy() * operand.as_inner().xz()
                + T::TWO * self.as_inner().s() * self.as_inner().xz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Rotor<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.xy() * operand.x() * self.xy())
                + self.yz() * operand.x() * self.yz()
                + self.s() * operand.z() * self.xz()
                + self.s() * operand.y() * self.xy()
                + self.xz() * operand.z() * self.s()
                - self.yz() * operand.y() * self.xz()
                + self.s() * operand.x() * self.s()
                - self.xz() * operand.x() * self.xz()
                + self.xy() * operand.y() * self.s()
                + self.xy() * operand.z() * self.yz()
                - self.xz() * operand.y() * self.yz()
                + self.yz() * operand.z() * self.xy(),
            -(self.s() * operand.x() * self.xy())
                + self.s() * operand.z() * self.yz()
                + self.xz() * operand.y() * self.xz()
                - self.xy() * operand.x() * self.s()
                - self.yz() * operand.y() * self.yz()
                + self.yz() * operand.z() * self.s()
                + self.s() * operand.y() * self.s()
                - self.xy() * operand.y() * self.xy()
                - self.xy() * operand.z() * self.xz()
                - self.yz() * operand.x() * self.xz()
                - self.xz() * operand.z() * self.xy()
                - self.xz() * operand.x() * self.yz(),
            -(self.yz() * operand.y() * self.s())
                - self.yz() * operand.z() * self.yz()
                - self.xz() * operand.y() * self.xy()
                + self.xy() * operand.x() * self.yz()
                - self.xy() * operand.y() * self.xz()
                - self.s() * operand.x() * self.xz()
                + self.xy() * operand.z() * self.xy()
                - self.s() * operand.y() * self.yz()
                - self.xz() * operand.x() * self.s()
                - self.xz() * operand.z() * self.xz()
                + self.s() * operand.z() * self.s()
                + self.yz() * operand.x() * self.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Unit<Rotor<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            operand.x()
                + -T::TWO * operand.x() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.x() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * self.as_inner().s() * operand.y() * self.as_inner().xy()
                + T::TWO * self.as_inner().s() * operand.z() * self.as_inner().xz()
                + -T::TWO * operand.y() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.z() * self.as_inner().xy() * self.as_inner().yz(),
            operand.y()
                + -T::TWO * operand.y() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.y() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * self.as_inner().s() * operand.x() * self.as_inner().xy()
                + T::TWO * self.as_inner().s() * operand.z() * self.as_inner().yz()
                + -T::TWO * operand.x() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.z() * self.as_inner().xy() * self.as_inner().xz(),
            operand.z()
                + -T::TWO * operand.z() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.z() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * self.as_inner().s() * operand.x() * self.as_inner().xz()
                + -T::TWO * self.as_inner().s() * operand.y() * self.as_inner().yz()
                + T::TWO * operand.x() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.y() * self.as_inner().xy() * self.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Point<T>>> for Rotor<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x() * self.xy() * self.xy())
                + -(operand.as_inner().x() * self.xz() * self.xz())
                + operand.as_inner().x() * self.yz() * self.yz()
                + self.s() * self.s() * operand.as_inner().x()
                + T::TWO * self.s() * operand.as_inner().y() * self.xy()
                + T::TWO * self.s() * operand.as_inner().z() * self.xz()
                + -T::TWO * operand.as_inner().y() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().z() * self.xy() * self.yz(),
            -(operand.as_inner().y() * self.xy() * self.xy())
                + operand.as_inner().y() * self.xz() * self.xz()
                + -(operand.as_inner().y() * self.yz() * self.yz())
                + self.s() * self.s() * operand.as_inner().y()
                + -T::TWO * self.s() * operand.as_inner().x() * self.xy()
                + T::TWO * self.s() * operand.as_inner().z() * self.yz()
                + -T::TWO * operand.as_inner().x() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().z() * self.xy() * self.xz(),
            operand.as_inner().z() * self.xy() * self.xy()
                + -(operand.as_inner().z() * self.xz() * self.xz())
                + -(operand.as_inner().z() * self.yz() * self.yz())
                + self.s() * self.s() * operand.as_inner().z()
                + -T::TWO * self.s() * operand.as_inner().x() * self.xz()
                + -T::TWO * self.s() * operand.as_inner().y() * self.yz()
                + T::TWO * operand.as_inner().x() * self.xy() * self.yz()
                + -T::TWO * operand.as_inner().y() * self.xy() * self.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Point<T>>> for Unit<Rotor<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            operand.as_inner().x()
                + -T::TWO * operand.as_inner().x() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().x() * self.as_inner().xz() * self.as_inner().xz()
                + T::TWO * self.as_inner().s() * operand.as_inner().y() * self.as_inner().xy()
                + T::TWO * self.as_inner().s() * operand.as_inner().z() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().z() * self.as_inner().xy() * self.as_inner().yz(),
            operand.as_inner().y()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().y() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * self.as_inner().s() * operand.as_inner().x() * self.as_inner().xy()
                + T::TWO * self.as_inner().s() * operand.as_inner().z() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().x() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xy() * self.as_inner().xz(),
            operand.as_inner().z()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * self.as_inner().s() * operand.as_inner().x() * self.as_inner().xz()
                + -T::TWO * self.as_inner().s() * operand.as_inner().y() * self.as_inner().yz()
                + T::TWO * operand.as_inner().x() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xy() * self.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Rotor<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.xy() * operand.xyz() * self.xy()
                + self.yz() * operand.xyz() * self.yz()
                + self.s() * operand.xyz() * self.s()
                + self.xz() * operand.xyz() * self.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Unit<Rotor<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Rotor<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.s() * self.s() * operand.as_inner().xyz()
                + self.xy() * self.xy() * operand.as_inner().xyz()
                + self.xz() * self.xz() * operand.as_inner().xyz()
                + self.yz() * self.yz() * operand.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Unit<Rotor<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Rotor<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            -(self.yz() * operand.xy() * self.xz()) + self.yz() * operand.xz() * self.xy()
                - self.xy() * operand.xy() * self.s()
                + self.xz() * operand.s() * self.xz()
                - self.xy() * operand.xz() * self.yz()
                + self.xy() * operand.yz() * self.xz()
                - self.xz() * operand.xz() * self.s()
                + self.s() * operand.xz() * self.xz()
                + self.s() * operand.xy() * self.xy()
                + self.s() * operand.yz() * self.yz()
                + self.xy() * operand.s() * self.xy()
                + self.xz() * operand.xy() * self.yz()
                + self.s() * operand.s() * self.s()
                - self.yz() * operand.yz() * self.s()
                - self.xz() * operand.yz() * self.xy()
                + self.yz() * operand.s() * self.yz(),
            -(self.xz() * operand.xy() * self.xz())
                + self.s() * operand.xz() * self.yz()
                + self.xy() * operand.yz() * self.yz()
                - self.xz() * operand.yz() * self.s()
                + self.s() * operand.xy() * self.s()
                + self.xy() * operand.s() * self.s()
                - self.yz() * operand.xy() * self.yz()
                + self.xz() * operand.s() * self.yz()
                + self.yz() * operand.yz() * self.xy()
                + self.xy() * operand.xz() * self.xz()
                + self.xz() * operand.xz() * self.xy()
                + self.xy() * operand.xy() * self.xy()
                - self.yz() * operand.s() * self.xz()
                - self.s() * operand.yz() * self.xz()
                + self.yz() * operand.xz() * self.s()
                - self.s() * operand.s() * self.xy(),
            -(self.s() * operand.s() * self.xz())
                + self.xz() * operand.yz() * self.yz()
                + self.yz() * operand.s() * self.xy()
                + self.s() * operand.xz() * self.s()
                - self.yz() * operand.xy() * self.s()
                + self.xy() * operand.xy() * self.xz()
                + self.xz() * operand.s() * self.s()
                - self.yz() * operand.xz() * self.yz()
                + self.xz() * operand.xz() * self.xz()
                + self.s() * operand.yz() * self.xy()
                - self.xy() * operand.s() * self.yz()
                - self.xy() * operand.xz() * self.xy()
                + self.xz() * operand.xy() * self.xy()
                - self.s() * operand.xy() * self.yz()
                + self.yz() * operand.yz() * self.xz()
                + self.xy() * operand.yz() * self.s(),
            -(self.xy() * operand.yz() * self.xy())
                + self.s() * operand.xy() * self.xz()
                + self.yz() * operand.yz() * self.yz()
                + self.s() * operand.yz() * self.s()
                + self.xy() * operand.xy() * self.yz()
                - self.s() * operand.xz() * self.xy()
                + self.xz() * operand.xy() * self.s()
                - self.s() * operand.s() * self.yz()
                - self.xy() * operand.xz() * self.s()
                + self.yz() * operand.xz() * self.xz()
                - self.xz() * operand.yz() * self.xz()
                + self.xy() * operand.s() * self.xz()
                - self.xz() * operand.s() * self.xy()
                + self.yz() * operand.xy() * self.xy()
                + self.xz() * operand.xz() * self.yz()
                + self.yz() * operand.s() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Rotor<T>> for Unit<Rotor<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.s(),
            operand.xy()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.xy()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.xy()
                + -T::TWO * self.as_inner().s() * self.as_inner().xz() * operand.yz()
                + T::TWO * self.as_inner().s() * self.as_inner().yz() * operand.xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.yz(),
            operand.xz()
                + -T::TWO * self.as_inner().xy() * self.as_inner().xy() * operand.xz()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.xz()
                + T::TWO * self.as_inner().s() * self.as_inner().xy() * operand.yz()
                + -T::TWO * self.as_inner().s() * self.as_inner().yz() * operand.xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.yz(),
            operand.yz()
                + -T::TWO * self.as_inner().xy() * self.as_inner().xy() * operand.yz()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.yz()
                + -T::TWO * self.as_inner().s() * self.as_inner().xy() * operand.xz()
                + T::TWO * self.as_inner().s() * self.as_inner().xz() * operand.xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Rotor<T>>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.as_inner().s() * self.xy() * self.xy()
                + operand.as_inner().s() * self.xz() * self.xz()
                + operand.as_inner().s() * self.yz() * self.yz()
                + self.s() * self.s() * operand.as_inner().s(),
            self.s() * self.s() * operand.as_inner().xy()
                + self.xy() * self.xy() * operand.as_inner().xy()
                + -(self.xz() * self.xz() * operand.as_inner().xy())
                + -(self.yz() * self.yz() * operand.as_inner().xy())
                + -T::TWO * self.s() * self.xz() * operand.as_inner().yz()
                + T::TWO * self.s() * self.yz() * operand.as_inner().xz()
                + T::TWO * self.xy() * self.xz() * operand.as_inner().xz()
                + T::TWO * self.xy() * self.yz() * operand.as_inner().yz(),
            self.s() * self.s() * operand.as_inner().xz()
                + -(self.xy() * self.xy() * operand.as_inner().xz())
                + self.xz() * self.xz() * operand.as_inner().xz()
                + -(self.yz() * self.yz() * operand.as_inner().xz())
                + T::TWO * self.s() * self.xy() * operand.as_inner().yz()
                + -T::TWO * self.s() * self.yz() * operand.as_inner().xy()
                + T::TWO * self.xy() * self.xz() * operand.as_inner().xy()
                + T::TWO * self.xz() * self.yz() * operand.as_inner().yz(),
            self.s() * self.s() * operand.as_inner().yz()
                + -(self.xy() * self.xy() * operand.as_inner().yz())
                + -(self.xz() * self.xz() * operand.as_inner().yz())
                + self.yz() * self.yz() * operand.as_inner().yz()
                + -T::TWO * self.s() * self.xy() * operand.as_inner().xz()
                + T::TWO * self.s() * self.xz() * operand.as_inner().xy()
                + T::TWO * self.xy() * self.yz() * operand.as_inner().xy()
                + T::TWO * self.xz() * self.yz() * operand.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Rotor<T>>> for Unit<Rotor<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.as_inner().s(),
            operand.as_inner().xy()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.as_inner().xy()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.as_inner().xy()
                + -T::TWO * self.as_inner().s() * self.as_inner().xz() * operand.as_inner().yz()
                + T::TWO * self.as_inner().s() * self.as_inner().yz() * operand.as_inner().xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.as_inner().xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.as_inner().yz(),
            operand.as_inner().xz()
                + -T::TWO * self.as_inner().xy() * self.as_inner().xy() * operand.as_inner().xz()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.as_inner().xz()
                + T::TWO * self.as_inner().s() * self.as_inner().xy() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().s() * self.as_inner().yz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.as_inner().yz(),
            operand.as_inner().yz()
                + -T::TWO * self.as_inner().xy() * self.as_inner().xy() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().s() * self.as_inner().xy() * operand.as_inner().xz()
                + T::TWO * self.as_inner().s() * self.as_inner().xz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Rotor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.s() * operand.s() * self.s()
                + self.xy() * operand.s() * self.xy()
                + self.xz() * operand.s() * self.xz()
                + self.yz() * operand.s() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unit<Rotor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Rotor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            operand.as_inner().s() * self.xy() * self.xy()
                + operand.as_inner().s() * self.xz() * self.xz()
                + operand.as_inner().s() * self.yz() * self.yz()
                + self.s() * self.s() * operand.as_inner().s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Unit<Rotor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.s() * operand.xy() * self.s(),
            self.s() * operand.xz() * self.s(),
            self.s() * operand.yz() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Line<T>> for Unit<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(operand.xy(), operand.xz(), operand.yz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Line<T>>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            self.s() * self.s() * operand.as_inner().xy(),
            self.s() * self.s() * operand.as_inner().xz(),
            self.s() * self.s() * operand.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Line<T>>> for Unit<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            operand.as_inner().xy(),
            operand.as_inner().xz(),
            operand.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.s() * operand.x() * self.s(),
            self.s() * operand.y() * self.s(),
            self.s() * operand.z() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Point<T>> for Unit<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(operand.x(), operand.y(), operand.z())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Point<T>>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            self.s() * self.s() * operand.as_inner().x(),
            self.s() * self.s() * operand.as_inner().y(),
            self.s() * self.s() * operand.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Point<T>>> for Unit<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            operand.as_inner().x(),
            operand.as_inner().y(),
            operand.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.s() * operand.xyz() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Pseudoscalar<T>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.s() * self.s() * operand.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Pseudoscalar<T>>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Rotor<T>> for Scalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            self.s() * operand.s() * self.s(),
            self.s() * operand.xy() * self.s(),
            self.s() * operand.xz() * self.s(),
            self.s() * operand.yz() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Rotor<T>> for Unit<Scalar<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(operand.s(), operand.xy(), operand.xz(), operand.yz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Rotor<T>>> for Scalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            self.s() * self.s() * operand.as_inner().s(),
            self.s() * self.s() * operand.as_inner().xy(),
            self.s() * self.s() * operand.as_inner().xz(),
            self.s() * self.s() * operand.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Rotor<T>>> for Unit<Scalar<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.as_inner().s(),
            operand.as_inner().xy(),
            operand.as_inner().xz(),
            operand.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * operand.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * self.s() * operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Sandwich<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn sandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.xy() * operand.xz() * self.xz() + self.xy() * operand.yz() * self.yz()
                - self.yz() * operand.xy() * self.yz()
                + self.xy() * operand.xy() * self.xy()
                + self.yz() * operand.yz() * self.xy()
                - self.xz() * operand.xy() * self.xz()
                + self.xz() * operand.xz() * self.xy(),
            self.xz() * operand.xy() * self.xy() + self.xz() * operand.yz() * self.yz()
                - self.yz() * operand.xz() * self.yz()
                - self.xy() * operand.xz() * self.xy()
                + self.yz() * operand.yz() * self.xz()
                + self.xz() * operand.xz() * self.xz()
                + self.xy() * operand.xy() * self.xz(),
            self.yz() * operand.yz() * self.yz()
                + self.yz() * operand.xy() * self.xy()
                + self.xz() * operand.xz() * self.yz()
                - self.xz() * operand.yz() * self.xz()
                + self.xy() * operand.xy() * self.yz()
                - self.xy() * operand.yz() * self.xy()
                + self.yz() * operand.xz() * self.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            operand.xy()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.xy()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.yz(),
            -(operand.xz())
                + T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.yz(),
            -(operand.yz())
                + T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.yz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Line<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            self.xy() * self.xy() * operand.as_inner().xy()
                + -(self.xz() * self.xz() * operand.as_inner().xy())
                + -(self.yz() * self.yz() * operand.as_inner().xy())
                + T::TWO * self.xy() * self.xz() * operand.as_inner().xz()
                + T::TWO * self.xy() * self.yz() * operand.as_inner().yz(),
            -(self.xy() * self.xy() * operand.as_inner().xz())
                + self.xz() * self.xz() * operand.as_inner().xz()
                + -(self.yz() * self.yz() * operand.as_inner().xz())
                + T::TWO * self.xy() * self.xz() * operand.as_inner().xy()
                + T::TWO * self.xz() * self.yz() * operand.as_inner().yz(),
            -(self.xy() * self.xy() * operand.as_inner().yz())
                + -(self.xz() * self.xz() * operand.as_inner().yz())
                + self.yz() * self.yz() * operand.as_inner().yz()
                + T::TWO * self.xy() * self.yz() * operand.as_inner().xy()
                + T::TWO * self.xz() * self.yz() * operand.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Line<T>>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            operand.as_inner().xy()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.as_inner().xy()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.as_inner().xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.as_inner().yz(),
            -(operand.as_inner().xz())
                + T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.as_inner().xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.as_inner().yz(),
            -(operand.as_inner().yz())
                + T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.as_inner().yz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.yz() * operand.x() * self.yz()
                + self.yz() * operand.z() * self.xy()
                + self.xy() * operand.z() * self.yz()
                - self.yz() * operand.y() * self.xz()
                - self.xz() * operand.x() * self.xz()
                - self.xy() * operand.x() * self.xy()
                - self.xz() * operand.y() * self.yz(),
            -(self.xy() * operand.y() * self.xy())
                - self.xz() * operand.x() * self.yz()
                - self.yz() * operand.y() * self.yz()
                - self.xz() * operand.z() * self.xy()
                - self.xy() * operand.z() * self.xz()
                + self.xz() * operand.y() * self.xz()
                - self.yz() * operand.x() * self.xz(),
            self.yz() * operand.x() * self.xy() - self.yz() * operand.z() * self.yz()
                + self.xy() * operand.x() * self.yz()
                + self.xy() * operand.z() * self.xy()
                - self.xy() * operand.y() * self.xz()
                - self.xz() * operand.y() * self.xy()
                - self.xz() * operand.z() * self.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Unit<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -(operand.x())
                + T::TWO * operand.x() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.y() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.z() * self.as_inner().xy() * self.as_inner().yz(),
            -(operand.y())
                + T::TWO * operand.y() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.x() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.z() * self.as_inner().xy() * self.as_inner().xz(),
            operand.z()
                + -T::TWO * operand.z() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.z() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.x() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.y() * self.as_inner().xy() * self.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Point<T>>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x() * self.xy() * self.xy())
                + -(operand.as_inner().x() * self.xz() * self.xz())
                + operand.as_inner().x() * self.yz() * self.yz()
                + -T::TWO * operand.as_inner().y() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().z() * self.xy() * self.yz(),
            -(operand.as_inner().y() * self.xy() * self.xy())
                + operand.as_inner().y() * self.xz() * self.xz()
                + -(operand.as_inner().y() * self.yz() * self.yz())
                + -T::TWO * operand.as_inner().x() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().z() * self.xy() * self.xz(),
            operand.as_inner().z() * self.xy() * self.xy()
                + -(operand.as_inner().z() * self.xz() * self.xz())
                + -(operand.as_inner().z() * self.yz() * self.yz())
                + T::TWO * operand.as_inner().x() * self.xy() * self.yz()
                + -T::TWO * operand.as_inner().y() * self.xy() * self.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Point<T>>> for Unit<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x())
                + T::TWO * operand.as_inner().x() * self.as_inner().yz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().z() * self.as_inner().xy() * self.as_inner().yz(),
            -(operand.as_inner().y())
                + T::TWO * operand.as_inner().y() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().x() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xy() * self.as_inner().xz(),
            operand.as_inner().z()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().x() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xy() * self.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Line<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.xy() * operand.xyz() * self.xy()
                + self.yz() * operand.xyz() * self.yz()
                + self.xz() * operand.xyz() * self.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Unit<Line<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Line<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.xy() * self.xy() * operand.as_inner().xyz()
                + self.xz() * self.xz() * operand.as_inner().xyz()
                + self.yz() * self.yz() * operand.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Unit<Line<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Rotor<T>> for Line<T> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            -(self.xz() * operand.xy() * self.yz())
                + self.xy() * operand.xz() * self.yz()
                + self.xz() * operand.yz() * self.xy()
                + self.yz() * operand.xy() * self.xz()
                + self.xz() * operand.s() * self.xz()
                - self.yz() * operand.xz() * self.xy()
                + self.xy() * operand.s() * self.xy()
                + self.yz() * operand.s() * self.yz()
                - self.xy() * operand.yz() * self.xz(),
            -(self.xz() * operand.s() * self.yz()) - self.xz() * operand.xy() * self.xz()
                + self.xy() * operand.xy() * self.xy()
                + self.xy() * operand.xz() * self.xz()
                + self.xy() * operand.yz() * self.yz()
                - self.yz() * operand.xy() * self.yz()
                + self.yz() * operand.yz() * self.xy()
                + self.yz() * operand.s() * self.xz()
                + self.xz() * operand.xz() * self.xy(),
            self.yz() * operand.yz() * self.xz() - self.yz() * operand.s() * self.xy()
                + self.xz() * operand.yz() * self.yz()
                - self.xy() * operand.xz() * self.xy()
                + self.xz() * operand.xz() * self.xz()
                - self.yz() * operand.xz() * self.yz()
                + self.xy() * operand.s() * self.yz()
                + self.xz() * operand.xy() * self.xy()
                + self.xy() * operand.xy() * self.xz(),
            self.xy() * operand.xy() * self.yz() - self.xy() * operand.yz() * self.xy()
                + self.xz() * operand.s() * self.xy()
                - self.xz() * operand.yz() * self.xz()
                + self.xz() * operand.xz() * self.yz()
                + self.yz() * operand.xy() * self.xy()
                + self.yz() * operand.xz() * self.xz()
                + self.yz() * operand.yz() * self.yz()
                - self.xy() * operand.s() * self.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Rotor<T>> for Unit<Line<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.s(),
            operand.xy()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.xy()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.yz(),
            -(operand.xz())
                + T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.yz(),
            -(operand.yz())
                + T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.yz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Rotor<T>>> for Line<T> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.as_inner().s() * self.xy() * self.xy()
                + operand.as_inner().s() * self.xz() * self.xz()
                + operand.as_inner().s() * self.yz() * self.yz(),
            self.xy() * self.xy() * operand.as_inner().xy()
                + -(self.xz() * self.xz() * operand.as_inner().xy())
                + -(self.yz() * self.yz() * operand.as_inner().xy())
                + T::TWO * self.xy() * self.xz() * operand.as_inner().xz()
                + T::TWO * self.xy() * self.yz() * operand.as_inner().yz(),
            -(self.xy() * self.xy() * operand.as_inner().xz())
                + self.xz() * self.xz() * operand.as_inner().xz()
                + -(self.yz() * self.yz() * operand.as_inner().xz())
                + T::TWO * self.xy() * self.xz() * operand.as_inner().xy()
                + T::TWO * self.xz() * self.yz() * operand.as_inner().yz(),
            -(self.xy() * self.xy() * operand.as_inner().yz())
                + -(self.xz() * self.xz() * operand.as_inner().yz())
                + self.yz() * self.yz() * operand.as_inner().yz()
                + T::TWO * self.xy() * self.yz() * operand.as_inner().xy()
                + T::TWO * self.xz() * self.yz() * operand.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Rotor<T>>> for Unit<Line<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.as_inner().s(),
            operand.as_inner().xy()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.as_inner().xy()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.as_inner().xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.as_inner().yz(),
            -(operand.as_inner().xz())
                + T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.as_inner().xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.as_inner().yz(),
            -(operand.as_inner().yz())
                + T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.as_inner().yz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.yz() * operand.s() * self.yz()
                + self.xz() * operand.s() * self.xz()
                + self.xy() * operand.s() * self.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unit<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            operand.as_inner().s() * self.xy() * self.xy()
                + operand.as_inner().s() * self.xz() * self.xz()
                + operand.as_inner().s() * self.yz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Unit<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.z() * operand.yz() * self.x() + self.x() * operand.yz() * self.z()
                - self.y() * operand.xz() * self.z()
                + self.z() * operand.xy() * self.z()
                - self.x() * operand.xy() * self.x()
                - self.y() * operand.xy() * self.y()
                - self.z() * operand.xz() * self.y(),
            -(self.z() * operand.xz() * self.z())
                - self.x() * operand.xz() * self.x()
                - self.y() * operand.xy() * self.z()
                - self.z() * operand.xy() * self.y()
                - self.x() * operand.yz() * self.y()
                + self.y() * operand.xz() * self.y()
                - self.y() * operand.yz() * self.x(),
            self.x() * operand.xy() * self.z() - self.y() * operand.yz() * self.y()
                + self.z() * operand.xy() * self.x()
                - self.y() * operand.xz() * self.x()
                + self.x() * operand.yz() * self.x()
                - self.x() * operand.xz() * self.y()
                - self.z() * operand.yz() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Unit<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            -(operand.xy())
                + T::TWO * self.as_inner().z() * self.as_inner().z() * operand.xy()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().z() * operand.xz(),
            -(operand.xz())
                + T::TWO * self.as_inner().y() * self.as_inner().y() * operand.xz()
                + -T::TWO * self.as_inner().x() * self.as_inner().y() * operand.yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().z() * operand.xy(),
            operand.yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().y() * operand.yz()
                + -T::TWO * self.as_inner().z() * self.as_inner().z() * operand.yz()
                + -T::TWO * self.as_inner().x() * self.as_inner().y() * operand.xz()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Line<T>>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(self.x() * self.x() * operand.as_inner().xy())
                + -(self.y() * self.y() * operand.as_inner().xy())
                + self.z() * self.z() * operand.as_inner().xy()
                + T::TWO * self.x() * self.z() * operand.as_inner().yz()
                + -T::TWO * self.y() * self.z() * operand.as_inner().xz(),
            -(self.x() * self.x() * operand.as_inner().xz())
                + self.y() * self.y() * operand.as_inner().xz()
                + -(self.z() * self.z() * operand.as_inner().xz())
                + -T::TWO * self.x() * self.y() * operand.as_inner().yz()
                + -T::TWO * self.y() * self.z() * operand.as_inner().xy(),
            self.x() * self.x() * operand.as_inner().yz()
                + -(self.y() * self.y() * operand.as_inner().yz())
                + -(self.z() * self.z() * operand.as_inner().yz())
                + -T::TWO * self.x() * self.y() * operand.as_inner().xz()
                + T::TWO * self.x() * self.z() * operand.as_inner().xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Line<T>>> for Unit<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(operand.as_inner().xy())
                + T::TWO * self.as_inner().z() * self.as_inner().z() * operand.as_inner().xy()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().z() * operand.as_inner().xz(),
            -(operand.as_inner().xz())
                + T::TWO * self.as_inner().y() * self.as_inner().y() * operand.as_inner().xz()
                + -T::TWO * self.as_inner().x() * self.as_inner().y() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().z() * operand.as_inner().xy(),
            operand.as_inner().yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().y() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().z() * self.as_inner().z() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().x() * self.as_inner().y() * operand.as_inner().xz()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.as_inner().xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.y() * operand.y() * self.x() - self.z() * operand.x() * self.z()
                + self.z() * operand.z() * self.x()
                + self.x() * operand.y() * self.y()
                + self.x() * operand.x() * self.x()
                + self.x() * operand.z() * self.z()
                - self.y() * operand.x() * self.y(),
            self.y() * operand.x() * self.x()
                + self.z() * operand.z() * self.y()
                + self.x() * operand.x() * self.y()
                - self.x() * operand.y() * self.x()
                + self.y() * operand.z() * self.z()
                + self.y() * operand.y() * self.y()
                - self.z() * operand.y() * self.z(),
            self.z() * operand.z() * self.z() - self.y() * operand.z() * self.y()
                + self.y() * operand.y() * self.z()
                - self.x() * operand.z() * self.x()
                + self.x() * operand.x() * self.z()
                + self.z() * operand.x() * self.x()
                + self.z() * operand.y() * self.y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            operand.x()
                + -T::TWO * operand.x() * self.as_inner().z() * self.as_inner().z()
                + -T::TWO * self.as_inner().y() * self.as_inner().y() * operand.x()
                + T::TWO * self.as_inner().x() * self.as_inner().y() * operand.y()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.z(),
            -(operand.y())
                + T::TWO * self.as_inner().y() * self.as_inner().y() * operand.y()
                + T::TWO * self.as_inner().x() * self.as_inner().y() * operand.x()
                + T::TWO * self.as_inner().y() * self.as_inner().z() * operand.z(),
            -(operand.z())
                + T::TWO * self.as_inner().z() * self.as_inner().z() * operand.z()
                + T::TWO * self.as_inner().x() * operand.x() * self.as_inner().z()
                + T::TWO * self.as_inner().y() * operand.y() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Point<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x() * self.z() * self.z())
                + self.x() * self.x() * operand.as_inner().x()
                + -(self.y() * self.y() * operand.as_inner().x())
                + T::TWO * self.x() * self.y() * operand.as_inner().y()
                + T::TWO * self.x() * self.z() * operand.as_inner().z(),
            -(operand.as_inner().y() * self.z() * self.z())
                + -(self.x() * self.x() * operand.as_inner().y())
                + self.y() * self.y() * operand.as_inner().y()
                + T::TWO * self.x() * self.y() * operand.as_inner().x()
                + T::TWO * self.y() * self.z() * operand.as_inner().z(),
            -(self.x() * self.x() * operand.as_inner().z())
                + -(self.y() * self.y() * operand.as_inner().z())
                + self.z() * self.z() * operand.as_inner().z()
                + T::TWO * self.x() * operand.as_inner().x() * self.z()
                + T::TWO * self.y() * operand.as_inner().y() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Point<T>>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            operand.as_inner().x()
                + -T::TWO * operand.as_inner().x() * self.as_inner().z() * self.as_inner().z()
                + -T::TWO * self.as_inner().y() * self.as_inner().y() * operand.as_inner().x()
                + T::TWO * self.as_inner().x() * self.as_inner().y() * operand.as_inner().y()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.as_inner().z(),
            -(operand.as_inner().y())
                + T::TWO * self.as_inner().y() * self.as_inner().y() * operand.as_inner().y()
                + T::TWO * self.as_inner().x() * self.as_inner().y() * operand.as_inner().x()
                + T::TWO * self.as_inner().y() * self.as_inner().z() * operand.as_inner().z(),
            -(operand.as_inner().z())
                + T::TWO * self.as_inner().z() * self.as_inner().z() * operand.as_inner().z()
                + T::TWO * self.as_inner().x() * operand.as_inner().x() * self.as_inner().z()
                + T::TWO * self.as_inner().y() * operand.as_inner().y() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Point<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.z() * operand.xyz() * self.z()
                + self.y() * operand.xyz() * self.y()
                + self.x() * operand.xyz() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Unit<Point<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Point<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.x() * self.x() * operand.as_inner().xyz()
                + self.y() * self.y() * operand.as_inner().xyz()
                + self.z() * self.z() * operand.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Unit<Point<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Rotor<T>> for Point<T> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            -(self.y() * operand.yz() * self.z()) - self.x() * operand.xy() * self.y()
                + self.y() * operand.s() * self.y()
                + self.y() * operand.xy() * self.x()
                + self.z() * operand.s() * self.z()
                - self.x() * operand.xz() * self.z()
                + self.z() * operand.xz() * self.x()
                + self.z() * operand.yz() * self.y()
                + self.x() * operand.s() * self.x(),
            self.z() * operand.xy() * self.z() + self.x() * operand.yz() * self.z()
                - self.y() * operand.xz() * self.z()
                + self.y() * operand.s() * self.x()
                + self.z() * operand.yz() * self.x()
                - self.x() * operand.s() * self.y()
                - self.z() * operand.xz() * self.y()
                - self.x() * operand.xy() * self.x()
                - self.y() * operand.xy() * self.y(),
            -(self.z() * operand.xz() * self.z()) - self.z() * operand.xy() * self.y()
                + self.z() * operand.s() * self.x()
                - self.x() * operand.yz() * self.y()
                - self.y() * operand.xy() * self.z()
                + self.y() * operand.xz() * self.y()
                - self.y() * operand.yz() * self.x()
                - self.x() * operand.s() * self.z()
                - self.x() * operand.xz() * self.x(),
            -(self.x() * operand.xz() * self.y()) + self.x() * operand.xy() * self.z()
                - self.y() * operand.yz() * self.y()
                + self.z() * operand.xy() * self.x()
                - self.y() * operand.s() * self.z()
                - self.y() * operand.xz() * self.x()
                - self.z() * operand.yz() * self.z()
                + self.x() * operand.yz() * self.x()
                + self.z() * operand.s() * self.y(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Rotor<T>> for Unit<Point<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.s(),
            -(operand.xy())
                + T::TWO * self.as_inner().z() * self.as_inner().z() * operand.xy()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().z() * operand.xz(),
            -(operand.xz())
                + T::TWO * self.as_inner().y() * self.as_inner().y() * operand.xz()
                + -T::TWO * self.as_inner().x() * self.as_inner().y() * operand.yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().z() * operand.xy(),
            operand.yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().y() * operand.yz()
                + -T::TWO * self.as_inner().z() * self.as_inner().z() * operand.yz()
                + -T::TWO * self.as_inner().x() * self.as_inner().y() * operand.xz()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Rotor<T>>> for Point<T> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.as_inner().s() * self.z() * self.z()
                + self.x() * self.x() * operand.as_inner().s()
                + self.y() * self.y() * operand.as_inner().s(),
            -(self.x() * self.x() * operand.as_inner().xy())
                + -(self.y() * self.y() * operand.as_inner().xy())
                + self.z() * self.z() * operand.as_inner().xy()
                + T::TWO * self.x() * self.z() * operand.as_inner().yz()
                + -T::TWO * self.y() * self.z() * operand.as_inner().xz(),
            -(self.x() * self.x() * operand.as_inner().xz())
                + self.y() * self.y() * operand.as_inner().xz()
                + -(self.z() * self.z() * operand.as_inner().xz())
                + -T::TWO * self.x() * self.y() * operand.as_inner().yz()
                + -T::TWO * self.y() * self.z() * operand.as_inner().xy(),
            self.x() * self.x() * operand.as_inner().yz()
                + -(self.y() * self.y() * operand.as_inner().yz())
                + -(self.z() * self.z() * operand.as_inner().yz())
                + -T::TWO * self.x() * self.y() * operand.as_inner().xz()
                + T::TWO * self.x() * self.z() * operand.as_inner().xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Rotor<T>>> for Unit<Point<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.as_inner().s(),
            -(operand.as_inner().xy())
                + T::TWO * self.as_inner().z() * self.as_inner().z() * operand.as_inner().xy()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().z() * operand.as_inner().xz(),
            -(operand.as_inner().xz())
                + T::TWO * self.as_inner().y() * self.as_inner().y() * operand.as_inner().xz()
                + -T::TWO * self.as_inner().x() * self.as_inner().y() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().z() * operand.as_inner().xy(),
            operand.as_inner().yz()
                + -T::TWO * self.as_inner().y() * self.as_inner().y() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().z() * self.as_inner().z() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().x() * self.as_inner().y() * operand.as_inner().xz()
                + T::TWO * self.as_inner().x() * self.as_inner().z() * operand.as_inner().xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.y() * operand.s() * self.y()
                + self.z() * operand.s() * self.z()
                + self.x() * operand.s() * self.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unit<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            operand.as_inner().s() * self.z() * self.z()
                + self.x() * self.x() * operand.as_inner().s()
                + self.y() * self.y() * operand.as_inner().s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Unit<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Pseudoscalar<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.xyz() * operand.xy() * self.xyz(),
            self.xyz() * operand.xz() * self.xyz(),
            self.xyz() * operand.yz() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Unit<Pseudoscalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(operand.xy(), operand.xz(), operand.yz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Line<T>>> for Pseudoscalar<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            self.xyz() * self.xyz() * operand.as_inner().xy(),
            self.xyz() * self.xyz() * operand.as_inner().xz(),
            self.xyz() * self.xyz() * operand.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Line<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            operand.as_inner().xy(),
            operand.as_inner().xz(),
            operand.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Pseudoscalar<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.xyz() * operand.x() * self.xyz(),
            self.xyz() * operand.y() * self.xyz(),
            self.xyz() * operand.z() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Unit<Pseudoscalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(operand.x(), operand.y(), operand.z())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Point<T>>> for Pseudoscalar<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            operand.as_inner().x() * self.xyz() * self.xyz(),
            operand.as_inner().y() * self.xyz() * self.xyz(),
            operand.as_inner().z() * self.xyz() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Point<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            operand.as_inner().x(),
            operand.as_inner().y(),
            operand.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.xyz() * operand.xyz() * self.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.xyz() * self.xyz() * operand.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Rotor<T>> for Pseudoscalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            self.xyz() * operand.s() * self.xyz(),
            self.xyz() * operand.xy() * self.xyz(),
            self.xyz() * operand.xz() * self.xyz(),
            self.xyz() * operand.yz() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Rotor<T>> for Unit<Pseudoscalar<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(operand.s(), operand.xy(), operand.xz(), operand.yz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Rotor<T>>> for Pseudoscalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.as_inner().s() * self.xyz() * self.xyz(),
            self.xyz() * self.xyz() * operand.as_inner().xy(),
            self.xyz() * self.xyz() * operand.as_inner().xz(),
            self.xyz() * self.xyz() * operand.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Rotor<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.as_inner().s(),
            operand.as_inner().xy(),
            operand.as_inner().xz(),
            operand.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.xyz() * operand.s() * self.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s() * self.xyz() * self.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Rotor<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.yz() * operand.yz() * self.xy() - self.yz() * operand.xz() * self.s()
                + self.xy() * operand.xy() * self.xy()
                - self.xz() * operand.xy() * self.xz()
                - self.yz() * operand.xy() * self.yz()
                + self.xy() * operand.xz() * self.xz()
                - self.s() * operand.xz() * self.yz()
                + self.s() * operand.yz() * self.xz()
                + self.xz() * operand.xz() * self.xy()
                + self.s() * operand.xy() * self.s()
                + self.xy() * operand.yz() * self.yz()
                + self.xz() * operand.yz() * self.s(),
            self.xz() * operand.xz() * self.xz()
                + self.s() * operand.xz() * self.s()
                + self.xy() * operand.xy() * self.xz()
                - self.xy() * operand.yz() * self.s()
                + self.xz() * operand.yz() * self.yz()
                + self.yz() * operand.xy() * self.s()
                - self.xy() * operand.xz() * self.xy()
                + self.xz() * operand.xy() * self.xy()
                + self.s() * operand.xy() * self.yz()
                - self.s() * operand.yz() * self.xy()
                - self.yz() * operand.xz() * self.yz()
                + self.yz() * operand.yz() * self.xz(),
            -(self.xy() * operand.yz() * self.xy())
                + self.s() * operand.xz() * self.xy()
                + self.xy() * operand.xy() * self.yz()
                - self.xz() * operand.xy() * self.s()
                - self.xz() * operand.yz() * self.xz()
                + self.yz() * operand.xy() * self.xy()
                + self.yz() * operand.xz() * self.xz()
                + self.s() * operand.yz() * self.s()
                + self.yz() * operand.yz() * self.yz()
                - self.s() * operand.xy() * self.xz()
                + self.xy() * operand.xz() * self.s()
                + self.xz() * operand.xz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Unit<Rotor<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            operand.xy()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.xy()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.xy()
                + T::TWO * self.as_inner().s() * self.as_inner().xz() * operand.yz()
                + -T::TWO * self.as_inner().s() * self.as_inner().yz() * operand.xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.yz(),
            operand.xz()
                + -T::TWO * self.as_inner().xy() * self.as_inner().xy() * operand.xz()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.xz()
                + -T::TWO * self.as_inner().s() * self.as_inner().xy() * operand.yz()
                + T::TWO * self.as_inner().s() * self.as_inner().yz() * operand.xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.yz(),
            operand.yz()
                + -T::TWO * self.as_inner().xy() * self.as_inner().xy() * operand.yz()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.yz()
                + T::TWO * self.as_inner().s() * self.as_inner().xy() * operand.xz()
                + -T::TWO * self.as_inner().s() * self.as_inner().xz() * operand.xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Line<T>>> for Rotor<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            self.s() * self.s() * operand.as_inner().xy()
                + self.xy() * self.xy() * operand.as_inner().xy()
                + -(self.xz() * self.xz() * operand.as_inner().xy())
                + -(self.yz() * self.yz() * operand.as_inner().xy())
                + T::TWO * self.s() * self.xz() * operand.as_inner().yz()
                + -T::TWO * self.s() * self.yz() * operand.as_inner().xz()
                + T::TWO * self.xy() * self.xz() * operand.as_inner().xz()
                + T::TWO * self.xy() * self.yz() * operand.as_inner().yz(),
            self.s() * self.s() * operand.as_inner().xz()
                + -(self.xy() * self.xy() * operand.as_inner().xz())
                + self.xz() * self.xz() * operand.as_inner().xz()
                + -(self.yz() * self.yz() * operand.as_inner().xz())
                + -T::TWO * self.s() * self.xy() * operand.as_inner().yz()
                + T::TWO * self.s() * self.yz() * operand.as_inner().xy()
                + T::TWO * self.xy() * self.xz() * operand.as_inner().xy()
                + T::TWO * self.xz() * self.yz() * operand.as_inner().yz(),
            self.s() * self.s() * operand.as_inner().yz()
                + -(self.xy() * self.xy() * operand.as_inner().yz())
                + -(self.xz() * self.xz() * operand.as_inner().yz())
                + self.yz() * self.yz() * operand.as_inner().yz()
                + T::TWO * self.s() * self.xy() * operand.as_inner().xz()
                + -T::TWO * self.s() * self.xz() * operand.as_inner().xy()
                + T::TWO * self.xy() * self.yz() * operand.as_inner().xy()
                + T::TWO * self.xz() * self.yz() * operand.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Line<T>>> for Unit<Rotor<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            operand.as_inner().xy()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.as_inner().xy()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().s() * self.as_inner().xz() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().s() * self.as_inner().yz() * operand.as_inner().xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.as_inner().xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.as_inner().yz(),
            operand.as_inner().xz()
                + -T::TWO * self.as_inner().xy() * self.as_inner().xy() * operand.as_inner().xz()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.as_inner().xz()
                + -T::TWO * self.as_inner().s() * self.as_inner().xy() * operand.as_inner().yz()
                + T::TWO * self.as_inner().s() * self.as_inner().yz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.as_inner().yz(),
            operand.as_inner().yz()
                + -T::TWO * self.as_inner().xy() * self.as_inner().xy() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.as_inner().yz()
                + T::TWO * self.as_inner().s() * self.as_inner().xy() * operand.as_inner().xz()
                + -T::TWO * self.as_inner().s() * self.as_inner().xz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Rotor<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.xy() * operand.y() * self.s()) + self.s() * operand.x() * self.s()
                - self.s() * operand.y() * self.xy()
                - self.xz() * operand.z() * self.s()
                + self.yz() * operand.x() * self.yz()
                - self.yz() * operand.y() * self.xz()
                - self.xy() * operand.x() * self.xy()
                + self.xy() * operand.z() * self.yz()
                + self.yz() * operand.z() * self.xy()
                - self.s() * operand.z() * self.xz()
                - self.xz() * operand.y() * self.yz()
                - self.xz() * operand.x() * self.xz(),
            self.s() * operand.y() * self.s() - self.xz() * operand.x() * self.yz()
                + self.xy() * operand.x() * self.s()
                - self.s() * operand.z() * self.yz()
                - self.xy() * operand.y() * self.xy()
                + self.xz() * operand.y() * self.xz()
                - self.xz() * operand.z() * self.xy()
                - self.yz() * operand.x() * self.xz()
                - self.yz() * operand.y() * self.yz()
                - self.xy() * operand.z() * self.xz()
                + self.s() * operand.x() * self.xy()
                - self.yz() * operand.z() * self.s(),
            self.s() * operand.y() * self.yz()
                + self.xy() * operand.x() * self.yz()
                + self.s() * operand.x() * self.xz()
                + self.yz() * operand.x() * self.xy()
                + self.yz() * operand.y() * self.s()
                - self.xy() * operand.y() * self.xz()
                + self.xy() * operand.z() * self.xy()
                + self.s() * operand.z() * self.s()
                + self.xz() * operand.x() * self.s()
                - self.xz() * operand.y() * self.xy()
                - self.yz() * operand.z() * self.yz()
                - self.xz() * operand.z() * self.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Unit<Rotor<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            operand.x()
                + -T::TWO * operand.x() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.x() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * self.as_inner().s() * operand.y() * self.as_inner().xy()
                + -T::TWO * self.as_inner().s() * operand.z() * self.as_inner().xz()
                + -T::TWO * operand.y() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.z() * self.as_inner().xy() * self.as_inner().yz(),
            operand.y()
                + -T::TWO * operand.y() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.y() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * self.as_inner().s() * operand.x() * self.as_inner().xy()
                + -T::TWO * self.as_inner().s() * operand.z() * self.as_inner().yz()
                + -T::TWO * operand.x() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.z() * self.as_inner().xy() * self.as_inner().xz(),
            operand.z()
                + -T::TWO * operand.z() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.z() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * self.as_inner().s() * operand.x() * self.as_inner().xz()
                + T::TWO * self.as_inner().s() * operand.y() * self.as_inner().yz()
                + T::TWO * operand.x() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.y() * self.as_inner().xy() * self.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Point<T>>> for Rotor<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(operand.as_inner().x() * self.xy() * self.xy())
                + -(operand.as_inner().x() * self.xz() * self.xz())
                + operand.as_inner().x() * self.yz() * self.yz()
                + self.s() * self.s() * operand.as_inner().x()
                + -T::TWO * self.s() * operand.as_inner().y() * self.xy()
                + -T::TWO * self.s() * operand.as_inner().z() * self.xz()
                + -T::TWO * operand.as_inner().y() * self.xz() * self.yz()
                + T::TWO * operand.as_inner().z() * self.xy() * self.yz(),
            -(operand.as_inner().y() * self.xy() * self.xy())
                + operand.as_inner().y() * self.xz() * self.xz()
                + -(operand.as_inner().y() * self.yz() * self.yz())
                + self.s() * self.s() * operand.as_inner().y()
                + T::TWO * self.s() * operand.as_inner().x() * self.xy()
                + -T::TWO * self.s() * operand.as_inner().z() * self.yz()
                + -T::TWO * operand.as_inner().x() * self.xz() * self.yz()
                + -T::TWO * operand.as_inner().z() * self.xy() * self.xz(),
            operand.as_inner().z() * self.xy() * self.xy()
                + -(operand.as_inner().z() * self.xz() * self.xz())
                + -(operand.as_inner().z() * self.yz() * self.yz())
                + self.s() * self.s() * operand.as_inner().z()
                + T::TWO * self.s() * operand.as_inner().x() * self.xz()
                + T::TWO * self.s() * operand.as_inner().y() * self.yz()
                + T::TWO * operand.as_inner().x() * self.xy() * self.yz()
                + -T::TWO * operand.as_inner().y() * self.xy() * self.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Point<T>>> for Unit<Rotor<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            operand.as_inner().x()
                + -T::TWO * operand.as_inner().x() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().x() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * self.as_inner().s() * operand.as_inner().y() * self.as_inner().xy()
                + -T::TWO * self.as_inner().s() * operand.as_inner().z() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xz() * self.as_inner().yz()
                + T::TWO * operand.as_inner().z() * self.as_inner().xy() * self.as_inner().yz(),
            operand.as_inner().y()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xy() * self.as_inner().xy()
                + -T::TWO * operand.as_inner().y() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * self.as_inner().s() * operand.as_inner().x() * self.as_inner().xy()
                + -T::TWO * self.as_inner().s() * operand.as_inner().z() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().x() * self.as_inner().xz() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xy() * self.as_inner().xz(),
            operand.as_inner().z()
                + -T::TWO * operand.as_inner().z() * self.as_inner().xz() * self.as_inner().xz()
                + -T::TWO * operand.as_inner().z() * self.as_inner().yz() * self.as_inner().yz()
                + T::TWO * self.as_inner().s() * operand.as_inner().x() * self.as_inner().xz()
                + T::TWO * self.as_inner().s() * operand.as_inner().y() * self.as_inner().yz()
                + T::TWO * operand.as_inner().x() * self.as_inner().xy() * self.as_inner().yz()
                + -T::TWO * operand.as_inner().y() * self.as_inner().xy() * self.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Rotor<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.s() * operand.xyz() * self.s()
                + self.xz() * operand.xyz() * self.xz()
                + self.xy() * operand.xyz() * self.xy()
                + self.yz() * operand.xyz() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Unit<Rotor<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Rotor<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.s() * self.s() * operand.as_inner().xyz()
                + self.xy() * self.xy() * operand.as_inner().xyz()
                + self.xz() * self.xz() * operand.as_inner().xyz()
                + self.yz() * self.yz() * operand.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Unit<Rotor<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Rotor<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            self.xy() * operand.xz() * self.yz()
                + self.xz() * operand.s() * self.xz()
                + self.xz() * operand.yz() * self.xy()
                + self.yz() * operand.s() * self.yz()
                + self.xy() * operand.s() * self.xy()
                - self.xz() * operand.xy() * self.yz()
                + self.yz() * operand.xy() * self.xz()
                + self.s() * operand.xz() * self.xz()
                - self.xy() * operand.xy() * self.s()
                - self.yz() * operand.yz() * self.s()
                - self.xy() * operand.yz() * self.xz()
                - self.xz() * operand.xz() * self.s()
                - self.yz() * operand.xz() * self.xy()
                + self.s() * operand.xy() * self.xy()
                + self.s() * operand.s() * self.s()
                + self.s() * operand.yz() * self.yz(),
            -(self.s() * operand.s() * self.xy())
                + self.s() * operand.yz() * self.xz()
                + self.xy() * operand.xz() * self.xz()
                + self.xy() * operand.yz() * self.yz()
                - self.s() * operand.xz() * self.yz()
                - self.xz() * operand.s() * self.yz()
                + self.yz() * operand.s() * self.xz()
                - self.yz() * operand.xy() * self.yz()
                + self.xy() * operand.s() * self.s()
                + self.xz() * operand.yz() * self.s()
                - self.xz() * operand.xy() * self.xz()
                + self.s() * operand.xy() * self.s()
                - self.yz() * operand.xz() * self.s()
                + self.xy() * operand.xy() * self.xy()
                + self.xz() * operand.xz() * self.xy()
                + self.yz() * operand.yz() * self.xy(),
            -(self.s() * operand.s() * self.xz()) + self.s() * operand.xy() * self.yz()
                - self.xy() * operand.xz() * self.xy()
                + self.xy() * operand.xy() * self.xz()
                - self.xy() * operand.yz() * self.s()
                - self.yz() * operand.s() * self.xy()
                + self.xz() * operand.xy() * self.xy()
                - self.yz() * operand.xz() * self.yz()
                + self.xz() * operand.yz() * self.yz()
                + self.yz() * operand.xy() * self.s()
                - self.s() * operand.yz() * self.xy()
                + self.s() * operand.xz() * self.s()
                + self.xy() * operand.s() * self.yz()
                + self.xz() * operand.s() * self.s()
                + self.xz() * operand.xz() * self.xz()
                + self.yz() * operand.yz() * self.xz(),
            self.s() * operand.yz() * self.s()
                + self.xy() * operand.xz() * self.s()
                + self.s() * operand.xz() * self.xy()
                + self.yz() * operand.s() * self.s()
                - self.xz() * operand.xy() * self.s()
                + self.yz() * operand.xz() * self.xz()
                - self.xy() * operand.s() * self.xz()
                - self.xz() * operand.yz() * self.xz()
                + self.yz() * operand.xy() * self.xy()
                - self.xy() * operand.yz() * self.xy()
                - self.s() * operand.s() * self.yz()
                + self.xz() * operand.s() * self.xy()
                + self.xy() * operand.xy() * self.yz()
                + self.yz() * operand.yz() * self.yz()
                + self.xz() * operand.xz() * self.yz()
                - self.s() * operand.xy() * self.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Rotor<T>> for Unit<Rotor<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.s(),
            operand.xy()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.xy()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.xy()
                + T::TWO * self.as_inner().s() * self.as_inner().xz() * operand.yz()
                + -T::TWO * self.as_inner().s() * self.as_inner().yz() * operand.xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.yz(),
            operand.xz()
                + -T::TWO * self.as_inner().xy() * self.as_inner().xy() * operand.xz()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.xz()
                + -T::TWO * self.as_inner().s() * self.as_inner().xy() * operand.yz()
                + T::TWO * self.as_inner().s() * self.as_inner().yz() * operand.xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.yz(),
            operand.yz()
                + -T::TWO * self.as_inner().xy() * self.as_inner().xy() * operand.yz()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.yz()
                + T::TWO * self.as_inner().s() * self.as_inner().xy() * operand.xz()
                + -T::TWO * self.as_inner().s() * self.as_inner().xz() * operand.xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Rotor<T>>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.as_inner().s() * self.xy() * self.xy()
                + operand.as_inner().s() * self.xz() * self.xz()
                + operand.as_inner().s() * self.yz() * self.yz()
                + self.s() * self.s() * operand.as_inner().s(),
            self.s() * self.s() * operand.as_inner().xy()
                + self.xy() * self.xy() * operand.as_inner().xy()
                + -(self.xz() * self.xz() * operand.as_inner().xy())
                + -(self.yz() * self.yz() * operand.as_inner().xy())
                + T::TWO * self.s() * self.xz() * operand.as_inner().yz()
                + -T::TWO * self.s() * self.yz() * operand.as_inner().xz()
                + T::TWO * self.xy() * self.xz() * operand.as_inner().xz()
                + T::TWO * self.xy() * self.yz() * operand.as_inner().yz(),
            self.s() * self.s() * operand.as_inner().xz()
                + -(self.xy() * self.xy() * operand.as_inner().xz())
                + self.xz() * self.xz() * operand.as_inner().xz()
                + -(self.yz() * self.yz() * operand.as_inner().xz())
                + -T::TWO * self.s() * self.xy() * operand.as_inner().yz()
                + T::TWO * self.s() * self.yz() * operand.as_inner().xy()
                + T::TWO * self.xy() * self.xz() * operand.as_inner().xy()
                + T::TWO * self.xz() * self.yz() * operand.as_inner().yz(),
            self.s() * self.s() * operand.as_inner().yz()
                + -(self.xy() * self.xy() * operand.as_inner().yz())
                + -(self.xz() * self.xz() * operand.as_inner().yz())
                + self.yz() * self.yz() * operand.as_inner().yz()
                + T::TWO * self.s() * self.xy() * operand.as_inner().xz()
                + -T::TWO * self.s() * self.xz() * operand.as_inner().xy()
                + T::TWO * self.xy() * self.yz() * operand.as_inner().xy()
                + T::TWO * self.xz() * self.yz() * operand.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Rotor<T>>> for Unit<Rotor<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.as_inner().s(),
            operand.as_inner().xy()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.as_inner().xy()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().s() * self.as_inner().xz() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().s() * self.as_inner().yz() * operand.as_inner().xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.as_inner().xz()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.as_inner().yz(),
            operand.as_inner().xz()
                + -T::TWO * self.as_inner().xy() * self.as_inner().xy() * operand.as_inner().xz()
                + -T::TWO * self.as_inner().yz() * self.as_inner().yz() * operand.as_inner().xz()
                + -T::TWO * self.as_inner().s() * self.as_inner().xy() * operand.as_inner().yz()
                + T::TWO * self.as_inner().s() * self.as_inner().yz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().xz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.as_inner().yz(),
            operand.as_inner().yz()
                + -T::TWO * self.as_inner().xy() * self.as_inner().xy() * operand.as_inner().yz()
                + -T::TWO * self.as_inner().xz() * self.as_inner().xz() * operand.as_inner().yz()
                + T::TWO * self.as_inner().s() * self.as_inner().xy() * operand.as_inner().xz()
                + -T::TWO * self.as_inner().s() * self.as_inner().xz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xy() * self.as_inner().yz() * operand.as_inner().xy()
                + T::TWO * self.as_inner().xz() * self.as_inner().yz() * operand.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Rotor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.s() * operand.s() * self.s()
                + self.xy() * operand.s() * self.xy()
                + self.yz() * operand.s() * self.yz()
                + self.xz() * operand.s() * self.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unit<Rotor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Rotor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            operand.as_inner().s() * self.xy() * self.xy()
                + operand.as_inner().s() * self.xz() * self.xz()
                + operand.as_inner().s() * self.yz() * self.yz()
                + self.s() * self.s() * operand.as_inner().s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Unit<Rotor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.s() * operand.xy() * self.s(),
            self.s() * operand.xz() * self.s(),
            self.s() * operand.yz() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Line<T>> for Unit<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Line<T>) -> Line<T> {
        Line::new_unchecked(operand.xy(), operand.xz(), operand.yz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Line<T>>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            self.s() * self.s() * operand.as_inner().xy(),
            self.s() * self.s() * operand.as_inner().xz(),
            self.s() * self.s() * operand.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Line<T>>> for Unit<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            operand.as_inner().xy(),
            operand.as_inner().xz(),
            operand.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            self.s() * operand.x() * self.s(),
            self.s() * operand.y() * self.s(),
            self.s() * operand.z() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Point<T>> for Unit<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Point<T>) -> Point<T> {
        Point::new_unchecked(operand.x(), operand.y(), operand.z())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Point<T>>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            self.s() * self.s() * operand.as_inner().x(),
            self.s() * self.s() * operand.as_inner().y(),
            self.s() * self.s() * operand.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Point<T>>> for Unit<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            operand.as_inner().x(),
            operand.as_inner().y(),
            operand.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.s() * operand.xyz() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Pseudoscalar<T>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.s() * self.s() * operand.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Pseudoscalar<T>>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(operand.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Rotor<T>> for Scalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(
            self.s() * operand.s() * self.s(),
            self.s() * operand.xy() * self.s(),
            self.s() * operand.xz() * self.s(),
            self.s() * operand.yz() * self.s(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Rotor<T>> for Unit<Scalar<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Rotor<T>) -> Rotor<T> {
        Rotor::new_unchecked(operand.s(), operand.xy(), operand.xz(), operand.yz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Rotor<T>>> for Scalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            self.s() * self.s() * operand.as_inner().s(),
            self.s() * self.s() * operand.as_inner().xy(),
            self.s() * self.s() * operand.as_inner().xz(),
            self.s() * self.s() * operand.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Rotor<T>>> for Unit<Scalar<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        Rotor::new_unchecked(
            operand.as_inner().s(),
            operand.as_inner().xy(),
            operand.as_inner().xz(),
            operand.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * operand.s() * self.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(operand.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * self.s() * operand.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antisandwich<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn antisandwich(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(operand.as_inner().s())
    }
}
impl<T: Float> Transform<Line<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Line<T>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Line<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Line<T>>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Line<T>>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Line<T>>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Point<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Point<T>> for Unit<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Point<T>>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Point<T>>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Point<T>>> for Unit<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Point<T>>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Line<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Unit<Line<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Line<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Unit<Line<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Rotor<T>> for Line<T> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Rotor<T>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Rotor<T>> for Unit<Line<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Rotor<T>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Rotor<T>>> for Line<T> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Rotor<T>>> for Unit<Line<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unit<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Unit<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Line<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Line<T>> for Unit<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Line<T>>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Line<T>>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Line<T>>> for Unit<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Line<T>>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Point<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Point<T>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Point<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Point<T>>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Point<T>>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Point<T>>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Point<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Unit<Point<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Point<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Unit<Point<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Rotor<T>> for Point<T> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Rotor<T>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Rotor<T>> for Unit<Point<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Rotor<T>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Rotor<T>>> for Point<T> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Rotor<T>>> for Unit<Point<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unit<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Unit<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Line<T>> for Pseudoscalar<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Line<T>> for Unit<Pseudoscalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Line<T>>> for Pseudoscalar<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Line<T>>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Line<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Line<T>>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Point<T>> for Pseudoscalar<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Point<T>> for Unit<Pseudoscalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Point<T>>> for Pseudoscalar<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Point<T>>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Point<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Point<T>>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Rotor<T>> for Pseudoscalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Rotor<T>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Rotor<T>> for Unit<Pseudoscalar<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Rotor<T>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Rotor<T>>> for Pseudoscalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Rotor<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Line<T>> for Rotor<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Line<T>> for Unit<Rotor<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Line<T>>> for Rotor<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Line<T>>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Line<T>>> for Unit<Rotor<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Line<T>>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Point<T>> for Rotor<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Point<T>> for Unit<Rotor<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Point<T>>> for Rotor<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Point<T>>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Point<T>>> for Unit<Rotor<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Point<T>>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Rotor<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Unit<Rotor<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Rotor<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Unit<Rotor<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Rotor<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Rotor<T>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Rotor<T>> for Unit<Rotor<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Rotor<T>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Rotor<T>>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Rotor<T>>> for Unit<Rotor<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Rotor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unit<Rotor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Rotor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Unit<Rotor<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Line<T>> for Unit<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Line<T>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Line<T>>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Line<T>>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Line<T>>> for Unit<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Line<T>>) -> Line<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Point<T>> for Unit<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Point<T>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Point<T>>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Point<T>>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Point<T>>> for Unit<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Point<T>>) -> Point<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Pseudoscalar<T>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Pseudoscalar<T>>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Rotor<T>> for Scalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Rotor<T>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Rotor<T>> for Unit<Scalar<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Rotor<T>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Rotor<T>>> for Scalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Rotor<T>>> for Unit<Scalar<T>> {
    type Output = Rotor<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Rotor<T>>) -> Rotor<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Scalar<T>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
impl<T: Float> Transform<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn transform(&self, operand: &Unit<Scalar<T>>) -> Scalar<T> {
        self.sandwich(operand)
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Line<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (self.xz() * operand.xz() * self.xy() - self.xz() * operand.xy() * self.xz()
                + self.xy() * operand.yz() * self.yz()
                - self.yz() * operand.xy() * self.yz()
                + self.xy() * operand.xy() * self.xy()
                + self.xy() * operand.xz() * self.xz()
                + self.yz() * operand.yz() * self.xy())
                * inv_norm_sq,
            (-(self.yz() * operand.xz() * self.yz())
                + self.yz() * operand.yz() * self.xz()
                + self.xz() * operand.xy() * self.xy()
                - self.xy() * operand.xz() * self.xy()
                + self.xy() * operand.xy() * self.xz()
                + self.xz() * operand.xz() * self.xz()
                + self.xz() * operand.yz() * self.yz())
                * inv_norm_sq,
            (-(self.xy() * operand.yz() * self.xy())
                + self.xz() * operand.xz() * self.yz()
                + self.yz() * operand.yz() * self.yz()
                - self.xz() * operand.yz() * self.xz()
                + self.yz() * operand.xy() * self.xy()
                + self.xy() * operand.xy() * self.yz()
                + self.yz() * operand.xz() * self.xz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Point<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (self.yz() * operand.x() * self.yz()
                - self.xy() * operand.x() * self.xy()
                - self.xz() * operand.y() * self.yz()
                - self.yz() * operand.y() * self.xz()
                + self.yz() * operand.z() * self.xy()
                + self.xy() * operand.z() * self.yz()
                - self.xz() * operand.x() * self.xz())
                * inv_norm_sq,
            (-(self.yz() * operand.y() * self.yz())
                - self.xz() * operand.x() * self.yz()
                - self.xy() * operand.y() * self.xy()
                + self.xz() * operand.y() * self.xz()
                - self.xz() * operand.z() * self.xy()
                - self.xy() * operand.z() * self.xz()
                - self.yz() * operand.x() * self.xz())
                * inv_norm_sq,
            (-(self.xz() * operand.z() * self.xz())
                + self.xy() * operand.x() * self.yz()
                + self.xy() * operand.z() * self.xy()
                - self.xz() * operand.y() * self.xy()
                - self.xy() * operand.y() * self.xz()
                + self.yz() * operand.x() * self.xy()
                - self.yz() * operand.z() * self.yz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Pseudoscalar<T>> for Line<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (self.xy() * operand.xyz() * self.xy()
                + self.yz() * operand.xyz() * self.yz()
                + self.xz() * operand.xyz() * self.xz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Rotor<T>> for Line<T> {
    type Output = Rotor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Rotor<T>) -> Option<Rotor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Rotor::new_unchecked(
            (self.xy() * operand.yz() * self.xz() - self.xz() * operand.yz() * self.xy()
                + self.yz() * operand.xz() * self.xy()
                + self.yz() * operand.s() * self.yz()
                + self.xy() * operand.s() * self.xy()
                - self.yz() * operand.xy() * self.xz()
                + self.xz() * operand.xy() * self.yz()
                + self.xz() * operand.s() * self.xz()
                - self.xy() * operand.xz() * self.yz())
                * inv_norm_sq,
            (self.xz() * operand.s() * self.yz()
                + self.xy() * operand.xz() * self.xz()
                + self.xz() * operand.xz() * self.xy()
                - self.yz() * operand.xy() * self.yz()
                + self.yz() * operand.yz() * self.xy()
                - self.yz() * operand.s() * self.xz()
                + self.xy() * operand.xy() * self.xy()
                - self.xz() * operand.xy() * self.xz()
                + self.xy() * operand.yz() * self.yz())
                * inv_norm_sq,
            (self.xy() * operand.xy() * self.xz() - self.xy() * operand.s() * self.yz()
                + self.xz() * operand.xy() * self.xy()
                + self.xz() * operand.yz() * self.yz()
                - self.xy() * operand.xz() * self.xy()
                - self.yz() * operand.xz() * self.yz()
                + self.xz() * operand.xz() * self.xz()
                + self.yz() * operand.yz() * self.xz()
                + self.yz() * operand.s() * self.xy())
                * inv_norm_sq,
            (self.yz() * operand.yz() * self.yz()
                + self.yz() * operand.xy() * self.xy()
                + self.yz() * operand.xz() * self.xz()
                - self.xy() * operand.yz() * self.xy()
                + self.xy() * operand.xy() * self.yz()
                + self.xy() * operand.s() * self.xz()
                + self.xz() * operand.xz() * self.yz()
                - self.xz() * operand.yz() * self.xz()
                - self.xz() * operand.s() * self.xy())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.xz() * operand.s() * self.xz()
                + self.xy() * operand.s() * self.xy()
                + self.yz() * operand.s() * self.yz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Line<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (-(self.y() * operand.xy() * self.y()) + self.z() * operand.xy() * self.z()
                - self.z() * operand.xz() * self.y()
                - self.x() * operand.xy() * self.x()
                - self.y() * operand.xz() * self.z()
                + self.z() * operand.yz() * self.x()
                + self.x() * operand.yz() * self.z())
                * inv_norm_sq,
            (-(self.z() * operand.xy() * self.y())
                - self.x() * operand.xz() * self.x()
                - self.z() * operand.xz() * self.z()
                - self.y() * operand.xy() * self.z()
                + self.y() * operand.xz() * self.y()
                - self.x() * operand.yz() * self.y()
                - self.y() * operand.yz() * self.x())
                * inv_norm_sq,
            (self.x() * operand.yz() * self.x() - self.y() * operand.yz() * self.y()
                + self.z() * operand.xy() * self.x()
                - self.x() * operand.xz() * self.y()
                - self.y() * operand.xz() * self.x()
                - self.z() * operand.yz() * self.z()
                + self.x() * operand.xy() * self.z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Point<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (self.x() * operand.y() * self.y() + self.x() * operand.x() * self.x()
                - self.y() * operand.x() * self.y()
                + self.y() * operand.y() * self.x()
                + self.z() * operand.z() * self.x()
                - self.z() * operand.x() * self.z()
                + self.x() * operand.z() * self.z())
                * inv_norm_sq,
            (self.y() * operand.x() * self.x()
                - self.z() * operand.y() * self.z()
                - self.x() * operand.y() * self.x()
                + self.y() * operand.z() * self.z()
                + self.y() * operand.y() * self.y()
                + self.x() * operand.x() * self.y()
                + self.z() * operand.z() * self.y())
                * inv_norm_sq,
            (self.z() * operand.z() * self.z() + self.x() * operand.x() * self.z()
                - self.y() * operand.z() * self.y()
                - self.x() * operand.z() * self.x()
                + self.z() * operand.x() * self.x()
                + self.y() * operand.y() * self.z()
                + self.z() * operand.y() * self.y())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Pseudoscalar<T>> for Point<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (self.y() * operand.xyz() * self.y()
                + self.z() * operand.xyz() * self.z()
                + self.x() * operand.xyz() * self.x())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Rotor<T>> for Point<T> {
    type Output = Rotor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Rotor<T>) -> Option<Rotor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Rotor::new_unchecked(
            (-(self.z() * operand.xz() * self.x())
                + self.y() * operand.s() * self.y()
                + self.y() * operand.yz() * self.z()
                + self.z() * operand.s() * self.z()
                + self.x() * operand.s() * self.x()
                + self.x() * operand.xz() * self.z()
                - self.z() * operand.yz() * self.y()
                - self.y() * operand.xy() * self.x()
                + self.x() * operand.xy() * self.y())
                * inv_norm_sq,
            (self.x() * operand.s() * self.y()
                - self.x() * operand.xy() * self.x()
                - self.z() * operand.xz() * self.y()
                + self.z() * operand.yz() * self.x()
                + self.x() * operand.yz() * self.z()
                + self.z() * operand.xy() * self.z()
                - self.y() * operand.s() * self.x()
                - self.y() * operand.xy() * self.y()
                - self.y() * operand.xz() * self.z())
                * inv_norm_sq,
            (self.x() * operand.s() * self.z()
                - self.y() * operand.xy() * self.z()
                - self.x() * operand.yz() * self.y()
                - self.z() * operand.xy() * self.y()
                - self.z() * operand.xz() * self.z()
                - self.z() * operand.s() * self.x()
                - self.x() * operand.xz() * self.x()
                + self.y() * operand.xz() * self.y()
                - self.y() * operand.yz() * self.x())
                * inv_norm_sq,
            (self.z() * operand.xy() * self.x()
                - self.x() * operand.xz() * self.y()
                - self.z() * operand.yz() * self.z()
                - self.z() * operand.s() * self.y()
                + self.x() * operand.xy() * self.z()
                + self.x() * operand.yz() * self.x()
                + self.y() * operand.s() * self.z()
                - self.y() * operand.xz() * self.x()
                - self.y() * operand.yz() * self.y())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.x() * operand.s() * self.x()
                + self.y() * operand.s() * self.y()
                + self.z() * operand.s() * self.z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Line<T>> for Pseudoscalar<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (self.xyz() * operand.xy() * self.xyz()) * inv_norm_sq,
            (self.xyz() * operand.xz() * self.xyz()) * inv_norm_sq,
            (self.xyz() * operand.yz() * self.xyz()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Point<T>> for Pseudoscalar<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (self.xyz() * operand.x() * self.xyz()) * inv_norm_sq,
            (self.xyz() * operand.y() * self.xyz()) * inv_norm_sq,
            (self.xyz() * operand.z() * self.xyz()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (self.xyz() * operand.xyz() * self.xyz()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Rotor<T>> for Pseudoscalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Rotor<T>) -> Option<Rotor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Rotor::new_unchecked(
            (self.xyz() * operand.s() * self.xyz()) * inv_norm_sq,
            (self.xyz() * operand.xy() * self.xyz()) * inv_norm_sq,
            (self.xyz() * operand.xz() * self.xyz()) * inv_norm_sq,
            (self.xyz() * operand.yz() * self.xyz()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.xyz() * operand.s() * self.xyz()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Line<T>> for Rotor<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (self.yz() * operand.yz() * self.xy()
                + self.s() * operand.xy() * self.s()
                + self.xy() * operand.xy() * self.xy()
                - self.xz() * operand.xy() * self.xz()
                + self.yz() * operand.xz() * self.s()
                + self.s() * operand.xz() * self.yz()
                - self.xz() * operand.yz() * self.s()
                - self.s() * operand.yz() * self.xz()
                + self.xz() * operand.xz() * self.xy()
                + self.xy() * operand.xz() * self.xz()
                + self.xy() * operand.yz() * self.yz()
                - self.yz() * operand.xy() * self.yz())
                * inv_norm_sq,
            (self.yz() * operand.yz() * self.xz()
                - self.yz() * operand.xy() * self.s()
                - self.s() * operand.xy() * self.yz()
                - self.yz() * operand.xz() * self.yz()
                + self.xz() * operand.xy() * self.xy()
                + self.xy() * operand.xy() * self.xz()
                - self.xy() * operand.xz() * self.xy()
                + self.xz() * operand.yz() * self.yz()
                + self.s() * operand.yz() * self.xy()
                + self.s() * operand.xz() * self.s()
                + self.xz() * operand.xz() * self.xz()
                + self.xy() * operand.yz() * self.s())
                * inv_norm_sq,
            (-(self.xy() * operand.xz() * self.s()) + self.xz() * operand.xy() * self.s()
                - self.s() * operand.xz() * self.xy()
                + self.xz() * operand.xz() * self.yz()
                - self.xy() * operand.yz() * self.xy()
                + self.yz() * operand.yz() * self.yz()
                + self.s() * operand.xy() * self.xz()
                + self.xy() * operand.xy() * self.yz()
                - self.xz() * operand.yz() * self.xz()
                + self.yz() * operand.xy() * self.xy()
                + self.s() * operand.yz() * self.s()
                + self.yz() * operand.xz() * self.xz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Point<T>> for Rotor<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (self.s() * operand.z() * self.xz() + self.yz() * operand.x() * self.yz()
                - self.yz() * operand.y() * self.xz()
                - self.xz() * operand.x() * self.xz()
                + self.xy() * operand.y() * self.s()
                + self.xy() * operand.z() * self.yz()
                + self.s() * operand.y() * self.xy()
                + self.yz() * operand.z() * self.xy()
                - self.xy() * operand.x() * self.xy()
                + self.s() * operand.x() * self.s()
                - self.xz() * operand.y() * self.yz()
                + self.xz() * operand.z() * self.s())
                * inv_norm_sq,
            (-(self.xy() * operand.z() * self.xz()) - self.xy() * operand.y() * self.xy()
                + self.xz() * operand.y() * self.xz()
                + self.s() * operand.y() * self.s()
                + self.s() * operand.z() * self.yz()
                - self.xz() * operand.x() * self.yz()
                - self.s() * operand.x() * self.xy()
                - self.yz() * operand.x() * self.xz()
                + self.yz() * operand.z() * self.s()
                - self.xy() * operand.x() * self.s()
                - self.yz() * operand.y() * self.yz()
                - self.xz() * operand.z() * self.xy())
                * inv_norm_sq,
            (-(self.xz() * operand.x() * self.s())
                - self.xz() * operand.z() * self.xz()
                - self.xy() * operand.y() * self.xz()
                + self.xy() * operand.z() * self.xy()
                + self.s() * operand.z() * self.s()
                - self.s() * operand.x() * self.xz()
                - self.s() * operand.y() * self.yz()
                + self.xy() * operand.x() * self.yz()
                - self.xz() * operand.y() * self.xy()
                + self.yz() * operand.x() * self.xy()
                - self.yz() * operand.y() * self.s()
                - self.yz() * operand.z() * self.yz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Pseudoscalar<T>> for Rotor<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (self.s() * operand.xyz() * self.s()
                + self.xz() * operand.xyz() * self.xz()
                + self.xy() * operand.xyz() * self.xy()
                + self.yz() * operand.xyz() * self.yz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Rotor<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Rotor<T>) -> Option<Rotor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Rotor::new_unchecked(
            (self.s() * operand.xz() * self.xz() + self.xz() * operand.xy() * self.yz()
                - self.yz() * operand.yz() * self.s()
                - self.xy() * operand.xz() * self.yz()
                - self.xz() * operand.yz() * self.xy()
                + self.xy() * operand.s() * self.xy()
                - self.xz() * operand.xz() * self.s()
                + self.s() * operand.s() * self.s()
                + self.s() * operand.xy() * self.xy()
                + self.xy() * operand.yz() * self.xz()
                + self.xz() * operand.s() * self.xz()
                - self.xy() * operand.xy() * self.s()
                + self.s() * operand.yz() * self.yz()
                + self.yz() * operand.xz() * self.xy()
                + self.yz() * operand.s() * self.yz()
                - self.yz() * operand.xy() * self.xz())
                * inv_norm_sq,
            (-(self.xz() * operand.xy() * self.xz()) + self.s() * operand.xz() * self.yz()
                - self.s() * operand.yz() * self.xz()
                - self.s() * operand.s() * self.xy()
                + self.xz() * operand.xz() * self.xy()
                - self.yz() * operand.s() * self.xz()
                + self.xz() * operand.s() * self.yz()
                + self.s() * operand.xy() * self.s()
                - self.xz() * operand.yz() * self.s()
                - self.yz() * operand.xy() * self.yz()
                + self.xy() * operand.xz() * self.xz()
                + self.yz() * operand.xz() * self.s()
                + self.xy() * operand.yz() * self.yz()
                + self.yz() * operand.yz() * self.xy()
                + self.xy() * operand.xy() * self.xy()
                + self.xy() * operand.s() * self.s())
                * inv_norm_sq,
            (self.xy() * operand.xy() * self.xz()
                + self.xz() * operand.xz() * self.xz()
                + self.xz() * operand.s() * self.s()
                - self.xy() * operand.xz() * self.xy()
                + self.xz() * operand.yz() * self.yz()
                + self.xy() * operand.yz() * self.s()
                - self.yz() * operand.xy() * self.s()
                - self.s() * operand.s() * self.xz()
                + self.yz() * operand.yz() * self.xz()
                + self.s() * operand.yz() * self.xy()
                + self.xz() * operand.xy() * self.xy()
                + self.s() * operand.xz() * self.s()
                - self.s() * operand.xy() * self.yz()
                - self.yz() * operand.xz() * self.yz()
                + self.yz() * operand.s() * self.xy()
                - self.xy() * operand.s() * self.yz())
                * inv_norm_sq,
            (self.yz() * operand.xz() * self.xz() + self.xy() * operand.s() * self.xz()
                - self.xz() * operand.s() * self.xy()
                + self.xz() * operand.xy() * self.s()
                + self.s() * operand.xy() * self.xz()
                - self.xz() * operand.yz() * self.xz()
                - self.xy() * operand.yz() * self.xy()
                + self.yz() * operand.yz() * self.yz()
                - self.s() * operand.xz() * self.xy()
                + self.xz() * operand.xz() * self.yz()
                + self.yz() * operand.xy() * self.xy()
                + self.xy() * operand.xy() * self.yz()
                + self.yz() * operand.s() * self.s()
                - self.s() * operand.s() * self.yz()
                - self.xy() * operand.xz() * self.s()
                + self.s() * operand.yz() * self.s())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Rotor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.s() * operand.s() * self.s()
                + self.xz() * operand.s() * self.xz()
                + self.yz() * operand.s() * self.yz()
                + self.xy() * operand.s() * self.xy())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (self.s() * operand.xy() * self.s()) * inv_norm_sq,
            (self.s() * operand.xz() * self.s()) * inv_norm_sq,
            (self.s() * operand.yz() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (self.s() * operand.x() * self.s()) * inv_norm_sq,
            (self.s() * operand.y() * self.s()) * inv_norm_sq,
            (self.s() * operand.z() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Pseudoscalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (self.s() * operand.xyz() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Rotor<T>> for Scalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Rotor<T>) -> Option<Rotor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Rotor::new_unchecked(
            (self.s() * operand.s() * self.s()) * inv_norm_sq,
            (self.s() * operand.xy() * self.s()) * inv_norm_sq,
            (self.s() * operand.xz() * self.s()) * inv_norm_sq,
            (self.s() * operand.yz() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseSandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_sandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.s() * operand.s() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Line<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (self.xy() * operand.xz() * self.xz() - self.xz() * operand.xy() * self.xz()
                + self.xz() * operand.xz() * self.xy()
                + self.yz() * operand.yz() * self.xy()
                + self.xy() * operand.xy() * self.xy()
                - self.yz() * operand.xy() * self.yz()
                + self.xy() * operand.yz() * self.yz())
                * inv_norm_sq,
            (self.xz() * operand.xy() * self.xy()
                + self.xy() * operand.xy() * self.xz()
                + self.xz() * operand.xz() * self.xz()
                + self.xz() * operand.yz() * self.yz()
                - self.yz() * operand.xz() * self.yz()
                + self.yz() * operand.yz() * self.xz()
                - self.xy() * operand.xz() * self.xy())
                * inv_norm_sq,
            (-(self.xz() * operand.yz() * self.xz())
                + self.xy() * operand.xy() * self.yz()
                + self.yz() * operand.xz() * self.xz()
                + self.yz() * operand.xy() * self.xy()
                + self.yz() * operand.yz() * self.yz()
                - self.xy() * operand.yz() * self.xy()
                + self.xz() * operand.xz() * self.yz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Point<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (self.xy() * operand.z() * self.yz()
                + self.yz() * operand.x() * self.yz()
                + self.yz() * operand.z() * self.xy()
                - self.yz() * operand.y() * self.xz()
                - self.xy() * operand.x() * self.xy()
                - self.xz() * operand.y() * self.yz()
                - self.xz() * operand.x() * self.xz())
                * inv_norm_sq,
            (-(self.xy() * operand.y() * self.xy()) + self.xz() * operand.y() * self.xz()
                - self.xy() * operand.z() * self.xz()
                - self.xz() * operand.z() * self.xy()
                - self.yz() * operand.y() * self.yz()
                - self.xz() * operand.x() * self.yz()
                - self.yz() * operand.x() * self.xz())
                * inv_norm_sq,
            (-(self.xz() * operand.z() * self.xz()) - self.xz() * operand.y() * self.xy()
                + self.xy() * operand.z() * self.xy()
                + self.xy() * operand.x() * self.yz()
                - self.xy() * operand.y() * self.xz()
                + self.yz() * operand.x() * self.xy()
                - self.yz() * operand.z() * self.yz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Pseudoscalar<T>> for Line<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (self.xz() * operand.xyz() * self.xz()
                + self.yz() * operand.xyz() * self.yz()
                + self.xy() * operand.xyz() * self.xy())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Rotor<T>> for Line<T> {
    type Output = Rotor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Rotor<T>) -> Option<Rotor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Rotor::new_unchecked(
            (self.xy() * operand.xz() * self.yz()
                + self.xz() * operand.s() * self.xz()
                + self.xy() * operand.s() * self.xy()
                - self.yz() * operand.xz() * self.xy()
                + self.xz() * operand.yz() * self.xy()
                - self.xy() * operand.yz() * self.xz()
                + self.yz() * operand.s() * self.yz()
                + self.yz() * operand.xy() * self.xz()
                - self.xz() * operand.xy() * self.yz())
                * inv_norm_sq,
            (-(self.xz() * operand.s() * self.yz())
                + self.xy() * operand.yz() * self.yz()
                + self.xz() * operand.xz() * self.xy()
                - self.xz() * operand.xy() * self.xz()
                + self.yz() * operand.s() * self.xz()
                + self.yz() * operand.yz() * self.xy()
                - self.yz() * operand.xy() * self.yz()
                + self.xy() * operand.xz() * self.xz()
                + self.xy() * operand.xy() * self.xy())
                * inv_norm_sq,
            (self.xz() * operand.yz() * self.yz()
                - self.yz() * operand.s() * self.xy()
                - self.yz() * operand.xz() * self.yz()
                + self.yz() * operand.yz() * self.xz()
                - self.xy() * operand.xz() * self.xy()
                + self.xz() * operand.xy() * self.xy()
                + self.xy() * operand.s() * self.yz()
                + self.xz() * operand.xz() * self.xz()
                + self.xy() * operand.xy() * self.xz())
                * inv_norm_sq,
            (-(self.xy() * operand.yz() * self.xy())
                + self.yz() * operand.xy() * self.xy()
                + self.xz() * operand.s() * self.xy()
                + self.xz() * operand.xz() * self.yz()
                + self.yz() * operand.yz() * self.yz()
                + self.yz() * operand.xz() * self.xz()
                + self.xy() * operand.xy() * self.yz()
                - self.xy() * operand.s() * self.xz()
                - self.xz() * operand.yz() * self.xz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.yz() * operand.s() * self.yz()
                + self.xy() * operand.s() * self.xy()
                + self.xz() * operand.s() * self.xz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Line<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (-(self.y() * operand.xz() * self.z()) - self.x() * operand.xy() * self.x()
                + self.z() * operand.xy() * self.z()
                - self.z() * operand.xz() * self.y()
                + self.z() * operand.yz() * self.x()
                + self.x() * operand.yz() * self.z()
                - self.y() * operand.xy() * self.y())
                * inv_norm_sq,
            (-(self.x() * operand.xz() * self.x())
                - self.y() * operand.xy() * self.z()
                - self.z() * operand.xz() * self.z()
                + self.y() * operand.xz() * self.y()
                - self.y() * operand.yz() * self.x()
                - self.x() * operand.yz() * self.y()
                - self.z() * operand.xy() * self.y())
                * inv_norm_sq,
            (-(self.z() * operand.yz() * self.z()) - self.x() * operand.xz() * self.y()
                + self.x() * operand.yz() * self.x()
                + self.x() * operand.xy() * self.z()
                - self.y() * operand.yz() * self.y()
                + self.z() * operand.xy() * self.x()
                - self.y() * operand.xz() * self.x())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Point<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (self.z() * operand.z() * self.x()
                + self.y() * operand.y() * self.x()
                + self.x() * operand.x() * self.x()
                - self.y() * operand.x() * self.y()
                + self.x() * operand.y() * self.y()
                + self.x() * operand.z() * self.z()
                - self.z() * operand.x() * self.z())
                * inv_norm_sq,
            (self.y() * operand.y() * self.y()
                - self.z() * operand.y() * self.z()
                - self.x() * operand.y() * self.x()
                + self.y() * operand.z() * self.z()
                + self.z() * operand.z() * self.y()
                + self.y() * operand.x() * self.x()
                + self.x() * operand.x() * self.y())
                * inv_norm_sq,
            (-(self.y() * operand.z() * self.y())
                + self.z() * operand.y() * self.y()
                + self.y() * operand.y() * self.z()
                + self.z() * operand.x() * self.x()
                + self.z() * operand.z() * self.z()
                + self.x() * operand.x() * self.z()
                - self.x() * operand.z() * self.x())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Pseudoscalar<T>> for Point<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (self.z() * operand.xyz() * self.z()
                + self.x() * operand.xyz() * self.x()
                + self.y() * operand.xyz() * self.y())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Rotor<T>> for Point<T> {
    type Output = Rotor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Rotor<T>) -> Option<Rotor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Rotor::new_unchecked(
            (-(self.y() * operand.yz() * self.z())
                + self.z() * operand.yz() * self.y()
                + self.z() * operand.s() * self.z()
                - self.x() * operand.xy() * self.y()
                - self.x() * operand.xz() * self.z()
                + self.y() * operand.s() * self.y()
                + self.y() * operand.xy() * self.x()
                + self.z() * operand.xz() * self.x()
                + self.x() * operand.s() * self.x())
                * inv_norm_sq,
            (-(self.x() * operand.s() * self.y())
                - self.y() * operand.xz() * self.z()
                - self.x() * operand.xy() * self.x()
                + self.z() * operand.xy() * self.z()
                + self.y() * operand.s() * self.x()
                + self.z() * operand.yz() * self.x()
                - self.z() * operand.xz() * self.y()
                - self.y() * operand.xy() * self.y()
                + self.x() * operand.yz() * self.z())
                * inv_norm_sq,
            (-(self.z() * operand.xz() * self.z())
                - self.x() * operand.xz() * self.x()
                - self.y() * operand.xy() * self.z()
                + self.y() * operand.xz() * self.y()
                + self.z() * operand.s() * self.x()
                - self.x() * operand.s() * self.z()
                - self.y() * operand.yz() * self.x()
                - self.z() * operand.xy() * self.y()
                - self.x() * operand.yz() * self.y())
                * inv_norm_sq,
            (self.x() * operand.yz() * self.x() - self.z() * operand.yz() * self.z()
                + self.z() * operand.xy() * self.x()
                - self.y() * operand.s() * self.z()
                - self.x() * operand.xz() * self.y()
                - self.y() * operand.yz() * self.y()
                - self.y() * operand.xz() * self.x()
                + self.x() * operand.xy() * self.z()
                + self.z() * operand.s() * self.y())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.x() * operand.s() * self.x()
                + self.y() * operand.s() * self.y()
                + self.z() * operand.s() * self.z())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Line<T>> for Pseudoscalar<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (self.xyz() * operand.xy() * self.xyz()) * inv_norm_sq,
            (self.xyz() * operand.xz() * self.xyz()) * inv_norm_sq,
            (self.xyz() * operand.yz() * self.xyz()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Point<T>> for Pseudoscalar<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (self.xyz() * operand.x() * self.xyz()) * inv_norm_sq,
            (self.xyz() * operand.y() * self.xyz()) * inv_norm_sq,
            (self.xyz() * operand.z() * self.xyz()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (self.xyz() * operand.xyz() * self.xyz()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Rotor<T>> for Pseudoscalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Rotor<T>) -> Option<Rotor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Rotor::new_unchecked(
            (self.xyz() * operand.s() * self.xyz()) * inv_norm_sq,
            (self.xyz() * operand.xy() * self.xyz()) * inv_norm_sq,
            (self.xyz() * operand.xz() * self.xyz()) * inv_norm_sq,
            (self.xyz() * operand.yz() * self.xyz()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.xyz() * operand.s() * self.xyz()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Line<T>> for Rotor<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (self.xz() * operand.xz() * self.xy()
                - self.s() * operand.xz() * self.yz()
                - self.yz() * operand.xz() * self.s()
                + self.xz() * operand.yz() * self.s()
                + self.s() * operand.xy() * self.s()
                - self.xz() * operand.xy() * self.xz()
                + self.xy() * operand.xy() * self.xy()
                + self.s() * operand.yz() * self.xz()
                + self.xy() * operand.yz() * self.yz()
                + self.xy() * operand.xz() * self.xz()
                - self.yz() * operand.xy() * self.yz()
                + self.yz() * operand.yz() * self.xy())
                * inv_norm_sq,
            (-(self.xy() * operand.xz() * self.xy()) + self.yz() * operand.xy() * self.s()
                - self.yz() * operand.xz() * self.yz()
                - self.s() * operand.yz() * self.xy()
                + self.yz() * operand.yz() * self.xz()
                + self.xz() * operand.xy() * self.xy()
                + self.xy() * operand.xy() * self.xz()
                + self.s() * operand.xy() * self.yz()
                + self.xz() * operand.yz() * self.yz()
                + self.xz() * operand.xz() * self.xz()
                + self.s() * operand.xz() * self.s()
                - self.xy() * operand.yz() * self.s())
                * inv_norm_sq,
            (self.yz() * operand.xy() * self.xy()
                + self.xy() * operand.xz() * self.s()
                + self.xz() * operand.xz() * self.yz()
                + self.yz() * operand.xz() * self.xz()
                - self.xz() * operand.xy() * self.s()
                - self.xz() * operand.yz() * self.xz()
                + self.yz() * operand.yz() * self.yz()
                + self.xy() * operand.xy() * self.yz()
                - self.s() * operand.xy() * self.xz()
                - self.xy() * operand.yz() * self.xy()
                + self.s() * operand.yz() * self.s()
                + self.s() * operand.xz() * self.xy())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Point<T>> for Rotor<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (-(self.yz() * operand.y() * self.xz())
                - self.xy() * operand.y() * self.s()
                - self.s() * operand.z() * self.xz()
                - self.xz() * operand.x() * self.xz()
                - self.xz() * operand.y() * self.yz()
                + self.yz() * operand.x() * self.yz()
                + self.s() * operand.x() * self.s()
                - self.s() * operand.y() * self.xy()
                + self.xy() * operand.z() * self.yz()
                + self.yz() * operand.z() * self.xy()
                - self.xy() * operand.x() * self.xy()
                - self.xz() * operand.z() * self.s())
                * inv_norm_sq,
            (-(self.s() * operand.z() * self.yz()) - self.xy() * operand.z() * self.xz()
                + self.s() * operand.y() * self.s()
                - self.xy() * operand.y() * self.xy()
                + self.xz() * operand.y() * self.xz()
                - self.xz() * operand.z() * self.xy()
                - self.yz() * operand.y() * self.yz()
                - self.yz() * operand.z() * self.s()
                + self.xy() * operand.x() * self.s()
                - self.xz() * operand.x() * self.yz()
                - self.yz() * operand.x() * self.xz()
                + self.s() * operand.x() * self.xy())
                * inv_norm_sq,
            (self.xy() * operand.z() * self.xy() - self.xz() * operand.y() * self.xy()
                + self.s() * operand.x() * self.xz()
                - self.xz() * operand.z() * self.xz()
                + self.xz() * operand.x() * self.s()
                + self.s() * operand.y() * self.yz()
                - self.yz() * operand.z() * self.yz()
                + self.s() * operand.z() * self.s()
                + self.xy() * operand.x() * self.yz()
                + self.yz() * operand.x() * self.xy()
                + self.yz() * operand.y() * self.s()
                - self.xy() * operand.y() * self.xz())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Pseudoscalar<T>> for Rotor<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (self.xy() * operand.xyz() * self.xy()
                + self.xz() * operand.xyz() * self.xz()
                + self.yz() * operand.xyz() * self.yz()
                + self.s() * operand.xyz() * self.s())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Rotor<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Rotor<T>) -> Option<Rotor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Rotor::new_unchecked(
            (self.yz() * operand.s() * self.yz() - self.yz() * operand.xz() * self.xy()
                + self.xy() * operand.xz() * self.yz()
                - self.xz() * operand.xy() * self.yz()
                + self.s() * operand.xy() * self.xy()
                + self.xy() * operand.s() * self.xy()
                - self.xy() * operand.yz() * self.xz()
                + self.s() * operand.s() * self.s()
                - self.xz() * operand.xz() * self.s()
                + self.xz() * operand.yz() * self.xy()
                + self.yz() * operand.xy() * self.xz()
                - self.yz() * operand.yz() * self.s()
                - self.xy() * operand.xy() * self.s()
                + self.s() * operand.xz() * self.xz()
                + self.s() * operand.yz() * self.yz()
                + self.xz() * operand.s() * self.xz())
                * inv_norm_sq,
            (self.xz() * operand.yz() * self.s() - self.s() * operand.xz() * self.yz()
                + self.s() * operand.yz() * self.xz()
                - self.xz() * operand.s() * self.yz()
                + self.xz() * operand.xz() * self.xy()
                - self.s() * operand.s() * self.xy()
                + self.xy() * operand.xy() * self.xy()
                + self.s() * operand.xy() * self.s()
                + self.xy() * operand.xz() * self.xz()
                - self.yz() * operand.xz() * self.s()
                + self.xy() * operand.s() * self.s()
                + self.xy() * operand.yz() * self.yz()
                - self.xz() * operand.xy() * self.xz()
                - self.yz() * operand.xy() * self.yz()
                + self.yz() * operand.s() * self.xz()
                + self.yz() * operand.yz() * self.xy())
                * inv_norm_sq,
            (self.xz() * operand.xy() * self.xy() - self.s() * operand.yz() * self.xy()
                + self.xy() * operand.xy() * self.xz()
                - self.yz() * operand.s() * self.xy()
                + self.xz() * operand.xz() * self.xz()
                + self.s() * operand.xz() * self.s()
                - self.xy() * operand.xz() * self.xy()
                + self.xy() * operand.s() * self.yz()
                + self.yz() * operand.xy() * self.s()
                - self.yz() * operand.xz() * self.yz()
                + self.xz() * operand.yz() * self.yz()
                + self.s() * operand.xy() * self.yz()
                - self.xy() * operand.yz() * self.s()
                + self.yz() * operand.yz() * self.xz()
                - self.s() * operand.s() * self.xz()
                + self.xz() * operand.s() * self.s())
                * inv_norm_sq,
            (self.yz() * operand.xz() * self.xz() + self.xz() * operand.s() * self.xy()
                - self.xy() * operand.s() * self.xz()
                + self.xy() * operand.xz() * self.s()
                - self.xy() * operand.yz() * self.xy()
                + self.yz() * operand.yz() * self.yz()
                - self.s() * operand.s() * self.yz()
                + self.s() * operand.xz() * self.xy()
                - self.xz() * operand.xy() * self.s()
                + self.yz() * operand.s() * self.s()
                + self.xy() * operand.xy() * self.yz()
                + self.xz() * operand.xz() * self.yz()
                - self.xz() * operand.yz() * self.xz()
                - self.s() * operand.xy() * self.xz()
                + self.s() * operand.yz() * self.s()
                + self.yz() * operand.xy() * self.xy())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Rotor<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.xz() * operand.s() * self.xz()
                + self.s() * operand.s() * self.s()
                + self.yz() * operand.s() * self.yz()
                + self.xy() * operand.s() * self.xy())
                * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Line<T>) -> Option<Line<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Line::new_unchecked(
            (self.s() * operand.xy() * self.s()) * inv_norm_sq,
            (self.s() * operand.xz() * self.s()) * inv_norm_sq,
            (self.s() * operand.yz() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Point<T>) -> Option<Point<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Point::new_unchecked(
            (self.s() * operand.x() * self.s()) * inv_norm_sq,
            (self.s() * operand.y() * self.s()) * inv_norm_sq,
            (self.s() * operand.z() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Pseudoscalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Pseudoscalar<T>) -> Option<Pseudoscalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Pseudoscalar::new_unchecked(
            (self.s() * operand.xyz() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Rotor<T>> for Scalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Rotor<T>) -> Option<Rotor<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Rotor::new_unchecked(
            (self.s() * operand.s() * self.s()) * inv_norm_sq,
            (self.s() * operand.xy() * self.s()) * inv_norm_sq,
            (self.s() * operand.xz() * self.s()) * inv_norm_sq,
            (self.s() * operand.yz() * self.s()) * inv_norm_sq,
        ))
    }
}
#[allow(unused_variables)]
impl<T: Float> InverseAntisandwich<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn try_inverse_antisandwich(&self, operand: &Scalar<T>) -> Option<Scalar<T>> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Scalar::new_unchecked(
            (self.s() * operand.s() * self.s()) * inv_norm_sq,
        ))
    }
}
impl<T: Float> Versor<Line<T>> for Line<T> {
    type Output = Rotor<T>;
    #[inline]
    fn compose(&self, other: &Line<T>) -> Rotor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Pseudoscalar<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn compose(&self, other: &Pseudoscalar<T>) -> Point<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Rotor<T>> for Line<T> {
    type Output = Rotor<T>;
    #[inline]
    fn compose(&self, other: &Rotor<T>) -> Rotor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Line<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Point<T>> for Point<T> {
    type Output = Rotor<T>;
    #[inline]
    fn compose(&self, other: &Point<T>) -> Rotor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Pseudoscalar<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn compose(&self, other: &Pseudoscalar<T>) -> Line<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Point<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Line<T>> for Pseudoscalar<T> {
    type Output = Point<T>;
    #[inline]
    fn compose(&self, other: &Line<T>) -> Point<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Point<T>> for Pseudoscalar<T> {
    type Output = Line<T>;
    #[inline]
    fn compose(&self, other: &Point<T>) -> Line<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn compose(&self, other: &Pseudoscalar<T>) -> Scalar<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Pseudoscalar<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Line<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn compose(&self, other: &Line<T>) -> Rotor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Rotor<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn compose(&self, other: &Rotor<T>) -> Rotor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Rotor<T> {
    type Output = Rotor<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Rotor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Line<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn compose(&self, other: &Line<T>) -> Line<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Point<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn compose(&self, other: &Point<T>) -> Point<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Pseudoscalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn compose(&self, other: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Rotor<T>> for Scalar<T> {
    type Output = Rotor<T>;
    #[inline]
    fn compose(&self, other: &Rotor<T>) -> Rotor<T> {
        *self * *other
    }
}
impl<T: Float> Versor<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn compose(&self, other: &Scalar<T>) -> Scalar<T> {
        *self * *other
    }
}
impl<T: Float> ScalarProduct<Line<T>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Line<T>) -> T {
        -(self.xy() * rhs.xy()) - self.xz() * rhs.xz() - self.yz() * rhs.yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Line<T>> for Unit<Line<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Line<T>) -> T {
        -(self.as_inner().xy() * rhs.xy())
            + -(self.as_inner().xz() * rhs.xz())
            + -(self.as_inner().yz() * rhs.yz())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Line<T>>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Line<T>>) -> T {
        -(self.xy() * rhs.as_inner().xy())
            + -(self.xz() * rhs.as_inner().xz())
            + -(self.yz() * rhs.as_inner().yz())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Line<T>>> for Unit<Line<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Line<T>>) -> T {
        -(self.as_inner().xy() * rhs.as_inner().xy())
            + -(self.as_inner().xz() * rhs.as_inner().xz())
            + -(self.as_inner().yz() * rhs.as_inner().yz())
    }
}
impl<T: Float> ScalarProduct<Point<T>> for Point<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Point<T>) -> T {
        self.x() * rhs.x() + self.y() * rhs.y() + self.z() * rhs.z()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Point<T>> for Unit<Point<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Point<T>) -> T {
        self.as_inner().x() * rhs.x()
            + self.as_inner().y() * rhs.y()
            + self.as_inner().z() * rhs.z()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Point<T>>> for Point<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Point<T>>) -> T {
        self.x() * rhs.as_inner().x()
            + self.y() * rhs.as_inner().y()
            + self.z() * rhs.as_inner().z()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Point<T>>> for Unit<Point<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Point<T>>) -> T {
        self.as_inner().x() * rhs.as_inner().x()
            + self.as_inner().y() * rhs.as_inner().y()
            + self.as_inner().z() * rhs.as_inner().z()
    }
}
impl<T: Float> ScalarProduct<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Pseudoscalar<T>) -> T {
        -(self.xyz() * rhs.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Pseudoscalar<T>) -> T {
        -(self.as_inner().xyz() * rhs.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Pseudoscalar<T>>) -> T {
        -(self.xyz() * rhs.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Pseudoscalar<T>>) -> T {
        -(self.as_inner().xyz() * rhs.as_inner().xyz())
    }
}
impl<T: Float> ScalarProduct<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Scalar<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Scalar<T>) -> T {
        self.as_inner().s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Scalar<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.s() * rhs.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> ScalarProduct<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn scalar_product(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
    }
}
impl<T: Float> BulkContract<Line<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.xy() * rhs.xy() + self.xz() * rhs.xz() + self.yz() * rhs.yz())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Line<T>> for Unit<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.as_inner().xy() * rhs.xy()
                + self.as_inner().xz() * rhs.xz()
                + self.as_inner().yz() * rhs.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Line<T>>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.xy() * rhs.as_inner().xy()
                + self.xz() * rhs.as_inner().xz()
                + self.yz() * rhs.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Line<T>>> for Unit<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.as_inner().xy() * rhs.as_inner().xy()
                + self.as_inner().xz() * rhs.as_inner().xz()
                + self.as_inner().yz() * rhs.as_inner().yz(),
        )
    }
}
impl<T: Float> BulkContract<Point<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.y() * self.xy()) + -(rhs.z() * self.xz()),
            rhs.x() * self.xy() + -(rhs.z() * self.yz()),
            rhs.x() * self.xz() + rhs.y() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Point<T>> for Unit<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.y() * self.as_inner().xy()) + -(rhs.z() * self.as_inner().xz()),
            rhs.x() * self.as_inner().xy() + -(rhs.z() * self.as_inner().yz()),
            rhs.x() * self.as_inner().xz() + rhs.y() * self.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Point<T>>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().y() * self.xy()) + -(rhs.as_inner().z() * self.xz()),
            rhs.as_inner().x() * self.xy() + -(rhs.as_inner().z() * self.yz()),
            rhs.as_inner().x() * self.xz() + rhs.as_inner().y() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Point<T>>> for Unit<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            -(rhs.as_inner().y() * self.as_inner().xy())
                + -(rhs.as_inner().z() * self.as_inner().xz()),
            rhs.as_inner().x() * self.as_inner().xy()
                + -(rhs.as_inner().z() * self.as_inner().yz()),
            rhs.as_inner().x() * self.as_inner().xz() + rhs.as_inner().y() * self.as_inner().yz(),
        )
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.s() * self.xy(),
            rhs.s() * self.xz(),
            rhs.s() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.s() * self.as_inner().xy(),
            rhs.s() * self.as_inner().xz(),
            rhs.s() * self.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().s() * self.xy(),
            rhs.as_inner().s() * self.xz(),
            rhs.as_inner().s() * self.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().s() * self.as_inner().xy(),
            rhs.as_inner().s() * self.as_inner().xz(),
            rhs.as_inner().s() * self.as_inner().yz(),
        )
    }
}
impl<T: Float> BulkContract<Point<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.x() * rhs.x() + self.y() * rhs.y() + self.z() * rhs.z())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Point<T>> for Unit<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.as_inner().x() * rhs.x()
                + self.as_inner().y() * rhs.y()
                + self.as_inner().z() * rhs.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Point<T>>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.x() * rhs.as_inner().x()
                + self.y() * rhs.as_inner().y()
                + self.z() * rhs.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Point<T>>> for Unit<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            self.as_inner().x() * rhs.as_inner().x()
                + self.as_inner().y() * rhs.as_inner().y()
                + self.as_inner().z() * rhs.as_inner().z(),
        )
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Point<T> {
        Point::new_unchecked(self.x() * rhs.s(), self.y() * rhs.s(), rhs.s() * self.z())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().x() * rhs.s(),
            self.as_inner().y() * rhs.s(),
            rhs.s() * self.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Point<T> {
        Point::new_unchecked(
            self.x() * rhs.as_inner().s(),
            self.y() * rhs.as_inner().s(),
            rhs.as_inner().s() * self.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().x() * rhs.as_inner().s(),
            self.as_inner().y() * rhs.as_inner().s(),
            rhs.as_inner().s() * self.as_inner().z(),
        )
    }
}
impl<T: Float> BulkContract<Line<T>> for Pseudoscalar<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            self.xyz() * rhs.yz(),
            -(self.xyz() * rhs.xz()),
            self.xyz() * rhs.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Line<T>> for Unit<Pseudoscalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().xyz() * rhs.yz(),
            -(self.as_inner().xyz() * rhs.xz()),
            self.as_inner().xyz() * rhs.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Line<T>>> for Pseudoscalar<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            self.xyz() * rhs.as_inner().yz(),
            -(self.xyz() * rhs.as_inner().xz()),
            self.xyz() * rhs.as_inner().xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Line<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().xyz() * rhs.as_inner().yz(),
            -(self.as_inner().xyz() * rhs.as_inner().xz()),
            self.as_inner().xyz() * rhs.as_inner().xy(),
        )
    }
}
impl<T: Float> BulkContract<Point<T>> for Pseudoscalar<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.z() * self.xyz(),
            -(rhs.y() * self.xyz()),
            rhs.x() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Point<T>> for Unit<Pseudoscalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            rhs.z() * self.as_inner().xyz(),
            -(rhs.y() * self.as_inner().xyz()),
            rhs.x() * self.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Point<T>>> for Pseudoscalar<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().z() * self.xyz(),
            -(rhs.as_inner().y() * self.xyz()),
            rhs.as_inner().x() * self.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Point<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            rhs.as_inner().z() * self.as_inner().xyz(),
            -(rhs.as_inner().y() * self.as_inner().xyz()),
            rhs.as_inner().x() * self.as_inner().xyz(),
        )
    }
}
impl<T: Float> BulkContract<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.xyz() * rhs.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().xyz() * rhs.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.xyz() * rhs.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().xyz() * rhs.as_inner().xyz())
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.s() * self.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.s() * self.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().s() * self.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(rhs.as_inner().s() * self.as_inner().xyz())
    }
}
impl<T: Float> BulkContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkContract<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.as_inner().s())
    }
}
impl<T: Float> WeightContract<Line<T>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.xy() * rhs.xy()) + -(self.xz() * rhs.xz()) + -(self.yz() * rhs.yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Line<T>> for Unit<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Line<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.as_inner().xy() * rhs.xy())
                + -(self.as_inner().xz() * rhs.xz())
                + -(self.as_inner().yz() * rhs.yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Line<T>>> for Line<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.xy() * rhs.as_inner().xy())
                + -(self.xz() * rhs.as_inner().xz())
                + -(self.yz() * rhs.as_inner().yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Line<T>>> for Unit<Line<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Line<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.as_inner().xy() * rhs.as_inner().xy())
                + -(self.as_inner().xz() * rhs.as_inner().xz())
                + -(self.as_inner().yz() * rhs.as_inner().yz()),
        )
    }
}
impl<T: Float> WeightContract<Point<T>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.y() * self.xy() + rhs.z() * self.xz(),
            -(rhs.x() * self.xy()) + rhs.z() * self.yz(),
            -(rhs.x() * self.xz()) + -(rhs.y() * self.yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Point<T>> for Unit<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Point<T>) -> Point<T> {
        Point::new_unchecked(
            rhs.y() * self.as_inner().xy() + rhs.z() * self.as_inner().xz(),
            -(rhs.x() * self.as_inner().xy()) + rhs.z() * self.as_inner().yz(),
            -(rhs.x() * self.as_inner().xz()) + -(rhs.y() * self.as_inner().yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Point<T>>> for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            rhs.as_inner().y() * self.xy() + rhs.as_inner().z() * self.xz(),
            -(rhs.as_inner().x() * self.xy()) + rhs.as_inner().z() * self.yz(),
            -(rhs.as_inner().x() * self.xz()) + -(rhs.as_inner().y() * self.yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Point<T>>> for Unit<Line<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Point<T>>) -> Point<T> {
        Point::new_unchecked(
            rhs.as_inner().y() * self.as_inner().xy() + rhs.as_inner().z() * self.as_inner().xz(),
            -(rhs.as_inner().x() * self.as_inner().xy())
                + rhs.as_inner().z() * self.as_inner().yz(),
            -(rhs.as_inner().x() * self.as_inner().xz())
                + -(rhs.as_inner().y() * self.as_inner().yz()),
        )
    }
}
impl<T: Float> WeightContract<Scalar<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Line<T> {
        Line::new_unchecked(
            -(rhs.s() * self.xy()),
            -(rhs.s() * self.xz()),
            -(rhs.s() * self.yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Scalar<T>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Line<T> {
        Line::new_unchecked(
            -(rhs.s() * self.as_inner().xy()),
            -(rhs.s() * self.as_inner().xz()),
            -(rhs.s() * self.as_inner().yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Line<T> {
        Line::new_unchecked(
            -(rhs.as_inner().s() * self.xy()),
            -(rhs.as_inner().s() * self.xz()),
            -(rhs.as_inner().s() * self.yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Line<T> {
        Line::new_unchecked(
            -(rhs.as_inner().s() * self.as_inner().xy()),
            -(rhs.as_inner().s() * self.as_inner().xz()),
            -(rhs.as_inner().s() * self.as_inner().yz()),
        )
    }
}
impl<T: Float> WeightContract<Point<T>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.x() * rhs.x()) + -(self.y() * rhs.y()) + -(self.z() * rhs.z()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Point<T>> for Unit<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Point<T>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.as_inner().x() * rhs.x())
                + -(self.as_inner().y() * rhs.y())
                + -(self.as_inner().z() * rhs.z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Point<T>>> for Point<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.x() * rhs.as_inner().x())
                + -(self.y() * rhs.as_inner().y())
                + -(self.z() * rhs.as_inner().z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Point<T>>> for Unit<Point<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Point<T>>) -> Scalar<T> {
        Scalar::new_unchecked(
            -(self.as_inner().x() * rhs.as_inner().x())
                + -(self.as_inner().y() * rhs.as_inner().y())
                + -(self.as_inner().z() * rhs.as_inner().z()),
        )
    }
}
impl<T: Float> WeightContract<Scalar<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.x() * rhs.s()),
            -(self.y() * rhs.s()),
            -(rhs.s() * self.z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Scalar<T>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.as_inner().x() * rhs.s()),
            -(self.as_inner().y() * rhs.s()),
            -(rhs.s() * self.as_inner().z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Point<T> {
        Point::new_unchecked(
            -(self.x() * rhs.as_inner().s()),
            -(self.y() * rhs.as_inner().s()),
            -(rhs.as_inner().s() * self.z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Point<T> {
        Point::new_unchecked(
            -(self.as_inner().x() * rhs.as_inner().s()),
            -(self.as_inner().y() * rhs.as_inner().s()),
            -(rhs.as_inner().s() * self.as_inner().z()),
        )
    }
}
impl<T: Float> WeightContract<Line<T>> for Pseudoscalar<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.xyz() * rhs.yz()),
            self.xyz() * rhs.xz(),
            -(self.xyz() * rhs.xy()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Line<T>> for Unit<Pseudoscalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.as_inner().xyz() * rhs.yz()),
            self.as_inner().xyz() * rhs.xz(),
            -(self.as_inner().xyz() * rhs.xy()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Line<T>>> for Pseudoscalar<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            -(self.xyz() * rhs.as_inner().yz()),
            self.xyz() * rhs.as_inner().xz(),
            -(self.xyz() * rhs.as_inner().xy()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Line<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            -(self.as_inner().xyz() * rhs.as_inner().yz()),
            self.as_inner().xyz() * rhs.as_inner().xz(),
            -(self.as_inner().xyz() * rhs.as_inner().xy()),
        )
    }
}
impl<T: Float> WeightContract<Point<T>> for Pseudoscalar<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            -(rhs.z() * self.xyz()),
            rhs.y() * self.xyz(),
            -(rhs.x() * self.xyz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Point<T>> for Unit<Pseudoscalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            -(rhs.z() * self.as_inner().xyz()),
            rhs.y() * self.as_inner().xyz(),
            -(rhs.x() * self.as_inner().xyz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Point<T>>> for Pseudoscalar<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            -(rhs.as_inner().z() * self.xyz()),
            rhs.as_inner().y() * self.xyz(),
            -(rhs.as_inner().x() * self.xyz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Point<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            -(rhs.as_inner().z() * self.as_inner().xyz()),
            rhs.as_inner().y() * self.as_inner().xyz(),
            -(rhs.as_inner().x() * self.as_inner().xyz()),
        )
    }
}
impl<T: Float> WeightContract<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.xyz() * rhs.xyz()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().xyz() * rhs.xyz()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.xyz() * rhs.as_inner().xyz()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().xyz() * rhs.as_inner().xyz()))
    }
}
impl<T: Float> WeightContract<Scalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(rhs.s() * self.xyz()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Scalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(rhs.s() * self.as_inner().xyz()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(rhs.as_inner().s() * self.xyz()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(rhs.as_inner().s() * self.as_inner().xyz()))
    }
}
impl<T: Float> WeightContract<Scalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.s() * rhs.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Scalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().s() * rhs.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.s() * rhs.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightContract<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_contract(&self, rhs: &Unit<Scalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().s() * rhs.as_inner().s()))
    }
}
impl<T: Float> BulkExpand<Line<T>> for Line<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Line<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.xy() * rhs.xy() + self.xz() * rhs.xz() + self.yz() * rhs.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Line<T>> for Unit<Line<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Line<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.as_inner().xy() * rhs.xy()
                + self.as_inner().xz() * rhs.xz()
                + self.as_inner().yz() * rhs.yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Line<T>>> for Line<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Line<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.xy() * rhs.as_inner().xy()
                + self.xz() * rhs.as_inner().xz()
                + self.yz() * rhs.as_inner().yz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Line<T>>> for Unit<Line<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Line<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.as_inner().xy() * rhs.as_inner().xy()
                + self.as_inner().xz() * rhs.as_inner().xz()
                + self.as_inner().yz() * rhs.as_inner().yz(),
        )
    }
}
impl<T: Float> BulkExpand<Pseudoscalar<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Pseudoscalar<T>) -> Line<T> {
        Line::new_unchecked(
            self.xy() * rhs.xyz(),
            self.xz() * rhs.xyz(),
            self.yz() * rhs.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Pseudoscalar<T>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Pseudoscalar<T>) -> Line<T> {
        Line::new_unchecked(
            self.as_inner().xy() * rhs.xyz(),
            self.as_inner().xz() * rhs.xyz(),
            self.as_inner().yz() * rhs.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Pseudoscalar<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Line<T> {
        Line::new_unchecked(
            self.xy() * rhs.as_inner().xyz(),
            self.xz() * rhs.as_inner().xyz(),
            self.yz() * rhs.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Pseudoscalar<T>>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Line<T> {
        Line::new_unchecked(
            self.as_inner().xy() * rhs.as_inner().xyz(),
            self.as_inner().xz() * rhs.as_inner().xyz(),
            self.as_inner().yz() * rhs.as_inner().xyz(),
        )
    }
}
impl<T: Float> BulkExpand<Line<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            -(self.x() * rhs.xz()) + -(self.y() * rhs.yz()),
            self.x() * rhs.xy() + -(self.z() * rhs.yz()),
            self.y() * rhs.xy() + self.z() * rhs.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Line<T>> for Unit<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            -(self.as_inner().x() * rhs.xz()) + -(self.as_inner().y() * rhs.yz()),
            self.as_inner().x() * rhs.xy() + -(self.as_inner().z() * rhs.yz()),
            self.as_inner().y() * rhs.xy() + self.as_inner().z() * rhs.xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Line<T>>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(self.x() * rhs.as_inner().xz()) + -(self.y() * rhs.as_inner().yz()),
            self.x() * rhs.as_inner().xy() + -(self.z() * rhs.as_inner().yz()),
            self.y() * rhs.as_inner().xy() + self.z() * rhs.as_inner().xz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Line<T>>> for Unit<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            -(self.as_inner().x() * rhs.as_inner().xz())
                + -(self.as_inner().y() * rhs.as_inner().yz()),
            self.as_inner().x() * rhs.as_inner().xy()
                + -(self.as_inner().z() * rhs.as_inner().yz()),
            self.as_inner().y() * rhs.as_inner().xy() + self.as_inner().z() * rhs.as_inner().xz(),
        )
    }
}
impl<T: Float> BulkExpand<Point<T>> for Point<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Point<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.x() * rhs.x() + self.y() * rhs.y() + self.z() * rhs.z())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Point<T>> for Unit<Point<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Point<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.as_inner().x() * rhs.x()
                + self.as_inner().y() * rhs.y()
                + self.as_inner().z() * rhs.z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Point<T>>> for Point<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Point<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.x() * rhs.as_inner().x()
                + self.y() * rhs.as_inner().y()
                + self.z() * rhs.as_inner().z(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Point<T>>> for Unit<Point<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Point<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            self.as_inner().x() * rhs.as_inner().x()
                + self.as_inner().y() * rhs.as_inner().y()
                + self.as_inner().z() * rhs.as_inner().z(),
        )
    }
}
impl<T: Float> BulkExpand<Pseudoscalar<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Pseudoscalar<T>) -> Point<T> {
        Point::new_unchecked(
            self.x() * rhs.xyz(),
            self.y() * rhs.xyz(),
            self.z() * rhs.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Pseudoscalar<T>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Pseudoscalar<T>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().x() * rhs.xyz(),
            self.as_inner().y() * rhs.xyz(),
            self.as_inner().z() * rhs.xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Pseudoscalar<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Point<T> {
        Point::new_unchecked(
            self.x() * rhs.as_inner().xyz(),
            self.y() * rhs.as_inner().xyz(),
            self.z() * rhs.as_inner().xyz(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Pseudoscalar<T>>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().x() * rhs.as_inner().xyz(),
            self.as_inner().y() * rhs.as_inner().xyz(),
            self.as_inner().z() * rhs.as_inner().xyz(),
        )
    }
}
impl<T: Float> BulkExpand<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.xyz() * rhs.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.as_inner().xyz() * rhs.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.xyz() * rhs.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.as_inner().xyz() * rhs.as_inner().xyz())
    }
}
impl<T: Float> BulkExpand<Line<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            self.s() * rhs.yz(),
            -(self.s() * rhs.xz()),
            self.s() * rhs.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Line<T>> for Unit<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().s() * rhs.yz(),
            -(self.as_inner().s() * rhs.xz()),
            self.as_inner().s() * rhs.xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Line<T>>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            self.s() * rhs.as_inner().yz(),
            -(self.s() * rhs.as_inner().xz()),
            self.s() * rhs.as_inner().xy(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Line<T>>> for Unit<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            self.as_inner().s() * rhs.as_inner().yz(),
            -(self.as_inner().s() * rhs.as_inner().xz()),
            self.as_inner().s() * rhs.as_inner().xy(),
        )
    }
}
impl<T: Float> BulkExpand<Point<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            self.s() * rhs.z(),
            -(self.s() * rhs.y()),
            self.s() * rhs.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Point<T>> for Unit<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            self.as_inner().s() * rhs.z(),
            -(self.as_inner().s() * rhs.y()),
            self.as_inner().s() * rhs.x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Point<T>>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            self.s() * rhs.as_inner().z(),
            -(self.s() * rhs.as_inner().y()),
            self.s() * rhs.as_inner().x(),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Point<T>>> for Unit<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            self.as_inner().s() * rhs.as_inner().z(),
            -(self.as_inner().s() * rhs.as_inner().y()),
            self.as_inner().s() * rhs.as_inner().x(),
        )
    }
}
impl<T: Float> BulkExpand<Pseudoscalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Pseudoscalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Pseudoscalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.s() * rhs.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Pseudoscalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(self.as_inner().s() * rhs.as_inner().xyz())
    }
}
impl<T: Float> BulkExpand<Scalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> BulkExpand<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn bulk_expand(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.as_inner().s() * rhs.as_inner().s())
    }
}
impl<T: Float> WeightExpand<Line<T>> for Line<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Line<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(self.xy() * rhs.xy()) + -(self.xz() * rhs.xz()) + -(self.yz() * rhs.yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Line<T>> for Unit<Line<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Line<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(self.as_inner().xy() * rhs.xy())
                + -(self.as_inner().xz() * rhs.xz())
                + -(self.as_inner().yz() * rhs.yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Line<T>>> for Line<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Line<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(self.xy() * rhs.as_inner().xy())
                + -(self.xz() * rhs.as_inner().xz())
                + -(self.yz() * rhs.as_inner().yz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Line<T>>> for Unit<Line<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Line<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(self.as_inner().xy() * rhs.as_inner().xy())
                + -(self.as_inner().xz() * rhs.as_inner().xz())
                + -(self.as_inner().yz() * rhs.as_inner().yz()),
        )
    }
}
impl<T: Float> WeightExpand<Pseudoscalar<T>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Pseudoscalar<T>) -> Line<T> {
        Line::new_unchecked(
            -(self.xy() * rhs.xyz()),
            -(self.xz() * rhs.xyz()),
            -(self.yz() * rhs.xyz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Pseudoscalar<T>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Pseudoscalar<T>) -> Line<T> {
        Line::new_unchecked(
            -(self.as_inner().xy() * rhs.xyz()),
            -(self.as_inner().xz() * rhs.xyz()),
            -(self.as_inner().yz() * rhs.xyz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Pseudoscalar<T>>> for Line<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Line<T> {
        Line::new_unchecked(
            -(self.xy() * rhs.as_inner().xyz()),
            -(self.xz() * rhs.as_inner().xyz()),
            -(self.yz() * rhs.as_inner().xyz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Pseudoscalar<T>>> for Unit<Line<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Line<T> {
        Line::new_unchecked(
            -(self.as_inner().xy() * rhs.as_inner().xyz()),
            -(self.as_inner().xz() * rhs.as_inner().xyz()),
            -(self.as_inner().yz() * rhs.as_inner().xyz()),
        )
    }
}
impl<T: Float> WeightExpand<Line<T>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.x() * rhs.xz() + self.y() * rhs.yz(),
            -(self.x() * rhs.xy()) + self.z() * rhs.yz(),
            -(self.y() * rhs.xy()) + -(self.z() * rhs.xz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Line<T>> for Unit<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Line<T>) -> Line<T> {
        Line::new_unchecked(
            self.as_inner().x() * rhs.xz() + self.as_inner().y() * rhs.yz(),
            -(self.as_inner().x() * rhs.xy()) + self.as_inner().z() * rhs.yz(),
            -(self.as_inner().y() * rhs.xy()) + -(self.as_inner().z() * rhs.xz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Line<T>>> for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            self.x() * rhs.as_inner().xz() + self.y() * rhs.as_inner().yz(),
            -(self.x() * rhs.as_inner().xy()) + self.z() * rhs.as_inner().yz(),
            -(self.y() * rhs.as_inner().xy()) + -(self.z() * rhs.as_inner().xz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Line<T>>> for Unit<Point<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Line<T>>) -> Line<T> {
        Line::new_unchecked(
            self.as_inner().x() * rhs.as_inner().xz() + self.as_inner().y() * rhs.as_inner().yz(),
            -(self.as_inner().x() * rhs.as_inner().xy())
                + self.as_inner().z() * rhs.as_inner().yz(),
            -(self.as_inner().y() * rhs.as_inner().xy())
                + -(self.as_inner().z() * rhs.as_inner().xz()),
        )
    }
}
impl<T: Float> WeightExpand<Point<T>> for Point<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Point<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(self.x() * rhs.x()) + -(self.y() * rhs.y()) + -(self.z() * rhs.z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Point<T>> for Unit<Point<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Point<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(self.as_inner().x() * rhs.x())
                + -(self.as_inner().y() * rhs.y())
                + -(self.as_inner().z() * rhs.z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Point<T>>> for Point<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Point<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(self.x() * rhs.as_inner().x())
                + -(self.y() * rhs.as_inner().y())
                + -(self.z() * rhs.as_inner().z()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Point<T>>> for Unit<Point<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Point<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(
            -(self.as_inner().x() * rhs.as_inner().x())
                + -(self.as_inner().y() * rhs.as_inner().y())
                + -(self.as_inner().z() * rhs.as_inner().z()),
        )
    }
}
impl<T: Float> WeightExpand<Pseudoscalar<T>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Pseudoscalar<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.x() * rhs.xyz()),
            -(self.y() * rhs.xyz()),
            -(self.z() * rhs.xyz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Pseudoscalar<T>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Pseudoscalar<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.as_inner().x() * rhs.xyz()),
            -(self.as_inner().y() * rhs.xyz()),
            -(self.as_inner().z() * rhs.xyz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Pseudoscalar<T>>> for Point<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Point<T> {
        Point::new_unchecked(
            -(self.x() * rhs.as_inner().xyz()),
            -(self.y() * rhs.as_inner().xyz()),
            -(self.z() * rhs.as_inner().xyz()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Pseudoscalar<T>>> for Unit<Point<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Point<T> {
        Point::new_unchecked(
            -(self.as_inner().x() * rhs.as_inner().xyz()),
            -(self.as_inner().y() * rhs.as_inner().xyz()),
            -(self.as_inner().z() * rhs.as_inner().xyz()),
        )
    }
}
impl<T: Float> WeightExpand<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(self.xyz() * rhs.xyz()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Pseudoscalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(self.as_inner().xyz() * rhs.xyz()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(self.xyz() * rhs.as_inner().xyz()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(self.as_inner().xyz() * rhs.as_inner().xyz()))
    }
}
impl<T: Float> WeightExpand<Line<T>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.s() * rhs.yz()),
            self.s() * rhs.xz(),
            -(self.s() * rhs.xy()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Line<T>> for Unit<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Line<T>) -> Point<T> {
        Point::new_unchecked(
            -(self.as_inner().s() * rhs.yz()),
            self.as_inner().s() * rhs.xz(),
            -(self.as_inner().s() * rhs.xy()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Line<T>>> for Scalar<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            -(self.s() * rhs.as_inner().yz()),
            self.s() * rhs.as_inner().xz(),
            -(self.s() * rhs.as_inner().xy()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Line<T>>> for Unit<Scalar<T>> {
    type Output = Point<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Line<T>>) -> Point<T> {
        Point::new_unchecked(
            -(self.as_inner().s() * rhs.as_inner().yz()),
            self.as_inner().s() * rhs.as_inner().xz(),
            -(self.as_inner().s() * rhs.as_inner().xy()),
        )
    }
}
impl<T: Float> WeightExpand<Point<T>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            -(self.s() * rhs.z()),
            self.s() * rhs.y(),
            -(self.s() * rhs.x()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Point<T>> for Unit<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Point<T>) -> Line<T> {
        Line::new_unchecked(
            -(self.as_inner().s() * rhs.z()),
            self.as_inner().s() * rhs.y(),
            -(self.as_inner().s() * rhs.x()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Point<T>>> for Scalar<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            -(self.s() * rhs.as_inner().z()),
            self.s() * rhs.as_inner().y(),
            -(self.s() * rhs.as_inner().x()),
        )
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Point<T>>> for Unit<Scalar<T>> {
    type Output = Line<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Point<T>>) -> Line<T> {
        Line::new_unchecked(
            -(self.as_inner().s() * rhs.as_inner().z()),
            self.as_inner().s() * rhs.as_inner().y(),
            -(self.as_inner().s() * rhs.as_inner().x()),
        )
    }
}
impl<T: Float> WeightExpand<Pseudoscalar<T>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.s() * rhs.xyz()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Pseudoscalar<T>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Pseudoscalar<T>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().s() * rhs.xyz()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Pseudoscalar<T>>> for Scalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.s() * rhs.as_inner().xyz()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Pseudoscalar<T>>> for Unit<Scalar<T>> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Pseudoscalar<T>>) -> Scalar<T> {
        Scalar::new_unchecked(-(self.as_inner().s() * rhs.as_inner().xyz()))
    }
}
impl<T: Float> WeightExpand<Scalar<T>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(self.s() * rhs.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Scalar<T>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Scalar<T>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(self.as_inner().s() * rhs.s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Scalar<T>>> for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(self.s() * rhs.as_inner().s()))
    }
}
#[allow(unused_variables)]
impl<T: Float> WeightExpand<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_expand(&self, rhs: &Unit<Scalar<T>>) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-(self.as_inner().s() * rhs.as_inner().s()))
    }
}
impl<T: Float> Dot<Line<T>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Line<T>) -> T {
        -(self.xy() * rhs.xy()) - self.xz() * rhs.xz() - self.yz() * rhs.yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Line<T>> for Unit<Line<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Line<T>) -> T {
        -(self.as_inner().xy() * rhs.xy())
            + -(self.as_inner().xz() * rhs.xz())
            + -(self.as_inner().yz() * rhs.yz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Line<T>>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Line<T>>) -> T {
        -(self.xy() * rhs.as_inner().xy())
            + -(self.xz() * rhs.as_inner().xz())
            + -(self.yz() * rhs.as_inner().yz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Line<T>>> for Unit<Line<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Line<T>>) -> T {
        -(self.as_inner().xy() * rhs.as_inner().xy())
            + -(self.as_inner().xz() * rhs.as_inner().xz())
            + -(self.as_inner().yz() * rhs.as_inner().yz())
    }
}
impl<T: Float> Dot<Rotor<T>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Rotor<T>) -> T {
        -(self.xy() * rhs.xy()) - self.xz() * rhs.xz() - self.yz() * rhs.yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Rotor<T>> for Unit<Line<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Rotor<T>) -> T {
        -(self.as_inner().xy() * rhs.xy())
            + -(self.as_inner().xz() * rhs.xz())
            + -(self.as_inner().yz() * rhs.yz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Rotor<T>>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Rotor<T>>) -> T {
        -(self.xy() * rhs.as_inner().xy())
            + -(self.xz() * rhs.as_inner().xz())
            + -(self.yz() * rhs.as_inner().yz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Rotor<T>>> for Unit<Line<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Rotor<T>>) -> T {
        -(self.as_inner().xy() * rhs.as_inner().xy())
            + -(self.as_inner().xz() * rhs.as_inner().xz())
            + -(self.as_inner().yz() * rhs.as_inner().yz())
    }
}
impl<T: Float> Dot<Point<T>> for Point<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Point<T>) -> T {
        self.x() * rhs.x() + self.y() * rhs.y() + self.z() * rhs.z()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Point<T>> for Unit<Point<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Point<T>) -> T {
        self.as_inner().x() * rhs.x()
            + self.as_inner().y() * rhs.y()
            + self.as_inner().z() * rhs.z()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Point<T>>> for Point<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Point<T>>) -> T {
        self.x() * rhs.as_inner().x()
            + self.y() * rhs.as_inner().y()
            + self.z() * rhs.as_inner().z()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Point<T>>> for Unit<Point<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Point<T>>) -> T {
        self.as_inner().x() * rhs.as_inner().x()
            + self.as_inner().y() * rhs.as_inner().y()
            + self.as_inner().z() * rhs.as_inner().z()
    }
}
impl<T: Float> Dot<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Pseudoscalar<T>) -> T {
        -(self.xyz() * rhs.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Pseudoscalar<T>) -> T {
        -(self.as_inner().xyz() * rhs.xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Pseudoscalar<T>>) -> T {
        -(self.xyz() * rhs.as_inner().xyz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Pseudoscalar<T>>) -> T {
        -(self.as_inner().xyz() * rhs.as_inner().xyz())
    }
}
impl<T: Float> Dot<Line<T>> for Rotor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Line<T>) -> T {
        -(self.xy() * rhs.xy()) - self.xz() * rhs.xz() - self.yz() * rhs.yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Line<T>> for Unit<Rotor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Line<T>) -> T {
        -(self.as_inner().xy() * rhs.xy())
            + -(self.as_inner().xz() * rhs.xz())
            + -(self.as_inner().yz() * rhs.yz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Line<T>>> for Rotor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Line<T>>) -> T {
        -(self.xy() * rhs.as_inner().xy())
            + -(self.xz() * rhs.as_inner().xz())
            + -(self.yz() * rhs.as_inner().yz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Line<T>>> for Unit<Rotor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Line<T>>) -> T {
        -(self.as_inner().xy() * rhs.as_inner().xy())
            + -(self.as_inner().xz() * rhs.as_inner().xz())
            + -(self.as_inner().yz() * rhs.as_inner().yz())
    }
}
impl<T: Float> Dot<Rotor<T>> for Rotor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Rotor<T>) -> T {
        self.s() * rhs.s() - self.xy() * rhs.xy() - self.xz() * rhs.xz() - self.yz() * rhs.yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Rotor<T>> for Unit<Rotor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Rotor<T>) -> T {
        self.as_inner().s() * rhs.s()
            + -(self.as_inner().xy() * rhs.xy())
            + -(self.as_inner().xz() * rhs.xz())
            + -(self.as_inner().yz() * rhs.yz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Rotor<T>>> for Rotor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Rotor<T>>) -> T {
        self.s() * rhs.as_inner().s()
            + -(self.xy() * rhs.as_inner().xy())
            + -(self.xz() * rhs.as_inner().xz())
            + -(self.yz() * rhs.as_inner().yz())
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Rotor<T>>> for Unit<Rotor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Rotor<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
            + -(self.as_inner().xy() * rhs.as_inner().xy())
            + -(self.as_inner().xz() * rhs.as_inner().xz())
            + -(self.as_inner().yz() * rhs.as_inner().yz())
    }
}
impl<T: Float> Dot<Scalar<T>> for Rotor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Scalar<T>> for Unit<Rotor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.as_inner().s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Scalar<T>>> for Rotor<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.s() * rhs.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Scalar<T>>> for Unit<Rotor<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
    }
}
impl<T: Float> Dot<Rotor<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Rotor<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Rotor<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Rotor<T>) -> T {
        self.as_inner().s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Rotor<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Rotor<T>>) -> T {
        self.s() * rhs.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Rotor<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Rotor<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
    }
}
impl<T: Float> Dot<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Scalar<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Scalar<T>) -> T {
        self.as_inner().s() * rhs.s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Scalar<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.s() * rhs.as_inner().s()
    }
}
#[allow(unused_variables)]
impl<T: Float> Dot<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn dot(&self, rhs: &Unit<Scalar<T>>) -> T {
        self.as_inner().s() * rhs.as_inner().s()
    }
}
impl<T: Float> Antidot<Line<T>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Line<T>) -> T {
        self.xy() * rhs.xy() + self.xz() * rhs.xz() + self.yz() * rhs.yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Line<T>> for Unit<Line<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Line<T>) -> T {
        self.as_inner().xy() * rhs.xy()
            + self.as_inner().xz() * rhs.xz()
            + self.as_inner().yz() * rhs.yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Line<T>>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Line<T>>) -> T {
        self.xy() * rhs.as_inner().xy()
            + self.xz() * rhs.as_inner().xz()
            + self.yz() * rhs.as_inner().yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Line<T>>> for Unit<Line<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Line<T>>) -> T {
        self.as_inner().xy() * rhs.as_inner().xy()
            + self.as_inner().xz() * rhs.as_inner().xz()
            + self.as_inner().yz() * rhs.as_inner().yz()
    }
}
impl<T: Float> Antidot<Rotor<T>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Rotor<T>) -> T {
        self.xy() * rhs.xy() + self.xz() * rhs.xz() + self.yz() * rhs.yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Rotor<T>> for Unit<Line<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Rotor<T>) -> T {
        self.as_inner().xy() * rhs.xy()
            + self.as_inner().xz() * rhs.xz()
            + self.as_inner().yz() * rhs.yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Rotor<T>>> for Line<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Rotor<T>>) -> T {
        self.xy() * rhs.as_inner().xy()
            + self.xz() * rhs.as_inner().xz()
            + self.yz() * rhs.as_inner().yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Rotor<T>>> for Unit<Line<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Rotor<T>>) -> T {
        self.as_inner().xy() * rhs.as_inner().xy()
            + self.as_inner().xz() * rhs.as_inner().xz()
            + self.as_inner().yz() * rhs.as_inner().yz()
    }
}
impl<T: Float> Antidot<Point<T>> for Point<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Point<T>) -> T {
        -(self.x() * rhs.x()) - self.y() * rhs.y() - self.z() * rhs.z()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Point<T>> for Unit<Point<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Point<T>) -> T {
        -(self.as_inner().x() * rhs.x())
            + -(self.as_inner().y() * rhs.y())
            + -(self.as_inner().z() * rhs.z())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Point<T>>> for Point<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Point<T>>) -> T {
        -(self.x() * rhs.as_inner().x())
            + -(self.y() * rhs.as_inner().y())
            + -(self.z() * rhs.as_inner().z())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Point<T>>> for Unit<Point<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Point<T>>) -> T {
        -(self.as_inner().x() * rhs.as_inner().x())
            + -(self.as_inner().y() * rhs.as_inner().y())
            + -(self.as_inner().z() * rhs.as_inner().z())
    }
}
impl<T: Float> Antidot<Pseudoscalar<T>> for Pseudoscalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Pseudoscalar<T>) -> T {
        self.xyz() * rhs.xyz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Pseudoscalar<T>> for Unit<Pseudoscalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Pseudoscalar<T>) -> T {
        self.as_inner().xyz() * rhs.xyz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Pseudoscalar<T>>> for Pseudoscalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Pseudoscalar<T>>) -> T {
        self.xyz() * rhs.as_inner().xyz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Pseudoscalar<T>>> for Unit<Pseudoscalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Pseudoscalar<T>>) -> T {
        self.as_inner().xyz() * rhs.as_inner().xyz()
    }
}
impl<T: Float> Antidot<Line<T>> for Rotor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Line<T>) -> T {
        self.xy() * rhs.xy() + self.xz() * rhs.xz() + self.yz() * rhs.yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Line<T>> for Unit<Rotor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Line<T>) -> T {
        self.as_inner().xy() * rhs.xy()
            + self.as_inner().xz() * rhs.xz()
            + self.as_inner().yz() * rhs.yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Line<T>>> for Rotor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Line<T>>) -> T {
        self.xy() * rhs.as_inner().xy()
            + self.xz() * rhs.as_inner().xz()
            + self.yz() * rhs.as_inner().yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Line<T>>> for Unit<Rotor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Line<T>>) -> T {
        self.as_inner().xy() * rhs.as_inner().xy()
            + self.as_inner().xz() * rhs.as_inner().xz()
            + self.as_inner().yz() * rhs.as_inner().yz()
    }
}
impl<T: Float> Antidot<Rotor<T>> for Rotor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Rotor<T>) -> T {
        -(self.s() * rhs.s()) + self.xy() * rhs.xy() + self.xz() * rhs.xz() + self.yz() * rhs.yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Rotor<T>> for Unit<Rotor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Rotor<T>) -> T {
        -(self.as_inner().s() * rhs.s())
            + self.as_inner().xy() * rhs.xy()
            + self.as_inner().xz() * rhs.xz()
            + self.as_inner().yz() * rhs.yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Rotor<T>>> for Rotor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Rotor<T>>) -> T {
        -(self.s() * rhs.as_inner().s())
            + self.xy() * rhs.as_inner().xy()
            + self.xz() * rhs.as_inner().xz()
            + self.yz() * rhs.as_inner().yz()
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Rotor<T>>> for Unit<Rotor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Rotor<T>>) -> T {
        -(self.as_inner().s() * rhs.as_inner().s())
            + self.as_inner().xy() * rhs.as_inner().xy()
            + self.as_inner().xz() * rhs.as_inner().xz()
            + self.as_inner().yz() * rhs.as_inner().yz()
    }
}
impl<T: Float> Antidot<Scalar<T>> for Rotor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        -(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Scalar<T>> for Unit<Rotor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        -(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Scalar<T>>> for Rotor<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Scalar<T>>) -> T {
        -(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Scalar<T>>> for Unit<Rotor<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Scalar<T>>) -> T {
        -(self.as_inner().s() * rhs.as_inner().s())
    }
}
impl<T: Float> Antidot<Rotor<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Rotor<T>) -> T {
        -(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Rotor<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Rotor<T>) -> T {
        -(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Rotor<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Rotor<T>>) -> T {
        -(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Rotor<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Rotor<T>>) -> T {
        -(self.as_inner().s() * rhs.as_inner().s())
    }
}
impl<T: Float> Antidot<Scalar<T>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        -(self.s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Scalar<T>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Scalar<T>) -> T {
        -(self.as_inner().s() * rhs.s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Scalar<T>>> for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Scalar<T>>) -> T {
        -(self.s() * rhs.as_inner().s())
    }
}
#[allow(unused_variables)]
impl<T: Float> Antidot<Unit<Scalar<T>>> for Unit<Scalar<T>> {
    type Scalar = T;
    #[inline]
    fn antidot(&self, rhs: &Unit<Scalar<T>>) -> T {
        -(self.as_inner().s() * rhs.as_inner().s())
    }
}
impl<T: Float> Reverse for Line<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(-self.xy(), -self.xz(), -self.yz())
    }
}
impl<T: Float> Reverse for Point<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.x(), self.y(), self.z())
    }
}
impl<T: Float> Reverse for Pseudoscalar<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(-self.xyz())
    }
}
impl<T: Float> Reverse for Rotor<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.s(), -self.xy(), -self.xz(), -self.yz())
    }
}
impl<T: Float> Reverse for Scalar<T> {
    #[inline]
    fn reverse(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> Antireverse for Line<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.xy(), self.xz(), self.yz())
    }
}
impl<T: Float> Antireverse for Point<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(-self.x(), -self.y(), -self.z())
    }
}
impl<T: Float> Antireverse for Pseudoscalar<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(self.xyz())
    }
}
impl<T: Float> Antireverse for Rotor<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(-self.s(), self.xy(), self.xz(), self.yz())
    }
}
impl<T: Float> Antireverse for Scalar<T> {
    #[inline]
    fn antireverse(&self) -> Self {
        Self::new_unchecked(-self.s())
    }
}
impl<T: Float> Involute for Line<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(-self.xy(), -self.xz(), -self.yz())
    }
}
impl<T: Float> Involute for Point<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.x(), self.y(), self.z())
    }
}
impl<T: Float> Involute for Pseudoscalar<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(-self.xyz())
    }
}
impl<T: Float> Involute for Rotor<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.s(), -self.xy(), -self.xz(), -self.yz())
    }
}
impl<T: Float> Involute for Scalar<T> {
    #[inline]
    fn involute(&self) -> Self {
        Self::new_unchecked(self.s())
    }
}
impl<T: Float> RightComplement for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn right_complement(&self) -> Point<T> {
        Point::new_unchecked(self.yz(), -self.xz(), self.xy())
    }
}
impl<T: Float> RightComplement for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn right_complement(&self) -> Line<T> {
        Line::new_unchecked(self.z(), -self.y(), self.x())
    }
}
impl<T: Float> RightComplement for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn right_complement(&self) -> Scalar<T> {
        Scalar::new_unchecked(self.xyz())
    }
}
impl<T: Float> RightComplement for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn right_complement(&self) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(self.s())
    }
}
impl<T: Float> WeightDual for Line<T> {
    type Output = Point<T>;
    #[inline]
    fn weight_dual(&self) -> Point<T> {
        Point::new_unchecked(-self.yz(), self.xz(), -self.xy())
    }
}
impl<T: Float> WeightDual for Point<T> {
    type Output = Line<T>;
    #[inline]
    fn weight_dual(&self) -> Line<T> {
        Line::new_unchecked(-self.z(), self.y(), -self.x())
    }
}
impl<T: Float> WeightDual for Pseudoscalar<T> {
    type Output = Scalar<T>;
    #[inline]
    fn weight_dual(&self) -> Scalar<T> {
        Scalar::new_unchecked(-self.xyz())
    }
}
impl<T: Float> WeightDual for Scalar<T> {
    type Output = Pseudoscalar<T>;
    #[inline]
    fn weight_dual(&self) -> Pseudoscalar<T> {
        Pseudoscalar::new_unchecked(-self.s())
    }
}
impl<T: Float> VersorInverse for Line<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(
            -self.xy() * inv_norm_sq,
            -self.xz() * inv_norm_sq,
            -self.yz() * inv_norm_sq,
        ))
    }
}
impl<T: Float> VersorInverse for Point<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(
            self.x() * inv_norm_sq,
            self.y() * inv_norm_sq,
            self.z() * inv_norm_sq,
        ))
    }
}
impl<T: Float> VersorInverse for Pseudoscalar<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(-self.xyz() * inv_norm_sq))
    }
}
impl<T: Float> VersorInverse for Rotor<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(
            self.s() * inv_norm_sq,
            -self.xy() * inv_norm_sq,
            -self.xz() * inv_norm_sq,
            -self.yz() * inv_norm_sq,
        ))
    }
}
impl<T: Float> VersorInverse for Scalar<T> {
    fn try_inverse(&self) -> Option<Self> {
        let norm_sq = <Self as crate::norm::Normed>::norm_squared(self);
        if norm_sq.abs() < T::epsilon() {
            return None;
        }
        let inv_norm_sq = T::one() / norm_sq;
        Some(Self::new_unchecked(self.s() * inv_norm_sq))
    }
}
impl<T: Float> crate::norm::Normed for Line<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.xy() * self.xy() + self.xz() * self.xz() + self.yz() * self.yz()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.xy() * factor, self.xz() * factor, self.yz() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Point<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.x() * self.x() + self.y() * self.y() + self.z() * self.z()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.x() * factor, self.y() * factor, self.z() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Pseudoscalar<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.xyz() * self.xyz()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.xyz() * factor)
    }
}
impl<T: Float> crate::norm::Normed for Rotor<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.s() * self.s() + self.xy() * self.xy() + self.xz() * self.xz() + self.yz() * self.yz()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(
            self.s() * factor,
            self.xy() * factor,
            self.xz() * factor,
            self.yz() * factor,
        )
    }
}
impl<T: Float> crate::norm::Normed for Scalar<T> {
    type Scalar = T;
    #[inline]
    fn norm_squared(&self) -> T {
        self.s() * self.s()
    }
    fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[inline]
    fn scale(&self, factor: T) -> Self {
        Self::new_unchecked(self.s() * factor)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Line<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.xy().abs_diff_eq(&other.xy(), epsilon)
            && self.xz().abs_diff_eq(&other.xz(), epsilon)
            && self.yz().abs_diff_eq(&other.yz(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Line<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.xy().relative_eq(&other.xy(), epsilon, max_relative)
            && self.xz().relative_eq(&other.xz(), epsilon, max_relative)
            && self.yz().relative_eq(&other.yz(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Line<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.xy().ulps_eq(&other.xy(), epsilon, max_ulps)
            && self.xz().ulps_eq(&other.xz(), epsilon, max_ulps)
            && self.yz().ulps_eq(&other.yz(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Point<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.x().abs_diff_eq(&other.x(), epsilon)
            && self.y().abs_diff_eq(&other.y(), epsilon)
            && self.z().abs_diff_eq(&other.z(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Point<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.x().relative_eq(&other.x(), epsilon, max_relative)
            && self.y().relative_eq(&other.y(), epsilon, max_relative)
            && self.z().relative_eq(&other.z(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Point<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.x().ulps_eq(&other.x(), epsilon, max_ulps)
            && self.y().ulps_eq(&other.y(), epsilon, max_ulps)
            && self.z().ulps_eq(&other.z(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Pseudoscalar<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.xyz().abs_diff_eq(&other.xyz(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Pseudoscalar<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.xyz().relative_eq(&other.xyz(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Pseudoscalar<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.xyz().ulps_eq(&other.xyz(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Rotor<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon)
            && self.xy().abs_diff_eq(&other.xy(), epsilon)
            && self.xz().abs_diff_eq(&other.xz(), epsilon)
            && self.yz().abs_diff_eq(&other.yz(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Rotor<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
            && self.xy().relative_eq(&other.xy(), epsilon, max_relative)
            && self.xz().relative_eq(&other.xz(), epsilon, max_relative)
            && self.yz().relative_eq(&other.yz(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Rotor<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
            && self.xy().ulps_eq(&other.xy(), epsilon, max_ulps)
            && self.xz().ulps_eq(&other.xz(), epsilon, max_ulps)
            && self.yz().ulps_eq(&other.yz(), epsilon, max_ulps)
    }
}
impl<T: Float + AbsDiffEq<Epsilon = T>> AbsDiffEq for Scalar<T> {
    type Epsilon = T;
    fn default_epsilon() -> Self::Epsilon {
        T::default_epsilon()
    }
    fn abs_diff_eq(&self, other: &Self, epsilon: Self::Epsilon) -> bool {
        self.s().abs_diff_eq(&other.s(), epsilon)
    }
}
impl<T: Float + RelativeEq<Epsilon = T>> RelativeEq for Scalar<T> {
    fn default_max_relative() -> Self::Epsilon {
        T::default_max_relative()
    }
    fn relative_eq(
        &self,
        other: &Self,
        epsilon: Self::Epsilon,
        max_relative: Self::Epsilon,
    ) -> bool {
        self.s().relative_eq(&other.s(), epsilon, max_relative)
    }
}
impl<T: Float + UlpsEq<Epsilon = T>> UlpsEq for Scalar<T> {
    fn default_max_ulps() -> u32 {
        T::default_max_ulps()
    }
    fn ulps_eq(&self, other: &Self, epsilon: Self::Epsilon, max_ulps: u32) -> bool {
        self.s().ulps_eq(&other.s(), epsilon, max_ulps)
    }
}
#[cfg(any(test, feature = "proptest-support"))]
#[allow(clippy::missing_docs_in_private_items)]
mod arbitrary_impls {
    use super::*;
    use proptest::prelude::*;
    use proptest::strategy::BoxedStrategy;
    use std::fmt::Debug;
    impl<T: Float + Debug + 'static> Arbitrary for Line<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0, -100.0f64..100.0, -100.0f64..100.0)
                .prop_map(|(x0, x1, x2)| {
                    Line::new_unchecked(T::from_f64(x0), T::from_f64(x1), T::from_f64(x2))
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Point<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0, -100.0f64..100.0, -100.0f64..100.0)
                .prop_map(|(x0, x1, x2)| {
                    Point::new_unchecked(T::from_f64(x0), T::from_f64(x1), T::from_f64(x2))
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Pseudoscalar<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| Pseudoscalar::new_unchecked(T::from_f64(x0)))
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Rotor<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
                -100.0f64..100.0,
            )
                .prop_map(|(x0, x1, x2, x3)| {
                    Rotor::new_unchecked(
                        T::from_f64(x0),
                        T::from_f64(x1),
                        T::from_f64(x2),
                        T::from_f64(x3),
                    )
                })
                .boxed()
        }
    }
    impl<T: Float + Debug + 'static> Arbitrary for Scalar<T> {
        type Parameters = ();
        type Strategy = BoxedStrategy<Self>;
        fn arbitrary_with(_: Self::Parameters) -> Self::Strategy {
            (-100.0f64..100.0)
                .prop_map(|x0| Scalar::new_unchecked(T::from_f64(x0)))
                .boxed()
        }
    }
}
