#![doc = " Type definitions for conformal2."]
#![doc = ""]
#![doc = " 2D Conformal Geometric Algebra Cl(3,1,0)"]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
#![allow(clippy::too_many_arguments)]
use crate::scalar::Float;
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
#[doc = "Circle in 2D space (or line as circle through infinity)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 7 | e1e2e3 | `w` |\n| 11 | e1e2e4 | `e12em` |\n| 13 | e1e3e4 | `e1epem` |\n| 14 | e2e3e4 | `e2epem` |\n\n\n# Example\n\n```\nuse clifford::specialized::conformal::dim2::Circle;\n\nlet v = Circle::new_unchecked(1.0, 2.0, 3.0, 4.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Circle<T: Float> {
    #[doc = "Coefficient of `w`."]
    w: T,
    #[doc = "Coefficient of `e12em`."]
    e12em: T,
    #[doc = "Coefficient of `e1epem`."]
    e1epem: T,
    #[doc = "Coefficient of `e2epem`."]
    e2epem: T,
}
impl<T: Float> Circle<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(w: T, e12em: T, e1epem: T, e2epem: T) -> Self {
        Self {
            w,
            e12em,
            e1epem,
            e2epem,
        }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(w: T, e12em: T, e1epem: T, e2epem: T) -> Self {
        Self::new(w, e12em, e1epem, e2epem)
    }
    #[doc = "Returns the `w` coefficient."]
    #[inline]
    pub fn w(&self) -> T {
        self.w
    }
    #[doc = "Returns the `e12em` coefficient."]
    #[inline]
    pub fn e12em(&self) -> T {
        self.e12em
    }
    #[doc = "Returns the `e1epem` coefficient."]
    #[inline]
    pub fn e1epem(&self) -> T {
        self.e1epem
    }
    #[doc = "Returns the `e2epem` coefficient."]
    #[inline]
    pub fn e2epem(&self) -> T {
        self.e2epem
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e2e3 element."]
    #[inline]
    pub fn unit_w() -> Self {
        Self::new_unchecked(T::one(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e2e4 element."]
    #[inline]
    pub fn unit_e12em() -> Self {
        Self::new_unchecked(T::zero(), T::one(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e3e4 element."]
    #[inline]
    pub fn unit_e1epem() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::one(), T::zero())
    }
    #[doc = "Creates the unit e2e3e4 element."]
    #[inline]
    pub fn unit_e2epem() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.w * self.w
            + self.e12em * self.e12em
            + self.e1epem * self.e1epem
            + self.e2epem * self.e2epem
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.w * s, self.e12em * s, self.e1epem * s, self.e2epem * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(-self.w, -self.e12em, -self.e1epem, -self.e2epem)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.w, self.e12em, self.e1epem, self.e2epem)
    }
}
impl<T: Float> Default for Circle<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Flat point (point pair with only em components)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 9 | e1e4 | `e1em` |\n| 10 | e2e4 | `e2em` |\n| 12 | e3e4 | `epem` |\n\n\n# Example\n\n```\nuse clifford::specialized::conformal::dim2::FlatPoint;\n\nlet v = FlatPoint::new_unchecked(1.0, 2.0, 3.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct FlatPoint<T: Float> {
    #[doc = "Coefficient of `e1em`."]
    e1em: T,
    #[doc = "Coefficient of `e2em`."]
    e2em: T,
    #[doc = "Coefficient of `epem`."]
    epem: T,
}
impl<T: Float> FlatPoint<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(e1em: T, e2em: T, epem: T) -> Self {
        Self { e1em, e2em, epem }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(e1em: T, e2em: T, epem: T) -> Self {
        Self::new(e1em, e2em, epem)
    }
    #[doc = "Returns the `e1em` coefficient."]
    #[inline]
    pub fn e1em(&self) -> T {
        self.e1em
    }
    #[doc = "Returns the `e2em` coefficient."]
    #[inline]
    pub fn e2em(&self) -> T {
        self.e2em
    }
    #[doc = "Returns the `epem` coefficient."]
    #[inline]
    pub fn epem(&self) -> T {
        self.epem
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e4 element."]
    #[inline]
    pub fn unit_e1em() -> Self {
        Self::new_unchecked(T::one(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e2e4 element."]
    #[inline]
    pub fn unit_e2em() -> Self {
        Self::new_unchecked(T::zero(), T::one(), T::zero())
    }
    #[doc = "Creates the unit e3e4 element."]
    #[inline]
    pub fn unit_epem() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.e1em * self.e1em + self.e2em * self.e2em + self.epem * self.epem
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.e1em * s, self.e2em * s, self.epem * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(-self.e1em, -self.e2em, -self.epem)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(-self.e1em, -self.e2em, -self.epem)
    }
}
impl<T: Float> Default for FlatPoint<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Line (circle through infinity, w=0)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 11 | e1e2e4 | `nx` |\n| 13 | e1e3e4 | `ny` |\n| 14 | e2e3e4 | `d` |\n\n\n# Example\n\n```\nuse clifford::specialized::conformal::dim2::Line;\n\nlet v = Line::new_unchecked(1.0, 2.0, 3.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Line<T: Float> {
    #[doc = "Coefficient of `nx`."]
    nx: T,
    #[doc = "Coefficient of `ny`."]
    ny: T,
    #[doc = "Coefficient of `d`."]
    d: T,
}
impl<T: Float> Line<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(nx: T, ny: T, d: T) -> Self {
        Self { nx, ny, d }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(nx: T, ny: T, d: T) -> Self {
        Self::new(nx, ny, d)
    }
    #[doc = "Returns the `nx` coefficient."]
    #[inline]
    pub fn nx(&self) -> T {
        self.nx
    }
    #[doc = "Returns the `ny` coefficient."]
    #[inline]
    pub fn ny(&self) -> T {
        self.ny
    }
    #[doc = "Returns the `d` coefficient."]
    #[inline]
    pub fn d(&self) -> T {
        self.d
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e2e4 element."]
    #[inline]
    pub fn unit_nx() -> Self {
        Self::new_unchecked(T::one(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e3e4 element."]
    #[inline]
    pub fn unit_ny() -> Self {
        Self::new_unchecked(T::zero(), T::one(), T::zero())
    }
    #[doc = "Creates the unit e2e3e4 element."]
    #[inline]
    pub fn unit_d() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.nx * self.nx + self.ny * self.ny + self.d * self.d
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.nx * s, self.ny * s, self.d * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(-self.nx, -self.ny, -self.d)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.nx, self.ny, self.d)
    }
}
impl<T: Float> Default for Line<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Motor (even subalgebra for conformal transformations)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 0 | s | `s` |\n| 3 | e1e2 | `m` |\n| 5 | e1e3 | `e1ep` |\n| 6 | e2e3 | `e2ep` |\n| 9 | e1e4 | `e1em` |\n| 10 | e2e4 | `e2em` |\n| 12 | e3e4 | `epem` |\n| 15 | e1e2e3e4 | `ps` |\n\n\n# Example\n\n```\nuse clifford::specialized::conformal::dim2::Motor;\n\nlet v = Motor::new_unchecked(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Motor<T: Float> {
    #[doc = "Coefficient of `s`."]
    s: T,
    #[doc = "Coefficient of `m`."]
    m: T,
    #[doc = "Coefficient of `e1ep`."]
    e1ep: T,
    #[doc = "Coefficient of `e2ep`."]
    e2ep: T,
    #[doc = "Coefficient of `e1em`."]
    e1em: T,
    #[doc = "Coefficient of `e2em`."]
    e2em: T,
    #[doc = "Coefficient of `epem`."]
    epem: T,
    #[doc = "Coefficient of `ps`."]
    ps: T,
}
impl<T: Float> Motor<T> {
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" **Warning:** This does not validate the geometric constraint."]
    #[doc = r" Use `new_checked()` to validate, or `from_components()` to"]
    #[doc = r" construct from independent parameters."]
    #[inline]
    pub fn new_unchecked(s: T, m: T, e1ep: T, e2ep: T, e1em: T, e2em: T, epem: T, ps: T) -> Self {
        Self {
            s,
            m,
            e1ep,
            e2ep,
            e1em,
            e2em,
            epem,
            ps,
        }
    }
    #[doc = r" Creates a new element, validating the geometric constraint."]
    #[doc = r""]
    #[doc = r" Returns `Err` if the constraint is violated beyond the given tolerance."]
    #[inline]
    pub fn new_checked(
        s: T,
        m: T,
        e1ep: T,
        e2ep: T,
        e1em: T,
        e2em: T,
        epem: T,
        ps: T,
        tolerance: T,
    ) -> Result<Self, &'static str> {
        let expected = (e1em * e2ep - e2em * e1ep + epem * m) / (s);
        let actual = ps;
        if (actual - expected).abs() > tolerance {
            return Err("Motor constraint");
        }
        Ok(Self::new_unchecked(s, m, e1ep, e2ep, e1em, e2em, epem, ps))
    }
    #[doc = "Creates a Motor from 7 independent components, computing `ps`.\n\nReturns `None` if the divisor would be zero (unstable computation)."]
    #[inline]
    pub fn from_components(
        s: T,
        m: T,
        e1ep: T,
        e2ep: T,
        e1em: T,
        e2em: T,
        epem: T,
    ) -> Option<Self> {
        if (s).abs() < T::epsilon() {
            return None;
        }
        Some(Self::new_unchecked(
            s,
            m,
            e1ep,
            e2ep,
            e1em,
            e2em,
            epem,
            (e1em * e2ep - e2em * e1ep + epem * m) / (s),
        ))
    }
    #[doc = "Returns the `s` coefficient."]
    #[inline]
    pub fn s(&self) -> T {
        self.s
    }
    #[doc = "Returns the `m` coefficient."]
    #[inline]
    pub fn m(&self) -> T {
        self.m
    }
    #[doc = "Returns the `e1ep` coefficient."]
    #[inline]
    pub fn e1ep(&self) -> T {
        self.e1ep
    }
    #[doc = "Returns the `e2ep` coefficient."]
    #[inline]
    pub fn e2ep(&self) -> T {
        self.e2ep
    }
    #[doc = "Returns the `e1em` coefficient."]
    #[inline]
    pub fn e1em(&self) -> T {
        self.e1em
    }
    #[doc = "Returns the `e2em` coefficient."]
    #[inline]
    pub fn e2em(&self) -> T {
        self.e2em
    }
    #[doc = "Returns the `epem` coefficient."]
    #[inline]
    pub fn epem(&self) -> T {
        self.epem
    }
    #[doc = "Returns the `ps` coefficient."]
    #[inline]
    pub fn ps(&self) -> T {
        self.ps
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.s * self.s
            + self.m * self.m
            + self.e1ep * self.e1ep
            + self.e2ep * self.e2ep
            + self.e1em * self.e1em
            + self.e2em * self.e2em
            + self.epem * self.epem
            + self.ps * self.ps
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(
            self.s * s,
            self.m * s,
            self.e1ep * s,
            self.e2ep * s,
            self.e1em * s,
            self.e2em * s,
            self.epem * s,
            self.ps * s,
        )
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(
            self.s, -self.m, -self.e1ep, -self.e2ep, -self.e1em, -self.e2em, -self.epem, self.ps,
        )
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(
            self.s, -self.m, -self.e1ep, -self.e2ep, -self.e1em, -self.e2em, -self.epem, self.ps,
        )
    }
}
impl<T: Float> Default for Motor<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Point pair / dipole (two points or oriented line segment)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 3 | e1e2 | `m` |\n| 5 | e1e3 | `e1ep` |\n| 6 | e2e3 | `e2ep` |\n| 9 | e1e4 | `e1em` |\n| 10 | e2e4 | `e2em` |\n| 12 | e3e4 | `epem` |\n\n\n# Example\n\n```\nuse clifford::specialized::conformal::dim2::PointPair;\n\nlet v = PointPair::new_unchecked(1.0, 2.0, 3.0, 4.0, 5.0, 6.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct PointPair<T: Float> {
    #[doc = "Coefficient of `m`."]
    m: T,
    #[doc = "Coefficient of `e1ep`."]
    e1ep: T,
    #[doc = "Coefficient of `e2ep`."]
    e2ep: T,
    #[doc = "Coefficient of `e1em`."]
    e1em: T,
    #[doc = "Coefficient of `e2em`."]
    e2em: T,
    #[doc = "Coefficient of `epem`."]
    epem: T,
}
impl<T: Float> PointPair<T> {
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" **Warning:** This does not validate the geometric constraint."]
    #[doc = r" Use `new_checked()` to validate, or `from_components()` to"]
    #[doc = r" construct from independent parameters."]
    #[inline]
    pub fn new_unchecked(m: T, e1ep: T, e2ep: T, e1em: T, e2em: T, epem: T) -> Self {
        Self {
            m,
            e1ep,
            e2ep,
            e1em,
            e2em,
            epem,
        }
    }
    #[doc = r" Creates a new element, validating the geometric constraint."]
    #[doc = r""]
    #[doc = r" Returns `Err` if the constraint is violated beyond the given tolerance."]
    #[inline]
    pub fn new_checked(
        m: T,
        e1ep: T,
        e2ep: T,
        e1em: T,
        e2em: T,
        epem: T,
        tolerance: T,
    ) -> Result<Self, &'static str> {
        let expected = (-e1em * e2ep + e2em * e1ep) / (m);
        let actual = epem;
        if (actual - expected).abs() > tolerance {
            return Err("PointPair constraint");
        }
        Ok(Self::new_unchecked(m, e1ep, e2ep, e1em, e2em, epem))
    }
    #[doc = "Creates a PointPair from 5 independent components, computing `epem`.\n\nReturns `None` if the divisor would be zero (unstable computation)."]
    #[inline]
    pub fn from_components(m: T, e1ep: T, e2ep: T, e1em: T, e2em: T) -> Option<Self> {
        if (m).abs() < T::epsilon() {
            return None;
        }
        Some(Self::new_unchecked(
            m,
            e1ep,
            e2ep,
            e1em,
            e2em,
            (-e1em * e2ep + e2em * e1ep) / (m),
        ))
    }
    #[doc = "Returns the `m` coefficient."]
    #[inline]
    pub fn m(&self) -> T {
        self.m
    }
    #[doc = "Returns the `e1ep` coefficient."]
    #[inline]
    pub fn e1ep(&self) -> T {
        self.e1ep
    }
    #[doc = "Returns the `e2ep` coefficient."]
    #[inline]
    pub fn e2ep(&self) -> T {
        self.e2ep
    }
    #[doc = "Returns the `e1em` coefficient."]
    #[inline]
    pub fn e1em(&self) -> T {
        self.e1em
    }
    #[doc = "Returns the `e2em` coefficient."]
    #[inline]
    pub fn e2em(&self) -> T {
        self.e2em
    }
    #[doc = "Returns the `epem` coefficient."]
    #[inline]
    pub fn epem(&self) -> T {
        self.epem
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e2 element."]
    #[inline]
    pub fn unit_m() -> Self {
        Self::new_unchecked(
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e3 element."]
    #[inline]
    pub fn unit_e1ep() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e2e3 element."]
    #[inline]
    pub fn unit_e2ep() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e4 element."]
    #[inline]
    pub fn unit_e1em() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e2e4 element."]
    #[inline]
    pub fn unit_e2em() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e3e4 element."]
    #[inline]
    pub fn unit_epem() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
        )
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.m * self.m
            + self.e1ep * self.e1ep
            + self.e2ep * self.e2ep
            + self.e1em * self.e1em
            + self.e2em * self.e2em
            + self.epem * self.epem
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(
            self.m * s,
            self.e1ep * s,
            self.e2ep * s,
            self.e1em * s,
            self.e2em * s,
            self.epem * s,
        )
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(
            -self.m, -self.e1ep, -self.e2ep, -self.e1em, -self.e2em, -self.epem,
        )
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(
            -self.m, -self.e1ep, -self.e2ep, -self.e1em, -self.e2em, -self.epem,
        )
    }
}
impl<T: Float> Default for PointPair<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Pseudoscalar (oriented 4-volume)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 15 | e1e2e3e4 | `ps` |\n\n\n# Example\n\n```\nuse clifford::specialized::conformal::dim2::Pseudoscalar;\n\nlet v = Pseudoscalar::new_unchecked(1.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Pseudoscalar<T: Float> {
    #[doc = "Coefficient of `ps`."]
    ps: T,
}
impl<T: Float> Pseudoscalar<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(ps: T) -> Self {
        Self { ps }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(ps: T) -> Self {
        Self::new(ps)
    }
    #[doc = "Returns the `ps` coefficient."]
    #[inline]
    pub fn ps(&self) -> T {
        self.ps
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero())
    }
    #[doc = "Creates the unit e1e2e3e4 element."]
    #[inline]
    pub fn unit_ps() -> Self {
        Self::new_unchecked(T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.ps * self.ps
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.ps * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.ps)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.ps)
    }
}
impl<T: Float> Default for Pseudoscalar<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Round point (null vectors represent actual 2D points)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 1 | e1 | `x` |\n| 2 | e2 | `y` |\n| 4 | e3 | `ep` |\n| 8 | e4 | `em` |\n\n\n# Example\n\n```\nuse clifford::specialized::conformal::dim2::RoundPoint;\n\nlet v = RoundPoint::new_unchecked(1.0, 2.0, 3.0, 4.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct RoundPoint<T: Float> {
    #[doc = "Coefficient of `x`."]
    x: T,
    #[doc = "Coefficient of `y`."]
    y: T,
    #[doc = "Coefficient of `ep`."]
    ep: T,
    #[doc = "Coefficient of `em`."]
    em: T,
}
impl<T: Float> RoundPoint<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(x: T, y: T, ep: T, em: T) -> Self {
        Self { x, y, ep, em }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(x: T, y: T, ep: T, em: T) -> Self {
        Self::new(x, y, ep, em)
    }
    #[doc = "Returns the `x` coefficient."]
    #[inline]
    pub fn x(&self) -> T {
        self.x
    }
    #[doc = "Returns the `y` coefficient."]
    #[inline]
    pub fn y(&self) -> T {
        self.y
    }
    #[doc = "Returns the `ep` coefficient."]
    #[inline]
    pub fn ep(&self) -> T {
        self.ep
    }
    #[doc = "Returns the `em` coefficient."]
    #[inline]
    pub fn em(&self) -> T {
        self.em
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1 element."]
    #[inline]
    pub fn unit_x() -> Self {
        Self::new_unchecked(T::one(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e2 element."]
    #[inline]
    pub fn unit_y() -> Self {
        Self::new_unchecked(T::zero(), T::one(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e3 element."]
    #[inline]
    pub fn unit_ep() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::one(), T::zero())
    }
    #[doc = "Creates the unit e4 element."]
    #[inline]
    pub fn unit_em() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.x * self.x + self.y * self.y + self.ep * self.ep + self.em * self.em
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.x * s, self.y * s, self.ep * s, self.em * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.x, self.y, self.ep, self.em)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(-self.x, -self.y, -self.ep, -self.em)
    }
}
impl<T: Float> Default for RoundPoint<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Scalar (grade-0 element)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 0 | s | `s` |\n\n\n# Example\n\n```\nuse clifford::specialized::conformal::dim2::Scalar;\n\nlet v = Scalar::new_unchecked(1.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Scalar<T: Float> {
    #[doc = "Coefficient of `s`."]
    s: T,
}
impl<T: Float> Scalar<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(s: T) -> Self {
        Self { s }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(s: T) -> Self {
        Self::new(s)
    }
    #[doc = "Returns the `s` coefficient."]
    #[inline]
    pub fn s(&self) -> T {
        self.s
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero())
    }
    #[doc = "Creates the unit s element."]
    #[inline]
    pub fn unit_s() -> Self {
        Self::new_unchecked(T::one())
    }
    #[doc = r" Returns the squared Euclidean norm (sum of squared coefficients)."]
    #[doc = r""]
    #[doc = r" This computes the coefficient-space Euclidean norm, not the"]
    #[doc = r" metric-aware geometric algebra norm. Components with zero metric"]
    #[doc = r" (degenerate bases) are excluded."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.s * self.s
    }
    #[doc = r" Returns the Euclidean norm (square root of sum of squared coefficients)."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.s * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.s)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.s)
    }
}
impl<T: Float> Default for Scalar<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "A unit Circle (norm = 1).\n\nThis type alias provides compile-time documentation that the Circle has been normalized."]
pub type UnitCircle<T> = crate::wrappers::Unit<Circle<T>>;
#[doc = "A Circle with positive norm squared (timelike in Minkowski).\n\nThis type alias wraps Circle in `Proper<T>`, guaranteeing norm² > 0."]
pub type ProperCircle<T> = crate::wrappers::Proper<Circle<T>>;
#[doc = "A Circle with negative norm squared (spacelike in Minkowski).\n\nThis type alias wraps Circle in `Spacelike<T>`, guaranteeing norm² < 0."]
pub type SpacelikeCircle<T> = crate::wrappers::Spacelike<Circle<T>>;
#[doc = "A Circle with zero norm squared (lightlike/null in Minkowski).\n\nThis type alias wraps Circle in `Null<T>`, guaranteeing norm² = 0."]
pub type NullCircle<T> = crate::wrappers::Null<Circle<T>>;
#[doc = "A unit FlatPoint (norm = 1).\n\nThis type alias provides compile-time documentation that the FlatPoint has been normalized."]
pub type UnitFlatPoint<T> = crate::wrappers::Unit<FlatPoint<T>>;
#[doc = "A FlatPoint with positive norm squared (timelike in Minkowski).\n\nThis type alias wraps FlatPoint in `Proper<T>`, guaranteeing norm² > 0."]
pub type ProperFlatPoint<T> = crate::wrappers::Proper<FlatPoint<T>>;
#[doc = "A FlatPoint with negative norm squared (spacelike in Minkowski).\n\nThis type alias wraps FlatPoint in `Spacelike<T>`, guaranteeing norm² < 0."]
pub type SpacelikeFlatPoint<T> = crate::wrappers::Spacelike<FlatPoint<T>>;
#[doc = "A FlatPoint with zero norm squared (lightlike/null in Minkowski).\n\nThis type alias wraps FlatPoint in `Null<T>`, guaranteeing norm² = 0."]
pub type NullFlatPoint<T> = crate::wrappers::Null<FlatPoint<T>>;
#[doc = "A unit Line (norm = 1).\n\nThis type alias provides compile-time documentation that the Line has been normalized."]
pub type UnitLine<T> = crate::wrappers::Unit<Line<T>>;
#[doc = "A Line with positive norm squared (timelike in Minkowski).\n\nThis type alias wraps Line in `Proper<T>`, guaranteeing norm² > 0."]
pub type ProperLine<T> = crate::wrappers::Proper<Line<T>>;
#[doc = "A Line with negative norm squared (spacelike in Minkowski).\n\nThis type alias wraps Line in `Spacelike<T>`, guaranteeing norm² < 0."]
pub type SpacelikeLine<T> = crate::wrappers::Spacelike<Line<T>>;
#[doc = "A Line with zero norm squared (lightlike/null in Minkowski).\n\nThis type alias wraps Line in `Null<T>`, guaranteeing norm² = 0."]
pub type NullLine<T> = crate::wrappers::Null<Line<T>>;
#[doc = "A unit PointPair (norm = 1).\n\nThis type alias provides compile-time documentation that the PointPair has been normalized."]
pub type UnitPointPair<T> = crate::wrappers::Unit<PointPair<T>>;
#[doc = "A PointPair with positive norm squared (timelike in Minkowski).\n\nThis type alias wraps PointPair in `Proper<T>`, guaranteeing norm² > 0."]
pub type ProperPointPair<T> = crate::wrappers::Proper<PointPair<T>>;
#[doc = "A PointPair with negative norm squared (spacelike in Minkowski).\n\nThis type alias wraps PointPair in `Spacelike<T>`, guaranteeing norm² < 0."]
pub type SpacelikePointPair<T> = crate::wrappers::Spacelike<PointPair<T>>;
#[doc = "A PointPair with zero norm squared (lightlike/null in Minkowski).\n\nThis type alias wraps PointPair in `Null<T>`, guaranteeing norm² = 0."]
pub type NullPointPair<T> = crate::wrappers::Null<PointPair<T>>;
#[doc = "A unit Pseudoscalar (norm = 1).\n\nThis type alias provides compile-time documentation that the Pseudoscalar has been normalized."]
pub type UnitPseudoscalar<T> = crate::wrappers::Unit<Pseudoscalar<T>>;
#[doc = "A Pseudoscalar with positive norm squared (timelike in Minkowski).\n\nThis type alias wraps Pseudoscalar in `Proper<T>`, guaranteeing norm² > 0."]
pub type ProperPseudoscalar<T> = crate::wrappers::Proper<Pseudoscalar<T>>;
#[doc = "A Pseudoscalar with negative norm squared (spacelike in Minkowski).\n\nThis type alias wraps Pseudoscalar in `Spacelike<T>`, guaranteeing norm² < 0."]
pub type SpacelikePseudoscalar<T> = crate::wrappers::Spacelike<Pseudoscalar<T>>;
#[doc = "A Pseudoscalar with zero norm squared (lightlike/null in Minkowski).\n\nThis type alias wraps Pseudoscalar in `Null<T>`, guaranteeing norm² = 0."]
pub type NullPseudoscalar<T> = crate::wrappers::Null<Pseudoscalar<T>>;
#[doc = "A unit RoundPoint (norm = 1).\n\nThis type alias provides compile-time documentation that the RoundPoint has been normalized."]
pub type UnitRoundPoint<T> = crate::wrappers::Unit<RoundPoint<T>>;
#[doc = "A RoundPoint with positive norm squared (timelike in Minkowski).\n\nThis type alias wraps RoundPoint in `Proper<T>`, guaranteeing norm² > 0."]
pub type ProperRoundPoint<T> = crate::wrappers::Proper<RoundPoint<T>>;
#[doc = "A RoundPoint with negative norm squared (spacelike in Minkowski).\n\nThis type alias wraps RoundPoint in `Spacelike<T>`, guaranteeing norm² < 0."]
pub type SpacelikeRoundPoint<T> = crate::wrappers::Spacelike<RoundPoint<T>>;
#[doc = "A RoundPoint with zero norm squared (lightlike/null in Minkowski).\n\nThis type alias wraps RoundPoint in `Null<T>`, guaranteeing norm² = 0."]
pub type NullRoundPoint<T> = crate::wrappers::Null<RoundPoint<T>>;
