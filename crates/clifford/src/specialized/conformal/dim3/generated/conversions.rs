#![doc = " Multivector conversions for conformal3."]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
use super::types::{
    Circle, Dipole, FlatPoint, Line, Motor, Plane, Pseudoscalar, RoundPoint, Scalar, Sphere,
};
use crate::algebra::Multivector;
use crate::basis::Blade;
use crate::scalar::Float;
use crate::signature::Conformal3;
impl<T: Float> From<Circle<T>> for Multivector<T, Conformal3> {
    fn from(value: Circle<T>) -> Self {
        Self::from_coeffs(&[
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            value.gw(),
            T::zero(),
            T::zero(),
            T::zero(),
            value.gz(),
            T::zero(),
            value.gy(),
            value.gx(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            value.mz(),
            T::zero(),
            value.my(),
            value.mx(),
            T::zero(),
            T::zero(),
            value.vx(),
            value.vy(),
            T::zero(),
            value.vz(),
            T::zero(),
            T::zero(),
            T::zero(),
        ])
    }
}
impl<T: Float> From<Dipole<T>> for Multivector<T, Conformal3> {
    fn from(value: Dipole<T>) -> Self {
        Self::from_coeffs(&[
            T::zero(),
            T::zero(),
            T::zero(),
            value.mx(),
            T::zero(),
            value.my(),
            value.mz(),
            T::zero(),
            T::zero(),
            value.vx(),
            value.vy(),
            T::zero(),
            value.vz(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            value.px(),
            value.py(),
            T::zero(),
            value.pz(),
            T::zero(),
            T::zero(),
            T::zero(),
            value.pw(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        ])
    }
}
impl<T: Float> From<FlatPoint<T>> for Multivector<T, Conformal3> {
    fn from(value: FlatPoint<T>) -> Self {
        Self::from_coeffs(&[
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            value.px(),
            value.py(),
            T::zero(),
            value.pz(),
            T::zero(),
            T::zero(),
            T::zero(),
            value.pw(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        ])
    }
}
impl<T: Float> From<Line<T>> for Multivector<T, Conformal3> {
    fn from(value: Line<T>) -> Self {
        Self::from_coeffs(&[
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            value.mz(),
            T::zero(),
            value.my(),
            value.mx(),
            T::zero(),
            T::zero(),
            value.vx(),
            value.vy(),
            T::zero(),
            value.vz(),
            T::zero(),
            T::zero(),
            T::zero(),
        ])
    }
}
impl<T: Float> From<Motor<T>> for Multivector<T, Conformal3> {
    fn from(value: Motor<T>) -> Self {
        Self::from_coeffs(&[
            value.s(),
            T::zero(),
            T::zero(),
            value.mx(),
            T::zero(),
            value.my(),
            value.mz(),
            T::zero(),
            T::zero(),
            value.vx(),
            value.vy(),
            T::zero(),
            value.vz(),
            T::zero(),
            T::zero(),
            value.u(),
            T::zero(),
            value.px(),
            value.py(),
            T::zero(),
            value.pz(),
            T::zero(),
            T::zero(),
            value.sx(),
            value.pw(),
            T::zero(),
            T::zero(),
            value.sy(),
            T::zero(),
            value.sz(),
            value.sw(),
            T::zero(),
        ])
    }
}
impl<T: Float> From<Plane<T>> for Multivector<T, Conformal3> {
    fn from(value: Plane<T>) -> Self {
        Self::from_coeffs(&[
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            value.w(),
            T::zero(),
            T::zero(),
            T::zero(),
            value.z(),
            T::zero(),
            value.y(),
            value.x(),
            T::zero(),
        ])
    }
}
impl<T: Float> From<Pseudoscalar<T>> for Multivector<T, Conformal3> {
    fn from(value: Pseudoscalar<T>) -> Self {
        Self::from_coeffs(&[
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            value.xyzwu(),
        ])
    }
}
impl<T: Float> From<RoundPoint<T>> for Multivector<T, Conformal3> {
    fn from(value: RoundPoint<T>) -> Self {
        Self::from_coeffs(&[
            T::zero(),
            value.x(),
            value.y(),
            T::zero(),
            value.z(),
            T::zero(),
            T::zero(),
            T::zero(),
            value.w(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            value.u(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        ])
    }
}
impl<T: Float> From<Scalar<T>> for Multivector<T, Conformal3> {
    fn from(value: Scalar<T>) -> Self {
        Self::from_coeffs(&[
            value.s(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        ])
    }
}
impl<T: Float> From<Sphere<T>> for Multivector<T, Conformal3> {
    fn from(value: Sphere<T>) -> Self {
        Self::from_coeffs(&[
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            value.u(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            value.x(),
            T::zero(),
            T::zero(),
            T::zero(),
            value.y(),
            T::zero(),
            value.z(),
            value.w(),
            T::zero(),
        ])
    }
}
impl<T: Float> From<Multivector<T, Conformal3>> for Circle<T> {
    #[doc = r" Extracts this type from a multivector."]
    #[doc = r""]
    #[doc = r" Note: This is a lossy projection that only extracts the relevant"]
    #[doc = r" grades. Other components of the multivector are discarded."]
    fn from(mv: Multivector<T, Conformal3>) -> Self {
        Self::new_unchecked(
            mv.get(Blade::from_index(7usize)),
            mv.get(Blade::from_index(11usize)),
            mv.get(Blade::from_index(13usize)),
            mv.get(Blade::from_index(14usize)),
            mv.get(Blade::from_index(19usize)),
            mv.get(Blade::from_index(21usize)),
            mv.get(Blade::from_index(22usize)),
            mv.get(Blade::from_index(25usize)),
            mv.get(Blade::from_index(26usize)),
            mv.get(Blade::from_index(28usize)),
        )
    }
}
impl<T: Float> From<Multivector<T, Conformal3>> for Dipole<T> {
    #[doc = r" Extracts this type from a multivector."]
    #[doc = r""]
    #[doc = r" Note: This is a lossy projection that only extracts the relevant"]
    #[doc = r" grades. Other components of the multivector are discarded."]
    fn from(mv: Multivector<T, Conformal3>) -> Self {
        Self::new_unchecked(
            mv.get(Blade::from_index(3usize)),
            mv.get(Blade::from_index(5usize)),
            mv.get(Blade::from_index(6usize)),
            mv.get(Blade::from_index(9usize)),
            mv.get(Blade::from_index(10usize)),
            mv.get(Blade::from_index(12usize)),
            mv.get(Blade::from_index(17usize)),
            mv.get(Blade::from_index(18usize)),
            mv.get(Blade::from_index(20usize)),
            mv.get(Blade::from_index(24usize)),
        )
    }
}
impl<T: Float> From<Multivector<T, Conformal3>> for FlatPoint<T> {
    #[doc = r" Extracts this type from a multivector."]
    #[doc = r""]
    #[doc = r" Note: This is a lossy projection that only extracts the relevant"]
    #[doc = r" grades. Other components of the multivector are discarded."]
    fn from(mv: Multivector<T, Conformal3>) -> Self {
        Self::new_unchecked(
            mv.get(Blade::from_index(17usize)),
            mv.get(Blade::from_index(18usize)),
            mv.get(Blade::from_index(20usize)),
            mv.get(Blade::from_index(24usize)),
        )
    }
}
impl<T: Float> From<Multivector<T, Conformal3>> for Line<T> {
    #[doc = r" Extracts this type from a multivector."]
    #[doc = r""]
    #[doc = r" Note: This is a lossy projection that only extracts the relevant"]
    #[doc = r" grades. Other components of the multivector are discarded."]
    fn from(mv: Multivector<T, Conformal3>) -> Self {
        Self::new_unchecked(
            mv.get(Blade::from_index(25usize)),
            mv.get(Blade::from_index(26usize)),
            mv.get(Blade::from_index(28usize)),
            mv.get(Blade::from_index(22usize)),
            mv.get(Blade::from_index(21usize)),
            mv.get(Blade::from_index(19usize)),
        )
    }
}
impl<T: Float> From<Multivector<T, Conformal3>> for Motor<T> {
    #[doc = r" Extracts this type from a multivector."]
    #[doc = r""]
    #[doc = r" Note: This is a lossy projection that only extracts the relevant"]
    #[doc = r" grades. Other components of the multivector are discarded."]
    fn from(mv: Multivector<T, Conformal3>) -> Self {
        Self::new_unchecked(
            mv.get(Blade::from_index(0usize)),
            mv.get(Blade::from_index(3usize)),
            mv.get(Blade::from_index(5usize)),
            mv.get(Blade::from_index(6usize)),
            mv.get(Blade::from_index(9usize)),
            mv.get(Blade::from_index(10usize)),
            mv.get(Blade::from_index(12usize)),
            mv.get(Blade::from_index(17usize)),
            mv.get(Blade::from_index(18usize)),
            mv.get(Blade::from_index(20usize)),
            mv.get(Blade::from_index(24usize)),
            mv.get(Blade::from_index(15usize)),
            mv.get(Blade::from_index(23usize)),
            mv.get(Blade::from_index(27usize)),
            mv.get(Blade::from_index(29usize)),
            mv.get(Blade::from_index(30usize)),
        )
    }
}
impl<T: Float> From<Multivector<T, Conformal3>> for Plane<T> {
    #[doc = r" Extracts this type from a multivector."]
    #[doc = r""]
    #[doc = r" Note: This is a lossy projection that only extracts the relevant"]
    #[doc = r" grades. Other components of the multivector are discarded."]
    fn from(mv: Multivector<T, Conformal3>) -> Self {
        Self::new_unchecked(
            mv.get(Blade::from_index(30usize)),
            mv.get(Blade::from_index(29usize)),
            mv.get(Blade::from_index(27usize)),
            mv.get(Blade::from_index(23usize)),
        )
    }
}
impl<T: Float> From<Multivector<T, Conformal3>> for Pseudoscalar<T> {
    #[doc = r" Extracts this type from a multivector."]
    #[doc = r""]
    #[doc = r" Note: This is a lossy projection that only extracts the relevant"]
    #[doc = r" grades. Other components of the multivector are discarded."]
    fn from(mv: Multivector<T, Conformal3>) -> Self {
        Self::new_unchecked(mv.get(Blade::from_index(31usize)))
    }
}
impl<T: Float> From<Multivector<T, Conformal3>> for RoundPoint<T> {
    #[doc = r" Extracts this type from a multivector."]
    #[doc = r""]
    #[doc = r" Note: This is a lossy projection that only extracts the relevant"]
    #[doc = r" grades. Other components of the multivector are discarded."]
    fn from(mv: Multivector<T, Conformal3>) -> Self {
        Self::new_unchecked(
            mv.get(Blade::from_index(1usize)),
            mv.get(Blade::from_index(2usize)),
            mv.get(Blade::from_index(4usize)),
            mv.get(Blade::from_index(8usize)),
            mv.get(Blade::from_index(16usize)),
        )
    }
}
impl<T: Float> From<Multivector<T, Conformal3>> for Scalar<T> {
    #[doc = r" Extracts this type from a multivector."]
    #[doc = r""]
    #[doc = r" Note: This is a lossy projection that only extracts the relevant"]
    #[doc = r" grades. Other components of the multivector are discarded."]
    fn from(mv: Multivector<T, Conformal3>) -> Self {
        Self::new_unchecked(mv.get(Blade::from_index(0usize)))
    }
}
impl<T: Float> From<Multivector<T, Conformal3>> for Sphere<T> {
    #[doc = r" Extracts this type from a multivector."]
    #[doc = r""]
    #[doc = r" Note: This is a lossy projection that only extracts the relevant"]
    #[doc = r" grades. Other components of the multivector are discarded."]
    fn from(mv: Multivector<T, Conformal3>) -> Self {
        Self::new_unchecked(
            mv.get(Blade::from_index(15usize)),
            mv.get(Blade::from_index(23usize)),
            mv.get(Blade::from_index(27usize)),
            mv.get(Blade::from_index(29usize)),
            mv.get(Blade::from_index(30usize)),
        )
    }
}
