#![doc = " Type definitions for conformal3."]
#![doc = ""]
#![doc = " 3D Conformal Geometric Algebra Cl(4,1,0)"]
#![doc = ""]
#![doc = " This file is auto-generated by clifford-codegen."]
#![doc = " Do not edit manually."]
#![allow(clippy::too_many_arguments)]
use crate::scalar::Float;
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
#[doc = "Circle in 3D space\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 7 | e1e2e3 | `gw` |\n| 11 | e1e2e4 | `gz` |\n| 13 | e1e3e4 | `gy` |\n| 14 | e2e3e4 | `gx` |\n| 19 | e1e2e5 | `mz` |\n| 21 | e1e3e5 | `my` |\n| 22 | e2e3e5 | `mx` |\n| 25 | e1e4e5 | `vx` |\n| 26 | e2e4e5 | `vy` |\n| 28 | e3e4e5 | `vz` |\n\n\n# Example\n\n```\nuse clifford::specialized::conformal::dim3::Circle;\n\nlet v = Circle::new_unchecked(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Circle<T: Float> {
    #[doc = "Coefficient of `gw`."]
    gw: T,
    #[doc = "Coefficient of `gz`."]
    gz: T,
    #[doc = "Coefficient of `gy`."]
    gy: T,
    #[doc = "Coefficient of `gx`."]
    gx: T,
    #[doc = "Coefficient of `mz`."]
    mz: T,
    #[doc = "Coefficient of `my`."]
    my: T,
    #[doc = "Coefficient of `mx`."]
    mx: T,
    #[doc = "Coefficient of `vx`."]
    vx: T,
    #[doc = "Coefficient of `vy`."]
    vy: T,
    #[doc = "Coefficient of `vz`."]
    vz: T,
}
impl<T: Float> Circle<T> {
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" **Warning:** This does not validate the geometric constraint."]
    #[doc = r" Use `new_checked()` to validate, or `from_components()` to"]
    #[doc = r" construct from independent parameters."]
    #[inline]
    pub fn new_unchecked(
        gw: T,
        gz: T,
        gy: T,
        gx: T,
        mz: T,
        my: T,
        mx: T,
        vx: T,
        vy: T,
        vz: T,
    ) -> Self {
        Self {
            gw,
            gz,
            gy,
            gx,
            mz,
            my,
            mx,
            vx,
            vy,
            vz,
        }
    }
    #[doc = r" Creates a new element, validating the geometric constraint."]
    #[doc = r""]
    #[doc = r" Returns `Err` if the constraint is violated beyond the given tolerance."]
    #[inline]
    pub fn new_checked(
        gw: T,
        gz: T,
        gy: T,
        gx: T,
        mz: T,
        my: T,
        mx: T,
        vx: T,
        vy: T,
        vz: T,
        tolerance: T,
    ) -> Result<Self, &'static str> {
        let expected = (-gw * vx + gw * vy + gz * my - gz * mx - gy * mz + gy * mx - gy * vy
            + gx * mz
            - gx * my
            + gx * vx
            - my * vy
            + mx * vx)
            / (gw);
        let actual = vz;
        if (actual - expected).abs() > tolerance {
            return Err("Circle constraint");
        }
        Ok(Self::new_unchecked(gw, gz, gy, gx, mz, my, mx, vx, vy, vz))
    }
    #[doc = "Creates a Circle from 9 independent components, computing `vz`.\n\nReturns `None` if the divisor would be zero (unstable computation)."]
    #[inline]
    pub fn from_components(
        gw: T,
        gz: T,
        gy: T,
        gx: T,
        mz: T,
        my: T,
        mx: T,
        vx: T,
        vy: T,
    ) -> Option<Self> {
        if (gw).abs() < T::epsilon() {
            return None;
        }
        Some(Self::new_unchecked(
            gw,
            gz,
            gy,
            gx,
            mz,
            my,
            mx,
            vx,
            vy,
            (-gw * vx + gw * vy + gz * my - gz * mx - gy * mz + gy * mx - gy * vy + gx * mz
                - gx * my
                + gx * vx
                - my * vy
                + mx * vx)
                / (gw),
        ))
    }
    #[doc = "Returns the `gw` coefficient."]
    #[inline]
    pub fn gw(&self) -> T {
        self.gw
    }
    #[doc = "Returns the `gz` coefficient."]
    #[inline]
    pub fn gz(&self) -> T {
        self.gz
    }
    #[doc = "Returns the `gy` coefficient."]
    #[inline]
    pub fn gy(&self) -> T {
        self.gy
    }
    #[doc = "Returns the `gx` coefficient."]
    #[inline]
    pub fn gx(&self) -> T {
        self.gx
    }
    #[doc = "Returns the `mz` coefficient."]
    #[inline]
    pub fn mz(&self) -> T {
        self.mz
    }
    #[doc = "Returns the `my` coefficient."]
    #[inline]
    pub fn my(&self) -> T {
        self.my
    }
    #[doc = "Returns the `mx` coefficient."]
    #[inline]
    pub fn mx(&self) -> T {
        self.mx
    }
    #[doc = "Returns the `vx` coefficient."]
    #[inline]
    pub fn vx(&self) -> T {
        self.vx
    }
    #[doc = "Returns the `vy` coefficient."]
    #[inline]
    pub fn vy(&self) -> T {
        self.vy
    }
    #[doc = "Returns the `vz` coefficient."]
    #[inline]
    pub fn vz(&self) -> T {
        self.vz
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e2e3 element."]
    #[inline]
    pub fn unit_gw() -> Self {
        Self::new_unchecked(
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e2e4 element."]
    #[inline]
    pub fn unit_gz() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e3e4 element."]
    #[inline]
    pub fn unit_gy() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e2e3e4 element."]
    #[inline]
    pub fn unit_gx() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e2e5 element."]
    #[inline]
    pub fn unit_mz() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e3e5 element."]
    #[inline]
    pub fn unit_my() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e2e3e5 element."]
    #[inline]
    pub fn unit_mx() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e4e5 element."]
    #[inline]
    pub fn unit_vx() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e2e4e5 element."]
    #[inline]
    pub fn unit_vy() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e3e4e5 element."]
    #[inline]
    pub fn unit_vz() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
        )
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.gw * self.gw
            + self.gz * self.gz
            + self.gy * self.gy
            + self.gx * self.gx
            + self.mz * self.mz
            + self.my * self.my
            + self.mx * self.mx
            + self.vx * self.vx
            + self.vy * self.vy
            + self.vz * self.vz
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(
            self.gw * s,
            self.gz * s,
            self.gy * s,
            self.gx * s,
            self.mz * s,
            self.my * s,
            self.mx * s,
            self.vx * s,
            self.vy * s,
            self.vz * s,
        )
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(
            -self.gw, -self.gz, -self.gy, -self.gx, -self.mz, -self.my, -self.mx, -self.vx,
            -self.vy, -self.vz,
        )
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(
            -self.gw, -self.gz, -self.gy, -self.gx, -self.mz, -self.my, -self.mx, -self.vx,
            -self.vy, -self.vz,
        )
    }
}
impl<T: Float> Default for Circle<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Dipole (point pair, oriented line segment)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 3 | e1e2 | `mx` |\n| 5 | e1e3 | `my` |\n| 6 | e2e3 | `mz` |\n| 9 | e1e4 | `vx` |\n| 10 | e2e4 | `vy` |\n| 12 | e3e4 | `vz` |\n| 17 | e1e5 | `px` |\n| 18 | e2e5 | `py` |\n| 20 | e3e5 | `pz` |\n| 24 | e4e5 | `pw` |\n\n\n# Example\n\n```\nuse clifford::specialized::conformal::dim3::Dipole;\n\nlet v = Dipole::new_unchecked(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Dipole<T: Float> {
    #[doc = "Coefficient of `mx`."]
    mx: T,
    #[doc = "Coefficient of `my`."]
    my: T,
    #[doc = "Coefficient of `mz`."]
    mz: T,
    #[doc = "Coefficient of `vx`."]
    vx: T,
    #[doc = "Coefficient of `vy`."]
    vy: T,
    #[doc = "Coefficient of `vz`."]
    vz: T,
    #[doc = "Coefficient of `px`."]
    px: T,
    #[doc = "Coefficient of `py`."]
    py: T,
    #[doc = "Coefficient of `pz`."]
    pz: T,
    #[doc = "Coefficient of `pw`."]
    pw: T,
}
impl<T: Float> Dipole<T> {
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" **Warning:** This does not validate the geometric constraint."]
    #[doc = r" Use `new_checked()` to validate, or `from_components()` to"]
    #[doc = r" construct from independent parameters."]
    #[inline]
    pub fn new_unchecked(
        mx: T,
        my: T,
        mz: T,
        vx: T,
        vy: T,
        vz: T,
        px: T,
        py: T,
        pz: T,
        pw: T,
    ) -> Self {
        Self {
            mx,
            my,
            mz,
            vx,
            vy,
            vz,
            px,
            py,
            pz,
            pw,
        }
    }
    #[doc = r" Creates a new element, validating the geometric constraint."]
    #[doc = r""]
    #[doc = r" Returns `Err` if the constraint is violated beyond the given tolerance."]
    #[inline]
    pub fn new_checked(
        mx: T,
        my: T,
        mz: T,
        vx: T,
        vy: T,
        vz: T,
        px: T,
        py: T,
        pz: T,
        pw: T,
        tolerance: T,
    ) -> Result<Self, &'static str> {
        let expected = (-px * mz - px * vy - px * vz + py * my + py * vx - py * vz - pz * mx
            + pz * vx
            + pz * vy
            - mz * vx
            + my * vy
            - mx * vz)
            / (mz);
        let actual = pw;
        if (actual - expected).abs() > tolerance {
            return Err("Dipole constraint");
        }
        Ok(Self::new_unchecked(mx, my, mz, vx, vy, vz, px, py, pz, pw))
    }
    #[doc = "Creates a Dipole from 9 independent components, computing `pw`.\n\nReturns `None` if the divisor would be zero (unstable computation)."]
    #[inline]
    pub fn from_components(
        mx: T,
        my: T,
        mz: T,
        vx: T,
        vy: T,
        vz: T,
        px: T,
        py: T,
        pz: T,
    ) -> Option<Self> {
        if (mz).abs() < T::epsilon() {
            return None;
        }
        Some(Self::new_unchecked(
            mx,
            my,
            mz,
            vx,
            vy,
            vz,
            px,
            py,
            pz,
            (-px * mz - px * vy - px * vz + py * my + py * vx - py * vz - pz * mx
                + pz * vx
                + pz * vy
                - mz * vx
                + my * vy
                - mx * vz)
                / (mz),
        ))
    }
    #[doc = "Returns the `mx` coefficient."]
    #[inline]
    pub fn mx(&self) -> T {
        self.mx
    }
    #[doc = "Returns the `my` coefficient."]
    #[inline]
    pub fn my(&self) -> T {
        self.my
    }
    #[doc = "Returns the `mz` coefficient."]
    #[inline]
    pub fn mz(&self) -> T {
        self.mz
    }
    #[doc = "Returns the `vx` coefficient."]
    #[inline]
    pub fn vx(&self) -> T {
        self.vx
    }
    #[doc = "Returns the `vy` coefficient."]
    #[inline]
    pub fn vy(&self) -> T {
        self.vy
    }
    #[doc = "Returns the `vz` coefficient."]
    #[inline]
    pub fn vz(&self) -> T {
        self.vz
    }
    #[doc = "Returns the `px` coefficient."]
    #[inline]
    pub fn px(&self) -> T {
        self.px
    }
    #[doc = "Returns the `py` coefficient."]
    #[inline]
    pub fn py(&self) -> T {
        self.py
    }
    #[doc = "Returns the `pz` coefficient."]
    #[inline]
    pub fn pz(&self) -> T {
        self.pz
    }
    #[doc = "Returns the `pw` coefficient."]
    #[inline]
    pub fn pw(&self) -> T {
        self.pw
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e2 element."]
    #[inline]
    pub fn unit_mx() -> Self {
        Self::new_unchecked(
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e3 element."]
    #[inline]
    pub fn unit_my() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e2e3 element."]
    #[inline]
    pub fn unit_mz() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e4 element."]
    #[inline]
    pub fn unit_vx() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e2e4 element."]
    #[inline]
    pub fn unit_vy() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e3e4 element."]
    #[inline]
    pub fn unit_vz() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e5 element."]
    #[inline]
    pub fn unit_px() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e2e5 element."]
    #[inline]
    pub fn unit_py() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e3e5 element."]
    #[inline]
    pub fn unit_pz() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e4e5 element."]
    #[inline]
    pub fn unit_pw() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
        )
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.mx * self.mx
            + self.my * self.my
            + self.mz * self.mz
            + self.vx * self.vx
            + self.vy * self.vy
            + self.vz * self.vz
            + self.px * self.px
            + self.py * self.py
            + self.pz * self.pz
            + self.pw * self.pw
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(
            self.mx * s,
            self.my * s,
            self.mz * s,
            self.vx * s,
            self.vy * s,
            self.vz * s,
            self.px * s,
            self.py * s,
            self.pz * s,
            self.pw * s,
        )
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(
            -self.mx, -self.my, -self.mz, -self.vx, -self.vy, -self.vz, -self.px, -self.py,
            -self.pz, -self.pw,
        )
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(
            -self.mx, -self.my, -self.mz, -self.vx, -self.vy, -self.vz, -self.px, -self.py,
            -self.pz, -self.pw,
        )
    }
}
impl<T: Float> Default for Dipole<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Flat point (v=0, m=0)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 17 | e1e5 | `px` |\n| 18 | e2e5 | `py` |\n| 20 | e3e5 | `pz` |\n| 24 | e4e5 | `pw` |\n\n\n# Example\n\n```\nuse clifford::specialized::conformal::dim3::FlatPoint;\n\nlet v = FlatPoint::new_unchecked(1.0, 2.0, 3.0, 4.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct FlatPoint<T: Float> {
    #[doc = "Coefficient of `px`."]
    px: T,
    #[doc = "Coefficient of `py`."]
    py: T,
    #[doc = "Coefficient of `pz`."]
    pz: T,
    #[doc = "Coefficient of `pw`."]
    pw: T,
}
impl<T: Float> FlatPoint<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(px: T, py: T, pz: T, pw: T) -> Self {
        Self { px, py, pz, pw }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(px: T, py: T, pz: T, pw: T) -> Self {
        Self::new(px, py, pz, pw)
    }
    #[doc = "Returns the `px` coefficient."]
    #[inline]
    pub fn px(&self) -> T {
        self.px
    }
    #[doc = "Returns the `py` coefficient."]
    #[inline]
    pub fn py(&self) -> T {
        self.py
    }
    #[doc = "Returns the `pz` coefficient."]
    #[inline]
    pub fn pz(&self) -> T {
        self.pz
    }
    #[doc = "Returns the `pw` coefficient."]
    #[inline]
    pub fn pw(&self) -> T {
        self.pw
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e5 element."]
    #[inline]
    pub fn unit_px() -> Self {
        Self::new_unchecked(T::one(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e2e5 element."]
    #[inline]
    pub fn unit_py() -> Self {
        Self::new_unchecked(T::zero(), T::one(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e3e5 element."]
    #[inline]
    pub fn unit_pz() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::one(), T::zero())
    }
    #[doc = "Creates the unit e4e5 element."]
    #[inline]
    pub fn unit_pw() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::one())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.px * self.px + self.py * self.py + self.pz * self.pz + self.pw * self.pw
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.px * s, self.py * s, self.pz * s, self.pw * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(-self.px, -self.py, -self.pz, -self.pw)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(-self.px, -self.py, -self.pz, -self.pw)
    }
}
impl<T: Float> Default for FlatPoint<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Line (circle through infinity, g=0)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 25 | e1e4e5 | `vx` |\n| 26 | e2e4e5 | `vy` |\n| 28 | e3e4e5 | `vz` |\n| 22 | e2e3e5 | `mx` |\n| 21 | e1e3e5 | `my` |\n| 19 | e1e2e5 | `mz` |\n\n\n# Example\n\n```\nuse clifford::specialized::conformal::dim3::Line;\n\nlet v = Line::new_unchecked(1.0, 2.0, 3.0, 4.0, 5.0, 6.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Line<T: Float> {
    #[doc = "Coefficient of `vx`."]
    vx: T,
    #[doc = "Coefficient of `vy`."]
    vy: T,
    #[doc = "Coefficient of `vz`."]
    vz: T,
    #[doc = "Coefficient of `mx`."]
    mx: T,
    #[doc = "Coefficient of `my`."]
    my: T,
    #[doc = "Coefficient of `mz`."]
    mz: T,
}
impl<T: Float> Line<T> {
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" **Warning:** This does not validate the geometric constraint."]
    #[doc = r" Use `new_checked()` to validate, or `from_components()` to"]
    #[doc = r" construct from independent parameters."]
    #[inline]
    pub fn new_unchecked(vx: T, vy: T, vz: T, mx: T, my: T, mz: T) -> Self {
        Self {
            vx,
            vy,
            vz,
            mx,
            my,
            mz,
        }
    }
    #[doc = r" Creates a new element, validating the geometric constraint."]
    #[doc = r""]
    #[doc = r" Returns `Err` if the constraint is violated beyond the given tolerance."]
    #[inline]
    pub fn new_checked(
        vx: T,
        vy: T,
        vz: T,
        mx: T,
        my: T,
        mz: T,
        tolerance: T,
    ) -> Result<Self, &'static str> {
        let expected = (my * vy - mx * vx) / (vz);
        let actual = mz;
        if (actual - expected).abs() > tolerance {
            return Err("Line constraint");
        }
        Ok(Self::new_unchecked(vx, vy, vz, mx, my, mz))
    }
    #[doc = "Creates a Line from 5 independent components, computing `mz`.\n\nReturns `None` if the divisor would be zero (unstable computation)."]
    #[inline]
    pub fn from_components(vx: T, vy: T, vz: T, mx: T, my: T) -> Option<Self> {
        if (vz).abs() < T::epsilon() {
            return None;
        }
        Some(Self::new_unchecked(
            vx,
            vy,
            vz,
            mx,
            my,
            (my * vy - mx * vx) / (vz),
        ))
    }
    #[doc = "Returns the `vx` coefficient."]
    #[inline]
    pub fn vx(&self) -> T {
        self.vx
    }
    #[doc = "Returns the `vy` coefficient."]
    #[inline]
    pub fn vy(&self) -> T {
        self.vy
    }
    #[doc = "Returns the `vz` coefficient."]
    #[inline]
    pub fn vz(&self) -> T {
        self.vz
    }
    #[doc = "Returns the `mx` coefficient."]
    #[inline]
    pub fn mx(&self) -> T {
        self.mx
    }
    #[doc = "Returns the `my` coefficient."]
    #[inline]
    pub fn my(&self) -> T {
        self.my
    }
    #[doc = "Returns the `mz` coefficient."]
    #[inline]
    pub fn mz(&self) -> T {
        self.mz
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e4e5 element."]
    #[inline]
    pub fn unit_vx() -> Self {
        Self::new_unchecked(
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e2e4e5 element."]
    #[inline]
    pub fn unit_vy() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e3e4e5 element."]
    #[inline]
    pub fn unit_vz() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e2e3e5 element."]
    #[inline]
    pub fn unit_mx() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e3e5 element."]
    #[inline]
    pub fn unit_my() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
            T::zero(),
        )
    }
    #[doc = "Creates the unit e1e2e5 element."]
    #[inline]
    pub fn unit_mz() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::one(),
        )
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.vx * self.vx
            + self.vy * self.vy
            + self.vz * self.vz
            + self.mx * self.mx
            + self.my * self.my
            + self.mz * self.mz
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(
            self.vx * s,
            self.vy * s,
            self.vz * s,
            self.mx * s,
            self.my * s,
            self.mz * s,
        )
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(-self.vx, -self.vy, -self.vz, -self.mx, -self.my, -self.mz)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(-self.vx, -self.vy, -self.vz, -self.mx, -self.my, -self.mz)
    }
}
impl<T: Float> Default for Line<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Motor (even subalgebra for conformal transformations)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 0 | s | `s` |\n| 3 | e1e2 | `mx` |\n| 5 | e1e3 | `my` |\n| 6 | e2e3 | `mz` |\n| 9 | e1e4 | `vx` |\n| 10 | e2e4 | `vy` |\n| 12 | e3e4 | `vz` |\n| 17 | e1e5 | `px` |\n| 18 | e2e5 | `py` |\n| 20 | e3e5 | `pz` |\n| 24 | e4e5 | `pw` |\n| 15 | e1e2e3e4 | `u` |\n| 23 | e1e2e3e5 | `sx` |\n| 27 | e1e2e4e5 | `sy` |\n| 29 | e1e3e4e5 | `sz` |\n| 30 | e2e3e4e5 | `sw` |\n\n\n# Example\n\n```\nuse clifford::specialized::conformal::dim3::Motor;\n\nlet v = Motor::new_unchecked(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Motor<T: Float> {
    #[doc = "Coefficient of `s`."]
    s: T,
    #[doc = "Coefficient of `mx`."]
    mx: T,
    #[doc = "Coefficient of `my`."]
    my: T,
    #[doc = "Coefficient of `mz`."]
    mz: T,
    #[doc = "Coefficient of `vx`."]
    vx: T,
    #[doc = "Coefficient of `vy`."]
    vy: T,
    #[doc = "Coefficient of `vz`."]
    vz: T,
    #[doc = "Coefficient of `px`."]
    px: T,
    #[doc = "Coefficient of `py`."]
    py: T,
    #[doc = "Coefficient of `pz`."]
    pz: T,
    #[doc = "Coefficient of `pw`."]
    pw: T,
    #[doc = "Coefficient of `u`."]
    u: T,
    #[doc = "Coefficient of `sx`."]
    sx: T,
    #[doc = "Coefficient of `sy`."]
    sy: T,
    #[doc = "Coefficient of `sz`."]
    sz: T,
    #[doc = "Coefficient of `sw`."]
    sw: T,
}
impl<T: Float> Motor<T> {
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" **Warning:** This does not validate the geometric constraint."]
    #[doc = r" Use `new_checked()` to validate, or `from_components()` to"]
    #[doc = r" construct from independent parameters."]
    #[inline]
    pub fn new_unchecked(
        s: T,
        mx: T,
        my: T,
        mz: T,
        vx: T,
        vy: T,
        vz: T,
        px: T,
        py: T,
        pz: T,
        pw: T,
        u: T,
        sx: T,
        sy: T,
        sz: T,
        sw: T,
    ) -> Self {
        Self {
            s,
            mx,
            my,
            mz,
            vx,
            vy,
            vz,
            px,
            py,
            pz,
            pw,
            u,
            sx,
            sy,
            sz,
            sw,
        }
    }
    #[doc = r" Creates a new element, validating the geometric constraint."]
    #[doc = r""]
    #[doc = r" Returns `Err` if the constraint is violated beyond the given tolerance."]
    #[inline]
    pub fn new_checked(
        s: T,
        mx: T,
        my: T,
        mz: T,
        vx: T,
        vy: T,
        vz: T,
        px: T,
        py: T,
        pz: T,
        pw: T,
        u: T,
        sx: T,
        sy: T,
        sz: T,
        sw: T,
        tolerance: T,
    ) -> Result<Self, &'static str> {
        let expected = (-s * u - s * sx - s * sy - s * sz + px * mz + px * vy + px * vz
            - px * u
            - py * my
            - py * vx
            + py * vz
            + py * u
            + py * sz
            + pz * mx
            - pz * vx
            - pz * vy
            - pz * u
            - pz * sy
            + pw * mz
            + pw * my
            + pw * mx
            + pw * u
            + pw * sx
            + mz * vx
            + mz * sy
            - mz * sz
            - my * vy
            - my * sy
            + mx * vz
            + mx * sz
            + vx * sx
            - vy * sx
            + vy * sz
            + vz * sx
            - vz * sy)
            / (s);
        let actual = sw;
        if (actual - expected).abs() > tolerance {
            return Err("Motor constraint");
        }
        Ok(Self::new_unchecked(
            s, mx, my, mz, vx, vy, vz, px, py, pz, pw, u, sx, sy, sz, sw,
        ))
    }
    #[doc = "Creates a Motor from 15 independent components, computing `sw`.\n\nReturns `None` if the divisor would be zero (unstable computation)."]
    #[inline]
    pub fn from_components(
        s: T,
        mx: T,
        my: T,
        mz: T,
        vx: T,
        vy: T,
        vz: T,
        px: T,
        py: T,
        pz: T,
        pw: T,
        u: T,
        sx: T,
        sy: T,
        sz: T,
    ) -> Option<Self> {
        if (s).abs() < T::epsilon() {
            return None;
        }
        Some(Self::new_unchecked(
            s,
            mx,
            my,
            mz,
            vx,
            vy,
            vz,
            px,
            py,
            pz,
            pw,
            u,
            sx,
            sy,
            sz,
            (-s * u - s * sx - s * sy - s * sz + px * mz + px * vy + px * vz
                - px * u
                - py * my
                - py * vx
                + py * vz
                + py * u
                + py * sz
                + pz * mx
                - pz * vx
                - pz * vy
                - pz * u
                - pz * sy
                + pw * mz
                + pw * my
                + pw * mx
                + pw * u
                + pw * sx
                + mz * vx
                + mz * sy
                - mz * sz
                - my * vy
                - my * sy
                + mx * vz
                + mx * sz
                + vx * sx
                - vy * sx
                + vy * sz
                + vz * sx
                - vz * sy)
                / (s),
        ))
    }
    #[doc = "Returns the `s` coefficient."]
    #[inline]
    pub fn s(&self) -> T {
        self.s
    }
    #[doc = "Returns the `mx` coefficient."]
    #[inline]
    pub fn mx(&self) -> T {
        self.mx
    }
    #[doc = "Returns the `my` coefficient."]
    #[inline]
    pub fn my(&self) -> T {
        self.my
    }
    #[doc = "Returns the `mz` coefficient."]
    #[inline]
    pub fn mz(&self) -> T {
        self.mz
    }
    #[doc = "Returns the `vx` coefficient."]
    #[inline]
    pub fn vx(&self) -> T {
        self.vx
    }
    #[doc = "Returns the `vy` coefficient."]
    #[inline]
    pub fn vy(&self) -> T {
        self.vy
    }
    #[doc = "Returns the `vz` coefficient."]
    #[inline]
    pub fn vz(&self) -> T {
        self.vz
    }
    #[doc = "Returns the `px` coefficient."]
    #[inline]
    pub fn px(&self) -> T {
        self.px
    }
    #[doc = "Returns the `py` coefficient."]
    #[inline]
    pub fn py(&self) -> T {
        self.py
    }
    #[doc = "Returns the `pz` coefficient."]
    #[inline]
    pub fn pz(&self) -> T {
        self.pz
    }
    #[doc = "Returns the `pw` coefficient."]
    #[inline]
    pub fn pw(&self) -> T {
        self.pw
    }
    #[doc = "Returns the `u` coefficient."]
    #[inline]
    pub fn u(&self) -> T {
        self.u
    }
    #[doc = "Returns the `sx` coefficient."]
    #[inline]
    pub fn sx(&self) -> T {
        self.sx
    }
    #[doc = "Returns the `sy` coefficient."]
    #[inline]
    pub fn sy(&self) -> T {
        self.sy
    }
    #[doc = "Returns the `sz` coefficient."]
    #[inline]
    pub fn sz(&self) -> T {
        self.sz
    }
    #[doc = "Returns the `sw` coefficient."]
    #[inline]
    pub fn sw(&self) -> T {
        self.sw
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
            T::zero(),
        )
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.s * self.s
            + self.mx * self.mx
            + self.my * self.my
            + self.mz * self.mz
            + self.vx * self.vx
            + self.vy * self.vy
            + self.vz * self.vz
            + self.px * self.px
            + self.py * self.py
            + self.pz * self.pz
            + self.pw * self.pw
            + self.u * self.u
            + self.sx * self.sx
            + self.sy * self.sy
            + self.sz * self.sz
            + self.sw * self.sw
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(
            self.s * s,
            self.mx * s,
            self.my * s,
            self.mz * s,
            self.vx * s,
            self.vy * s,
            self.vz * s,
            self.px * s,
            self.py * s,
            self.pz * s,
            self.pw * s,
            self.u * s,
            self.sx * s,
            self.sy * s,
            self.sz * s,
            self.sw * s,
        )
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(
            self.s, -self.mx, -self.my, -self.mz, -self.vx, -self.vy, -self.vz, -self.px, -self.py,
            -self.pz, -self.pw, self.u, self.sx, self.sy, self.sz, self.sw,
        )
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(
            self.s, -self.mx, -self.my, -self.mz, -self.vx, -self.vy, -self.vz, -self.px, -self.py,
            -self.pz, -self.pw, self.u, self.sx, self.sy, self.sz, self.sw,
        )
    }
}
impl<T: Float> Default for Motor<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Plane (sphere through infinity, u=0)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 30 | e2e3e4e5 | `x` |\n| 29 | e1e3e4e5 | `y` |\n| 27 | e1e2e4e5 | `z` |\n| 23 | e1e2e3e5 | `w` |\n\n\n# Example\n\n```\nuse clifford::specialized::conformal::dim3::Plane;\n\nlet v = Plane::new_unchecked(1.0, 2.0, 3.0, 4.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Plane<T: Float> {
    #[doc = "Coefficient of `x`."]
    x: T,
    #[doc = "Coefficient of `y`."]
    y: T,
    #[doc = "Coefficient of `z`."]
    z: T,
    #[doc = "Coefficient of `w`."]
    w: T,
}
impl<T: Float> Plane<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(x: T, y: T, z: T, w: T) -> Self {
        Self { x, y, z, w }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(x: T, y: T, z: T, w: T) -> Self {
        Self::new(x, y, z, w)
    }
    #[doc = "Returns the `x` coefficient."]
    #[inline]
    pub fn x(&self) -> T {
        self.x
    }
    #[doc = "Returns the `y` coefficient."]
    #[inline]
    pub fn y(&self) -> T {
        self.y
    }
    #[doc = "Returns the `z` coefficient."]
    #[inline]
    pub fn z(&self) -> T {
        self.z
    }
    #[doc = "Returns the `w` coefficient."]
    #[inline]
    pub fn w(&self) -> T {
        self.w
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e2e3e4e5 element."]
    #[inline]
    pub fn unit_x() -> Self {
        Self::new_unchecked(T::one(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e3e4e5 element."]
    #[inline]
    pub fn unit_y() -> Self {
        Self::new_unchecked(T::zero(), T::one(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e2e4e5 element."]
    #[inline]
    pub fn unit_z() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::one(), T::zero())
    }
    #[doc = "Creates the unit e1e2e3e5 element."]
    #[inline]
    pub fn unit_w() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::one())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.x * s, self.y * s, self.z * s, self.w * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.x, self.y, self.z, self.w)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.x, self.y, self.z, self.w)
    }
}
impl<T: Float> Default for Plane<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Pseudoscalar (oriented 5-volume)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 31 | e1e2e3e4e5 | `xyzwu` |\n\n\n# Example\n\n```\nuse clifford::specialized::conformal::dim3::Pseudoscalar;\n\nlet v = Pseudoscalar::new_unchecked(1.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Pseudoscalar<T: Float> {
    #[doc = "Coefficient of `xyzwu`."]
    xyzwu: T,
}
impl<T: Float> Pseudoscalar<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(xyzwu: T) -> Self {
        Self { xyzwu }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(xyzwu: T) -> Self {
        Self::new(xyzwu)
    }
    #[doc = "Returns the `xyzwu` coefficient."]
    #[inline]
    pub fn xyzwu(&self) -> T {
        self.xyzwu
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero())
    }
    #[doc = "Creates the unit e1e2e3e4e5 element."]
    #[inline]
    pub fn unit_xyzwu() -> Self {
        Self::new_unchecked(T::one())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.xyzwu * self.xyzwu
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.xyzwu * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.xyzwu)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.xyzwu)
    }
}
impl<T: Float> Default for Pseudoscalar<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Round point (null vectors represent actual points)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 1 | e1 | `x` |\n| 2 | e2 | `y` |\n| 4 | e3 | `z` |\n| 8 | e4 | `w` |\n| 16 | e5 | `u` |\n\n\n# Example\n\n```\nuse clifford::specialized::conformal::dim3::RoundPoint;\n\nlet v = RoundPoint::new_unchecked(1.0, 2.0, 3.0, 4.0, 5.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct RoundPoint<T: Float> {
    #[doc = "Coefficient of `x`."]
    x: T,
    #[doc = "Coefficient of `y`."]
    y: T,
    #[doc = "Coefficient of `z`."]
    z: T,
    #[doc = "Coefficient of `w`."]
    w: T,
    #[doc = "Coefficient of `u`."]
    u: T,
}
impl<T: Float> RoundPoint<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(x: T, y: T, z: T, w: T, u: T) -> Self {
        Self { x, y, z, w, u }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(x: T, y: T, z: T, w: T, u: T) -> Self {
        Self::new(x, y, z, w, u)
    }
    #[doc = "Returns the `x` coefficient."]
    #[inline]
    pub fn x(&self) -> T {
        self.x
    }
    #[doc = "Returns the `y` coefficient."]
    #[inline]
    pub fn y(&self) -> T {
        self.y
    }
    #[doc = "Returns the `z` coefficient."]
    #[inline]
    pub fn z(&self) -> T {
        self.z
    }
    #[doc = "Returns the `w` coefficient."]
    #[inline]
    pub fn w(&self) -> T {
        self.w
    }
    #[doc = "Returns the `u` coefficient."]
    #[inline]
    pub fn u(&self) -> T {
        self.u
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1 element."]
    #[inline]
    pub fn unit_x() -> Self {
        Self::new_unchecked(T::one(), T::zero(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e2 element."]
    #[inline]
    pub fn unit_y() -> Self {
        Self::new_unchecked(T::zero(), T::one(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e3 element."]
    #[inline]
    pub fn unit_z() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::one(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e4 element."]
    #[inline]
    pub fn unit_w() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::one(), T::zero())
    }
    #[doc = "Creates the unit e5 element."]
    #[inline]
    pub fn unit_u() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero(), T::one())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w + self.u * self.u
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.x * s, self.y * s, self.z * s, self.w * s, self.u * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.x, self.y, self.z, self.w, self.u)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.x, self.y, self.z, self.w, self.u)
    }
}
impl<T: Float> Default for RoundPoint<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Scalar (grade-0 element)\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 0 | s | `s` |\n\n\n# Example\n\n```\nuse clifford::specialized::conformal::dim3::Scalar;\n\nlet v = Scalar::new_unchecked(1.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Scalar<T: Float> {
    #[doc = "Coefficient of `s`."]
    s: T,
}
impl<T: Float> Scalar<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(s: T) -> Self {
        Self { s }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(s: T) -> Self {
        Self::new(s)
    }
    #[doc = "Returns the `s` coefficient."]
    #[inline]
    pub fn s(&self) -> T {
        self.s
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero())
    }
    #[doc = "Creates the unit s element."]
    #[inline]
    pub fn unit_s() -> Self {
        Self::new_unchecked(T::one())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.s * self.s
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.s * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.s)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.s)
    }
}
impl<T: Float> Default for Scalar<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "Sphere in 3D space\n\n# Basis Ordering\n\n| Index | Blade | Field |\n|-------|-------|-------|\n| 15 | e1e2e3e4 | `u` |\n| 23 | e1e2e3e5 | `x` |\n| 27 | e1e2e4e5 | `y` |\n| 29 | e1e3e4e5 | `z` |\n| 30 | e2e3e4e5 | `w` |\n\n\n# Example\n\n```\nuse clifford::specialized::conformal::dim3::Sphere;\n\nlet v = Sphere::new_unchecked(1.0, 2.0, 3.0, 4.0, 5.0);\n```"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[repr(C)]
pub struct Sphere<T: Float> {
    #[doc = "Coefficient of `u`."]
    u: T,
    #[doc = "Coefficient of `x`."]
    x: T,
    #[doc = "Coefficient of `y`."]
    y: T,
    #[doc = "Coefficient of `z`."]
    z: T,
    #[doc = "Coefficient of `w`."]
    w: T,
}
impl<T: Float> Sphere<T> {
    #[doc = r" Creates a new element from components."]
    #[inline]
    pub fn new(u: T, x: T, y: T, z: T, w: T) -> Self {
        Self { u, x, y, z, w }
    }
    #[doc = r" Creates a new element from components without validation."]
    #[doc = r""]
    #[doc = r" This is an alias for `new()`. It exists for consistency with types"]
    #[doc = r" that have geometric constraints, where unchecked construction is"]
    #[doc = r" used in performance-critical code or trusted contexts."]
    #[inline]
    pub fn new_unchecked(u: T, x: T, y: T, z: T, w: T) -> Self {
        Self::new(u, x, y, z, w)
    }
    #[doc = "Returns the `u` coefficient."]
    #[inline]
    pub fn u(&self) -> T {
        self.u
    }
    #[doc = "Returns the `x` coefficient."]
    #[inline]
    pub fn x(&self) -> T {
        self.x
    }
    #[doc = "Returns the `y` coefficient."]
    #[inline]
    pub fn y(&self) -> T {
        self.y
    }
    #[doc = "Returns the `z` coefficient."]
    #[inline]
    pub fn z(&self) -> T {
        self.z
    }
    #[doc = "Returns the `w` coefficient."]
    #[inline]
    pub fn w(&self) -> T {
        self.w
    }
    #[doc = r" Creates the zero element."]
    #[inline]
    pub fn zero() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e2e3e4 element."]
    #[inline]
    pub fn unit_u() -> Self {
        Self::new_unchecked(T::one(), T::zero(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e2e3e5 element."]
    #[inline]
    pub fn unit_x() -> Self {
        Self::new_unchecked(T::zero(), T::one(), T::zero(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e2e4e5 element."]
    #[inline]
    pub fn unit_y() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::one(), T::zero(), T::zero())
    }
    #[doc = "Creates the unit e1e3e4e5 element."]
    #[inline]
    pub fn unit_z() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::one(), T::zero())
    }
    #[doc = "Creates the unit e2e3e4e5 element."]
    #[inline]
    pub fn unit_w() -> Self {
        Self::new_unchecked(T::zero(), T::zero(), T::zero(), T::zero(), T::one())
    }
    #[doc = r" Returns the squared Euclidean norm."]
    #[doc = r""]
    #[doc = r" This is the sum of squares of all components."]
    #[inline]
    pub fn norm_squared(&self) -> T {
        self.u * self.u + self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w
    }
    #[doc = r" Returns the Euclidean norm."]
    #[inline]
    pub fn norm(&self) -> T {
        self.norm_squared().sqrt()
    }
    #[doc = r" Attempts to normalize this element."]
    #[doc = r""]
    #[doc = r" Returns `None` if the norm is too small (less than epsilon)."]
    #[inline]
    pub fn try_normalize(&self) -> Option<Self> {
        let n = self.norm();
        if n < T::epsilon() {
            None
        } else {
            Some(self.scale(T::one() / n))
        }
    }
    #[doc = r" Normalizes this element, panicking if the norm is too small."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" Panics if the norm is less than epsilon."]
    #[inline]
    pub fn normalize(&self) -> Self {
        self.try_normalize().expect("cannot normalize zero element")
    }
    #[doc = r" Scales all components by a scalar."]
    #[inline]
    pub fn scale(&self, s: T) -> Self {
        Self::new_unchecked(self.u * s, self.x * s, self.y * s, self.z * s, self.w * s)
    }
    #[doc = r" Returns the reverse (reversion)."]
    #[doc = r""]
    #[doc = r" For a k-blade, the reverse has sign (-1)^(k(k-1)/2):"]
    #[doc = r" - Grade 0: +1"]
    #[doc = r" - Grade 1: +1"]
    #[doc = r" - Grade 2: -1"]
    #[doc = r" - Grade 3: -1"]
    #[doc = r" - Grade 4: +1"]
    #[doc = r" - ..."]
    #[inline]
    pub fn reverse(&self) -> Self {
        Self::new_unchecked(self.u, self.x, self.y, self.z, self.w)
    }
    #[doc = r" Returns the antireverse."]
    #[doc = r""]
    #[doc = r" For a k-blade in an n-dimensional algebra, the antireverse has sign (-1)^((n-k)(n-k-1)/2)."]
    #[doc = r" This is equivalent to complement(reverse(complement(x)))."]
    #[doc = r""]
    #[doc = r" In PGA (n=4):"]
    #[doc = r" - Grade 0 (antigrade 4): (-1)^(4*3/2) = (-1)^6 = +1"]
    #[doc = r" - Grade 1 (antigrade 3): (-1)^(3*2/2) = (-1)^3 = -1"]
    #[doc = r" - Grade 2 (antigrade 2): (-1)^(2*1/2) = (-1)^1 = -1"]
    #[doc = r" - Grade 3 (antigrade 1): (-1)^(1*0/2) = (-1)^0 = +1"]
    #[doc = r" - Grade 4 (antigrade 0): (-1)^(0*0/2) = (-1)^0 = +1"]
    #[inline]
    pub fn antireverse(&self) -> Self {
        Self::new_unchecked(self.u, self.x, self.y, self.z, self.w)
    }
}
impl<T: Float> Default for Sphere<T> {
    fn default() -> Self {
        Self::zero()
    }
}
#[doc = "A unit Circle (norm = 1).\n\nThis type alias provides compile-time documentation that the Circle has been normalized."]
pub type UnitCircle<T> = crate::wrappers::Unit<Circle<T>>;
#[doc = "A Circle with positive norm squared (timelike in Minkowski).\n\nThis type alias wraps Circle in `Proper<T>`, guaranteeing norm > 0."]
pub type ProperCircle<T> = crate::wrappers::Proper<Circle<T>>;
#[doc = "A Circle with negative norm squared (spacelike in Minkowski).\n\nThis type alias wraps Circle in `Spacelike<T>`, guaranteeing norm < 0."]
pub type SpacelikeCircle<T> = crate::wrappers::Spacelike<Circle<T>>;
#[doc = "A Circle with zero norm squared (lightlike/null in Minkowski).\n\nThis type alias wraps Circle in `Null<T>`, guaranteeing norm = 0."]
pub type NullCircle<T> = crate::wrappers::Null<Circle<T>>;
#[doc = "A unit Dipole (norm = 1).\n\nThis type alias provides compile-time documentation that the Dipole has been normalized."]
pub type UnitDipole<T> = crate::wrappers::Unit<Dipole<T>>;
#[doc = "A Dipole with positive norm squared (timelike in Minkowski).\n\nThis type alias wraps Dipole in `Proper<T>`, guaranteeing norm > 0."]
pub type ProperDipole<T> = crate::wrappers::Proper<Dipole<T>>;
#[doc = "A Dipole with negative norm squared (spacelike in Minkowski).\n\nThis type alias wraps Dipole in `Spacelike<T>`, guaranteeing norm < 0."]
pub type SpacelikeDipole<T> = crate::wrappers::Spacelike<Dipole<T>>;
#[doc = "A Dipole with zero norm squared (lightlike/null in Minkowski).\n\nThis type alias wraps Dipole in `Null<T>`, guaranteeing norm = 0."]
pub type NullDipole<T> = crate::wrappers::Null<Dipole<T>>;
#[doc = "A unit FlatPoint (norm = 1).\n\nThis type alias provides compile-time documentation that the FlatPoint has been normalized."]
pub type UnitFlatPoint<T> = crate::wrappers::Unit<FlatPoint<T>>;
#[doc = "A FlatPoint with positive norm squared (timelike in Minkowski).\n\nThis type alias wraps FlatPoint in `Proper<T>`, guaranteeing norm > 0."]
pub type ProperFlatPoint<T> = crate::wrappers::Proper<FlatPoint<T>>;
#[doc = "A FlatPoint with negative norm squared (spacelike in Minkowski).\n\nThis type alias wraps FlatPoint in `Spacelike<T>`, guaranteeing norm < 0."]
pub type SpacelikeFlatPoint<T> = crate::wrappers::Spacelike<FlatPoint<T>>;
#[doc = "A FlatPoint with zero norm squared (lightlike/null in Minkowski).\n\nThis type alias wraps FlatPoint in `Null<T>`, guaranteeing norm = 0."]
pub type NullFlatPoint<T> = crate::wrappers::Null<FlatPoint<T>>;
#[doc = "A unit Line (norm = 1).\n\nThis type alias provides compile-time documentation that the Line has been normalized."]
pub type UnitLine<T> = crate::wrappers::Unit<Line<T>>;
#[doc = "A Line with positive norm squared (timelike in Minkowski).\n\nThis type alias wraps Line in `Proper<T>`, guaranteeing norm > 0."]
pub type ProperLine<T> = crate::wrappers::Proper<Line<T>>;
#[doc = "A Line with negative norm squared (spacelike in Minkowski).\n\nThis type alias wraps Line in `Spacelike<T>`, guaranteeing norm < 0."]
pub type SpacelikeLine<T> = crate::wrappers::Spacelike<Line<T>>;
#[doc = "A Line with zero norm squared (lightlike/null in Minkowski).\n\nThis type alias wraps Line in `Null<T>`, guaranteeing norm = 0."]
pub type NullLine<T> = crate::wrappers::Null<Line<T>>;
#[doc = "A unit Plane (norm = 1).\n\nThis type alias provides compile-time documentation that the Plane has been normalized."]
pub type UnitPlane<T> = crate::wrappers::Unit<Plane<T>>;
#[doc = "A Plane with positive norm squared (timelike in Minkowski).\n\nThis type alias wraps Plane in `Proper<T>`, guaranteeing norm > 0."]
pub type ProperPlane<T> = crate::wrappers::Proper<Plane<T>>;
#[doc = "A Plane with negative norm squared (spacelike in Minkowski).\n\nThis type alias wraps Plane in `Spacelike<T>`, guaranteeing norm < 0."]
pub type SpacelikePlane<T> = crate::wrappers::Spacelike<Plane<T>>;
#[doc = "A Plane with zero norm squared (lightlike/null in Minkowski).\n\nThis type alias wraps Plane in `Null<T>`, guaranteeing norm = 0."]
pub type NullPlane<T> = crate::wrappers::Null<Plane<T>>;
#[doc = "A unit Pseudoscalar (norm = 1).\n\nThis type alias provides compile-time documentation that the Pseudoscalar has been normalized."]
pub type UnitPseudoscalar<T> = crate::wrappers::Unit<Pseudoscalar<T>>;
#[doc = "A Pseudoscalar with positive norm squared (timelike in Minkowski).\n\nThis type alias wraps Pseudoscalar in `Proper<T>`, guaranteeing norm > 0."]
pub type ProperPseudoscalar<T> = crate::wrappers::Proper<Pseudoscalar<T>>;
#[doc = "A Pseudoscalar with negative norm squared (spacelike in Minkowski).\n\nThis type alias wraps Pseudoscalar in `Spacelike<T>`, guaranteeing norm < 0."]
pub type SpacelikePseudoscalar<T> = crate::wrappers::Spacelike<Pseudoscalar<T>>;
#[doc = "A Pseudoscalar with zero norm squared (lightlike/null in Minkowski).\n\nThis type alias wraps Pseudoscalar in `Null<T>`, guaranteeing norm = 0."]
pub type NullPseudoscalar<T> = crate::wrappers::Null<Pseudoscalar<T>>;
#[doc = "A unit RoundPoint (norm = 1).\n\nThis type alias provides compile-time documentation that the RoundPoint has been normalized."]
pub type UnitRoundPoint<T> = crate::wrappers::Unit<RoundPoint<T>>;
#[doc = "A RoundPoint with positive norm squared (timelike in Minkowski).\n\nThis type alias wraps RoundPoint in `Proper<T>`, guaranteeing norm > 0."]
pub type ProperRoundPoint<T> = crate::wrappers::Proper<RoundPoint<T>>;
#[doc = "A RoundPoint with negative norm squared (spacelike in Minkowski).\n\nThis type alias wraps RoundPoint in `Spacelike<T>`, guaranteeing norm < 0."]
pub type SpacelikeRoundPoint<T> = crate::wrappers::Spacelike<RoundPoint<T>>;
#[doc = "A RoundPoint with zero norm squared (lightlike/null in Minkowski).\n\nThis type alias wraps RoundPoint in `Null<T>`, guaranteeing norm = 0."]
pub type NullRoundPoint<T> = crate::wrappers::Null<RoundPoint<T>>;
#[doc = "A unit Sphere (norm = 1).\n\nThis type alias provides compile-time documentation that the Sphere has been normalized."]
pub type UnitSphere<T> = crate::wrappers::Unit<Sphere<T>>;
#[doc = "A Sphere with positive norm squared (timelike in Minkowski).\n\nThis type alias wraps Sphere in `Proper<T>`, guaranteeing norm > 0."]
pub type ProperSphere<T> = crate::wrappers::Proper<Sphere<T>>;
#[doc = "A Sphere with negative norm squared (spacelike in Minkowski).\n\nThis type alias wraps Sphere in `Spacelike<T>`, guaranteeing norm < 0."]
pub type SpacelikeSphere<T> = crate::wrappers::Spacelike<Sphere<T>>;
#[doc = "A Sphere with zero norm squared (lightlike/null in Minkowski).\n\nThis type alias wraps Sphere in `Null<T>`, guaranteeing norm = 0."]
pub type NullSphere<T> = crate::wrappers::Null<Sphere<T>>;
